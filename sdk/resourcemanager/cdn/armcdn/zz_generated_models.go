//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AFDCustomDomainsBeginCreateOptions contains the optional parameters for the AFDCustomDomains.BeginCreate method.
type AFDCustomDomainsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AFDCustomDomainsBeginDeleteOptions contains the optional parameters for the AFDCustomDomains.BeginDelete method.
type AFDCustomDomainsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AFDCustomDomainsBeginRefreshValidationTokenOptions contains the optional parameters for the AFDCustomDomains.BeginRefreshValidationToken method.
type AFDCustomDomainsBeginRefreshValidationTokenOptions struct {
	// placeholder for future optional parameters
}

// AFDCustomDomainsBeginUpdateOptions contains the optional parameters for the AFDCustomDomains.BeginUpdate method.
type AFDCustomDomainsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AFDCustomDomainsGetOptions contains the optional parameters for the AFDCustomDomains.Get method.
type AFDCustomDomainsGetOptions struct {
	// placeholder for future optional parameters
}

// AFDCustomDomainsListByProfileOptions contains the optional parameters for the AFDCustomDomains.ListByProfile method.
type AFDCustomDomainsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// AFDDomain - Friendly domain name mapping to the endpoint hostname that the customer provides for branding purposes, e.g. www.contoso.com.
type AFDDomain struct {
	ProxyResource
	// The JSON object that contains the properties of the domain to create.
	Properties *AFDDomainProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDDomain.
func (a AFDDomain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDDomainHTTPSParameters - The JSON object that contains the properties to secure a domain.
type AFDDomainHTTPSParameters struct {
	// REQUIRED; Defines the source of the SSL certificate.
	CertificateType *AfdCertificateType `json:"certificateType,omitempty"`

	// TLS protocol version that will be used for Https
	MinimumTLSVersion *AfdMinimumTLSVersion `json:"minimumTlsVersion,omitempty"`

	// Resource reference to the secret. ie. subs/rg/profile/secret
	Secret *ResourceReference `json:"secret,omitempty"`
}

// AFDDomainListResult - Result of the request to list domains. It contains a list of domain objects and a URL link to get the next set of results.
type AFDDomainListResult struct {
	// URL to get the next set of domain objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of AzureFrontDoor domains within a profile.
	Value []*AFDDomain `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDDomainListResult.
func (a AFDDomainListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AFDDomainProperties - The JSON object that contains the properties of the domain to create.
type AFDDomainProperties struct {
	AFDDomainUpdatePropertiesParameters
	AFDStateProperties
	// REQUIRED; The host name of the domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// READ-ONLY; Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step. DCV stands for DomainControlValidation.
	DomainValidationState *DomainValidationState `json:"domainValidationState,omitempty" azure:"ro"`

	// READ-ONLY; Values the customer needs to validate domain ownership
	ValidationProperties *DomainValidationProperties `json:"validationProperties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDDomainProperties.
func (a AFDDomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.AFDDomainUpdatePropertiesParameters.marshalInternal(objectMap)
	a.AFDStateProperties.marshalInternal(objectMap)
	populate(objectMap, "domainValidationState", a.DomainValidationState)
	populate(objectMap, "hostName", a.HostName)
	populate(objectMap, "validationProperties", a.ValidationProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDDomainProperties.
func (a *AFDDomainProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainValidationState":
			err = unpopulate(val, &a.DomainValidationState)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &a.HostName)
			delete(rawMsg, key)
		case "validationProperties":
			err = unpopulate(val, &a.ValidationProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.AFDDomainUpdatePropertiesParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	if err := a.AFDStateProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AFDDomainUpdateParameters - The domain JSON object required for domain creation or update.
type AFDDomainUpdateParameters struct {
	// The JSON object that contains the properties of the domain to create.
	Properties *AFDDomainUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDDomainUpdateParameters.
func (a AFDDomainUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDDomainUpdatePropertiesParameters - The JSON object that contains the properties of the domain to create.
type AFDDomainUpdatePropertiesParameters struct {
	// Resource reference to the Azure DNS zone
	AzureDNSZone *ResourceReference `json:"azureDnsZone,omitempty"`

	// The configuration specifying how to enable HTTPS for the domain - using AzureFrontDoor managed certificate or user's own certificate. If not specified,
	// enabling ssl uses AzureFrontDoor managed
	// certificate by default.
	TLSSettings *AFDDomainHTTPSParameters `json:"tlsSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDDomainUpdatePropertiesParameters.
func (a AFDDomainUpdatePropertiesParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDDomainUpdatePropertiesParameters.
func (a *AFDDomainUpdatePropertiesParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AFDDomainUpdatePropertiesParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "azureDnsZone", a.AzureDNSZone)
	populate(objectMap, "tlsSettings", a.TLSSettings)
}

func (a *AFDDomainUpdatePropertiesParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureDnsZone":
			err = unpopulate(val, &a.AzureDNSZone)
			delete(rawMsg, key)
		case "tlsSettings":
			err = unpopulate(val, &a.TLSSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AFDEndpoint - CDN endpoint is the entity within a CDN profile containing configuration information such as origin, protocol, content caching and delivery
// behavior. The AzureFrontDoor endpoint uses the URL format
// .azureedge.net.
type AFDEndpoint struct {
	TrackedResource
	// The JSON object that contains the properties required to create an endpoint.
	Properties *AFDEndpointProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDEndpoint.
func (a AFDEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDEndpointListResult - Result of the request to list endpoints. It contains a list of endpoint objects and a URL link to get the next set of results.
type AFDEndpointListResult struct {
	// URL to get the next set of endpoint objects if there is any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of AzureFrontDoor endpoints within a profile
	Value []*AFDEndpoint `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDEndpointListResult.
func (a AFDEndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AFDEndpointProperties - The JSON object that contains the properties required to create an endpoint.
type AFDEndpointProperties struct {
	AFDEndpointPropertiesUpdateParameters
	AFDStateProperties
	// READ-ONLY; The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
	HostName *string `json:"hostName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDEndpointProperties.
func (a AFDEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.AFDEndpointPropertiesUpdateParameters.marshalInternal(objectMap)
	a.AFDStateProperties.marshalInternal(objectMap)
	populate(objectMap, "hostName", a.HostName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDEndpointProperties.
func (a *AFDEndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostName":
			err = unpopulate(val, &a.HostName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.AFDEndpointPropertiesUpdateParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	if err := a.AFDStateProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AFDEndpointPropertiesUpdateParameters - The JSON object containing endpoint update parameters.
type AFDEndpointPropertiesUpdateParameters struct {
	// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *EnabledState `json:"enabledState,omitempty"`

	// Send and receive timeout on forwarding request to the origin. When timeout is reached, the request fails and returns.
	OriginResponseTimeoutSeconds *int32 `json:"originResponseTimeoutSeconds,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDEndpointPropertiesUpdateParameters.
func (a AFDEndpointPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDEndpointPropertiesUpdateParameters.
func (a *AFDEndpointPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AFDEndpointPropertiesUpdateParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "enabledState", a.EnabledState)
	populate(objectMap, "originResponseTimeoutSeconds", a.OriginResponseTimeoutSeconds)
}

func (a *AFDEndpointPropertiesUpdateParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabledState":
			err = unpopulate(val, &a.EnabledState)
			delete(rawMsg, key)
		case "originResponseTimeoutSeconds":
			err = unpopulate(val, &a.OriginResponseTimeoutSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AFDEndpointUpdateParameters - Properties required to create or update an endpoint.
type AFDEndpointUpdateParameters struct {
	// The JSON object containing endpoint update parameters.
	Properties *AFDEndpointPropertiesUpdateParameters `json:"properties,omitempty"`

	// Endpoint tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDEndpointUpdateParameters.
func (a AFDEndpointUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// AFDEndpointsBeginCreateOptions contains the optional parameters for the AFDEndpoints.BeginCreate method.
type AFDEndpointsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsBeginDeleteOptions contains the optional parameters for the AFDEndpoints.BeginDelete method.
type AFDEndpointsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsBeginPurgeContentOptions contains the optional parameters for the AFDEndpoints.BeginPurgeContent method.
type AFDEndpointsBeginPurgeContentOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsBeginUpdateOptions contains the optional parameters for the AFDEndpoints.BeginUpdate method.
type AFDEndpointsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsGetOptions contains the optional parameters for the AFDEndpoints.Get method.
type AFDEndpointsGetOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsListByProfileOptions contains the optional parameters for the AFDEndpoints.ListByProfile method.
type AFDEndpointsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsListResourceUsageOptions contains the optional parameters for the AFDEndpoints.ListResourceUsage method.
type AFDEndpointsListResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// AFDEndpointsValidateCustomDomainOptions contains the optional parameters for the AFDEndpoints.ValidateCustomDomain method.
type AFDEndpointsValidateCustomDomainOptions struct {
	// placeholder for future optional parameters
}

// AFDOrigin - CDN origin is the source of the content being delivered via CDN. When the edge nodes represented by an endpoint do not have the requested
// content cached, they attempt to fetch it from one or more of
// the configured origins.
type AFDOrigin struct {
	ProxyResource
	// The JSON object that contains the properties of the origin.
	Properties *AFDOriginProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOrigin.
func (a AFDOrigin) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDOriginGroup - AFDOrigin group comprising of origins is used for load balancing to origins when the content cannot be served from CDN.
type AFDOriginGroup struct {
	ProxyResource
	// The JSON object that contains the properties of the origin group.
	Properties *AFDOriginGroupProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginGroup.
func (a AFDOriginGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDOriginGroupListResult - Result of the request to list origin groups. It contains a list of origin groups objects and a URL link to get the next set
// of results.
type AFDOriginGroupListResult struct {
	// URL to get the next set of origin objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN origin groups within an endpoint
	Value []*AFDOriginGroup `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginGroupListResult.
func (a AFDOriginGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AFDOriginGroupProperties - The JSON object that contains the properties of the origin group.
type AFDOriginGroupProperties struct {
	AFDOriginGroupUpdatePropertiesParameters
	AFDStateProperties
}

// AFDOriginGroupUpdateParameters - AFDOrigin group properties needed for origin group creation or update.
type AFDOriginGroupUpdateParameters struct {
	// The JSON object that contains the properties of the origin group.
	Properties *AFDOriginGroupUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginGroupUpdateParameters.
func (a AFDOriginGroupUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDOriginGroupUpdatePropertiesParameters - The JSON object that contains the properties of the origin group.
type AFDOriginGroupUpdatePropertiesParameters struct {
	// Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters `json:"healthProbeSettings,omitempty"`

	// Load balancing settings for a backend pool
	LoadBalancingSettings *LoadBalancingSettingsParameters `json:"loadBalancingSettings,omitempty"`

	// The JSON object that contains the properties to determine origin health using real requests/responses. This property is currently not supported.
	ResponseBasedAfdOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedAfdOriginErrorDetectionSettings,omitempty"`

	// Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
	SessionAffinityState *EnabledState `json:"sessionAffinityState,omitempty"`

	// Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins.
	// This property is currently not supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int32 `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginGroupUpdatePropertiesParameters.
func (a AFDOriginGroupUpdatePropertiesParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDOriginGroupUpdatePropertiesParameters.
func (a *AFDOriginGroupUpdatePropertiesParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AFDOriginGroupUpdatePropertiesParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "healthProbeSettings", a.HealthProbeSettings)
	populate(objectMap, "loadBalancingSettings", a.LoadBalancingSettings)
	populate(objectMap, "responseBasedAfdOriginErrorDetectionSettings", a.ResponseBasedAfdOriginErrorDetectionSettings)
	populate(objectMap, "sessionAffinityState", a.SessionAffinityState)
	populate(objectMap, "trafficRestorationTimeToHealedOrNewEndpointsInMinutes", a.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)
}

func (a *AFDOriginGroupUpdatePropertiesParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "healthProbeSettings":
			err = unpopulate(val, &a.HealthProbeSettings)
			delete(rawMsg, key)
		case "loadBalancingSettings":
			err = unpopulate(val, &a.LoadBalancingSettings)
			delete(rawMsg, key)
		case "responseBasedAfdOriginErrorDetectionSettings":
			err = unpopulate(val, &a.ResponseBasedAfdOriginErrorDetectionSettings)
			delete(rawMsg, key)
		case "sessionAffinityState":
			err = unpopulate(val, &a.SessionAffinityState)
			delete(rawMsg, key)
		case "trafficRestorationTimeToHealedOrNewEndpointsInMinutes":
			err = unpopulate(val, &a.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AFDOriginGroupsBeginCreateOptions contains the optional parameters for the AFDOriginGroups.BeginCreate method.
type AFDOriginGroupsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginGroupsBeginDeleteOptions contains the optional parameters for the AFDOriginGroups.BeginDelete method.
type AFDOriginGroupsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginGroupsBeginUpdateOptions contains the optional parameters for the AFDOriginGroups.BeginUpdate method.
type AFDOriginGroupsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginGroupsGetOptions contains the optional parameters for the AFDOriginGroups.Get method.
type AFDOriginGroupsGetOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginGroupsListByProfileOptions contains the optional parameters for the AFDOriginGroups.ListByProfile method.
type AFDOriginGroupsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginGroupsListResourceUsageOptions contains the optional parameters for the AFDOriginGroups.ListResourceUsage method.
type AFDOriginGroupsListResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginListResult - Result of the request to list origins. It contains a list of origin objects and a URL link to get the next set of results.
type AFDOriginListResult struct {
	// URL to get the next set of origin objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN origins within an endpoint
	Value []*AFDOrigin `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginListResult.
func (a AFDOriginListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AFDOriginProperties - The JSON object that contains the properties of the origin.
type AFDOriginProperties struct {
	AFDOriginUpdatePropertiesParameters
	AFDStateProperties
}

// AFDOriginUpdateParameters - AFDOrigin properties needed for origin update.
type AFDOriginUpdateParameters struct {
	// The JSON object that contains the properties of the origin.
	Properties *AFDOriginUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginUpdateParameters.
func (a AFDOriginUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AFDOriginUpdatePropertiesParameters - The JSON object that contains the properties of the origin.
type AFDOriginUpdatePropertiesParameters struct {
	// Resource reference to the Azure origin resource.
	AzureOrigin *ResourceReference `json:"azureOrigin,omitempty"`

	// Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled
	// backend in single enabled backend pool.
	EnabledState *EnabledState `json:"enabledState,omitempty"`

	// The value of the HTTP port. Must be between 1 and 65535.
	HTTPPort *int32 `json:"httpPort,omitempty"`

	// The value of the HTTPS port. Must be between 1 and 65535.
	HTTPSPort *int32 `json:"httpsPort,omitempty"`

	// The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This should be unique across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such
	// as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default. This overrides the host header defined at Endpoint
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must
	// be between 1 and 5
	Priority *int32 `json:"priority,omitempty"`

	// The properties of the private link resource for private origin.
	SharedPrivateLinkResource map[string]interface{} `json:"sharedPrivateLinkResource,omitempty"`

	// Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int32 `json:"weight,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDOriginUpdatePropertiesParameters.
func (a AFDOriginUpdatePropertiesParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDOriginUpdatePropertiesParameters.
func (a *AFDOriginUpdatePropertiesParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AFDOriginUpdatePropertiesParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "azureOrigin", a.AzureOrigin)
	populate(objectMap, "enabledState", a.EnabledState)
	populate(objectMap, "httpPort", a.HTTPPort)
	populate(objectMap, "httpsPort", a.HTTPSPort)
	populate(objectMap, "hostName", a.HostName)
	populate(objectMap, "originHostHeader", a.OriginHostHeader)
	populate(objectMap, "priority", a.Priority)
	populate(objectMap, "sharedPrivateLinkResource", a.SharedPrivateLinkResource)
	populate(objectMap, "weight", a.Weight)
}

func (a *AFDOriginUpdatePropertiesParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureOrigin":
			err = unpopulate(val, &a.AzureOrigin)
			delete(rawMsg, key)
		case "enabledState":
			err = unpopulate(val, &a.EnabledState)
			delete(rawMsg, key)
		case "httpPort":
			err = unpopulate(val, &a.HTTPPort)
			delete(rawMsg, key)
		case "httpsPort":
			err = unpopulate(val, &a.HTTPSPort)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &a.HostName)
			delete(rawMsg, key)
		case "originHostHeader":
			err = unpopulate(val, &a.OriginHostHeader)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, &a.Priority)
			delete(rawMsg, key)
		case "sharedPrivateLinkResource":
			err = unpopulate(val, &a.SharedPrivateLinkResource)
			delete(rawMsg, key)
		case "weight":
			err = unpopulate(val, &a.Weight)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AFDOriginsBeginCreateOptions contains the optional parameters for the AFDOrigins.BeginCreate method.
type AFDOriginsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginsBeginDeleteOptions contains the optional parameters for the AFDOrigins.BeginDelete method.
type AFDOriginsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginsBeginUpdateOptions contains the optional parameters for the AFDOrigins.BeginUpdate method.
type AFDOriginsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginsGetOptions contains the optional parameters for the AFDOrigins.Get method.
type AFDOriginsGetOptions struct {
	// placeholder for future optional parameters
}

// AFDOriginsListByOriginGroupOptions contains the optional parameters for the AFDOrigins.ListByOriginGroup method.
type AFDOriginsListByOriginGroupOptions struct {
	// placeholder for future optional parameters
}

// AFDProfilesCheckHostNameAvailabilityOptions contains the optional parameters for the AFDProfiles.CheckHostNameAvailability method.
type AFDProfilesCheckHostNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// AFDProfilesListResourceUsageOptions contains the optional parameters for the AFDProfiles.ListResourceUsage method.
type AFDProfilesListResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// AFDStateProperties - The tracking states for afd resources.
type AFDStateProperties struct {
	// READ-ONLY
	DeploymentStatus *DeploymentStatus `json:"deploymentStatus,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status
	ProvisioningState *AfdProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AFDStateProperties.
func (a AFDStateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AFDStateProperties.
func (a *AFDStateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AFDStateProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "deploymentStatus", a.DeploymentStatus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
}

func (a *AFDStateProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, &a.DeploymentStatus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AfdErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type AfdErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorResponse `json:"error,omitempty"`
}

// Error implements the error interface for type AfdErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e AfdErrorResponse) Error() string {
	return e.raw
}

// AfdPurgeParameters - Parameters required for content purge.
type AfdPurgeParameters struct {
	// REQUIRED; The path to the content to be purged. Can describe a file path or a wild card directory.
	ContentPaths []*string `json:"contentPaths,omitempty"`

	// List of domains.
	Domains []*string `json:"domains,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AfdPurgeParameters.
func (a AfdPurgeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentPaths", a.ContentPaths)
	populate(objectMap, "domains", a.Domains)
	return json.Marshal(objectMap)
}

// CacheExpirationActionParameters - Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters struct {
	// REQUIRED; Caching behavior for the requests
	CacheBehavior *CacheBehavior `json:"cacheBehavior,omitempty"`

	// REQUIRED; The level at which the content needs to be cached.
	CacheType *CacheType `json:"cacheType,omitempty"`

	// REQUIRED
	ODataType *CacheExpirationActionParametersODataType `json:"@odata.type,omitempty"`

	// The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`
}

// CacheKeyQueryStringActionParameters - Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters struct {
	// REQUIRED
	ODataType *CacheKeyQueryStringActionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Caching behavior for the requests
	QueryStringBehavior *QueryStringBehavior `json:"queryStringBehavior,omitempty"`

	// query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`
}

// CdnCertificateSourceParameters - Defines the parameters for using CDN managed certificate for securing custom domain.
type CdnCertificateSourceParameters struct {
	// REQUIRED; Type of certificate used
	CertificateType *CertificateType `json:"certificateType,omitempty"`

	// REQUIRED
	ODataType *CdnCertificateSourceParametersODataType `json:"@odata.type,omitempty"`
}

// CdnEndpoint - Defines the ARM Resource ID for the linked endpoints
type CdnEndpoint struct {
	// ARM Resource ID string.
	ID *string `json:"id,omitempty"`
}

// CdnManagedHTTPSParameters - Defines the certificate source parameters using CDN managed certificate for enabling SSL.
type CdnManagedHTTPSParameters struct {
	CustomDomainHTTPSParameters
	// REQUIRED; Defines the certificate source parameters using CDN managed certificate for enabling SSL.
	CertificateSourceParameters *CdnCertificateSourceParameters `json:"certificateSourceParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CdnManagedHTTPSParameters.
func (c CdnManagedHTTPSParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.CustomDomainHTTPSParameters.marshalInternal(objectMap, CertificateSourceCdn)
	populate(objectMap, "certificateSourceParameters", c.CertificateSourceParameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CdnManagedHTTPSParameters.
func (c *CdnManagedHTTPSParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateSourceParameters":
			err = unpopulate(val, &c.CertificateSourceParameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.CustomDomainHTTPSParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CdnManagementClientCheckNameAvailabilityOptions contains the optional parameters for the CdnManagementClient.CheckNameAvailability method.
type CdnManagementClientCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// CdnManagementClientCheckNameAvailabilityWithSubscriptionOptions contains the optional parameters for the CdnManagementClient.CheckNameAvailabilityWithSubscription
// method.
type CdnManagementClientCheckNameAvailabilityWithSubscriptionOptions struct {
	// placeholder for future optional parameters
}

// CdnManagementClientValidateProbeOptions contains the optional parameters for the CdnManagementClient.ValidateProbe method.
type CdnManagementClientValidateProbeOptions struct {
	// placeholder for future optional parameters
}

// CdnWebApplicationFirewallPolicy - Defines web application firewall policy for Azure CDN.
type CdnWebApplicationFirewallPolicy struct {
	TrackedResource
	// REQUIRED; The pricing tier (defines a CDN provider, feature list and rate) of the CdnWebApplicationFirewallPolicy.
	SKU *SKU `json:"sku,omitempty"`

	// Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Properties of the web application firewall policy.
	Properties *CdnWebApplicationFirewallPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CdnWebApplicationFirewallPolicy.
func (c CdnWebApplicationFirewallPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "sku", c.SKU)
	return json.Marshal(objectMap)
}

// CdnWebApplicationFirewallPolicyList - Defines a list of WebApplicationFirewallPolicies for Azure CDN. It contains a list of WebApplicationFirewallPolicy
// objects and a URL link to get the next set of results.
type CdnWebApplicationFirewallPolicyList struct {
	// URL to get the next set of WebApplicationFirewallPolicy objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Azure CDN WebApplicationFirewallPolicies within a resource group.
	Value []*CdnWebApplicationFirewallPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CdnWebApplicationFirewallPolicyList.
func (c CdnWebApplicationFirewallPolicyList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CdnWebApplicationFirewallPolicyPatchParameters - Properties required to update a CdnWebApplicationFirewallPolicy.
type CdnWebApplicationFirewallPolicyPatchParameters struct {
	// CdnWebApplicationFirewallPolicy tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CdnWebApplicationFirewallPolicyPatchParameters.
func (c CdnWebApplicationFirewallPolicyPatchParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// CdnWebApplicationFirewallPolicyProperties - Defines CDN web application firewall policy properties.
type CdnWebApplicationFirewallPolicyProperties struct {
	// Describes custom rules inside the policy.
	CustomRules *CustomRuleList `json:"customRules,omitempty"`

	// Describes managed rules inside the policy.
	ManagedRules *ManagedRuleSetList `json:"managedRules,omitempty"`

	// Describes policySettings for policy
	PolicySettings *PolicySettings `json:"policySettings,omitempty"`

	// Describes rate limit rules inside the policy.
	RateLimitRules *RateLimitRuleList `json:"rateLimitRules,omitempty"`

	// READ-ONLY; Describes Azure CDN endpoints associated with this Web Application Firewall policy.
	EndpointLinks []*CdnEndpoint `json:"endpointLinks,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the WebApplicationFirewallPolicy.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the policy.
	ResourceState *PolicyResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CdnWebApplicationFirewallPolicyProperties.
func (c CdnWebApplicationFirewallPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customRules", c.CustomRules)
	populate(objectMap, "endpointLinks", c.EndpointLinks)
	populate(objectMap, "managedRules", c.ManagedRules)
	populate(objectMap, "policySettings", c.PolicySettings)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "rateLimitRules", c.RateLimitRules)
	populate(objectMap, "resourceState", c.ResourceState)
	return json.Marshal(objectMap)
}

// Certificate used for https
type Certificate struct {
	// Certificate expiration date.
	ExpirationDate *string `json:"expirationDate,omitempty"`

	// Subject name in the certificate.
	Subject *string `json:"subject,omitempty"`

	// Certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Certificate.
func (c Certificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (c Certificate) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "expirationDate", c.ExpirationDate)
	populate(objectMap, "subject", c.Subject)
	populate(objectMap, "thumbprint", c.Thumbprint)
}

// CheckNameAvailabilityInput - Input of CheckNameAvailability API.
type CheckNameAvailabilityInput struct {
	// REQUIRED; The resource name to validate.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of the resource whose name is to be validated.
	Type *string `json:"type,omitempty"`
}

// CheckNameAvailabilityOutput - Output of check name availability API.
type CheckNameAvailabilityOutput struct {
	// READ-ONLY; The detailed error message describing why the name is not available.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether the name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty" azure:"ro"`

	// READ-ONLY; The reason why the name is not available.
	Reason *string `json:"reason,omitempty" azure:"ro"`
}

// CidrIPAddress - CIDR Ip address
type CidrIPAddress struct {
	// Ip address itself.
	BaseIPAddress *string `json:"baseIpAddress,omitempty"`

	// The length of the prefix of the ip address.
	PrefixLength *int32 `json:"prefixLength,omitempty"`
}

type Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems struct {
	DateTime *time.Time `json:"dateTime,omitempty"`
	Value    *float32   `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems.
func (c Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "dateTime", c.DateTime)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems.
func (c *Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateTime":
			err = unpopulateTimeRFC3339(val, &c.DateTime)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems struct {
	DateTime *time.Time `json:"dateTime,omitempty"`
	Value    *float32   `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems.
func (c Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "dateTime", c.DateTime)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems.
func (c *Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateTime":
			err = unpopulateTimeRFC3339(val, &c.DateTime)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems struct {
	Metric     *string  `json:"metric,omitempty"`
	Percentage *float64 `json:"percentage,omitempty"`
	Value      *int64   `json:"value,omitempty"`
}

// CompressionSettings - settings for compression.
type CompressionSettings struct {
	// List of content types on which compression applies. The value should be a valid MIME type.
	ContentTypesToCompress []*string `json:"contentTypesToCompress,omitempty"`

	// Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed
	// if user requests for a compressed version.
	// Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *bool `json:"isCompressionEnabled,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CompressionSettings.
func (c CompressionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentTypesToCompress", c.ContentTypesToCompress)
	populate(objectMap, "isCompressionEnabled", c.IsCompressionEnabled)
	return json.Marshal(objectMap)
}

// ContinentsResponse - Continents Response
type ContinentsResponse struct {
	Continents       []*ContinentsResponseContinentsItem       `json:"continents,omitempty"`
	CountryOrRegions []*ContinentsResponseCountryOrRegionsItem `json:"countryOrRegions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContinentsResponse.
func (c ContinentsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "continents", c.Continents)
	populate(objectMap, "countryOrRegions", c.CountryOrRegions)
	return json.Marshal(objectMap)
}

type ContinentsResponseContinentsItem struct {
	ID *string `json:"id,omitempty"`
}

type ContinentsResponseCountryOrRegionsItem struct {
	ContinentID *string `json:"continentId,omitempty"`
	ID          *string `json:"id,omitempty"`
}

// CookiesMatchConditionParameters - Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters struct {
	// REQUIRED
	ODataType *CookiesMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *CookiesOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Name of Cookies to be matched
	Selector *string `json:"selector,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CookiesMatchConditionParameters.
func (c CookiesMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", c.MatchValues)
	populate(objectMap, "negateCondition", c.NegateCondition)
	populate(objectMap, "@odata.type", c.ODataType)
	populate(objectMap, "operator", c.Operator)
	populate(objectMap, "selector", c.Selector)
	populate(objectMap, "transforms", c.Transforms)
	return json.Marshal(objectMap)
}

// CustomDomain - Friendly domain name mapping to the endpoint hostname that the customer provides for branding purposes, e.g. www.contoso.com.
type CustomDomain struct {
	ProxyResource
	// The JSON object that contains the properties of the custom domain to create.
	Properties *CustomDomainProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomDomain.
func (c CustomDomain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// CustomDomainHTTPSParametersClassification provides polymorphic access to related types.
// Call the interface's GetCustomDomainHTTPSParameters() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CdnManagedHttpsParameters, *CustomDomainHTTPSParameters, *UserManagedHttpsParameters
type CustomDomainHTTPSParametersClassification interface {
	// GetCustomDomainHTTPSParameters returns the CustomDomainHTTPSParameters content of the underlying type.
	GetCustomDomainHTTPSParameters() *CustomDomainHTTPSParameters
}

// CustomDomainHTTPSParameters - The JSON object that contains the properties to secure a custom domain.
type CustomDomainHTTPSParameters struct {
	// REQUIRED; Defines the source of the SSL certificate.
	CertificateSource *CertificateSource `json:"certificateSource,omitempty"`

	// REQUIRED; Defines the TLS extension protocol that is used for secure delivery.
	ProtocolType *ProtocolType `json:"protocolType,omitempty"`

	// TLS protocol version that will be used for Https
	MinimumTLSVersion *MinimumTLSVersion `json:"minimumTlsVersion,omitempty"`
}

// GetCustomDomainHTTPSParameters implements the CustomDomainHTTPSParametersClassification interface for type CustomDomainHTTPSParameters.
func (c *CustomDomainHTTPSParameters) GetCustomDomainHTTPSParameters() *CustomDomainHTTPSParameters {
	return c
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDomainHTTPSParameters.
func (c *CustomDomainHTTPSParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CustomDomainHTTPSParameters) marshalInternal(objectMap map[string]interface{}, discValue CertificateSource) {
	c.CertificateSource = &discValue
	objectMap["certificateSource"] = c.CertificateSource
	populate(objectMap, "minimumTlsVersion", c.MinimumTLSVersion)
	populate(objectMap, "protocolType", c.ProtocolType)
}

func (c *CustomDomainHTTPSParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateSource":
			err = unpopulate(val, &c.CertificateSource)
			delete(rawMsg, key)
		case "minimumTlsVersion":
			err = unpopulate(val, &c.MinimumTLSVersion)
			delete(rawMsg, key)
		case "protocolType":
			err = unpopulate(val, &c.ProtocolType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomDomainListResult - Result of the request to list custom domains. It contains a list of custom domain objects and a URL link to get the next set
// of results.
type CustomDomainListResult struct {
	// URL to get the next set of custom domain objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN CustomDomains within an endpoint.
	Value []*CustomDomain `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomDomainListResult.
func (c CustomDomainListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CustomDomainParameters - The customDomain JSON object required for custom domain creation or update.
type CustomDomainParameters struct {
	// The JSON object that contains the properties of the custom domain to create.
	Properties *CustomDomainPropertiesParameters `json:"properties,omitempty"`
}

// CustomDomainProperties - The JSON object that contains the properties of the custom domain to create.
type CustomDomainProperties struct {
	// REQUIRED; The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// Certificate parameters for securing custom HTTPS
	CustomHTTPSParameters CustomDomainHTTPSParametersClassification `json:"customHttpsParameters,omitempty"`

	// Special validation or data may be required when delivering CDN to some regions due to local compliance reasons. E.g. ICP license number of a custom domain
	// is required to deliver content in China.
	ValidationData *string `json:"validationData,omitempty"`

	// READ-ONLY; Provisioning status of Custom Https of the custom domain.
	CustomHTTPSProvisioningState *CustomHTTPSProvisioningState `json:"customHttpsProvisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
	CustomHTTPSProvisioningSubstate *CustomHTTPSProvisioningSubstate `json:"customHttpsProvisioningSubstate,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status of the custom domain.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the custom domain.
	ResourceState *CustomDomainResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomDomainProperties.
func (c CustomDomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customHttpsParameters", c.CustomHTTPSParameters)
	populate(objectMap, "customHttpsProvisioningState", c.CustomHTTPSProvisioningState)
	populate(objectMap, "customHttpsProvisioningSubstate", c.CustomHTTPSProvisioningSubstate)
	populate(objectMap, "hostName", c.HostName)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "resourceState", c.ResourceState)
	populate(objectMap, "validationData", c.ValidationData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDomainProperties.
func (c *CustomDomainProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customHttpsParameters":
			c.CustomHTTPSParameters, err = unmarshalCustomDomainHTTPSParametersClassification(val)
			delete(rawMsg, key)
		case "customHttpsProvisioningState":
			err = unpopulate(val, &c.CustomHTTPSProvisioningState)
			delete(rawMsg, key)
		case "customHttpsProvisioningSubstate":
			err = unpopulate(val, &c.CustomHTTPSProvisioningSubstate)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &c.HostName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &c.ResourceState)
			delete(rawMsg, key)
		case "validationData":
			err = unpopulate(val, &c.ValidationData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomDomainPropertiesParameters - The JSON object that contains the properties of the custom domain to create.
type CustomDomainPropertiesParameters struct {
	// REQUIRED; The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`
}

// CustomDomainsBeginCreateOptions contains the optional parameters for the CustomDomains.BeginCreate method.
type CustomDomainsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// CustomDomainsBeginDeleteOptions contains the optional parameters for the CustomDomains.BeginDelete method.
type CustomDomainsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// CustomDomainsBeginDisableCustomHTTPSOptions contains the optional parameters for the CustomDomains.BeginDisableCustomHTTPS method.
type CustomDomainsBeginDisableCustomHTTPSOptions struct {
	// placeholder for future optional parameters
}

// CustomDomainsBeginEnableCustomHTTPSOptions contains the optional parameters for the CustomDomains.BeginEnableCustomHTTPS method.
type CustomDomainsBeginEnableCustomHTTPSOptions struct {
	// The configuration specifying how to enable HTTPS for the custom domain - using CDN managed certificate or user's own certificate. If not specified, enabling
	// ssl uses CDN managed certificate by default.
	CustomDomainHTTPSParameters CustomDomainHTTPSParametersClassification
}

// CustomDomainsGetOptions contains the optional parameters for the CustomDomains.Get method.
type CustomDomainsGetOptions struct {
	// placeholder for future optional parameters
}

// CustomDomainsListByEndpointOptions contains the optional parameters for the CustomDomains.ListByEndpoint method.
type CustomDomainsListByEndpointOptions struct {
	// placeholder for future optional parameters
}

// CustomRule - Defines the common attributes for a custom rule that can be included in a waf policy
type CustomRule struct {
	// REQUIRED; Describes what action to be applied when rule matches
	Action *ActionType `json:"action,omitempty"`

	// REQUIRED; List of match conditions.
	MatchConditions []*MatchCondition `json:"matchConditions,omitempty"`

	// REQUIRED; Defines the name of the custom rule
	Name *string `json:"name,omitempty"`

	// REQUIRED; Defines in what order this rule be evaluated in the overall list of custom rules
	Priority *int32 `json:"priority,omitempty"`

	// Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *CustomRuleEnabledState `json:"enabledState,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomRule.
func (c CustomRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (c CustomRule) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "action", c.Action)
	populate(objectMap, "enabledState", c.EnabledState)
	populate(objectMap, "matchConditions", c.MatchConditions)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "priority", c.Priority)
}

// CustomRuleList - Defines contents of custom rules
type CustomRuleList struct {
	// List of rules
	Rules []*CustomRule `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomRuleList.
func (c CustomRuleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rules", c.Rules)
	return json.Marshal(objectMap)
}

// CustomerCertificate - Customer Certificate used for https
type CustomerCertificate struct {
	Certificate
	// REQUIRED; Complete Url to the certificate
	CertificateURL *string `json:"certificateUrl,omitempty"`

	// Certificate issuing authority.
	CertificateAuthority *string `json:"certificateAuthority,omitempty"`

	// The list of SANs.
	SubjectAlternativeNames []*string `json:"subjectAlternativeNames,omitempty"`

	// Whether to use the latest version for the certificate
	UseLatestVersion *bool `json:"useLatestVersion,omitempty"`

	// Certificate version.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomerCertificate.
func (c CustomerCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Certificate.marshalInternal(objectMap)
	populate(objectMap, "certificateAuthority", c.CertificateAuthority)
	populate(objectMap, "certificateUrl", c.CertificateURL)
	populate(objectMap, "subjectAlternativeNames", c.SubjectAlternativeNames)
	populate(objectMap, "useLatestVersion", c.UseLatestVersion)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// CustomerCertificateParameters - Customer Certificate used for https
type CustomerCertificateParameters struct {
	SecretParameters
	// REQUIRED; Resource reference to the KV secret
	SecretSource *ResourceReference `json:"secretSource,omitempty"`

	// Certificate issuing authority.
	CertificateAuthority *string `json:"certificateAuthority,omitempty"`

	// Version of the secret to be used
	SecretVersion *string `json:"secretVersion,omitempty"`

	// The list of SANs.
	SubjectAlternativeNames []*string `json:"subjectAlternativeNames,omitempty"`

	// Whether to use the latest version for the certificate
	UseLatestVersion *bool `json:"useLatestVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomerCertificateParameters.
func (c CustomerCertificateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.SecretParameters.marshalInternal(objectMap, SecretTypeCustomerCertificate)
	populate(objectMap, "certificateAuthority", c.CertificateAuthority)
	populate(objectMap, "secretSource", c.SecretSource)
	populate(objectMap, "secretVersion", c.SecretVersion)
	populate(objectMap, "subjectAlternativeNames", c.SubjectAlternativeNames)
	populate(objectMap, "useLatestVersion", c.UseLatestVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerCertificateParameters.
func (c *CustomerCertificateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateAuthority":
			err = unpopulate(val, &c.CertificateAuthority)
			delete(rawMsg, key)
		case "secretSource":
			err = unpopulate(val, &c.SecretSource)
			delete(rawMsg, key)
		case "secretVersion":
			err = unpopulate(val, &c.SecretVersion)
			delete(rawMsg, key)
		case "subjectAlternativeNames":
			err = unpopulate(val, &c.SubjectAlternativeNames)
			delete(rawMsg, key)
		case "useLatestVersion":
			err = unpopulate(val, &c.UseLatestVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.SecretParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeepCreatedOrigin - The main origin of CDN content which is added when creating a CDN endpoint.
type DeepCreatedOrigin struct {
	// REQUIRED; Origin name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// Properties of the origin created on the CDN endpoint.
	Properties *DeepCreatedOriginProperties `json:"properties,omitempty"`
}

// DeepCreatedOriginGroup - The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the origin
// group based on origin health.
type DeepCreatedOriginGroup struct {
	// REQUIRED; Origin group name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// Properties of the origin group created on the CDN endpoint.
	Properties *DeepCreatedOriginGroupProperties `json:"properties,omitempty"`
}

// DeepCreatedOriginGroupProperties - Properties of the origin group created on the CDN endpoint.
type DeepCreatedOriginGroupProperties struct {
	// REQUIRED; The source of the content being delivered via CDN within given origin group.
	Origins []*ResourceReference `json:"origins,omitempty"`

	// Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters `json:"healthProbeSettings,omitempty"`

	// The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
	ResponseBasedOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`

	// Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins.
	// This property is currently not supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int32 `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeepCreatedOriginGroupProperties.
func (d DeepCreatedOriginGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "healthProbeSettings", d.HealthProbeSettings)
	populate(objectMap, "origins", d.Origins)
	populate(objectMap, "responseBasedOriginErrorDetectionSettings", d.ResponseBasedOriginErrorDetectionSettings)
	populate(objectMap, "trafficRestorationTimeToHealedOrNewEndpointsInMinutes", d.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)
	return json.Marshal(objectMap)
}

// DeepCreatedOriginProperties - Properties of the origin created on the CDN endpoint.
type DeepCreatedOriginProperties struct {
	// REQUIRED; The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// Origin is enabled for load balancing or not. By default, origin is always enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// The value of the HTTP port. Must be between 1 and 65535.
	HTTPPort *int32 `json:"httpPort,omitempty"`

	// The value of the HTTPS port. Must be between 1 and 65535.
	HTTPSPort *int32 `json:"httpsPort,omitempty"`

	// The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such
	// as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must
	// be between 1 and 5.
	Priority *int32 `json:"priority,omitempty"`

	// The Alias of the Private Link resource. Populating this optional field indicates that this origin is 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// A custom message to be included in the approval request to connect to the Private Link.
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`

	// Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int32 `json:"weight,omitempty"`
}

// DeliveryRule - A rule that specifies a set of actions and conditions
type DeliveryRule struct {
	// REQUIRED; A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleActionAutoGeneratedClassification `json:"actions,omitempty"`

	// REQUIRED; The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,}. A rule with a lesser order will be applied before
	// a rule with a greater order. Rule with order 0 is a special
	// rule. It does not require any condition and actions listed in it will always be applied.
	Order *int32 `json:"order,omitempty"`

	// A list of conditions that must be matched for the actions to be executed
	Conditions []DeliveryRuleConditionClassification `json:"conditions,omitempty"`

	// Name of the rule
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRule.
func (d DeliveryRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", d.Actions)
	populate(objectMap, "conditions", d.Conditions)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "order", d.Order)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRule.
func (d *DeliveryRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			d.Actions, err = unmarshalDeliveryRuleActionAutoGeneratedClassificationArray(val)
			delete(rawMsg, key)
		case "conditions":
			d.Conditions, err = unmarshalDeliveryRuleConditionClassificationArray(val)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, &d.Order)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryRuleActionAutoGeneratedClassification provides polymorphic access to related types.
// Call the interface's GetDeliveryRuleActionAutoGenerated() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DeliveryRuleActionAutoGenerated, *DeliveryRuleCacheExpirationAction, *DeliveryRuleCacheKeyQueryStringAction, *DeliveryRuleRequestHeaderAction,
// - *DeliveryRuleResponseHeaderAction, *OriginGroupOverrideAction, *UrlRedirectAction, *UrlRewriteAction, *UrlSigningAction
type DeliveryRuleActionAutoGeneratedClassification interface {
	// GetDeliveryRuleActionAutoGenerated returns the DeliveryRuleActionAutoGenerated content of the underlying type.
	GetDeliveryRuleActionAutoGenerated() *DeliveryRuleActionAutoGenerated
}

// DeliveryRuleActionAutoGenerated - An action for the delivery rule.
type DeliveryRuleActionAutoGenerated struct {
	// REQUIRED; The name of the action for the delivery rule.
	Name *DeliveryRuleAction `json:"name,omitempty"`
}

// GetDeliveryRuleActionAutoGenerated implements the DeliveryRuleActionAutoGeneratedClassification interface for type DeliveryRuleActionAutoGenerated.
func (d *DeliveryRuleActionAutoGenerated) GetDeliveryRuleActionAutoGenerated() *DeliveryRuleActionAutoGenerated {
	return d
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleActionAutoGenerated.
func (d *DeliveryRuleActionAutoGenerated) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DeliveryRuleActionAutoGenerated) marshalInternal(objectMap map[string]interface{}, discValue DeliveryRuleAction) {
	d.Name = &discValue
	objectMap["name"] = d.Name
}

func (d *DeliveryRuleActionAutoGenerated) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryRuleCacheExpirationAction - Defines the cache expiration action for the delivery rule.
type DeliveryRuleCacheExpirationAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *CacheExpirationActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleCacheExpirationAction.
func (d DeliveryRuleCacheExpirationAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionCacheExpiration)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleCacheExpirationAction.
func (d *DeliveryRuleCacheExpirationAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleCacheKeyQueryStringAction - Defines the cache-key query string action for the delivery rule.
type DeliveryRuleCacheKeyQueryStringAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *CacheKeyQueryStringActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleCacheKeyQueryStringAction.
func (d DeliveryRuleCacheKeyQueryStringAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionCacheKeyQueryString)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleCacheKeyQueryStringAction.
func (d *DeliveryRuleCacheKeyQueryStringAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleConditionClassification provides polymorphic access to related types.
// Call the interface's GetDeliveryRuleCondition() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DeliveryRuleCondition, *DeliveryRuleCookiesCondition, *DeliveryRuleHttpVersionCondition, *DeliveryRuleIsDeviceCondition,
// - *DeliveryRulePostArgsCondition, *DeliveryRuleQueryStringCondition, *DeliveryRuleRemoteAddressCondition, *DeliveryRuleRequestBodyCondition,
// - *DeliveryRuleRequestHeaderCondition, *DeliveryRuleRequestMethodCondition, *DeliveryRuleRequestSchemeCondition, *DeliveryRuleRequestUriCondition,
// - *DeliveryRuleUrlFileExtensionCondition, *DeliveryRuleUrlFileNameCondition, *DeliveryRuleUrlPathCondition
type DeliveryRuleConditionClassification interface {
	// GetDeliveryRuleCondition returns the DeliveryRuleCondition content of the underlying type.
	GetDeliveryRuleCondition() *DeliveryRuleCondition
}

// DeliveryRuleCondition - A condition for the delivery rule.
type DeliveryRuleCondition struct {
	// REQUIRED; The name of the condition for the delivery rule.
	Name *MatchVariable `json:"name,omitempty"`
}

// GetDeliveryRuleCondition implements the DeliveryRuleConditionClassification interface for type DeliveryRuleCondition.
func (d *DeliveryRuleCondition) GetDeliveryRuleCondition() *DeliveryRuleCondition { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleCondition.
func (d *DeliveryRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DeliveryRuleCondition) marshalInternal(objectMap map[string]interface{}, discValue MatchVariable) {
	d.Name = &discValue
	objectMap["name"] = d.Name
}

func (d *DeliveryRuleCondition) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryRuleCookiesCondition - Defines the Cookies condition for the delivery rule.
type DeliveryRuleCookiesCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *CookiesMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleCookiesCondition.
func (d DeliveryRuleCookiesCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableCookies)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleCookiesCondition.
func (d *DeliveryRuleCookiesCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleHTTPVersionCondition - Defines the HttpVersion condition for the delivery rule.
type DeliveryRuleHTTPVersionCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *HTTPVersionMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleHTTPVersionCondition.
func (d DeliveryRuleHTTPVersionCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableHTTPVersion)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleHTTPVersionCondition.
func (d *DeliveryRuleHTTPVersionCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleIsDeviceCondition - Defines the IsDevice condition for the delivery rule.
type DeliveryRuleIsDeviceCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *IsDeviceMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleIsDeviceCondition.
func (d DeliveryRuleIsDeviceCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableIsDevice)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleIsDeviceCondition.
func (d *DeliveryRuleIsDeviceCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRulePostArgsCondition - Defines the PostArgs condition for the delivery rule.
type DeliveryRulePostArgsCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *PostArgsMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRulePostArgsCondition.
func (d DeliveryRulePostArgsCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariablePostArgs)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRulePostArgsCondition.
func (d *DeliveryRulePostArgsCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleQueryStringCondition - Defines the QueryString condition for the delivery rule.
type DeliveryRuleQueryStringCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *QueryStringMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleQueryStringCondition.
func (d DeliveryRuleQueryStringCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableQueryString)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleQueryStringCondition.
func (d *DeliveryRuleQueryStringCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRemoteAddressCondition - Defines the RemoteAddress condition for the delivery rule.
type DeliveryRuleRemoteAddressCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *RemoteAddressMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRemoteAddressCondition.
func (d DeliveryRuleRemoteAddressCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableRemoteAddress)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRemoteAddressCondition.
func (d *DeliveryRuleRemoteAddressCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRequestBodyCondition - Defines the RequestBody condition for the delivery rule.
type DeliveryRuleRequestBodyCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *RequestBodyMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRequestBodyCondition.
func (d DeliveryRuleRequestBodyCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableRequestBody)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRequestBodyCondition.
func (d *DeliveryRuleRequestBodyCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRequestHeaderAction - Defines the request header action for the delivery rule.
type DeliveryRuleRequestHeaderAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *HeaderActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRequestHeaderAction.
func (d DeliveryRuleRequestHeaderAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionModifyRequestHeader)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRequestHeaderAction.
func (d *DeliveryRuleRequestHeaderAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRequestHeaderCondition - Defines the RequestHeader condition for the delivery rule.
type DeliveryRuleRequestHeaderCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *RequestHeaderMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRequestHeaderCondition.
func (d DeliveryRuleRequestHeaderCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableRequestHeader)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRequestHeaderCondition.
func (d *DeliveryRuleRequestHeaderCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRequestMethodCondition - Defines the RequestMethod condition for the delivery rule.
type DeliveryRuleRequestMethodCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *RequestMethodMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRequestMethodCondition.
func (d DeliveryRuleRequestMethodCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableRequestMethod)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRequestMethodCondition.
func (d *DeliveryRuleRequestMethodCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRequestSchemeCondition - Defines the RequestScheme condition for the delivery rule.
type DeliveryRuleRequestSchemeCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *RequestSchemeMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRequestSchemeCondition.
func (d DeliveryRuleRequestSchemeCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableRequestScheme)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRequestSchemeCondition.
func (d *DeliveryRuleRequestSchemeCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleRequestURICondition - Defines the RequestUri condition for the delivery rule.
type DeliveryRuleRequestURICondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *RequestURIMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleRequestURICondition.
func (d DeliveryRuleRequestURICondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableRequestURI)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleRequestURICondition.
func (d *DeliveryRuleRequestURICondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleResponseHeaderAction - Defines the response header action for the delivery rule.
type DeliveryRuleResponseHeaderAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *HeaderActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleResponseHeaderAction.
func (d DeliveryRuleResponseHeaderAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionModifyResponseHeader)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleResponseHeaderAction.
func (d *DeliveryRuleResponseHeaderAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleURLFileExtensionCondition - Defines the UrlFileExtension condition for the delivery rule.
type DeliveryRuleURLFileExtensionCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *URLFileExtensionMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleURLFileExtensionCondition.
func (d DeliveryRuleURLFileExtensionCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableURLFileExtension)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleURLFileExtensionCondition.
func (d *DeliveryRuleURLFileExtensionCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleURLFileNameCondition - Defines the UrlFileName condition for the delivery rule.
type DeliveryRuleURLFileNameCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *URLFileNameMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleURLFileNameCondition.
func (d DeliveryRuleURLFileNameCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableURLFileName)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleURLFileNameCondition.
func (d *DeliveryRuleURLFileNameCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeliveryRuleURLPathCondition - Defines the UrlPath condition for the delivery rule.
type DeliveryRuleURLPathCondition struct {
	DeliveryRuleCondition
	// REQUIRED; Defines the parameters for the condition.
	Parameters *URLPathMatchConditionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryRuleURLPathCondition.
func (d DeliveryRuleURLPathCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryRuleCondition.marshalInternal(objectMap, MatchVariableURLPath)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryRuleURLPathCondition.
func (d *DeliveryRuleURLPathCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryRuleCondition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DomainValidationProperties - The JSON object that contains the properties to validate a domain.
type DomainValidationProperties struct {
	// READ-ONLY; The date time that the token expires
	ExpirationDate *string `json:"expirationDate,omitempty" azure:"ro"`

	// READ-ONLY; Challenge used for DNS TXT record or file based validation
	ValidationToken *string `json:"validationToken,omitempty" azure:"ro"`
}

// EdgeNode - Edgenode is a global Point of Presence (POP) location used to deliver CDN content to end users.
type EdgeNode struct {
	ProxyResource
	// The JSON object that contains the properties required to create an edgenode.
	Properties *EdgeNodeProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EdgeNode.
func (e EdgeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// EdgeNodeProperties - The JSON object that contains the properties required to create an edgenode.
type EdgeNodeProperties struct {
	// REQUIRED; List of ip address groups.
	IPAddressGroups []*IPAddressGroup `json:"ipAddressGroups,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EdgeNodeProperties.
func (e EdgeNodeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ipAddressGroups", e.IPAddressGroups)
	return json.Marshal(objectMap)
}

// EdgeNodesListOptions contains the optional parameters for the EdgeNodes.List method.
type EdgeNodesListOptions struct {
	// placeholder for future optional parameters
}

// EdgenodeResult - Result of the request to list CDN edgenodes. It contains a list of ip address group and a URL link to get the next set of results.
type EdgenodeResult struct {
	// URL to get the next set of edgenode list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; Edge node of CDN service.
	Value []*EdgeNode `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EdgenodeResult.
func (e EdgenodeResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// Endpoint - CDN endpoint is the entity within a CDN profile containing configuration information such as origin, protocol, content caching and delivery
// behavior. The CDN endpoint uses the URL format
// .azureedge.net.
type Endpoint struct {
	TrackedResource
	// The JSON object that contains the properties required to create an endpoint.
	Properties *EndpointProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Endpoint.
func (e Endpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// EndpointListResult - Result of the request to list endpoints. It contains a list of endpoint objects and a URL link to get the next set of results.
type EndpointListResult struct {
	// URL to get the next set of endpoint objects if there is any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN endpoints within a profile
	Value []*Endpoint `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EndpointListResult.
func (e EndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EndpointProperties - The JSON object that contains the properties required to create an endpoint.
type EndpointProperties struct {
	EndpointPropertiesUpdateParameters
	// REQUIRED; The source of the content being delivered via CDN.
	Origins []*DeepCreatedOrigin `json:"origins,omitempty"`

	// The origin groups comprising of origins that are used for load balancing the traffic based on availability.
	OriginGroups []*DeepCreatedOriginGroup `json:"originGroups,omitempty"`

	// READ-ONLY; The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
	HostName *string `json:"hostName,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status of the endpoint.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the endpoint.
	ResourceState *EndpointResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EndpointProperties.
func (e EndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.EndpointPropertiesUpdateParameters.marshalInternal(objectMap)
	populate(objectMap, "hostName", e.HostName)
	populate(objectMap, "originGroups", e.OriginGroups)
	populate(objectMap, "origins", e.Origins)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "resourceState", e.ResourceState)
	return json.Marshal(objectMap)
}

// EndpointPropertiesUpdateParameters - The JSON object containing endpoint update parameters.
type EndpointPropertiesUpdateParameters struct {
	// List of content types on which compression applies. The value should be a valid MIME type.
	ContentTypesToCompress []*string `json:"contentTypesToCompress,omitempty"`

	// A reference to the origin group.
	DefaultOriginGroup *ResourceReference `json:"defaultOriginGroup,omitempty"`

	// A policy that specifies the delivery rules to be used for an endpoint.
	DeliveryPolicy *EndpointPropertiesUpdateParametersDeliveryPolicy `json:"deliveryPolicy,omitempty"`

	// List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule to a specified path or content, e.g. block
	// APAC for path /pictures/
	GeoFilters []*GeoFilter `json:"geoFilters,omitempty"`

	// Indicates whether content compression is enabled on CDN. Default value is false. If compression is enabled, content will be served as compressed if user
	// requests for a compressed version. Content
	// won't be compressed on CDN when requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *bool `json:"isCompressionEnabled,omitempty"`

	// Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol (HTTP or HTTPS) must be allowed.
	IsHTTPAllowed *bool `json:"isHttpAllowed,omitempty"`

	// Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol (HTTP or HTTPS) must be allowed.
	IsHTTPSAllowed *bool `json:"isHttpsAllowed,omitempty"`

	// Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario
	// driven optimization.
	OptimizationType *OptimizationType `json:"optimizationType,omitempty"`

	// The host header value sent to the origin with each request. This property at Endpoint is only allowed when endpoint uses single origin and can be overridden
	// by the same property specified at origin.If
	// you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this
	// host header value to match the origin hostname by
	// default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// A directory path on the origin that CDN can use to retrieve content from, e.g. contoso.cloudapp.net/originpath.
	OriginPath *string `json:"originPath,omitempty"`

	// Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the most optimal routes for the CDN. This is
	// relative to the origin path. This property is only
	// relevant when using a single origin.
	ProbePath *string `json:"probePath,omitempty"`

	// Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain
	// query strings from being cached, or cache
	// every request with a unique URL.
	QueryStringCachingBehavior *QueryStringCachingBehavior `json:"queryStringCachingBehavior,omitempty"`

	// List of keys used to validate the signed URL hashes.
	URLSigningKeys []*URLSigningKey `json:"urlSigningKeys,omitempty"`

	// Defines the Web Application Firewall policy for the endpoint (if applicable)
	WebApplicationFirewallPolicyLink *EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EndpointPropertiesUpdateParameters.
func (e EndpointPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (e EndpointPropertiesUpdateParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "contentTypesToCompress", e.ContentTypesToCompress)
	populate(objectMap, "defaultOriginGroup", e.DefaultOriginGroup)
	populate(objectMap, "deliveryPolicy", e.DeliveryPolicy)
	populate(objectMap, "geoFilters", e.GeoFilters)
	populate(objectMap, "isCompressionEnabled", e.IsCompressionEnabled)
	populate(objectMap, "isHttpAllowed", e.IsHTTPAllowed)
	populate(objectMap, "isHttpsAllowed", e.IsHTTPSAllowed)
	populate(objectMap, "optimizationType", e.OptimizationType)
	populate(objectMap, "originHostHeader", e.OriginHostHeader)
	populate(objectMap, "originPath", e.OriginPath)
	populate(objectMap, "probePath", e.ProbePath)
	populate(objectMap, "queryStringCachingBehavior", e.QueryStringCachingBehavior)
	populate(objectMap, "urlSigningKeys", e.URLSigningKeys)
	populate(objectMap, "webApplicationFirewallPolicyLink", e.WebApplicationFirewallPolicyLink)
}

// EndpointPropertiesUpdateParametersDeliveryPolicy - A policy that specifies the delivery rules to be used for an endpoint.
type EndpointPropertiesUpdateParametersDeliveryPolicy struct {
	// REQUIRED; A list of the delivery rules.
	Rules []*DeliveryRule `json:"rules,omitempty"`

	// User-friendly description of the policy.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EndpointPropertiesUpdateParametersDeliveryPolicy.
func (e EndpointPropertiesUpdateParametersDeliveryPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", e.Description)
	populate(objectMap, "rules", e.Rules)
	return json.Marshal(objectMap)
}

// EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink - Defines the Web Application Firewall policy for the endpoint (if applicable)
type EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// EndpointUpdateParameters - Properties required to create or update an endpoint.
type EndpointUpdateParameters struct {
	// The JSON object containing endpoint update parameters.
	Properties *EndpointPropertiesUpdateParameters `json:"properties,omitempty"`

	// Endpoint tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EndpointUpdateParameters.
func (e EndpointUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// EndpointsBeginCreateOptions contains the optional parameters for the Endpoints.BeginCreate method.
type EndpointsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// EndpointsBeginDeleteOptions contains the optional parameters for the Endpoints.BeginDelete method.
type EndpointsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// EndpointsBeginLoadContentOptions contains the optional parameters for the Endpoints.BeginLoadContent method.
type EndpointsBeginLoadContentOptions struct {
	// placeholder for future optional parameters
}

// EndpointsBeginPurgeContentOptions contains the optional parameters for the Endpoints.BeginPurgeContent method.
type EndpointsBeginPurgeContentOptions struct {
	// placeholder for future optional parameters
}

// EndpointsBeginStartOptions contains the optional parameters for the Endpoints.BeginStart method.
type EndpointsBeginStartOptions struct {
	// placeholder for future optional parameters
}

// EndpointsBeginStopOptions contains the optional parameters for the Endpoints.BeginStop method.
type EndpointsBeginStopOptions struct {
	// placeholder for future optional parameters
}

// EndpointsBeginUpdateOptions contains the optional parameters for the Endpoints.BeginUpdate method.
type EndpointsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// EndpointsGetOptions contains the optional parameters for the Endpoints.Get method.
type EndpointsGetOptions struct {
	// placeholder for future optional parameters
}

// EndpointsListByProfileOptions contains the optional parameters for the Endpoints.ListByProfile method.
type EndpointsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// EndpointsListResourceUsageOptions contains the optional parameters for the Endpoints.ListResourceUsage method.
type EndpointsListResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// EndpointsValidateCustomDomainOptions contains the optional parameters for the Endpoints.ValidateCustomDomain method.
type EndpointsValidateCustomDomainOptions struct {
	// placeholder for future optional parameters
}

// ErrorResponse - Error response indicates CDN service is not able to process the incoming request. The reason is provided in the error message.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// GeoFilter - Rules defining user's geo access within a CDN endpoint.
type GeoFilter struct {
	// REQUIRED; Action of the geo filter, i.e. allow or block access.
	Action *GeoFilterActions `json:"action,omitempty"`

	// REQUIRED; Two letter country codes defining user country access in a geo filter, e.g. AU, MX, US.
	CountryCodes []*string `json:"countryCodes,omitempty"`

	// REQUIRED; Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
	RelativePath *string `json:"relativePath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoFilter.
func (g GeoFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", g.Action)
	populate(objectMap, "countryCodes", g.CountryCodes)
	populate(objectMap, "relativePath", g.RelativePath)
	return json.Marshal(objectMap)
}

// HTTPErrorRangeParameters - The JSON object that represents the range for http status codes
type HTTPErrorRangeParameters struct {
	// The inclusive start of the http status code range.
	Begin *int32 `json:"begin,omitempty"`

	// The inclusive end of the http status code range.
	End *int32 `json:"end,omitempty"`
}

// HTTPVersionMatchConditionParameters - Defines the parameters for HttpVersion match conditions
type HTTPVersionMatchConditionParameters struct {
	// REQUIRED
	ODataType *HTTPVersionMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *HTTPVersionOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPVersionMatchConditionParameters.
func (h HTTPVersionMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", h.MatchValues)
	populate(objectMap, "negateCondition", h.NegateCondition)
	populate(objectMap, "@odata.type", h.ODataType)
	populate(objectMap, "operator", h.Operator)
	return json.Marshal(objectMap)
}

// HeaderActionParameters - Defines the parameters for the request header action.
type HeaderActionParameters struct {
	// REQUIRED; Action to perform
	HeaderAction *HeaderAction `json:"headerAction,omitempty"`

	// REQUIRED; Name of the header to modify
	HeaderName *string `json:"headerName,omitempty"`

	// REQUIRED
	ODataType *HeaderActionParametersODataType `json:"@odata.type,omitempty"`

	// Value for the specified action
	Value *string `json:"value,omitempty"`
}

// HealthProbeParameters - The JSON object that contains the properties to send health probes to origin.
type HealthProbeParameters struct {
	// The number of seconds between health probes.Default is 240sec.
	ProbeIntervalInSeconds *int32 `json:"probeIntervalInSeconds,omitempty"`

	// The path relative to the origin that is used to determine the health of the origin.
	ProbePath *string `json:"probePath,omitempty"`

	// Protocol to use for health probe.
	ProbeProtocol *ProbeProtocol `json:"probeProtocol,omitempty"`

	// The type of health probe request that is made.
	ProbeRequestType *HealthProbeRequestType `json:"probeRequestType,omitempty"`
}

// IPAddressGroup - CDN Ip address group
type IPAddressGroup struct {
	// The delivery region of the ip address group
	DeliveryRegion *string `json:"deliveryRegion,omitempty"`

	// The list of ip v4 addresses.
	IPv4Addresses []*CidrIPAddress `json:"ipv4Addresses,omitempty"`

	// The list of ip v6 addresses.
	IPv6Addresses []*CidrIPAddress `json:"ipv6Addresses,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPAddressGroup.
func (i IPAddressGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryRegion", i.DeliveryRegion)
	populate(objectMap, "ipv4Addresses", i.IPv4Addresses)
	populate(objectMap, "ipv6Addresses", i.IPv6Addresses)
	return json.Marshal(objectMap)
}

// IsDeviceMatchConditionParameters - Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters struct {
	// REQUIRED
	ODataType *IsDeviceMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *IsDeviceOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*IsDeviceMatchConditionParametersMatchValuesItem `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IsDeviceMatchConditionParameters.
func (i IsDeviceMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", i.MatchValues)
	populate(objectMap, "negateCondition", i.NegateCondition)
	populate(objectMap, "@odata.type", i.ODataType)
	populate(objectMap, "operator", i.Operator)
	populate(objectMap, "transforms", i.Transforms)
	return json.Marshal(objectMap)
}

// KeyVaultCertificateSourceParameters - Describes the parameters for using a user's KeyVault certificate for securing custom domain.
type KeyVaultCertificateSourceParameters struct {
	// REQUIRED; Describes the action that shall be taken when the certificate is removed from Key Vault.
	DeleteRule *DeleteRule `json:"deleteRule,omitempty"`

	// REQUIRED
	ODataType *KeyVaultCertificateSourceParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Resource group of the user's Key Vault containing the SSL certificate
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// REQUIRED; The name of Key Vault Secret (representing the full certificate PFX) in Key Vault.
	SecretName *string `json:"secretName,omitempty"`

	// REQUIRED; Subscription Id of the user's Key Vault containing the SSL certificate
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// REQUIRED; Describes the action that shall be taken when the certificate is updated in Key Vault.
	UpdateRule *UpdateRule `json:"updateRule,omitempty"`

	// REQUIRED; The name of the user's Key Vault containing the SSL certificate
	VaultName *string `json:"vaultName,omitempty"`

	// The version(GUID) of Key Vault Secret in Key Vault.
	SecretVersion *string `json:"secretVersion,omitempty"`
}

// KeyVaultSigningKeyParameters - Describes the parameters for using a user's KeyVault for URL Signing Key.
type KeyVaultSigningKeyParameters struct {
	// REQUIRED
	ODataType *KeyVaultSigningKeyParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Resource group of the user's Key Vault containing the secret
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// REQUIRED; The name of secret in Key Vault.
	SecretName *string `json:"secretName,omitempty"`

	// REQUIRED; The version(GUID) of secret in Key Vault.
	SecretVersion *string `json:"secretVersion,omitempty"`

	// REQUIRED; Subscription Id of the user's Key Vault containing the secret
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// REQUIRED; The name of the user's Key Vault containing the secret
	VaultName *string `json:"vaultName,omitempty"`
}

// LoadBalancingSettingsParameters - Round-Robin load balancing settings for a backend pool
type LoadBalancingSettingsParameters struct {
	// The additional latency in milliseconds for probes to fall into the lowest latency bucket
	AdditionalLatencyInMilliseconds *int32 `json:"additionalLatencyInMilliseconds,omitempty"`

	// The number of samples to consider for load balancing decisions
	SampleSize *int32 `json:"sampleSize,omitempty"`

	// The number of samples within the sample period that must succeed
	SuccessfulSamplesRequired *int32 `json:"successfulSamplesRequired,omitempty"`
}

// LoadParameters - Parameters required for content load.
type LoadParameters struct {
	// REQUIRED; The path to the content to be loaded. Path should be a relative file URL of the origin.
	ContentPaths []*string `json:"contentPaths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LoadParameters.
func (l LoadParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentPaths", l.ContentPaths)
	return json.Marshal(objectMap)
}

// LogAnalyticsGetLogAnalyticsLocationsOptions contains the optional parameters for the LogAnalytics.GetLogAnalyticsLocations method.
type LogAnalyticsGetLogAnalyticsLocationsOptions struct {
	// placeholder for future optional parameters
}

// LogAnalyticsGetLogAnalyticsMetricsOptions contains the optional parameters for the LogAnalytics.GetLogAnalyticsMetrics method.
type LogAnalyticsGetLogAnalyticsMetricsOptions struct {
	Continents       []string
	CountryOrRegions []string
	GroupBy          []LogMetricsGroupBy
}

// LogAnalyticsGetLogAnalyticsRankingsOptions contains the optional parameters for the LogAnalytics.GetLogAnalyticsRankings method.
type LogAnalyticsGetLogAnalyticsRankingsOptions struct {
	CustomDomains []string
}

// LogAnalyticsGetLogAnalyticsResourcesOptions contains the optional parameters for the LogAnalytics.GetLogAnalyticsResources method.
type LogAnalyticsGetLogAnalyticsResourcesOptions struct {
	// placeholder for future optional parameters
}

// LogAnalyticsGetWafLogAnalyticsMetricsOptions contains the optional parameters for the LogAnalytics.GetWafLogAnalyticsMetrics method.
type LogAnalyticsGetWafLogAnalyticsMetricsOptions struct {
	Actions   []WafAction
	GroupBy   []WafRankingGroupBy
	RuleTypes []WafRuleType
}

// LogAnalyticsGetWafLogAnalyticsRankingsOptions contains the optional parameters for the LogAnalytics.GetWafLogAnalyticsRankings method.
type LogAnalyticsGetWafLogAnalyticsRankingsOptions struct {
	Actions   []WafAction
	RuleTypes []WafRuleType
}

// ManagedCertificate - Managed Certificate used for https
type ManagedCertificate struct {
	Certificate
}

// ManagedCertificateParameters - Managed Certificate used for https
type ManagedCertificateParameters struct {
	SecretParameters
}

// MarshalJSON implements the json.Marshaller interface for type ManagedCertificateParameters.
func (m ManagedCertificateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.SecretParameters.marshalInternal(objectMap, SecretTypeManagedCertificate)
	return json.Marshal(objectMap)
}

// ManagedRuleDefinition - Describes a managed rule definition.
type ManagedRuleDefinition struct {
	// READ-ONLY; Describes the functionality of the managed rule.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the managed rule.
	RuleID *string `json:"ruleId,omitempty" azure:"ro"`
}

// ManagedRuleGroupDefinition - Describes a managed rule group.
type ManagedRuleGroupDefinition struct {
	// READ-ONLY; Description of the managed rule group.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Name of the managed rule group.
	RuleGroupName *string `json:"ruleGroupName,omitempty" azure:"ro"`

	// READ-ONLY; List of rules within the managed rule group.
	Rules []*ManagedRuleDefinition `json:"rules,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleGroupDefinition.
func (m ManagedRuleGroupDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "ruleGroupName", m.RuleGroupName)
	populate(objectMap, "rules", m.Rules)
	return json.Marshal(objectMap)
}

// ManagedRuleGroupOverride - Defines a managed rule group override setting.
type ManagedRuleGroupOverride struct {
	// REQUIRED; Describes the managed rule group within the rule set to override
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []*ManagedRuleOverride `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleGroupOverride.
func (m ManagedRuleGroupOverride) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ruleGroupName", m.RuleGroupName)
	populate(objectMap, "rules", m.Rules)
	return json.Marshal(objectMap)
}

// ManagedRuleOverride - Defines a managed rule group override setting.
type ManagedRuleOverride struct {
	// REQUIRED; Identifier for the managed rule.
	RuleID *string `json:"ruleId,omitempty"`

	// Describes the override action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
	EnabledState *ManagedRuleEnabledState `json:"enabledState,omitempty"`
}

// ManagedRuleSet - Defines a managed rule set.
type ManagedRuleSet struct {
	// REQUIRED; Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// REQUIRED; Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`

	// Verizon only : If the rule set supports anomaly detection mode, this describes the threshold for blocking requests.
	AnomalyScore *int32 `json:"anomalyScore,omitempty"`

	// Defines the rule overrides to apply to the rule set.
	RuleGroupOverrides []*ManagedRuleGroupOverride `json:"ruleGroupOverrides,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSet.
func (m ManagedRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "anomalyScore", m.AnomalyScore)
	populate(objectMap, "ruleGroupOverrides", m.RuleGroupOverrides)
	populate(objectMap, "ruleSetType", m.RuleSetType)
	populate(objectMap, "ruleSetVersion", m.RuleSetVersion)
	return json.Marshal(objectMap)
}

// ManagedRuleSetDefinition - Describes a managed rule set definition.
type ManagedRuleSetDefinition struct {
	Resource
	// Describes managed rule set definition properties.
	Properties *ManagedRuleSetDefinitionProperties `json:"properties,omitempty"`

	// The pricing tier (defines a CDN provider, feature list and rate) of the CdnWebApplicationFirewallPolicy.
	SKU *SKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetDefinition.
func (m ManagedRuleSetDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "sku", m.SKU)
	return json.Marshal(objectMap)
}

// ManagedRuleSetDefinitionList - List of managed rule set definitions available for use in a policy.
type ManagedRuleSetDefinitionList struct {
	// URL to retrieve next set of managed rule set definitions.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of managed rule set definitions.
	Value []*ManagedRuleSetDefinition `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetDefinitionList.
func (m ManagedRuleSetDefinitionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// ManagedRuleSetDefinitionProperties - Properties for a managed rule set definition.
type ManagedRuleSetDefinitionProperties struct {
	// READ-ONLY; Provisioning state of the managed rule set.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Rule groups of the managed rule set.
	RuleGroups []*ManagedRuleGroupDefinition `json:"ruleGroups,omitempty" azure:"ro"`

	// READ-ONLY; Type of the managed rule set.
	RuleSetType *string `json:"ruleSetType,omitempty" azure:"ro"`

	// READ-ONLY; Version of the managed rule set type.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetDefinitionProperties.
func (m ManagedRuleSetDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "ruleGroups", m.RuleGroups)
	populate(objectMap, "ruleSetType", m.RuleSetType)
	populate(objectMap, "ruleSetVersion", m.RuleSetVersion)
	return json.Marshal(objectMap)
}

// ManagedRuleSetList - Defines the list of managed rule sets for the policy.
type ManagedRuleSetList struct {
	// List of rule sets.
	ManagedRuleSets []*ManagedRuleSet `json:"managedRuleSets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetList.
func (m ManagedRuleSetList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "managedRuleSets", m.ManagedRuleSets)
	return json.Marshal(objectMap)
}

// ManagedRuleSetsListOptions contains the optional parameters for the ManagedRuleSets.List method.
type ManagedRuleSetsListOptions struct {
	// placeholder for future optional parameters
}

// MatchCondition - Define match conditions
type MatchCondition struct {
	// REQUIRED; List of possible match values.
	MatchValue []*string `json:"matchValue,omitempty"`

	// REQUIRED; Match variable to compare against.
	MatchVariable *MatchVariable `json:"matchVariable,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *Operator `json:"operator,omitempty"`

	// Describes if the result of this condition should be negated.
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
	Selector *string `json:"selector,omitempty"`

	// List of transforms.
	Transforms []*TransformType `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MatchCondition.
func (m MatchCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValue", m.MatchValue)
	populate(objectMap, "matchVariable", m.MatchVariable)
	populate(objectMap, "negateCondition", m.NegateCondition)
	populate(objectMap, "operator", m.Operator)
	populate(objectMap, "selector", m.Selector)
	populate(objectMap, "transforms", m.Transforms)
	return json.Marshal(objectMap)
}

// MetricsResponse - Metrics Response
type MetricsResponse struct {
	DateTimeBegin *time.Time                   `json:"dateTimeBegin,omitempty"`
	DateTimeEnd   *time.Time                   `json:"dateTimeEnd,omitempty"`
	Granularity   *MetricsResponseGranularity  `json:"granularity,omitempty"`
	Series        []*MetricsResponseSeriesItem `json:"series,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricsResponse.
func (m MetricsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "dateTimeBegin", m.DateTimeBegin)
	populateTimeRFC3339(objectMap, "dateTimeEnd", m.DateTimeEnd)
	populate(objectMap, "granularity", m.Granularity)
	populate(objectMap, "series", m.Series)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricsResponse.
func (m *MetricsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateTimeBegin":
			err = unpopulateTimeRFC3339(val, &m.DateTimeBegin)
			delete(rawMsg, key)
		case "dateTimeEnd":
			err = unpopulateTimeRFC3339(val, &m.DateTimeEnd)
			delete(rawMsg, key)
		case "granularity":
			err = unpopulate(val, &m.Granularity)
			delete(rawMsg, key)
		case "series":
			err = unpopulate(val, &m.Series)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MetricsResponseSeriesItem struct {
	Data   []*Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems `json:"data,omitempty"`
	Groups []*MetricsResponseSeriesPropertiesItemsItem                                        `json:"groups,omitempty"`
	Metric *string                                                                            `json:"metric,omitempty"`
	Unit   *MetricsResponseSeriesItemUnit                                                     `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricsResponseSeriesItem.
func (m MetricsResponseSeriesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", m.Data)
	populate(objectMap, "groups", m.Groups)
	populate(objectMap, "metric", m.Metric)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

type MetricsResponseSeriesPropertiesItemsItem struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Operation - CDN REST API operation
type Operation struct {
	// The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty" azure:"ro"`
}

// OperationDisplay - The object that represents the operation.
type OperationDisplay struct {
	// READ-ONLY; Operation type: Read, write, delete, etc.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Service provider: Microsoft.Cdn
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource on which the operation is performed: Profile, endpoint, etc.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OperationsListResult - Result of the request to list CDN operations. It contains a list of operations and a URL link to get the next set of results.
type OperationsListResult struct {
	// URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN operations supported by the CDN resource provider.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationsListResult.
func (o OperationsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// Origin - CDN origin is the source of the content being delivered via CDN. When the edge nodes represented by an endpoint do not have the requested content
// cached, they attempt to fetch it from one or more of
// the configured origins.
type Origin struct {
	ProxyResource
	// The JSON object that contains the properties of the origin.
	Properties *OriginProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Origin.
func (o Origin) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// OriginGroup - Origin group comprising of origins is used for load balancing to origins when the content cannot be served from CDN.
type OriginGroup struct {
	ProxyResource
	// The JSON object that contains the properties of the origin group.
	Properties *OriginGroupProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginGroup.
func (o OriginGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// OriginGroupListResult - Result of the request to list origin groups. It contains a list of origin groups objects and a URL link to get the next set of
// results.
type OriginGroupListResult struct {
	// URL to get the next set of origin objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN origin groups within an endpoint
	Value []*OriginGroup `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginGroupListResult.
func (o OriginGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OriginGroupOverrideAction - Defines the origin group override action for the delivery rule.
type OriginGroupOverrideAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *OriginGroupOverrideActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginGroupOverrideAction.
func (o OriginGroupOverrideAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionOriginGroupOverride)
	populate(objectMap, "parameters", o.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginGroupOverrideAction.
func (o *OriginGroupOverrideAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := o.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// OriginGroupOverrideActionParameters - Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters struct {
	// REQUIRED
	ODataType *OriginGroupOverrideActionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; defines the OriginGroup that would override the DefaultOriginGroup.
	OriginGroup *ResourceReference `json:"originGroup,omitempty"`
}

// OriginGroupProperties - The JSON object that contains the properties of the origin group.
type OriginGroupProperties struct {
	OriginGroupUpdatePropertiesParameters
	// READ-ONLY; Provisioning status of the origin group.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the origin group.
	ResourceState *OriginGroupResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginGroupProperties.
func (o OriginGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.OriginGroupUpdatePropertiesParameters.marshalInternal(objectMap)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "resourceState", o.ResourceState)
	return json.Marshal(objectMap)
}

// OriginGroupUpdateParameters - Origin group properties needed for origin group creation or update.
type OriginGroupUpdateParameters struct {
	// The JSON object that contains the properties of the origin group.
	Properties *OriginGroupUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginGroupUpdateParameters.
func (o OriginGroupUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// OriginGroupUpdatePropertiesParameters - The JSON object that contains the properties of the origin group.
type OriginGroupUpdatePropertiesParameters struct {
	// Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters `json:"healthProbeSettings,omitempty"`

	// The source of the content being delivered via CDN within given origin group.
	Origins []*ResourceReference `json:"origins,omitempty"`

	// The JSON object that contains the properties to determine origin health using real requests/responses. This property is currently not supported.
	ResponseBasedOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`

	// Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins.
	// This property is currently not supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int32 `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginGroupUpdatePropertiesParameters.
func (o OriginGroupUpdatePropertiesParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (o OriginGroupUpdatePropertiesParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "healthProbeSettings", o.HealthProbeSettings)
	populate(objectMap, "origins", o.Origins)
	populate(objectMap, "responseBasedOriginErrorDetectionSettings", o.ResponseBasedOriginErrorDetectionSettings)
	populate(objectMap, "trafficRestorationTimeToHealedOrNewEndpointsInMinutes", o.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)
}

// OriginGroupsBeginCreateOptions contains the optional parameters for the OriginGroups.BeginCreate method.
type OriginGroupsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// OriginGroupsBeginDeleteOptions contains the optional parameters for the OriginGroups.BeginDelete method.
type OriginGroupsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// OriginGroupsBeginUpdateOptions contains the optional parameters for the OriginGroups.BeginUpdate method.
type OriginGroupsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// OriginGroupsGetOptions contains the optional parameters for the OriginGroups.Get method.
type OriginGroupsGetOptions struct {
	// placeholder for future optional parameters
}

// OriginGroupsListByEndpointOptions contains the optional parameters for the OriginGroups.ListByEndpoint method.
type OriginGroupsListByEndpointOptions struct {
	// placeholder for future optional parameters
}

// OriginListResult - Result of the request to list origins. It contains a list of origin objects and a URL link to get the next set of results.
type OriginListResult struct {
	// URL to get the next set of origin objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN origins within an endpoint
	Value []*Origin `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginListResult.
func (o OriginListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OriginProperties - The JSON object that contains the properties of the origin.
type OriginProperties struct {
	OriginUpdatePropertiesParameters
	// READ-ONLY; The approval status for the connection to the Private Link
	PrivateEndpointStatus *PrivateEndpointStatus `json:"privateEndpointStatus,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status of the origin.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the origin.
	ResourceState *OriginResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// OriginUpdateParameters - Origin properties needed for origin update.
type OriginUpdateParameters struct {
	// The JSON object that contains the properties of the origin.
	Properties *OriginUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OriginUpdateParameters.
func (o OriginUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// OriginUpdatePropertiesParameters - The JSON object that contains the properties of the origin.
type OriginUpdatePropertiesParameters struct {
	// Origin is enabled for load balancing or not
	Enabled *bool `json:"enabled,omitempty"`

	// The value of the HTTP port. Must be between 1 and 65535.
	HTTPPort *int32 `json:"httpPort,omitempty"`

	// The value of the HTTPS port. Must be between 1 and 65535.
	HTTPSPort *int32 `json:"httpsPort,omitempty"`

	// The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This should be unique across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such
	// as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default. This overrides the host header defined at Endpoint
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must
	// be between 1 and 5
	Priority *int32 `json:"priority,omitempty"`

	// The Alias of the Private Link resource. Populating this optional field indicates that this origin is 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// A custom message to be included in the approval request to connect to the Private Link.
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`

	// Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int32 `json:"weight,omitempty"`
}

// OriginsBeginCreateOptions contains the optional parameters for the Origins.BeginCreate method.
type OriginsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// OriginsBeginDeleteOptions contains the optional parameters for the Origins.BeginDelete method.
type OriginsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// OriginsBeginUpdateOptions contains the optional parameters for the Origins.BeginUpdate method.
type OriginsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// OriginsGetOptions contains the optional parameters for the Origins.Get method.
type OriginsGetOptions struct {
	// placeholder for future optional parameters
}

// OriginsListByEndpointOptions contains the optional parameters for the Origins.ListByEndpoint method.
type OriginsListByEndpointOptions struct {
	// placeholder for future optional parameters
}

// PoliciesBeginCreateOrUpdateOptions contains the optional parameters for the Policies.BeginCreateOrUpdate method.
type PoliciesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PoliciesBeginUpdateOptions contains the optional parameters for the Policies.BeginUpdate method.
type PoliciesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// PoliciesDeleteOptions contains the optional parameters for the Policies.Delete method.
type PoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// PoliciesGetOptions contains the optional parameters for the Policies.Get method.
type PoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// PoliciesListOptions contains the optional parameters for the Policies.List method.
type PoliciesListOptions struct {
	// placeholder for future optional parameters
}

// PolicySettings - Defines contents of a web application firewall global configuration
type PolicySettings struct {
	// If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
	DefaultCustomBlockResponseBody *string `json:"defaultCustomBlockResponseBody,omitempty"`

	// If the action type is block, this field defines the default customer overridable http response status code.
	DefaultCustomBlockResponseStatusCode *PolicySettingsDefaultCustomBlockResponseStatusCode `json:"defaultCustomBlockResponseStatusCode,omitempty"`

	// If action type is redirect, this field represents the default redirect URL for the client.
	DefaultRedirectURL *string `json:"defaultRedirectUrl,omitempty"`

	// describes if the policy is in enabled state or disabled state
	EnabledState *PolicyEnabledState `json:"enabledState,omitempty"`

	// Describes if it is in detection mode or prevention mode at policy level.
	Mode *PolicyMode `json:"mode,omitempty"`
}

// PostArgsMatchConditionParameters - Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters struct {
	// REQUIRED
	ODataType *PostArgsMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *PostArgsOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Name of PostArg to be matched
	Selector *string `json:"selector,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostArgsMatchConditionParameters.
func (p PostArgsMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", p.MatchValues)
	populate(objectMap, "negateCondition", p.NegateCondition)
	populate(objectMap, "@odata.type", p.ODataType)
	populate(objectMap, "operator", p.Operator)
	populate(objectMap, "selector", p.Selector)
	populate(objectMap, "transforms", p.Transforms)
	return json.Marshal(objectMap)
}

// Profile - CDN profile is a logical grouping of endpoints that share the same settings, such as CDN provider and pricing tier.
type Profile struct {
	TrackedResource
	// REQUIRED; The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
	SKU *SKU `json:"sku,omitempty"`

	// The JSON object that contains the properties required to create a profile.
	Properties *ProfileProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Profile.
func (p Profile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	return json.Marshal(objectMap)
}

// ProfileListResult - Result of the request to list profiles. It contains a list of profile objects and a URL link to get the next set of results.
type ProfileListResult struct {
	// URL to get the next set of profile objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of CDN profiles within a resource group.
	Value []*Profile `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProfileListResult.
func (p ProfileListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ProfileProperties - The JSON object that contains the properties required to create a profile.
type ProfileProperties struct {
	// READ-ONLY; The Id of the frontdoor.
	FrontdoorID *string `json:"frontdoorId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status of the profile.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the profile.
	ResourceState *ProfileResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// ProfileUpdateParameters - Properties required to update a profile.
type ProfileUpdateParameters struct {
	// Profile tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ProfileUpdateParameters.
func (p ProfileUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// ProfilesBeginCreateOptions contains the optional parameters for the Profiles.BeginCreate method.
type ProfilesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// ProfilesBeginDeleteOptions contains the optional parameters for the Profiles.BeginDelete method.
type ProfilesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ProfilesBeginUpdateOptions contains the optional parameters for the Profiles.BeginUpdate method.
type ProfilesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ProfilesGenerateSsoURIOptions contains the optional parameters for the Profiles.GenerateSsoURI method.
type ProfilesGenerateSsoURIOptions struct {
	// placeholder for future optional parameters
}

// ProfilesGetOptions contains the optional parameters for the Profiles.Get method.
type ProfilesGetOptions struct {
	// placeholder for future optional parameters
}

// ProfilesListByResourceGroupOptions contains the optional parameters for the Profiles.ListByResourceGroup method.
type ProfilesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ProfilesListOptions contains the optional parameters for the Profiles.List method.
type ProfilesListOptions struct {
	// placeholder for future optional parameters
}

// ProfilesListResourceUsageOptions contains the optional parameters for the Profiles.ListResourceUsage method.
type ProfilesListResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// ProfilesListSupportedOptimizationTypesOptions contains the optional parameters for the Profiles.ListSupportedOptimizationTypes method.
type ProfilesListSupportedOptimizationTypesOptions struct {
	// placeholder for future optional parameters
}

// ProxyResource - The resource model definition for a ARM proxy resource. It will have everything other than required location and tags
type ProxyResource struct {
	Resource
}

func (p ProxyResource) marshalInternal(objectMap map[string]interface{}) {
	p.Resource.marshalInternal(objectMap)
}

// PurgeParameters - Parameters required for content purge.
type PurgeParameters struct {
	// REQUIRED; The path to the content to be purged. Can describe a file path or a wild card directory.
	ContentPaths []*string `json:"contentPaths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PurgeParameters.
func (p PurgeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentPaths", p.ContentPaths)
	return json.Marshal(objectMap)
}

// QueryStringMatchConditionParameters - Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters struct {
	// REQUIRED
	ODataType *QueryStringMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *QueryStringOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryStringMatchConditionParameters.
func (q QueryStringMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", q.MatchValues)
	populate(objectMap, "negateCondition", q.NegateCondition)
	populate(objectMap, "@odata.type", q.ODataType)
	populate(objectMap, "operator", q.Operator)
	populate(objectMap, "transforms", q.Transforms)
	return json.Marshal(objectMap)
}

// RankingsResponse - Rankings Response
type RankingsResponse struct {
	DateTimeBegin *time.Time                    `json:"dateTimeBegin,omitempty"`
	DateTimeEnd   *time.Time                    `json:"dateTimeEnd,omitempty"`
	Tables        []*RankingsResponseTablesItem `json:"tables,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RankingsResponse.
func (r RankingsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "dateTimeBegin", r.DateTimeBegin)
	populateTimeRFC3339(objectMap, "dateTimeEnd", r.DateTimeEnd)
	populate(objectMap, "tables", r.Tables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RankingsResponse.
func (r *RankingsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateTimeBegin":
			err = unpopulateTimeRFC3339(val, &r.DateTimeBegin)
			delete(rawMsg, key)
		case "dateTimeEnd":
			err = unpopulateTimeRFC3339(val, &r.DateTimeEnd)
			delete(rawMsg, key)
		case "tables":
			err = unpopulate(val, &r.Tables)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type RankingsResponseTablesItem struct {
	Data    []*RankingsResponseTablesPropertiesItemsItem `json:"data,omitempty"`
	Ranking *string                                      `json:"ranking,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RankingsResponseTablesItem.
func (r RankingsResponseTablesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", r.Data)
	populate(objectMap, "ranking", r.Ranking)
	return json.Marshal(objectMap)
}

type RankingsResponseTablesPropertiesItemsItem struct {
	Metrics []*RankingsResponseTablesPropertiesItemsMetricsItem `json:"metrics,omitempty"`
	Name    *string                                             `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RankingsResponseTablesPropertiesItemsItem.
func (r RankingsResponseTablesPropertiesItemsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "metrics", r.Metrics)
	populate(objectMap, "name", r.Name)
	return json.Marshal(objectMap)
}

type RankingsResponseTablesPropertiesItemsMetricsItem struct {
	Metric     *string  `json:"metric,omitempty"`
	Percentage *float32 `json:"percentage,omitempty"`
	Value      *int64   `json:"value,omitempty"`
}

// RateLimitRule - Defines a rate limiting rule that can be included in a waf policy
type RateLimitRule struct {
	CustomRule
	// REQUIRED; Defines rate limit duration. Default is 1 minute.
	RateLimitDurationInMinutes *int32 `json:"rateLimitDurationInMinutes,omitempty"`

	// REQUIRED; Defines rate limit threshold.
	RateLimitThreshold *int32 `json:"rateLimitThreshold,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RateLimitRule.
func (r RateLimitRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.CustomRule.marshalInternal(objectMap)
	populate(objectMap, "rateLimitDurationInMinutes", r.RateLimitDurationInMinutes)
	populate(objectMap, "rateLimitThreshold", r.RateLimitThreshold)
	return json.Marshal(objectMap)
}

// RateLimitRuleList - Defines contents of rate limit rules
type RateLimitRuleList struct {
	// List of rules
	Rules []*RateLimitRule `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RateLimitRuleList.
func (r RateLimitRuleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rules", r.Rules)
	return json.Marshal(objectMap)
}

// RemoteAddressMatchConditionParameters - Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters struct {
	// REQUIRED
	ODataType *RemoteAddressMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *RemoteAddressOperator `json:"operator,omitempty"`

	// Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator
	// this match condition is considered a match.
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RemoteAddressMatchConditionParameters.
func (r RemoteAddressMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", r.MatchValues)
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "@odata.type", r.ODataType)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "transforms", r.Transforms)
	return json.Marshal(objectMap)
}

// RequestBodyMatchConditionParameters - Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters struct {
	// REQUIRED
	ODataType *RequestBodyMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *RequestBodyOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RequestBodyMatchConditionParameters.
func (r RequestBodyMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", r.MatchValues)
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "@odata.type", r.ODataType)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "transforms", r.Transforms)
	return json.Marshal(objectMap)
}

// RequestHeaderMatchConditionParameters - Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters struct {
	// REQUIRED
	ODataType *RequestHeaderMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *RequestHeaderOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Name of Header to be matched
	Selector *string `json:"selector,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RequestHeaderMatchConditionParameters.
func (r RequestHeaderMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", r.MatchValues)
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "@odata.type", r.ODataType)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "selector", r.Selector)
	populate(objectMap, "transforms", r.Transforms)
	return json.Marshal(objectMap)
}

// RequestMethodMatchConditionParameters - Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters struct {
	// REQUIRED
	ODataType *RequestMethodMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *RequestMethodOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*RequestMethodMatchConditionParametersMatchValuesItem `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RequestMethodMatchConditionParameters.
func (r RequestMethodMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", r.MatchValues)
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "@odata.type", r.ODataType)
	populate(objectMap, "operator", r.Operator)
	return json.Marshal(objectMap)
}

// RequestSchemeMatchConditionParameters - Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters struct {
	// REQUIRED
	ODataType *RequestSchemeMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *RequestSchemeMatchConditionParametersOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*RequestSchemeMatchConditionParametersMatchValuesItem `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RequestSchemeMatchConditionParameters.
func (r RequestSchemeMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", r.MatchValues)
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "@odata.type", r.ODataType)
	populate(objectMap, "operator", r.Operator)
	return json.Marshal(objectMap)
}

// RequestURIMatchConditionParameters - Defines the parameters for RequestUri match conditions
type RequestURIMatchConditionParameters struct {
	// REQUIRED
	ODataType *RequestURIMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *RequestURIOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RequestURIMatchConditionParameters.
func (r RequestURIMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", r.MatchValues)
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "@odata.type", r.ODataType)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "transforms", r.Transforms)
	return json.Marshal(objectMap)
}

// Resource - The core properties of ARM resources
type Resource struct {
	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Read only system data
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
}

// ResourceReference - Reference to another resource.
type ResourceReference struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// ResourceUsage - Output of check resource usage API.
type ResourceUsage struct {
	// READ-ONLY; Actual value of usage on the specified resource type.
	CurrentValue *int32 `json:"currentValue,omitempty" azure:"ro"`

	// READ-ONLY; Quota of the specified resource type.
	Limit *int32 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; Resource type for which the usage is provided.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; Unit of the usage. e.g. Count.
	Unit *string `json:"unit,omitempty" azure:"ro"`
}

// ResourceUsageListOptions contains the optional parameters for the ResourceUsage.List method.
type ResourceUsageListOptions struct {
	// placeholder for future optional parameters
}

// ResourceUsageListResult - Output of check resource usage API.
type ResourceUsageListResult struct {
	// URL to get the next set of custom domain objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of resource usages.
	Value []*ResourceUsage `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceUsageListResult.
func (r ResourceUsageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// ResourcesResponse - Resources Response
type ResourcesResponse struct {
	CustomDomains []*ResourcesResponseCustomDomainsItem `json:"customDomains,omitempty"`
	Endpoints     []*ResourcesResponseEndpointsItem     `json:"endpoints,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourcesResponse.
func (r ResourcesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customDomains", r.CustomDomains)
	populate(objectMap, "endpoints", r.Endpoints)
	return json.Marshal(objectMap)
}

type ResourcesResponseCustomDomainsItem struct {
	EndpointID *string `json:"endpointId,omitempty"`
	History    *bool   `json:"history,omitempty"`
	ID         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type ResourcesResponseEndpointsItem struct {
	CustomDomains []*ResourcesResponseEndpointsPropertiesItemsItem `json:"customDomains,omitempty"`
	History       *bool                                            `json:"history,omitempty"`
	ID            *string                                          `json:"id,omitempty"`
	Name          *string                                          `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourcesResponseEndpointsItem.
func (r ResourcesResponseEndpointsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customDomains", r.CustomDomains)
	populate(objectMap, "history", r.History)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	return json.Marshal(objectMap)
}

type ResourcesResponseEndpointsPropertiesItemsItem struct {
	EndpointID *string `json:"endpointId,omitempty"`
	History    *bool   `json:"history,omitempty"`
	ID         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
}

// ResponseBasedOriginErrorDetectionParameters - The JSON object that contains the properties to determine origin health using real requests/responses.
type ResponseBasedOriginErrorDetectionParameters struct {
	// The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
	HTTPErrorRanges []*HTTPErrorRangeParameters `json:"httpErrorRanges,omitempty"`

	// Type of response errors for real user requests for which origin will be deemed unhealthy
	ResponseBasedDetectedErrorTypes *ResponseBasedDetectedErrorTypes `json:"responseBasedDetectedErrorTypes,omitempty"`

	// The percentage of failed requests in the sample where failover should trigger.
	ResponseBasedFailoverThresholdPercentage *int32 `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponseBasedOriginErrorDetectionParameters.
func (r ResponseBasedOriginErrorDetectionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "httpErrorRanges", r.HTTPErrorRanges)
	populate(objectMap, "responseBasedDetectedErrorTypes", r.ResponseBasedDetectedErrorTypes)
	populate(objectMap, "responseBasedFailoverThresholdPercentage", r.ResponseBasedFailoverThresholdPercentage)
	return json.Marshal(objectMap)
}

// Route - Friendly Routes name mapping to the any Routes or secret related information.
type Route struct {
	ProxyResource
	// The JSON object that contains the properties of the Routes to create.
	Properties *RouteProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Route.
func (r Route) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// RouteListResult - Result of the request to list routes. It contains a list of route objects and a URL link to get the next set of results.
type RouteListResult struct {
	// URL to get the next set of route objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of AzureFrontDoor routes within a profile.
	Value []*Route `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RouteListResult.
func (r RouteListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RouteProperties - The JSON object that contains the properties of the Routes to create.
type RouteProperties struct {
	AFDStateProperties
	RouteUpdatePropertiesParameters
}

// RouteUpdateParameters - The domain JSON object required for domain creation or update.
type RouteUpdateParameters struct {
	// The JSON object that contains the properties of the domain to create.
	Properties *RouteUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RouteUpdateParameters.
func (r RouteUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// RouteUpdatePropertiesParameters - The JSON object that contains the properties of the domain to create.
type RouteUpdatePropertiesParameters struct {
	// compression settings.
	CompressionSettings map[string]interface{} `json:"compressionSettings,omitempty"`

	// Domains referenced by this endpoint.
	CustomDomains []*ResourceReference `json:"customDomains,omitempty"`

	// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *EnabledState `json:"enabledState,omitempty"`

	// Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *ForwardingProtocol `json:"forwardingProtocol,omitempty"`

	// Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that
	// gets executed.
	HTTPSRedirect *HTTPSRedirect `json:"httpsRedirect,omitempty"`

	// whether this route will be linked to the default endpoint domain.
	LinkToDefaultDomain *LinkToDefaultDomain `json:"linkToDefaultDomain,omitempty"`

	// A reference to the origin group.
	OriginGroup *ResourceReference `json:"originGroup,omitempty"`

	// A directory path on the origin that AzureFrontDoor can use to retrieve content from, e.g. contoso.cloudapp.net/originpath.
	OriginPath *string `json:"originPath,omitempty"`

	// The route patterns of the rule.
	PatternsToMatch []*string `json:"patternsToMatch,omitempty"`

	// Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain
	// query strings from being cached, or cache
	// every request with a unique URL.
	QueryStringCachingBehavior *AfdQueryStringCachingBehavior `json:"queryStringCachingBehavior,omitempty"`

	// rule sets referenced by this endpoint.
	RuleSets []*ResourceReference `json:"ruleSets,omitempty"`

	// List of supported protocols for this route.
	SupportedProtocols []*AFDEndpointProtocols `json:"supportedProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RouteUpdatePropertiesParameters.
func (r RouteUpdatePropertiesParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouteUpdatePropertiesParameters.
func (r *RouteUpdatePropertiesParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RouteUpdatePropertiesParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "compressionSettings", r.CompressionSettings)
	populate(objectMap, "customDomains", r.CustomDomains)
	populate(objectMap, "enabledState", r.EnabledState)
	populate(objectMap, "forwardingProtocol", r.ForwardingProtocol)
	populate(objectMap, "httpsRedirect", r.HTTPSRedirect)
	populate(objectMap, "linkToDefaultDomain", r.LinkToDefaultDomain)
	populate(objectMap, "originGroup", r.OriginGroup)
	populate(objectMap, "originPath", r.OriginPath)
	populate(objectMap, "patternsToMatch", r.PatternsToMatch)
	populate(objectMap, "queryStringCachingBehavior", r.QueryStringCachingBehavior)
	populate(objectMap, "ruleSets", r.RuleSets)
	populate(objectMap, "supportedProtocols", r.SupportedProtocols)
}

func (r *RouteUpdatePropertiesParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionSettings":
			err = unpopulate(val, &r.CompressionSettings)
			delete(rawMsg, key)
		case "customDomains":
			err = unpopulate(val, &r.CustomDomains)
			delete(rawMsg, key)
		case "enabledState":
			err = unpopulate(val, &r.EnabledState)
			delete(rawMsg, key)
		case "forwardingProtocol":
			err = unpopulate(val, &r.ForwardingProtocol)
			delete(rawMsg, key)
		case "httpsRedirect":
			err = unpopulate(val, &r.HTTPSRedirect)
			delete(rawMsg, key)
		case "linkToDefaultDomain":
			err = unpopulate(val, &r.LinkToDefaultDomain)
			delete(rawMsg, key)
		case "originGroup":
			err = unpopulate(val, &r.OriginGroup)
			delete(rawMsg, key)
		case "originPath":
			err = unpopulate(val, &r.OriginPath)
			delete(rawMsg, key)
		case "patternsToMatch":
			err = unpopulate(val, &r.PatternsToMatch)
			delete(rawMsg, key)
		case "queryStringCachingBehavior":
			err = unpopulate(val, &r.QueryStringCachingBehavior)
			delete(rawMsg, key)
		case "ruleSets":
			err = unpopulate(val, &r.RuleSets)
			delete(rawMsg, key)
		case "supportedProtocols":
			err = unpopulate(val, &r.SupportedProtocols)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoutesBeginCreateOptions contains the optional parameters for the Routes.BeginCreate method.
type RoutesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// RoutesBeginDeleteOptions contains the optional parameters for the Routes.BeginDelete method.
type RoutesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RoutesBeginUpdateOptions contains the optional parameters for the Routes.BeginUpdate method.
type RoutesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// RoutesGetOptions contains the optional parameters for the Routes.Get method.
type RoutesGetOptions struct {
	// placeholder for future optional parameters
}

// RoutesListByEndpointOptions contains the optional parameters for the Routes.ListByEndpoint method.
type RoutesListByEndpointOptions struct {
	// placeholder for future optional parameters
}

// Rule - Friendly Rules name mapping to the any Rules or secret related information.
type Rule struct {
	ProxyResource
	// The JSON object that contains the properties of the Rules to create.
	Properties *RuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Rule.
func (r Rule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// RuleListResult - Result of the request to list rules. It contains a list of rule objects and a URL link to get the next set of results.
type RuleListResult struct {
	// URL to get the next set of rule objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of AzureFrontDoor rules within a rule set.
	Value []*Rule `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleListResult.
func (r RuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RuleProperties - The JSON object that contains the properties of the Rules to create.
type RuleProperties struct {
	AFDStateProperties
	RuleUpdatePropertiesParameters
}

// RuleSet - Friendly RuleSet name mapping to the any RuleSet or secret related information.
type RuleSet struct {
	ProxyResource
	// The JSON object that contains the properties of the Rule Set to create.
	Properties *RuleSetProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleSet.
func (r RuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// RuleSetListResult - Result of the request to list rule sets. It contains a list of rule set objects and a URL link to get the next set of results.
type RuleSetListResult struct {
	// URL to get the next set of rule set objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of AzureFrontDoor rule sets within a profile.
	Value []*RuleSet `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleSetListResult.
func (r RuleSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RuleSetProperties - The JSON object that contains the properties of the Rule Set to create.
type RuleSetProperties struct {
	AFDStateProperties
}

// RuleSetsBeginCreateOptions contains the optional parameters for the RuleSets.BeginCreate method.
type RuleSetsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// RuleSetsBeginDeleteOptions contains the optional parameters for the RuleSets.BeginDelete method.
type RuleSetsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RuleSetsGetOptions contains the optional parameters for the RuleSets.Get method.
type RuleSetsGetOptions struct {
	// placeholder for future optional parameters
}

// RuleSetsListByProfileOptions contains the optional parameters for the RuleSets.ListByProfile method.
type RuleSetsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// RuleSetsListResourceUsageOptions contains the optional parameters for the RuleSets.ListResourceUsage method.
type RuleSetsListResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// RuleUpdateParameters - The domain JSON object required for domain creation or update.
type RuleUpdateParameters struct {
	// The JSON object that contains the properties of the domain to create.
	Properties *RuleUpdatePropertiesParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleUpdateParameters.
func (r RuleUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// RuleUpdatePropertiesParameters - The JSON object that contains the properties of the domain to create.
type RuleUpdatePropertiesParameters struct {
	// A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleActionAutoGeneratedClassification `json:"actions,omitempty"`

	// A list of conditions that must be matched for the actions to be executed
	Conditions []DeliveryRuleConditionClassification `json:"conditions,omitempty"`

	// If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
	MatchProcessingBehavior *MatchProcessingBehavior `json:"matchProcessingBehavior,omitempty"`

	// The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,}. A rule with a lesser order will be applied before a rule with
	// a greater order. Rule with order 0 is a special
	// rule. It does not require any condition and actions listed in it will always be applied.
	Order *int32 `json:"order,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleUpdatePropertiesParameters.
func (r RuleUpdatePropertiesParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleUpdatePropertiesParameters.
func (r *RuleUpdatePropertiesParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RuleUpdatePropertiesParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "actions", r.Actions)
	populate(objectMap, "conditions", r.Conditions)
	populate(objectMap, "matchProcessingBehavior", r.MatchProcessingBehavior)
	populate(objectMap, "order", r.Order)
}

func (r *RuleUpdatePropertiesParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			r.Actions, err = unmarshalDeliveryRuleActionAutoGeneratedClassificationArray(val)
			delete(rawMsg, key)
		case "conditions":
			r.Conditions, err = unmarshalDeliveryRuleConditionClassificationArray(val)
			delete(rawMsg, key)
		case "matchProcessingBehavior":
			err = unpopulate(val, &r.MatchProcessingBehavior)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, &r.Order)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RulesBeginCreateOptions contains the optional parameters for the Rules.BeginCreate method.
type RulesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// RulesBeginDeleteOptions contains the optional parameters for the Rules.BeginDelete method.
type RulesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RulesBeginUpdateOptions contains the optional parameters for the Rules.BeginUpdate method.
type RulesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// RulesGetOptions contains the optional parameters for the Rules.Get method.
type RulesGetOptions struct {
	// placeholder for future optional parameters
}

// RulesListByRuleSetOptions contains the optional parameters for the Rules.ListByRuleSet method.
type RulesListByRuleSetOptions struct {
	// placeholder for future optional parameters
}

// SKU - The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
type SKU struct {
	// Name of the pricing tier.
	Name *SKUName `json:"name,omitempty"`
}

// Secret - Friendly Secret name mapping to the any Secret or secret related information.
type Secret struct {
	ProxyResource
	// The JSON object that contains the properties of the Secret to create.
	Properties *SecretProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Secret.
func (s Secret) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SecretListResult - Result of the request to list secrets. It contains a list of Secret objects and a URL link to get the next set of results.
type SecretListResult struct {
	// URL to get the next set of Secret objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of AzureFrontDoor secrets within a profile.
	Value []*Secret `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretListResult.
func (s SecretListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SecretParametersClassification provides polymorphic access to related types.
// Call the interface's GetSecretParameters() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CustomerCertificateParameters, *ManagedCertificateParameters, *SecretParameters, *UrlSigningKeyParameters
type SecretParametersClassification interface {
	// GetSecretParameters returns the SecretParameters content of the underlying type.
	GetSecretParameters() *SecretParameters
}

// SecretParameters - The json object containing secret parameters
type SecretParameters struct {
	// REQUIRED; The type of the Secret to create.
	Type *SecretType `json:"type,omitempty"`
}

// GetSecretParameters implements the SecretParametersClassification interface for type SecretParameters.
func (s *SecretParameters) GetSecretParameters() *SecretParameters { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretParameters.
func (s *SecretParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s SecretParameters) marshalInternal(objectMap map[string]interface{}, discValue SecretType) {
	s.Type = &discValue
	objectMap["type"] = s.Type
}

func (s *SecretParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SecretProperties - The JSON object that contains the properties of the Secret to create.
type SecretProperties struct {
	AFDStateProperties
	// object which contains secret parameters
	Parameters SecretParametersClassification `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretProperties.
func (s SecretProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AFDStateProperties.marshalInternal(objectMap)
	populate(objectMap, "parameters", s.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretProperties.
func (s *SecretProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			s.Parameters, err = unmarshalSecretParametersClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AFDStateProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SecretsBeginCreateOptions contains the optional parameters for the Secrets.BeginCreate method.
type SecretsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// SecretsBeginDeleteOptions contains the optional parameters for the Secrets.BeginDelete method.
type SecretsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SecretsBeginUpdateOptions contains the optional parameters for the Secrets.BeginUpdate method.
type SecretsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SecretsGetOptions contains the optional parameters for the Secrets.Get method.
type SecretsGetOptions struct {
	// placeholder for future optional parameters
}

// SecretsListByProfileOptions contains the optional parameters for the Secrets.ListByProfile method.
type SecretsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// SecurityPoliciesBeginCreateOptions contains the optional parameters for the SecurityPolicies.BeginCreate method.
type SecurityPoliciesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// SecurityPoliciesBeginDeleteOptions contains the optional parameters for the SecurityPolicies.BeginDelete method.
type SecurityPoliciesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SecurityPoliciesBeginPatchOptions contains the optional parameters for the SecurityPolicies.BeginPatch method.
type SecurityPoliciesBeginPatchOptions struct {
	// placeholder for future optional parameters
}

// SecurityPoliciesGetOptions contains the optional parameters for the SecurityPolicies.Get method.
type SecurityPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// SecurityPoliciesListByProfileOptions contains the optional parameters for the SecurityPolicies.ListByProfile method.
type SecurityPoliciesListByProfileOptions struct {
	// placeholder for future optional parameters
}

// SecurityPolicy association for AzureFrontDoor profile
type SecurityPolicy struct {
	ProxyResource
	// The json object that contains properties required to create a security policy
	Properties *SecurityPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityPolicy.
func (s SecurityPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SecurityPolicyListResult - Result of the request to list security policies. It contains a list of security policy objects and a URL link to get the next
// set of results.
type SecurityPolicyListResult struct {
	// URL to get the next set of security policy objects if there is any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Security policies within a profile
	Value []*SecurityPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityPolicyListResult.
func (s SecurityPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SecurityPolicyParametersClassification provides polymorphic access to related types.
// Call the interface's GetSecurityPolicyParameters() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SecurityPolicyParameters, *SecurityPolicyWebApplicationFirewallParameters
type SecurityPolicyParametersClassification interface {
	// GetSecurityPolicyParameters returns the SecurityPolicyParameters content of the underlying type.
	GetSecurityPolicyParameters() *SecurityPolicyParameters
}

// SecurityPolicyParameters - The json object containing security policy parameters
type SecurityPolicyParameters struct {
	// REQUIRED; The type of the Security policy to create.
	Type *SecurityPolicyType `json:"type,omitempty"`
}

// GetSecurityPolicyParameters implements the SecurityPolicyParametersClassification interface for type SecurityPolicyParameters.
func (s *SecurityPolicyParameters) GetSecurityPolicyParameters() *SecurityPolicyParameters { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityPolicyParameters.
func (s *SecurityPolicyParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s SecurityPolicyParameters) marshalInternal(objectMap map[string]interface{}, discValue SecurityPolicyType) {
	s.Type = &discValue
	objectMap["type"] = s.Type
}

func (s *SecurityPolicyParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SecurityPolicyProperties - The json object that contains properties required to create a security policy
type SecurityPolicyProperties struct {
	AFDStateProperties
	// object which contains security policy parameters
	Parameters SecurityPolicyParametersClassification `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityPolicyProperties.
func (s SecurityPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AFDStateProperties.marshalInternal(objectMap)
	populate(objectMap, "parameters", s.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityPolicyProperties.
func (s *SecurityPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			s.Parameters, err = unmarshalSecurityPolicyParametersClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AFDStateProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SecurityPolicyWebApplicationFirewallAssociation - settings for security policy patterns to match
type SecurityPolicyWebApplicationFirewallAssociation struct {
	// List of domains.
	Domains []*ResourceReference `json:"domains,omitempty"`

	// List of paths
	PatternsToMatch []*string `json:"patternsToMatch,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityPolicyWebApplicationFirewallAssociation.
func (s SecurityPolicyWebApplicationFirewallAssociation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "domains", s.Domains)
	populate(objectMap, "patternsToMatch", s.PatternsToMatch)
	return json.Marshal(objectMap)
}

// SecurityPolicyWebApplicationFirewallParameters - The json object containing security policy waf parameters
type SecurityPolicyWebApplicationFirewallParameters struct {
	SecurityPolicyParameters
	// Waf associations
	Associations []*SecurityPolicyWebApplicationFirewallAssociation `json:"associations,omitempty"`

	// Resource ID.
	WafPolicy *ResourceReference `json:"wafPolicy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityPolicyWebApplicationFirewallParameters.
func (s SecurityPolicyWebApplicationFirewallParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SecurityPolicyParameters.marshalInternal(objectMap, SecurityPolicyTypeWebApplicationFirewall)
	populate(objectMap, "associations", s.Associations)
	populate(objectMap, "wafPolicy", s.WafPolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityPolicyWebApplicationFirewallParameters.
func (s *SecurityPolicyWebApplicationFirewallParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "associations":
			err = unpopulate(val, &s.Associations)
			delete(rawMsg, key)
		case "wafPolicy":
			err = unpopulate(val, &s.WafPolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.SecurityPolicyParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SharedPrivateLinkResourceProperties - Describes the properties of an existing Shared Private Link Resource to use when connecting to a private origin.
type SharedPrivateLinkResourceProperties struct {
	// The group id from the provider of resource the shared private link resource is for.
	GroupID *string `json:"groupId,omitempty"`

	// The resource id of the resource the shared private link resource is for.
	PrivateLink *ResourceReference `json:"privateLink,omitempty"`

	// The location of the shared private link resource
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// The request message for requesting approval of the shared private link resource.
	RequestMessage *string `json:"requestMessage,omitempty"`

	// Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
	Status *SharedPrivateLinkResourceStatus `json:"status,omitempty"`
}

// SsoURI - The URI required to login to the supplemental portal from the Azure portal.
type SsoURI struct {
	// READ-ONLY; The URI used to login to the supplemental portal.
	SsoURIValue *string `json:"ssoUriValue,omitempty" azure:"ro"`
}

// SupportedOptimizationTypesListResult - The result of the GetSupportedOptimizationTypes API
type SupportedOptimizationTypesListResult struct {
	// READ-ONLY; Supported optimization types for a profile.
	SupportedOptimizationTypes []*OptimizationType `json:"supportedOptimizationTypes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SupportedOptimizationTypesListResult.
func (s SupportedOptimizationTypesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "supportedOptimizationTypes", s.SupportedOptimizationTypes)
	return json.Marshal(objectMap)
}

// SystemData - Read only system data
type SystemData struct {
	// The timestamp of resource creation (UTC)
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// An identifier for the identity that created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource
	CreatedByType *IdentityType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// An identifier for the identity that last modified the resource
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource
	LastModifiedByType *IdentityType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TrackedResource - The resource model definition for a ARM tracked top level resource.
type TrackedResource struct {
	Resource
	// REQUIRED; Resource location.
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
}

// URLFileExtensionMatchConditionParameters - Defines the parameters for UrlFileExtension match conditions
type URLFileExtensionMatchConditionParameters struct {
	// REQUIRED
	ODataType *URLFileExtensionMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *URLFileExtensionOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLFileExtensionMatchConditionParameters.
func (u URLFileExtensionMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", u.MatchValues)
	populate(objectMap, "negateCondition", u.NegateCondition)
	populate(objectMap, "@odata.type", u.ODataType)
	populate(objectMap, "operator", u.Operator)
	populate(objectMap, "transforms", u.Transforms)
	return json.Marshal(objectMap)
}

// URLFileNameMatchConditionParameters - Defines the parameters for UrlFilename match conditions
type URLFileNameMatchConditionParameters struct {
	// REQUIRED
	ODataType *URLFileNameMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *URLFileNameOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLFileNameMatchConditionParameters.
func (u URLFileNameMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", u.MatchValues)
	populate(objectMap, "negateCondition", u.NegateCondition)
	populate(objectMap, "@odata.type", u.ODataType)
	populate(objectMap, "operator", u.Operator)
	populate(objectMap, "transforms", u.Transforms)
	return json.Marshal(objectMap)
}

// URLPathMatchConditionParameters - Defines the parameters for UrlPath match conditions
type URLPathMatchConditionParameters struct {
	// REQUIRED
	ODataType *URLPathMatchConditionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; Describes operator to be matched
	Operator *URLPathOperator `json:"operator,omitempty"`

	// The match value for the condition of the delivery rule
	MatchValues []*string `json:"matchValues,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLPathMatchConditionParameters.
func (u URLPathMatchConditionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValues", u.MatchValues)
	populate(objectMap, "negateCondition", u.NegateCondition)
	populate(objectMap, "@odata.type", u.ODataType)
	populate(objectMap, "operator", u.Operator)
	populate(objectMap, "transforms", u.Transforms)
	return json.Marshal(objectMap)
}

// URLRedirectAction - Defines the url redirect action for the delivery rule.
type URLRedirectAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *URLRedirectActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLRedirectAction.
func (u URLRedirectAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionURLRedirect)
	populate(objectMap, "parameters", u.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URLRedirectAction.
func (u *URLRedirectAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &u.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// URLRedirectActionParameters - Defines the parameters for the url redirect action.
type URLRedirectActionParameters struct {
	// REQUIRED
	ODataType *URLRedirectActionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; The redirect type the rule will use when redirecting traffic.
	RedirectType *RedirectType `json:"redirectType,omitempty"`

	// Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHostname *string `json:"customHostname,omitempty"`

	// The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming
	// query string. Query string must be in =
	// format. ? and & will be added automatically so do not include them.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// Protocol to use for the redirect. The default value is MatchRequest
	DestinationProtocol *DestinationProtocol `json:"destinationProtocol,omitempty"`
}

// URLRewriteAction - Defines the url rewrite action for the delivery rule.
type URLRewriteAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *URLRewriteActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLRewriteAction.
func (u URLRewriteAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionURLRewrite)
	populate(objectMap, "parameters", u.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URLRewriteAction.
func (u *URLRewriteAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &u.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// URLRewriteActionParameters - Defines the parameters for the url rewrite action.
type URLRewriteActionParameters struct {
	// REQUIRED; Define the relative URL to which the above requests will be rewritten by.
	Destination *string `json:"destination,omitempty"`

	// REQUIRED
	ODataType *URLRewriteActionParametersODataType `json:"@odata.type,omitempty"`

	// REQUIRED; define a request URI pattern that identifies the type of requests that may be rewritten. If value is blank, all strings are matched.
	SourcePattern *string `json:"sourcePattern,omitempty"`

	// Whether to preserve unmatched path. Default value is true.
	PreserveUnmatchedPath *bool `json:"preserveUnmatchedPath,omitempty"`
}

// URLSigningAction - Defines the url signing action for the delivery rule.
type URLSigningAction struct {
	DeliveryRuleActionAutoGenerated
	// REQUIRED; Defines the parameters for the action.
	Parameters *URLSigningActionParameters `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLSigningAction.
func (u URLSigningAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.DeliveryRuleActionAutoGenerated.marshalInternal(objectMap, DeliveryRuleActionURLSigning)
	populate(objectMap, "parameters", u.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URLSigningAction.
func (u *URLSigningAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, &u.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.DeliveryRuleActionAutoGenerated.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// URLSigningActionParameters - Defines the parameters for the Url Signing action.
type URLSigningActionParameters struct {
	// REQUIRED
	ODataType *URLSigningActionParametersODataType `json:"@odata.type,omitempty"`

	// Algorithm to use for URL signing
	Algorithm *Algorithm `json:"algorithm,omitempty"`

	// Defines which query string parameters in the url to be considered for expires, key id etc.
	ParameterNameOverride []*URLSigningParamIdentifier `json:"parameterNameOverride,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLSigningActionParameters.
func (u URLSigningActionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "algorithm", u.Algorithm)
	populate(objectMap, "@odata.type", u.ODataType)
	populate(objectMap, "parameterNameOverride", u.ParameterNameOverride)
	return json.Marshal(objectMap)
}

// URLSigningKey - Url signing key
type URLSigningKey struct {
	// REQUIRED; Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
	KeyID *string `json:"keyId,omitempty"`

	// REQUIRED; Defines the parameters for using customer key vault for Url Signing Key.
	KeySourceParameters *KeyVaultSigningKeyParameters `json:"keySourceParameters,omitempty"`
}

// URLSigningKeyParameters - Url signing key parameters
type URLSigningKeyParameters struct {
	SecretParameters
	// REQUIRED; Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
	KeyID *string `json:"keyId,omitempty"`

	// REQUIRED; Resource reference to the KV secret
	SecretSource *ResourceReference `json:"secretSource,omitempty"`

	// Version of the secret to be used
	SecretVersion *string `json:"secretVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type URLSigningKeyParameters.
func (u URLSigningKeyParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.SecretParameters.marshalInternal(objectMap, SecretTypeURLSigningKey)
	populate(objectMap, "keyId", u.KeyID)
	populate(objectMap, "secretSource", u.SecretSource)
	populate(objectMap, "secretVersion", u.SecretVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URLSigningKeyParameters.
func (u *URLSigningKeyParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyId":
			err = unpopulate(val, &u.KeyID)
			delete(rawMsg, key)
		case "secretSource":
			err = unpopulate(val, &u.SecretSource)
			delete(rawMsg, key)
		case "secretVersion":
			err = unpopulate(val, &u.SecretVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.SecretParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// URLSigningParamIdentifier - Defines how to identify a parameter for a specific purpose e.g. expires
type URLSigningParamIdentifier struct {
	// REQUIRED; Indicates the purpose of the parameter
	ParamIndicator *ParamIndicator `json:"paramIndicator,omitempty"`

	// REQUIRED; Parameter name
	ParamName *string `json:"paramName,omitempty"`
}

// Usage - Describes resource usage.
type Usage struct {
	// REQUIRED; The current value of the usage.
	CurrentValue *int64 `json:"currentValue,omitempty"`

	// REQUIRED; The limit of usage.
	Limit *int64 `json:"limit,omitempty"`

	// REQUIRED; The name of the type of usage.
	Name *UsageName `json:"name,omitempty"`

	// REQUIRED; An enum describing the unit of measurement.
	Unit *UsageUnit `json:"unit,omitempty"`

	// READ-ONLY; Resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// UsageName - The usage names.
type UsageName struct {
	// A localized string describing the resource name.
	LocalizedValue *string `json:"localizedValue,omitempty"`

	// A string describing the resource name.
	Value *string `json:"value,omitempty"`
}

// UsagesListResult - The list usages operation response.
type UsagesListResult struct {
	// URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of resource usages.
	Value []*Usage `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UsagesListResult.
func (u UsagesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UserManagedHTTPSParameters - Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
type UserManagedHTTPSParameters struct {
	CustomDomainHTTPSParameters
	// REQUIRED; Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
	CertificateSourceParameters *KeyVaultCertificateSourceParameters `json:"certificateSourceParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UserManagedHTTPSParameters.
func (u UserManagedHTTPSParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.CustomDomainHTTPSParameters.marshalInternal(objectMap, CertificateSourceAzureKeyVault)
	populate(objectMap, "certificateSourceParameters", u.CertificateSourceParameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserManagedHTTPSParameters.
func (u *UserManagedHTTPSParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateSourceParameters":
			err = unpopulate(val, &u.CertificateSourceParameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.CustomDomainHTTPSParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidateCustomDomainInput - Input of the custom domain to be validated for DNS mapping.
type ValidateCustomDomainInput struct {
	// REQUIRED; The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`
}

// ValidateCustomDomainOutput - Output of custom domain validation.
type ValidateCustomDomainOutput struct {
	// READ-ONLY; Indicates whether the custom domain is valid or not.
	CustomDomainValidated *bool `json:"customDomainValidated,omitempty" azure:"ro"`

	// READ-ONLY; Error message describing why the custom domain is not valid.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The reason why the custom domain is not valid.
	Reason *string `json:"reason,omitempty" azure:"ro"`
}

// ValidateProbeInput - Input of the validate probe API.
type ValidateProbeInput struct {
	// REQUIRED; The probe URL to validate.
	ProbeURL *string `json:"probeURL,omitempty"`
}

// ValidateProbeOutput - Output of the validate probe API.
type ValidateProbeOutput struct {
	// READ-ONLY; Specifies the error code when the probe url is not accepted.
	ErrorCode *string `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether the probe URL is accepted or not.
	IsValid *bool `json:"isValid,omitempty" azure:"ro"`

	// READ-ONLY; The detailed error message describing why the probe URL is not accepted.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ValidateSecretInput - Input of the secret to be validated.
type ValidateSecretInput struct {
	// REQUIRED; The secret source.
	SecretSource *ResourceReference `json:"secretSource,omitempty"`

	// REQUIRED; The secret type.
	SecretType *ValidateSecretType `json:"secretType,omitempty"`
}

// ValidateSecretOptions contains the optional parameters for the Validate.Secret method.
type ValidateSecretOptions struct {
	// placeholder for future optional parameters
}

// ValidateSecretOutput - Output of the validated secret.
type ValidateSecretOutput struct {
	// Detailed error message
	Message *string `json:"message,omitempty"`

	// The validation status.
	Status *Status `json:"status,omitempty"`
}

// ValidationToken - The validation token.
type ValidationToken struct {
	// READ-ONLY
	Token *string `json:"token,omitempty" azure:"ro"`
}

// WafMetricsResponse - Waf Metrics Response
type WafMetricsResponse struct {
	DateTimeBegin *time.Time                      `json:"dateTimeBegin,omitempty"`
	DateTimeEnd   *time.Time                      `json:"dateTimeEnd,omitempty"`
	Granularity   *WafMetricsResponseGranularity  `json:"granularity,omitempty"`
	Series        []*WafMetricsResponseSeriesItem `json:"series,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WafMetricsResponse.
func (w WafMetricsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "dateTimeBegin", w.DateTimeBegin)
	populateTimeRFC3339(objectMap, "dateTimeEnd", w.DateTimeEnd)
	populate(objectMap, "granularity", w.Granularity)
	populate(objectMap, "series", w.Series)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WafMetricsResponse.
func (w *WafMetricsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateTimeBegin":
			err = unpopulateTimeRFC3339(val, &w.DateTimeBegin)
			delete(rawMsg, key)
		case "dateTimeEnd":
			err = unpopulateTimeRFC3339(val, &w.DateTimeEnd)
			delete(rawMsg, key)
		case "granularity":
			err = unpopulate(val, &w.Granularity)
			delete(rawMsg, key)
		case "series":
			err = unpopulate(val, &w.Series)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type WafMetricsResponseSeriesItem struct {
	Data   []*Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems `json:"data,omitempty"`
	Groups []*WafMetricsResponseSeriesPropertiesItemsItem                                        `json:"groups,omitempty"`
	Metric *string                                                                               `json:"metric,omitempty"`
	Unit   *WafMetricsResponseSeriesItemUnit                                                     `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WafMetricsResponseSeriesItem.
func (w WafMetricsResponseSeriesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", w.Data)
	populate(objectMap, "groups", w.Groups)
	populate(objectMap, "metric", w.Metric)
	populate(objectMap, "unit", w.Unit)
	return json.Marshal(objectMap)
}

type WafMetricsResponseSeriesPropertiesItemsItem struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// WafRankingsResponse - Waf Rankings Response
type WafRankingsResponse struct {
	Data          []*WafRankingsResponseDataItem `json:"data,omitempty"`
	DateTimeBegin *time.Time                     `json:"dateTimeBegin,omitempty"`
	DateTimeEnd   *time.Time                     `json:"dateTimeEnd,omitempty"`
	Groups        []*string                      `json:"groups,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WafRankingsResponse.
func (w WafRankingsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", w.Data)
	populateTimeRFC3339(objectMap, "dateTimeBegin", w.DateTimeBegin)
	populateTimeRFC3339(objectMap, "dateTimeEnd", w.DateTimeEnd)
	populate(objectMap, "groups", w.Groups)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WafRankingsResponse.
func (w *WafRankingsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
			err = unpopulate(val, &w.Data)
			delete(rawMsg, key)
		case "dateTimeBegin":
			err = unpopulateTimeRFC3339(val, &w.DateTimeBegin)
			delete(rawMsg, key)
		case "dateTimeEnd":
			err = unpopulateTimeRFC3339(val, &w.DateTimeEnd)
			delete(rawMsg, key)
		case "groups":
			err = unpopulate(val, &w.Groups)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type WafRankingsResponseDataItem struct {
	GroupValues []*string                                                                              `json:"groupValues,omitempty"`
	Metrics     []*ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems `json:"metrics,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WafRankingsResponseDataItem.
func (w WafRankingsResponseDataItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupValues", w.GroupValues)
	populate(objectMap, "metrics", w.Metrics)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
