//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AFDCustomDomainsClientListByProfilePager provides operations for iterating over paged responses.
type AFDCustomDomainsClientListByProfilePager struct {
	client    *AFDCustomDomainsClient
	current   AFDCustomDomainsClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDCustomDomainsClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDCustomDomainsClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDCustomDomainsClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDDomainListResult.NextLink == nil || len(*p.current.AFDDomainListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDCustomDomainsClientListByProfileResponse page.
func (p *AFDCustomDomainsClientListByProfilePager) PageResponse() AFDCustomDomainsClientListByProfileResponse {
	return p.current
}

// AFDEndpointsClientListByProfilePager provides operations for iterating over paged responses.
type AFDEndpointsClientListByProfilePager struct {
	client    *AFDEndpointsClient
	current   AFDEndpointsClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDEndpointsClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDEndpointsClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDEndpointsClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDEndpointListResult.NextLink == nil || len(*p.current.AFDEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDEndpointsClientListByProfileResponse page.
func (p *AFDEndpointsClientListByProfilePager) PageResponse() AFDEndpointsClientListByProfileResponse {
	return p.current
}

// AFDEndpointsClientListResourceUsagePager provides operations for iterating over paged responses.
type AFDEndpointsClientListResourceUsagePager struct {
	client    *AFDEndpointsClient
	current   AFDEndpointsClientListResourceUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDEndpointsClientListResourceUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDEndpointsClientListResourceUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDEndpointsClientListResourceUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDEndpointsClientListResourceUsageResponse page.
func (p *AFDEndpointsClientListResourceUsagePager) PageResponse() AFDEndpointsClientListResourceUsageResponse {
	return p.current
}

// AFDOriginGroupsClientListByProfilePager provides operations for iterating over paged responses.
type AFDOriginGroupsClientListByProfilePager struct {
	client    *AFDOriginGroupsClient
	current   AFDOriginGroupsClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDOriginGroupsClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDOriginGroupsClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDOriginGroupsClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDOriginGroupListResult.NextLink == nil || len(*p.current.AFDOriginGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDOriginGroupsClientListByProfileResponse page.
func (p *AFDOriginGroupsClientListByProfilePager) PageResponse() AFDOriginGroupsClientListByProfileResponse {
	return p.current
}

// AFDOriginGroupsClientListResourceUsagePager provides operations for iterating over paged responses.
type AFDOriginGroupsClientListResourceUsagePager struct {
	client    *AFDOriginGroupsClient
	current   AFDOriginGroupsClientListResourceUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDOriginGroupsClientListResourceUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDOriginGroupsClientListResourceUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDOriginGroupsClientListResourceUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDOriginGroupsClientListResourceUsageResponse page.
func (p *AFDOriginGroupsClientListResourceUsagePager) PageResponse() AFDOriginGroupsClientListResourceUsageResponse {
	return p.current
}

// AFDOriginsClientListByOriginGroupPager provides operations for iterating over paged responses.
type AFDOriginsClientListByOriginGroupPager struct {
	client    *AFDOriginsClient
	current   AFDOriginsClientListByOriginGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDOriginsClientListByOriginGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDOriginsClientListByOriginGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDOriginsClientListByOriginGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDOriginListResult.NextLink == nil || len(*p.current.AFDOriginListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByOriginGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDOriginsClientListByOriginGroupResponse page.
func (p *AFDOriginsClientListByOriginGroupPager) PageResponse() AFDOriginsClientListByOriginGroupResponse {
	return p.current
}

// AFDProfilesClientListResourceUsagePager provides operations for iterating over paged responses.
type AFDProfilesClientListResourceUsagePager struct {
	client    *AFDProfilesClient
	current   AFDProfilesClientListResourceUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDProfilesClientListResourceUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AFDProfilesClientListResourceUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AFDProfilesClientListResourceUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AFDProfilesClientListResourceUsageResponse page.
func (p *AFDProfilesClientListResourceUsagePager) PageResponse() AFDProfilesClientListResourceUsageResponse {
	return p.current
}

// CustomDomainsClientListByEndpointPager provides operations for iterating over paged responses.
type CustomDomainsClientListByEndpointPager struct {
	client    *CustomDomainsClient
	current   CustomDomainsClientListByEndpointResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomDomainsClientListByEndpointResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomDomainsClientListByEndpointPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomDomainsClientListByEndpointPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomDomainListResult.NextLink == nil || len(*p.current.CustomDomainListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomDomainsClientListByEndpointResponse page.
func (p *CustomDomainsClientListByEndpointPager) PageResponse() CustomDomainsClientListByEndpointResponse {
	return p.current
}

// EdgeNodesClientListPager provides operations for iterating over paged responses.
type EdgeNodesClientListPager struct {
	client    *EdgeNodesClient
	current   EdgeNodesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EdgeNodesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EdgeNodesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EdgeNodesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EdgenodeResult.NextLink == nil || len(*p.current.EdgenodeResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EdgeNodesClientListResponse page.
func (p *EdgeNodesClientListPager) PageResponse() EdgeNodesClientListResponse {
	return p.current
}

// EndpointsClientListByProfilePager provides operations for iterating over paged responses.
type EndpointsClientListByProfilePager struct {
	client    *EndpointsClient
	current   EndpointsClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EndpointsClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EndpointsClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EndpointsClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EndpointListResult.NextLink == nil || len(*p.current.EndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EndpointsClientListByProfileResponse page.
func (p *EndpointsClientListByProfilePager) PageResponse() EndpointsClientListByProfileResponse {
	return p.current
}

// EndpointsClientListResourceUsagePager provides operations for iterating over paged responses.
type EndpointsClientListResourceUsagePager struct {
	client    *EndpointsClient
	current   EndpointsClientListResourceUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EndpointsClientListResourceUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EndpointsClientListResourceUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EndpointsClientListResourceUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceUsageListResult.NextLink == nil || len(*p.current.ResourceUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EndpointsClientListResourceUsageResponse page.
func (p *EndpointsClientListResourceUsagePager) PageResponse() EndpointsClientListResourceUsageResponse {
	return p.current
}

// ManagedRuleSetsClientListPager provides operations for iterating over paged responses.
type ManagedRuleSetsClientListPager struct {
	client    *ManagedRuleSetsClient
	current   ManagedRuleSetsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedRuleSetsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedRuleSetsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedRuleSetsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedRuleSetDefinitionList.NextLink == nil || len(*p.current.ManagedRuleSetDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedRuleSetsClientListResponse page.
func (p *ManagedRuleSetsClientListPager) PageResponse() ManagedRuleSetsClientListResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationsListResult.NextLink == nil || len(*p.current.OperationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// OriginGroupsClientListByEndpointPager provides operations for iterating over paged responses.
type OriginGroupsClientListByEndpointPager struct {
	client    *OriginGroupsClient
	current   OriginGroupsClientListByEndpointResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OriginGroupsClientListByEndpointResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OriginGroupsClientListByEndpointPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OriginGroupsClientListByEndpointPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OriginGroupListResult.NextLink == nil || len(*p.current.OriginGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OriginGroupsClientListByEndpointResponse page.
func (p *OriginGroupsClientListByEndpointPager) PageResponse() OriginGroupsClientListByEndpointResponse {
	return p.current
}

// OriginsClientListByEndpointPager provides operations for iterating over paged responses.
type OriginsClientListByEndpointPager struct {
	client    *OriginsClient
	current   OriginsClientListByEndpointResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OriginsClientListByEndpointResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OriginsClientListByEndpointPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OriginsClientListByEndpointPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OriginListResult.NextLink == nil || len(*p.current.OriginListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OriginsClientListByEndpointResponse page.
func (p *OriginsClientListByEndpointPager) PageResponse() OriginsClientListByEndpointResponse {
	return p.current
}

// PoliciesClientListPager provides operations for iterating over paged responses.
type PoliciesClientListPager struct {
	client    *PoliciesClient
	current   PoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyList.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PoliciesClientListResponse page.
func (p *PoliciesClientListPager) PageResponse() PoliciesClientListResponse {
	return p.current
}

// ProfilesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ProfilesClientListByResourceGroupPager struct {
	client    *ProfilesClient
	current   ProfilesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProfilesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProfilesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProfilesClientListByResourceGroupResponse page.
func (p *ProfilesClientListByResourceGroupPager) PageResponse() ProfilesClientListByResourceGroupResponse {
	return p.current
}

// ProfilesClientListPager provides operations for iterating over paged responses.
type ProfilesClientListPager struct {
	client    *ProfilesClient
	current   ProfilesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProfilesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProfilesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProfilesClientListResponse page.
func (p *ProfilesClientListPager) PageResponse() ProfilesClientListResponse {
	return p.current
}

// ProfilesClientListResourceUsagePager provides operations for iterating over paged responses.
type ProfilesClientListResourceUsagePager struct {
	client    *ProfilesClient
	current   ProfilesClientListResourceUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListResourceUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProfilesClientListResourceUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProfilesClientListResourceUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceUsageListResult.NextLink == nil || len(*p.current.ResourceUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProfilesClientListResourceUsageResponse page.
func (p *ProfilesClientListResourceUsagePager) PageResponse() ProfilesClientListResourceUsageResponse {
	return p.current
}

// ResourceUsageClientListPager provides operations for iterating over paged responses.
type ResourceUsageClientListPager struct {
	client    *ResourceUsageClient
	current   ResourceUsageClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceUsageClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceUsageClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceUsageClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceUsageListResult.NextLink == nil || len(*p.current.ResourceUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceUsageClientListResponse page.
func (p *ResourceUsageClientListPager) PageResponse() ResourceUsageClientListResponse {
	return p.current
}

// RoutesClientListByEndpointPager provides operations for iterating over paged responses.
type RoutesClientListByEndpointPager struct {
	client    *RoutesClient
	current   RoutesClientListByEndpointResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutesClientListByEndpointResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoutesClientListByEndpointPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoutesClientListByEndpointPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoutesClientListByEndpointResponse page.
func (p *RoutesClientListByEndpointPager) PageResponse() RoutesClientListByEndpointResponse {
	return p.current
}

// RuleSetsClientListByProfilePager provides operations for iterating over paged responses.
type RuleSetsClientListByProfilePager struct {
	client    *RuleSetsClient
	current   RuleSetsClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RuleSetsClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RuleSetsClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RuleSetsClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RuleSetListResult.NextLink == nil || len(*p.current.RuleSetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RuleSetsClientListByProfileResponse page.
func (p *RuleSetsClientListByProfilePager) PageResponse() RuleSetsClientListByProfileResponse {
	return p.current
}

// RuleSetsClientListResourceUsagePager provides operations for iterating over paged responses.
type RuleSetsClientListResourceUsagePager struct {
	client    *RuleSetsClient
	current   RuleSetsClientListResourceUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RuleSetsClientListResourceUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RuleSetsClientListResourceUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RuleSetsClientListResourceUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RuleSetsClientListResourceUsageResponse page.
func (p *RuleSetsClientListResourceUsagePager) PageResponse() RuleSetsClientListResourceUsageResponse {
	return p.current
}

// RulesClientListByRuleSetPager provides operations for iterating over paged responses.
type RulesClientListByRuleSetPager struct {
	client    *RulesClient
	current   RulesClientListByRuleSetResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RulesClientListByRuleSetResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RulesClientListByRuleSetPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RulesClientListByRuleSetPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RuleListResult.NextLink == nil || len(*p.current.RuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByRuleSetHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RulesClientListByRuleSetResponse page.
func (p *RulesClientListByRuleSetPager) PageResponse() RulesClientListByRuleSetResponse {
	return p.current
}

// SecretsClientListByProfilePager provides operations for iterating over paged responses.
type SecretsClientListByProfilePager struct {
	client    *SecretsClient
	current   SecretsClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecretsClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecretsClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecretsClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecretListResult.NextLink == nil || len(*p.current.SecretListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecretsClientListByProfileResponse page.
func (p *SecretsClientListByProfilePager) PageResponse() SecretsClientListByProfileResponse {
	return p.current
}

// SecurityPoliciesClientListByProfilePager provides operations for iterating over paged responses.
type SecurityPoliciesClientListByProfilePager struct {
	client    *SecurityPoliciesClient
	current   SecurityPoliciesClientListByProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPoliciesClientListByProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityPoliciesClientListByProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityPoliciesClientListByProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPolicyListResult.NextLink == nil || len(*p.current.SecurityPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityPoliciesClientListByProfileResponse page.
func (p *SecurityPoliciesClientListByProfilePager) PageResponse() SecurityPoliciesClientListByProfileResponse {
	return p.current
}
