//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// AFDCustomDomainsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDCustomDomainsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDCustomDomainsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDCustomDomainsClientCreateResponse will be returned.
func (p *AFDCustomDomainsClientCreatePoller) FinalResponse(ctx context.Context) (AFDCustomDomainsClientCreateResponse, error) {
	respType := AFDCustomDomainsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDDomain)
	if err != nil {
		return AFDCustomDomainsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDCustomDomainsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDCustomDomainsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDCustomDomainsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDCustomDomainsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDCustomDomainsClientDeleteResponse will be returned.
func (p *AFDCustomDomainsClientDeletePoller) FinalResponse(ctx context.Context) (AFDCustomDomainsClientDeleteResponse, error) {
	respType := AFDCustomDomainsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDCustomDomainsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDCustomDomainsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDCustomDomainsClientRefreshValidationTokenPoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsClientRefreshValidationTokenPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDCustomDomainsClientRefreshValidationTokenPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDCustomDomainsClientRefreshValidationTokenPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDCustomDomainsClientRefreshValidationTokenResponse will be returned.
func (p *AFDCustomDomainsClientRefreshValidationTokenPoller) FinalResponse(ctx context.Context) (AFDCustomDomainsClientRefreshValidationTokenResponse, error) {
	respType := AFDCustomDomainsClientRefreshValidationTokenResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDCustomDomainsClientRefreshValidationTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDCustomDomainsClientRefreshValidationTokenPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDCustomDomainsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDCustomDomainsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDCustomDomainsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDCustomDomainsClientUpdateResponse will be returned.
func (p *AFDCustomDomainsClientUpdatePoller) FinalResponse(ctx context.Context) (AFDCustomDomainsClientUpdateResponse, error) {
	respType := AFDCustomDomainsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDDomain)
	if err != nil {
		return AFDCustomDomainsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDCustomDomainsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDEndpointsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDEndpointsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDEndpointsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDEndpointsClientCreateResponse will be returned.
func (p *AFDEndpointsClientCreatePoller) FinalResponse(ctx context.Context) (AFDEndpointsClientCreateResponse, error) {
	respType := AFDEndpointsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDEndpoint)
	if err != nil {
		return AFDEndpointsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDEndpointsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDEndpointsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDEndpointsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDEndpointsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDEndpointsClientDeleteResponse will be returned.
func (p *AFDEndpointsClientDeletePoller) FinalResponse(ctx context.Context) (AFDEndpointsClientDeleteResponse, error) {
	respType := AFDEndpointsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDEndpointsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDEndpointsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDEndpointsClientPurgeContentPoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsClientPurgeContentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDEndpointsClientPurgeContentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDEndpointsClientPurgeContentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDEndpointsClientPurgeContentResponse will be returned.
func (p *AFDEndpointsClientPurgeContentPoller) FinalResponse(ctx context.Context) (AFDEndpointsClientPurgeContentResponse, error) {
	respType := AFDEndpointsClientPurgeContentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDEndpointsClientPurgeContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDEndpointsClientPurgeContentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDEndpointsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDEndpointsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDEndpointsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDEndpointsClientUpdateResponse will be returned.
func (p *AFDEndpointsClientUpdatePoller) FinalResponse(ctx context.Context) (AFDEndpointsClientUpdateResponse, error) {
	respType := AFDEndpointsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDEndpoint)
	if err != nil {
		return AFDEndpointsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDEndpointsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDOriginGroupsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginGroupsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDOriginGroupsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDOriginGroupsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDOriginGroupsClientCreateResponse will be returned.
func (p *AFDOriginGroupsClientCreatePoller) FinalResponse(ctx context.Context) (AFDOriginGroupsClientCreateResponse, error) {
	respType := AFDOriginGroupsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOriginGroup)
	if err != nil {
		return AFDOriginGroupsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDOriginGroupsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDOriginGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDOriginGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDOriginGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDOriginGroupsClientDeleteResponse will be returned.
func (p *AFDOriginGroupsClientDeletePoller) FinalResponse(ctx context.Context) (AFDOriginGroupsClientDeleteResponse, error) {
	respType := AFDOriginGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDOriginGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDOriginGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDOriginGroupsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginGroupsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDOriginGroupsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDOriginGroupsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDOriginGroupsClientUpdateResponse will be returned.
func (p *AFDOriginGroupsClientUpdatePoller) FinalResponse(ctx context.Context) (AFDOriginGroupsClientUpdateResponse, error) {
	respType := AFDOriginGroupsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOriginGroup)
	if err != nil {
		return AFDOriginGroupsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDOriginGroupsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDOriginsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDOriginsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDOriginsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDOriginsClientCreateResponse will be returned.
func (p *AFDOriginsClientCreatePoller) FinalResponse(ctx context.Context) (AFDOriginsClientCreateResponse, error) {
	respType := AFDOriginsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOrigin)
	if err != nil {
		return AFDOriginsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDOriginsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDOriginsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDOriginsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDOriginsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDOriginsClientDeleteResponse will be returned.
func (p *AFDOriginsClientDeletePoller) FinalResponse(ctx context.Context) (AFDOriginsClientDeleteResponse, error) {
	respType := AFDOriginsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDOriginsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDOriginsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AFDOriginsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AFDOriginsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AFDOriginsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AFDOriginsClientUpdateResponse will be returned.
func (p *AFDOriginsClientUpdatePoller) FinalResponse(ctx context.Context) (AFDOriginsClientUpdateResponse, error) {
	respType := AFDOriginsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOrigin)
	if err != nil {
		return AFDOriginsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AFDOriginsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CustomDomainsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CustomDomainsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CustomDomainsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CustomDomainsClientCreateResponse will be returned.
func (p *CustomDomainsClientCreatePoller) FinalResponse(ctx context.Context) (CustomDomainsClientCreateResponse, error) {
	respType := CustomDomainsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CustomDomainsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CustomDomainsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CustomDomainsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CustomDomainsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CustomDomainsClientDeleteResponse will be returned.
func (p *CustomDomainsClientDeletePoller) FinalResponse(ctx context.Context) (CustomDomainsClientDeleteResponse, error) {
	respType := CustomDomainsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CustomDomainsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientCreateResponse will be returned.
func (p *EndpointsClientCreatePoller) FinalResponse(ctx context.Context) (EndpointsClientCreateResponse, error) {
	respType := EndpointsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientDeleteResponse will be returned.
func (p *EndpointsClientDeletePoller) FinalResponse(ctx context.Context) (EndpointsClientDeleteResponse, error) {
	respType := EndpointsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EndpointsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientLoadContentPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientLoadContentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientLoadContentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientLoadContentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientLoadContentResponse will be returned.
func (p *EndpointsClientLoadContentPoller) FinalResponse(ctx context.Context) (EndpointsClientLoadContentResponse, error) {
	respType := EndpointsClientLoadContentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EndpointsClientLoadContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientLoadContentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientPurgeContentPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientPurgeContentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientPurgeContentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientPurgeContentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientPurgeContentResponse will be returned.
func (p *EndpointsClientPurgeContentPoller) FinalResponse(ctx context.Context) (EndpointsClientPurgeContentResponse, error) {
	respType := EndpointsClientPurgeContentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EndpointsClientPurgeContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientPurgeContentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientStartResponse will be returned.
func (p *EndpointsClientStartPoller) FinalResponse(ctx context.Context) (EndpointsClientStartResponse, error) {
	respType := EndpointsClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientStopPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientStopResponse will be returned.
func (p *EndpointsClientStopPoller) FinalResponse(ctx context.Context) (EndpointsClientStopResponse, error) {
	respType := EndpointsClientStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsClientStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EndpointsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EndpointsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EndpointsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EndpointsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EndpointsClientUpdateResponse will be returned.
func (p *EndpointsClientUpdatePoller) FinalResponse(ctx context.Context) (EndpointsClientUpdateResponse, error) {
	respType := EndpointsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EndpointsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OriginGroupsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type OriginGroupsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OriginGroupsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OriginGroupsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OriginGroupsClientCreateResponse will be returned.
func (p *OriginGroupsClientCreatePoller) FinalResponse(ctx context.Context) (OriginGroupsClientCreateResponse, error) {
	respType := OriginGroupsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OriginGroup)
	if err != nil {
		return OriginGroupsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OriginGroupsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OriginGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type OriginGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OriginGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OriginGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OriginGroupsClientDeleteResponse will be returned.
func (p *OriginGroupsClientDeletePoller) FinalResponse(ctx context.Context) (OriginGroupsClientDeleteResponse, error) {
	respType := OriginGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OriginGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OriginGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OriginGroupsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OriginGroupsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OriginGroupsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OriginGroupsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OriginGroupsClientUpdateResponse will be returned.
func (p *OriginGroupsClientUpdatePoller) FinalResponse(ctx context.Context) (OriginGroupsClientUpdateResponse, error) {
	respType := OriginGroupsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OriginGroup)
	if err != nil {
		return OriginGroupsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OriginGroupsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OriginsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type OriginsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OriginsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OriginsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OriginsClientCreateResponse will be returned.
func (p *OriginsClientCreatePoller) FinalResponse(ctx context.Context) (OriginsClientCreateResponse, error) {
	respType := OriginsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Origin)
	if err != nil {
		return OriginsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OriginsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OriginsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type OriginsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OriginsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OriginsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OriginsClientDeleteResponse will be returned.
func (p *OriginsClientDeletePoller) FinalResponse(ctx context.Context) (OriginsClientDeleteResponse, error) {
	respType := OriginsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OriginsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OriginsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OriginsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OriginsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OriginsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OriginsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OriginsClientUpdateResponse will be returned.
func (p *OriginsClientUpdatePoller) FinalResponse(ctx context.Context) (OriginsClientUpdateResponse, error) {
	respType := OriginsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Origin)
	if err != nil {
		return OriginsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OriginsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PoliciesClientCreateOrUpdateResponse will be returned.
func (p *PoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PoliciesClientCreateOrUpdateResponse, error) {
	respType := PoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WebApplicationFirewallPolicy)
	if err != nil {
		return PoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PoliciesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PoliciesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PoliciesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PoliciesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PoliciesClientUpdateResponse will be returned.
func (p *PoliciesClientUpdatePoller) FinalResponse(ctx context.Context) (PoliciesClientUpdateResponse, error) {
	respType := PoliciesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WebApplicationFirewallPolicy)
	if err != nil {
		return PoliciesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PoliciesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ProfilesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ProfilesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ProfilesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ProfilesClientCreateResponse will be returned.
func (p *ProfilesClientCreatePoller) FinalResponse(ctx context.Context) (ProfilesClientCreateResponse, error) {
	respType := ProfilesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Profile)
	if err != nil {
		return ProfilesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ProfilesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ProfilesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ProfilesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ProfilesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ProfilesClientDeleteResponse will be returned.
func (p *ProfilesClientDeletePoller) FinalResponse(ctx context.Context) (ProfilesClientDeleteResponse, error) {
	respType := ProfilesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ProfilesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ProfilesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ProfilesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ProfilesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ProfilesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ProfilesClientUpdateResponse will be returned.
func (p *ProfilesClientUpdatePoller) FinalResponse(ctx context.Context) (ProfilesClientUpdateResponse, error) {
	respType := ProfilesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Profile)
	if err != nil {
		return ProfilesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ProfilesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutesClientCreateResponse will be returned.
func (p *RoutesClientCreatePoller) FinalResponse(ctx context.Context) (RoutesClientCreateResponse, error) {
	respType := RoutesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Route)
	if err != nil {
		return RoutesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RoutesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutesClientDeleteResponse will be returned.
func (p *RoutesClientDeletePoller) FinalResponse(ctx context.Context) (RoutesClientDeleteResponse, error) {
	respType := RoutesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RoutesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutesClientUpdateResponse will be returned.
func (p *RoutesClientUpdatePoller) FinalResponse(ctx context.Context) (RoutesClientUpdateResponse, error) {
	respType := RoutesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Route)
	if err != nil {
		return RoutesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RuleSetsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RuleSetsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RuleSetsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RuleSetsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RuleSetsClientDeleteResponse will be returned.
func (p *RuleSetsClientDeletePoller) FinalResponse(ctx context.Context) (RuleSetsClientDeleteResponse, error) {
	respType := RuleSetsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RuleSetsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RuleSetsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RulesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type RulesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RulesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RulesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RulesClientCreateResponse will be returned.
func (p *RulesClientCreatePoller) FinalResponse(ctx context.Context) (RulesClientCreateResponse, error) {
	respType := RulesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Rule)
	if err != nil {
		return RulesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RulesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RulesClientDeleteResponse will be returned.
func (p *RulesClientDeletePoller) FinalResponse(ctx context.Context) (RulesClientDeleteResponse, error) {
	respType := RulesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RulesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RulesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RulesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RulesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RulesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RulesClientUpdateResponse will be returned.
func (p *RulesClientUpdatePoller) FinalResponse(ctx context.Context) (RulesClientUpdateResponse, error) {
	respType := RulesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Rule)
	if err != nil {
		return RulesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RulesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecretsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type SecretsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecretsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecretsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecretsClientCreateResponse will be returned.
func (p *SecretsClientCreatePoller) FinalResponse(ctx context.Context) (SecretsClientCreateResponse, error) {
	respType := SecretsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Secret)
	if err != nil {
		return SecretsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecretsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecretsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecretsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecretsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecretsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecretsClientDeleteResponse will be returned.
func (p *SecretsClientDeletePoller) FinalResponse(ctx context.Context) (SecretsClientDeleteResponse, error) {
	respType := SecretsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecretsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecretsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityPoliciesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPoliciesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPoliciesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityPoliciesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityPoliciesClientCreateResponse will be returned.
func (p *SecurityPoliciesClientCreatePoller) FinalResponse(ctx context.Context) (SecurityPoliciesClientCreateResponse, error) {
	respType := SecurityPoliciesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityPolicy)
	if err != nil {
		return SecurityPoliciesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityPoliciesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityPoliciesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPoliciesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPoliciesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityPoliciesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityPoliciesClientDeleteResponse will be returned.
func (p *SecurityPoliciesClientDeletePoller) FinalResponse(ctx context.Context) (SecurityPoliciesClientDeleteResponse, error) {
	respType := SecurityPoliciesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecurityPoliciesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityPoliciesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityPoliciesClientPatchPoller provides polling facilities until the operation reaches a terminal state.
type SecurityPoliciesClientPatchPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPoliciesClientPatchPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityPoliciesClientPatchPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityPoliciesClientPatchResponse will be returned.
func (p *SecurityPoliciesClientPatchPoller) FinalResponse(ctx context.Context) (SecurityPoliciesClientPatchResponse, error) {
	respType := SecurityPoliciesClientPatchResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityPolicy)
	if err != nil {
		return SecurityPoliciesClientPatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityPoliciesClientPatchPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
