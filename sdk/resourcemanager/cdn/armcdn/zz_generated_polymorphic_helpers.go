//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import "encoding/json"

func unmarshalCustomDomainHTTPSParametersClassification(rawMsg json.RawMessage) (CustomDomainHTTPSParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b CustomDomainHTTPSParametersClassification
	switch m["certificateSource"] {
	case string(CertificateSourceAzureKeyVault):
		b = &UserManagedHTTPSParameters{}
	case string(CertificateSourceCdn):
		b = &CdnManagedHTTPSParameters{}
	default:
		b = &CustomDomainHTTPSParameters{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalCustomDomainHTTPSParametersClassificationArray(rawMsg json.RawMessage) ([]CustomDomainHTTPSParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CustomDomainHTTPSParametersClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCustomDomainHTTPSParametersClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalCustomDomainHTTPSParametersClassificationMap(rawMsg json.RawMessage) (map[string]CustomDomainHTTPSParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]CustomDomainHTTPSParametersClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalCustomDomainHTTPSParametersClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalDeliveryRuleActionAutoGeneratedClassification(rawMsg json.RawMessage) (DeliveryRuleActionAutoGeneratedClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b DeliveryRuleActionAutoGeneratedClassification
	switch m["name"] {
	case string(DeliveryRuleActionCacheExpiration):
		b = &DeliveryRuleCacheExpirationAction{}
	case string(DeliveryRuleActionCacheKeyQueryString):
		b = &DeliveryRuleCacheKeyQueryStringAction{}
	case string(DeliveryRuleActionModifyRequestHeader):
		b = &DeliveryRuleRequestHeaderAction{}
	case string(DeliveryRuleActionModifyResponseHeader):
		b = &DeliveryRuleResponseHeaderAction{}
	case string(DeliveryRuleActionOriginGroupOverride):
		b = &OriginGroupOverrideAction{}
	case string(DeliveryRuleActionURLRedirect):
		b = &URLRedirectAction{}
	case string(DeliveryRuleActionURLRewrite):
		b = &URLRewriteAction{}
	case string(DeliveryRuleActionURLSigning):
		b = &URLSigningAction{}
	default:
		b = &DeliveryRuleActionAutoGenerated{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalDeliveryRuleActionAutoGeneratedClassificationArray(rawMsg json.RawMessage) ([]DeliveryRuleActionAutoGeneratedClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DeliveryRuleActionAutoGeneratedClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDeliveryRuleActionAutoGeneratedClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalDeliveryRuleActionAutoGeneratedClassificationMap(rawMsg json.RawMessage) (map[string]DeliveryRuleActionAutoGeneratedClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]DeliveryRuleActionAutoGeneratedClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalDeliveryRuleActionAutoGeneratedClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalDeliveryRuleConditionClassification(rawMsg json.RawMessage) (DeliveryRuleConditionClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b DeliveryRuleConditionClassification
	switch m["name"] {
	case string(MatchVariableCookies):
		b = &DeliveryRuleCookiesCondition{}
	case string(MatchVariableHTTPVersion):
		b = &DeliveryRuleHTTPVersionCondition{}
	case string(MatchVariableIsDevice):
		b = &DeliveryRuleIsDeviceCondition{}
	case string(MatchVariablePostArgs):
		b = &DeliveryRulePostArgsCondition{}
	case string(MatchVariableQueryString):
		b = &DeliveryRuleQueryStringCondition{}
	case string(MatchVariableRemoteAddress):
		b = &DeliveryRuleRemoteAddressCondition{}
	case string(MatchVariableRequestBody):
		b = &DeliveryRuleRequestBodyCondition{}
	case string(MatchVariableRequestHeader):
		b = &DeliveryRuleRequestHeaderCondition{}
	case string(MatchVariableRequestMethod):
		b = &DeliveryRuleRequestMethodCondition{}
	case string(MatchVariableRequestScheme):
		b = &DeliveryRuleRequestSchemeCondition{}
	case string(MatchVariableRequestURI):
		b = &DeliveryRuleRequestURICondition{}
	case string(MatchVariableURLFileExtension):
		b = &DeliveryRuleURLFileExtensionCondition{}
	case string(MatchVariableURLFileName):
		b = &DeliveryRuleURLFileNameCondition{}
	case string(MatchVariableURLPath):
		b = &DeliveryRuleURLPathCondition{}
	default:
		b = &DeliveryRuleCondition{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalDeliveryRuleConditionClassificationArray(rawMsg json.RawMessage) ([]DeliveryRuleConditionClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DeliveryRuleConditionClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDeliveryRuleConditionClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalDeliveryRuleConditionClassificationMap(rawMsg json.RawMessage) (map[string]DeliveryRuleConditionClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]DeliveryRuleConditionClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalDeliveryRuleConditionClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalSecretParametersClassification(rawMsg json.RawMessage) (SecretParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SecretParametersClassification
	switch m["type"] {
	case string(SecretTypeCustomerCertificate):
		b = &CustomerCertificateParameters{}
	case string(SecretTypeManagedCertificate):
		b = &ManagedCertificateParameters{}
	case string(SecretTypeURLSigningKey):
		b = &URLSigningKeyParameters{}
	default:
		b = &SecretParameters{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalSecretParametersClassificationArray(rawMsg json.RawMessage) ([]SecretParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SecretParametersClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSecretParametersClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSecretParametersClassificationMap(rawMsg json.RawMessage) (map[string]SecretParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]SecretParametersClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalSecretParametersClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalSecurityPolicyParametersClassification(rawMsg json.RawMessage) (SecurityPolicyParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SecurityPolicyParametersClassification
	switch m["type"] {
	case string(SecurityPolicyTypeWebApplicationFirewall):
		b = &SecurityPolicyWebApplicationFirewallParameters{}
	default:
		b = &SecurityPolicyParameters{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalSecurityPolicyParametersClassificationArray(rawMsg json.RawMessage) ([]SecurityPolicyParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SecurityPolicyParametersClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSecurityPolicyParametersClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSecurityPolicyParametersClassificationMap(rawMsg json.RawMessage) (map[string]SecurityPolicyParametersClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]SecurityPolicyParametersClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalSecurityPolicyParametersClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}
