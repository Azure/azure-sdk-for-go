//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AFDCustomDomainsCreatePollerResponse contains the response from method AFDCustomDomains.Create.
type AFDCustomDomainsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsCreateResponse, error) {
	respType := AFDCustomDomainsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsCreatePollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsCreatePollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsCreateResponse contains the response from method AFDCustomDomains.Create.
type AFDCustomDomainsCreateResponse struct {
	AFDCustomDomainsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsCreateResult contains the result from method AFDCustomDomains.Create.
type AFDCustomDomainsCreateResult struct {
	AFDDomain
}

// AFDCustomDomainsDeletePollerResponse contains the response from method AFDCustomDomains.Delete.
type AFDCustomDomainsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsDeleteResponse, error) {
	respType := AFDCustomDomainsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsDeletePollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsDeletePollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsDeleteResponse contains the response from method AFDCustomDomains.Delete.
type AFDCustomDomainsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsGetResponse contains the response from method AFDCustomDomains.Get.
type AFDCustomDomainsGetResponse struct {
	AFDCustomDomainsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsGetResult contains the result from method AFDCustomDomains.Get.
type AFDCustomDomainsGetResult struct {
	AFDDomain
}

// AFDCustomDomainsListByProfileResponse contains the response from method AFDCustomDomains.ListByProfile.
type AFDCustomDomainsListByProfileResponse struct {
	AFDCustomDomainsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsListByProfileResult contains the result from method AFDCustomDomains.ListByProfile.
type AFDCustomDomainsListByProfileResult struct {
	AFDDomainListResult
}

// AFDCustomDomainsRefreshValidationTokenPollerResponse contains the response from method AFDCustomDomains.RefreshValidationToken.
type AFDCustomDomainsRefreshValidationTokenPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsRefreshValidationTokenPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsRefreshValidationTokenPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsRefreshValidationTokenResponse, error) {
	respType := AFDCustomDomainsRefreshValidationTokenResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ValidationToken)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsRefreshValidationTokenPollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsRefreshValidationTokenPollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.RefreshValidationToken", token, client.pl, client.refreshValidationTokenHandleError)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsRefreshValidationTokenPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsRefreshValidationTokenResponse contains the response from method AFDCustomDomains.RefreshValidationToken.
type AFDCustomDomainsRefreshValidationTokenResponse struct {
	AFDCustomDomainsRefreshValidationTokenResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsRefreshValidationTokenResult contains the result from method AFDCustomDomains.RefreshValidationToken.
type AFDCustomDomainsRefreshValidationTokenResult struct {
	ValidationToken
}

// AFDCustomDomainsUpdatePollerResponse contains the response from method AFDCustomDomains.Update.
type AFDCustomDomainsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsUpdateResponse, error) {
	respType := AFDCustomDomainsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsUpdatePollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsUpdatePollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsUpdateResponse contains the response from method AFDCustomDomains.Update.
type AFDCustomDomainsUpdateResponse struct {
	AFDCustomDomainsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsUpdateResult contains the result from method AFDCustomDomains.Update.
type AFDCustomDomainsUpdateResult struct {
	AFDDomain
}

// AFDEndpointsCreatePollerResponse contains the response from method AFDEndpoints.Create.
type AFDEndpointsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsCreateResponse, error) {
	respType := AFDEndpointsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsCreatePollerResponse from the provided client and resume token.
func (l *AFDEndpointsCreatePollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsCreateResponse contains the response from method AFDEndpoints.Create.
type AFDEndpointsCreateResponse struct {
	AFDEndpointsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsCreateResult contains the result from method AFDEndpoints.Create.
type AFDEndpointsCreateResult struct {
	AFDEndpoint
}

// AFDEndpointsDeletePollerResponse contains the response from method AFDEndpoints.Delete.
type AFDEndpointsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsDeleteResponse, error) {
	respType := AFDEndpointsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsDeletePollerResponse from the provided client and resume token.
func (l *AFDEndpointsDeletePollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsDeleteResponse contains the response from method AFDEndpoints.Delete.
type AFDEndpointsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsGetResponse contains the response from method AFDEndpoints.Get.
type AFDEndpointsGetResponse struct {
	AFDEndpointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsGetResult contains the result from method AFDEndpoints.Get.
type AFDEndpointsGetResult struct {
	AFDEndpoint
}

// AFDEndpointsListByProfileResponse contains the response from method AFDEndpoints.ListByProfile.
type AFDEndpointsListByProfileResponse struct {
	AFDEndpointsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsListByProfileResult contains the result from method AFDEndpoints.ListByProfile.
type AFDEndpointsListByProfileResult struct {
	AFDEndpointListResult
}

// AFDEndpointsListResourceUsageResponse contains the response from method AFDEndpoints.ListResourceUsage.
type AFDEndpointsListResourceUsageResponse struct {
	AFDEndpointsListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsListResourceUsageResult contains the result from method AFDEndpoints.ListResourceUsage.
type AFDEndpointsListResourceUsageResult struct {
	UsagesListResult
}

// AFDEndpointsPurgeContentPollerResponse contains the response from method AFDEndpoints.PurgeContent.
type AFDEndpointsPurgeContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsPurgeContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsPurgeContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsPurgeContentResponse, error) {
	respType := AFDEndpointsPurgeContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsPurgeContentPollerResponse from the provided client and resume token.
func (l *AFDEndpointsPurgeContentPollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.PurgeContent", token, client.pl, client.purgeContentHandleError)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsPurgeContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsPurgeContentResponse contains the response from method AFDEndpoints.PurgeContent.
type AFDEndpointsPurgeContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsUpdatePollerResponse contains the response from method AFDEndpoints.Update.
type AFDEndpointsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsUpdateResponse, error) {
	respType := AFDEndpointsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsUpdatePollerResponse from the provided client and resume token.
func (l *AFDEndpointsUpdatePollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsUpdateResponse contains the response from method AFDEndpoints.Update.
type AFDEndpointsUpdateResponse struct {
	AFDEndpointsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsUpdateResult contains the result from method AFDEndpoints.Update.
type AFDEndpointsUpdateResult struct {
	AFDEndpoint
}

// AFDEndpointsValidateCustomDomainResponse contains the response from method AFDEndpoints.ValidateCustomDomain.
type AFDEndpointsValidateCustomDomainResponse struct {
	AFDEndpointsValidateCustomDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsValidateCustomDomainResult contains the result from method AFDEndpoints.ValidateCustomDomain.
type AFDEndpointsValidateCustomDomainResult struct {
	ValidateCustomDomainOutput
}

// AFDOriginGroupsCreatePollerResponse contains the response from method AFDOriginGroups.Create.
type AFDOriginGroupsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginGroupsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginGroupsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsCreateResponse, error) {
	respType := AFDOriginGroupsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginGroupsCreatePollerResponse from the provided client and resume token.
func (l *AFDOriginGroupsCreatePollerResponse) Resume(ctx context.Context, client *AFDOriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginGroupsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &AFDOriginGroupsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginGroupsCreateResponse contains the response from method AFDOriginGroups.Create.
type AFDOriginGroupsCreateResponse struct {
	AFDOriginGroupsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsCreateResult contains the result from method AFDOriginGroups.Create.
type AFDOriginGroupsCreateResult struct {
	AFDOriginGroup
}

// AFDOriginGroupsDeletePollerResponse contains the response from method AFDOriginGroups.Delete.
type AFDOriginGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsDeleteResponse, error) {
	respType := AFDOriginGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginGroupsDeletePollerResponse from the provided client and resume token.
func (l *AFDOriginGroupsDeletePollerResponse) Resume(ctx context.Context, client *AFDOriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AFDOriginGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginGroupsDeleteResponse contains the response from method AFDOriginGroups.Delete.
type AFDOriginGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsGetResponse contains the response from method AFDOriginGroups.Get.
type AFDOriginGroupsGetResponse struct {
	AFDOriginGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsGetResult contains the result from method AFDOriginGroups.Get.
type AFDOriginGroupsGetResult struct {
	AFDOriginGroup
}

// AFDOriginGroupsListByProfileResponse contains the response from method AFDOriginGroups.ListByProfile.
type AFDOriginGroupsListByProfileResponse struct {
	AFDOriginGroupsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsListByProfileResult contains the result from method AFDOriginGroups.ListByProfile.
type AFDOriginGroupsListByProfileResult struct {
	AFDOriginGroupListResult
}

// AFDOriginGroupsListResourceUsageResponse contains the response from method AFDOriginGroups.ListResourceUsage.
type AFDOriginGroupsListResourceUsageResponse struct {
	AFDOriginGroupsListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsListResourceUsageResult contains the result from method AFDOriginGroups.ListResourceUsage.
type AFDOriginGroupsListResourceUsageResult struct {
	UsagesListResult
}

// AFDOriginGroupsUpdatePollerResponse contains the response from method AFDOriginGroups.Update.
type AFDOriginGroupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginGroupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginGroupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsUpdateResponse, error) {
	respType := AFDOriginGroupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginGroupsUpdatePollerResponse from the provided client and resume token.
func (l *AFDOriginGroupsUpdatePollerResponse) Resume(ctx context.Context, client *AFDOriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginGroupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &AFDOriginGroupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginGroupsUpdateResponse contains the response from method AFDOriginGroups.Update.
type AFDOriginGroupsUpdateResponse struct {
	AFDOriginGroupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsUpdateResult contains the result from method AFDOriginGroups.Update.
type AFDOriginGroupsUpdateResult struct {
	AFDOriginGroup
}

// AFDOriginsCreatePollerResponse contains the response from method AFDOrigins.Create.
type AFDOriginsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsCreateResponse, error) {
	respType := AFDOriginsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOrigin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginsCreatePollerResponse from the provided client and resume token.
func (l *AFDOriginsCreatePollerResponse) Resume(ctx context.Context, client *AFDOriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &AFDOriginsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginsCreateResponse contains the response from method AFDOrigins.Create.
type AFDOriginsCreateResponse struct {
	AFDOriginsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsCreateResult contains the result from method AFDOrigins.Create.
type AFDOriginsCreateResult struct {
	AFDOrigin
}

// AFDOriginsDeletePollerResponse contains the response from method AFDOrigins.Delete.
type AFDOriginsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsDeleteResponse, error) {
	respType := AFDOriginsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginsDeletePollerResponse from the provided client and resume token.
func (l *AFDOriginsDeletePollerResponse) Resume(ctx context.Context, client *AFDOriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AFDOriginsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginsDeleteResponse contains the response from method AFDOrigins.Delete.
type AFDOriginsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsGetResponse contains the response from method AFDOrigins.Get.
type AFDOriginsGetResponse struct {
	AFDOriginsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsGetResult contains the result from method AFDOrigins.Get.
type AFDOriginsGetResult struct {
	AFDOrigin
}

// AFDOriginsListByOriginGroupResponse contains the response from method AFDOrigins.ListByOriginGroup.
type AFDOriginsListByOriginGroupResponse struct {
	AFDOriginsListByOriginGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsListByOriginGroupResult contains the result from method AFDOrigins.ListByOriginGroup.
type AFDOriginsListByOriginGroupResult struct {
	AFDOriginListResult
}

// AFDOriginsUpdatePollerResponse contains the response from method AFDOrigins.Update.
type AFDOriginsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsUpdateResponse, error) {
	respType := AFDOriginsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOrigin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginsUpdatePollerResponse from the provided client and resume token.
func (l *AFDOriginsUpdatePollerResponse) Resume(ctx context.Context, client *AFDOriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &AFDOriginsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginsUpdateResponse contains the response from method AFDOrigins.Update.
type AFDOriginsUpdateResponse struct {
	AFDOriginsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsUpdateResult contains the result from method AFDOrigins.Update.
type AFDOriginsUpdateResult struct {
	AFDOrigin
}

// AFDProfilesCheckHostNameAvailabilityResponse contains the response from method AFDProfiles.CheckHostNameAvailability.
type AFDProfilesCheckHostNameAvailabilityResponse struct {
	AFDProfilesCheckHostNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDProfilesCheckHostNameAvailabilityResult contains the result from method AFDProfiles.CheckHostNameAvailability.
type AFDProfilesCheckHostNameAvailabilityResult struct {
	ValidateCustomDomainOutput
}

// AFDProfilesListResourceUsageResponse contains the response from method AFDProfiles.ListResourceUsage.
type AFDProfilesListResourceUsageResponse struct {
	AFDProfilesListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDProfilesListResourceUsageResult contains the result from method AFDProfiles.ListResourceUsage.
type AFDProfilesListResourceUsageResult struct {
	UsagesListResult
}

// CdnManagementClientCheckNameAvailabilityResponse contains the response from method CdnManagementClient.CheckNameAvailability.
type CdnManagementClientCheckNameAvailabilityResponse struct {
	CdnManagementClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CdnManagementClientCheckNameAvailabilityResult contains the result from method CdnManagementClient.CheckNameAvailability.
type CdnManagementClientCheckNameAvailabilityResult struct {
	CheckNameAvailabilityOutput
}

// CdnManagementClientCheckNameAvailabilityWithSubscriptionResponse contains the response from method CdnManagementClient.CheckNameAvailabilityWithSubscription.
type CdnManagementClientCheckNameAvailabilityWithSubscriptionResponse struct {
	CdnManagementClientCheckNameAvailabilityWithSubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CdnManagementClientCheckNameAvailabilityWithSubscriptionResult contains the result from method CdnManagementClient.CheckNameAvailabilityWithSubscription.
type CdnManagementClientCheckNameAvailabilityWithSubscriptionResult struct {
	CheckNameAvailabilityOutput
}

// CdnManagementClientValidateProbeResponse contains the response from method CdnManagementClient.ValidateProbe.
type CdnManagementClientValidateProbeResponse struct {
	CdnManagementClientValidateProbeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CdnManagementClientValidateProbeResult contains the result from method CdnManagementClient.ValidateProbe.
type CdnManagementClientValidateProbeResult struct {
	ValidateProbeOutput
}

// CustomDomainsCreatePollerResponse contains the response from method CustomDomains.Create.
type CustomDomainsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsCreateResponse, error) {
	respType := CustomDomainsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsCreatePollerResponse from the provided client and resume token.
func (l *CustomDomainsCreatePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsCreateResponse contains the response from method CustomDomains.Create.
type CustomDomainsCreateResponse struct {
	CustomDomainsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsCreateResult contains the result from method CustomDomains.Create.
type CustomDomainsCreateResult struct {
	CustomDomain
}

// CustomDomainsDeletePollerResponse contains the response from method CustomDomains.Delete.
type CustomDomainsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsDeleteResponse, error) {
	respType := CustomDomainsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsDeletePollerResponse from the provided client and resume token.
func (l *CustomDomainsDeletePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsDeleteResponse contains the response from method CustomDomains.Delete.
type CustomDomainsDeleteResponse struct {
	CustomDomainsDeleteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsDeleteResult contains the result from method CustomDomains.Delete.
type CustomDomainsDeleteResult struct {
	CustomDomain
}

// CustomDomainsDisableCustomHTTPSPollerResponse contains the response from method CustomDomains.DisableCustomHTTPS.
type CustomDomainsDisableCustomHTTPSPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsDisableCustomHTTPSPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsDisableCustomHTTPSPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsDisableCustomHTTPSResponse, error) {
	respType := CustomDomainsDisableCustomHTTPSResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsDisableCustomHTTPSPollerResponse from the provided client and resume token.
func (l *CustomDomainsDisableCustomHTTPSPollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.DisableCustomHTTPS", token, client.pl, client.disableCustomHTTPSHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsDisableCustomHTTPSPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsDisableCustomHTTPSResponse contains the response from method CustomDomains.DisableCustomHTTPS.
type CustomDomainsDisableCustomHTTPSResponse struct {
	CustomDomainsDisableCustomHTTPSResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsDisableCustomHTTPSResult contains the result from method CustomDomains.DisableCustomHTTPS.
type CustomDomainsDisableCustomHTTPSResult struct {
	CustomDomain
}

// CustomDomainsEnableCustomHTTPSPollerResponse contains the response from method CustomDomains.EnableCustomHTTPS.
type CustomDomainsEnableCustomHTTPSPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsEnableCustomHTTPSPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsEnableCustomHTTPSPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsEnableCustomHTTPSResponse, error) {
	respType := CustomDomainsEnableCustomHTTPSResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsEnableCustomHTTPSPollerResponse from the provided client and resume token.
func (l *CustomDomainsEnableCustomHTTPSPollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.EnableCustomHTTPS", token, client.pl, client.enableCustomHTTPSHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsEnableCustomHTTPSPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsEnableCustomHTTPSResponse contains the response from method CustomDomains.EnableCustomHTTPS.
type CustomDomainsEnableCustomHTTPSResponse struct {
	CustomDomainsEnableCustomHTTPSResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsEnableCustomHTTPSResult contains the result from method CustomDomains.EnableCustomHTTPS.
type CustomDomainsEnableCustomHTTPSResult struct {
	CustomDomain
}

// CustomDomainsGetResponse contains the response from method CustomDomains.Get.
type CustomDomainsGetResponse struct {
	CustomDomainsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsGetResult contains the result from method CustomDomains.Get.
type CustomDomainsGetResult struct {
	CustomDomain
}

// CustomDomainsListByEndpointResponse contains the response from method CustomDomains.ListByEndpoint.
type CustomDomainsListByEndpointResponse struct {
	CustomDomainsListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsListByEndpointResult contains the result from method CustomDomains.ListByEndpoint.
type CustomDomainsListByEndpointResult struct {
	CustomDomainListResult
}

// EdgeNodesListResponse contains the response from method EdgeNodes.List.
type EdgeNodesListResponse struct {
	EdgeNodesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EdgeNodesListResult contains the result from method EdgeNodes.List.
type EdgeNodesListResult struct {
	EdgenodeResult
}

// EndpointsCreatePollerResponse contains the response from method Endpoints.Create.
type EndpointsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsCreateResponse, error) {
	respType := EndpointsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsCreatePollerResponse from the provided client and resume token.
func (l *EndpointsCreatePollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsCreateResponse contains the response from method Endpoints.Create.
type EndpointsCreateResponse struct {
	EndpointsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsCreateResult contains the result from method Endpoints.Create.
type EndpointsCreateResult struct {
	Endpoint
}

// EndpointsDeletePollerResponse contains the response from method Endpoints.Delete.
type EndpointsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsDeleteResponse, error) {
	respType := EndpointsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsDeletePollerResponse from the provided client and resume token.
func (l *EndpointsDeletePollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsDeleteResponse contains the response from method Endpoints.Delete.
type EndpointsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsGetResponse contains the response from method Endpoints.Get.
type EndpointsGetResponse struct {
	EndpointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsGetResult contains the result from method Endpoints.Get.
type EndpointsGetResult struct {
	Endpoint
}

// EndpointsListByProfileResponse contains the response from method Endpoints.ListByProfile.
type EndpointsListByProfileResponse struct {
	EndpointsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsListByProfileResult contains the result from method Endpoints.ListByProfile.
type EndpointsListByProfileResult struct {
	EndpointListResult
}

// EndpointsListResourceUsageResponse contains the response from method Endpoints.ListResourceUsage.
type EndpointsListResourceUsageResponse struct {
	EndpointsListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsListResourceUsageResult contains the result from method Endpoints.ListResourceUsage.
type EndpointsListResourceUsageResult struct {
	ResourceUsageListResult
}

// EndpointsLoadContentPollerResponse contains the response from method Endpoints.LoadContent.
type EndpointsLoadContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsLoadContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsLoadContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsLoadContentResponse, error) {
	respType := EndpointsLoadContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsLoadContentPollerResponse from the provided client and resume token.
func (l *EndpointsLoadContentPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.LoadContent", token, client.pl, client.loadContentHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsLoadContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsLoadContentResponse contains the response from method Endpoints.LoadContent.
type EndpointsLoadContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsPurgeContentPollerResponse contains the response from method Endpoints.PurgeContent.
type EndpointsPurgeContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsPurgeContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsPurgeContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsPurgeContentResponse, error) {
	respType := EndpointsPurgeContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsPurgeContentPollerResponse from the provided client and resume token.
func (l *EndpointsPurgeContentPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.PurgeContent", token, client.pl, client.purgeContentHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsPurgeContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsPurgeContentResponse contains the response from method Endpoints.PurgeContent.
type EndpointsPurgeContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsStartPollerResponse contains the response from method Endpoints.Start.
type EndpointsStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsStartResponse, error) {
	respType := EndpointsStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsStartPollerResponse from the provided client and resume token.
func (l *EndpointsStartPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsStartResponse contains the response from method Endpoints.Start.
type EndpointsStartResponse struct {
	EndpointsStartResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsStartResult contains the result from method Endpoints.Start.
type EndpointsStartResult struct {
	Endpoint
}

// EndpointsStopPollerResponse contains the response from method Endpoints.Stop.
type EndpointsStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsStopResponse, error) {
	respType := EndpointsStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsStopPollerResponse from the provided client and resume token.
func (l *EndpointsStopPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsStopResponse contains the response from method Endpoints.Stop.
type EndpointsStopResponse struct {
	EndpointsStopResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsStopResult contains the result from method Endpoints.Stop.
type EndpointsStopResult struct {
	Endpoint
}

// EndpointsUpdatePollerResponse contains the response from method Endpoints.Update.
type EndpointsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsUpdateResponse, error) {
	respType := EndpointsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsUpdatePollerResponse from the provided client and resume token.
func (l *EndpointsUpdatePollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsUpdateResponse contains the response from method Endpoints.Update.
type EndpointsUpdateResponse struct {
	EndpointsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsUpdateResult contains the result from method Endpoints.Update.
type EndpointsUpdateResult struct {
	Endpoint
}

// EndpointsValidateCustomDomainResponse contains the response from method Endpoints.ValidateCustomDomain.
type EndpointsValidateCustomDomainResponse struct {
	EndpointsValidateCustomDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsValidateCustomDomainResult contains the result from method Endpoints.ValidateCustomDomain.
type EndpointsValidateCustomDomainResult struct {
	ValidateCustomDomainOutput
}

// LogAnalyticsGetLogAnalyticsLocationsResponse contains the response from method LogAnalytics.GetLogAnalyticsLocations.
type LogAnalyticsGetLogAnalyticsLocationsResponse struct {
	LogAnalyticsGetLogAnalyticsLocationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsGetLogAnalyticsLocationsResult contains the result from method LogAnalytics.GetLogAnalyticsLocations.
type LogAnalyticsGetLogAnalyticsLocationsResult struct {
	ContinentsResponse
}

// LogAnalyticsGetLogAnalyticsMetricsResponse contains the response from method LogAnalytics.GetLogAnalyticsMetrics.
type LogAnalyticsGetLogAnalyticsMetricsResponse struct {
	LogAnalyticsGetLogAnalyticsMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsGetLogAnalyticsMetricsResult contains the result from method LogAnalytics.GetLogAnalyticsMetrics.
type LogAnalyticsGetLogAnalyticsMetricsResult struct {
	MetricsResponse
}

// LogAnalyticsGetLogAnalyticsRankingsResponse contains the response from method LogAnalytics.GetLogAnalyticsRankings.
type LogAnalyticsGetLogAnalyticsRankingsResponse struct {
	LogAnalyticsGetLogAnalyticsRankingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsGetLogAnalyticsRankingsResult contains the result from method LogAnalytics.GetLogAnalyticsRankings.
type LogAnalyticsGetLogAnalyticsRankingsResult struct {
	RankingsResponse
}

// LogAnalyticsGetLogAnalyticsResourcesResponse contains the response from method LogAnalytics.GetLogAnalyticsResources.
type LogAnalyticsGetLogAnalyticsResourcesResponse struct {
	LogAnalyticsGetLogAnalyticsResourcesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsGetLogAnalyticsResourcesResult contains the result from method LogAnalytics.GetLogAnalyticsResources.
type LogAnalyticsGetLogAnalyticsResourcesResult struct {
	ResourcesResponse
}

// LogAnalyticsGetWafLogAnalyticsMetricsResponse contains the response from method LogAnalytics.GetWafLogAnalyticsMetrics.
type LogAnalyticsGetWafLogAnalyticsMetricsResponse struct {
	LogAnalyticsGetWafLogAnalyticsMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsGetWafLogAnalyticsMetricsResult contains the result from method LogAnalytics.GetWafLogAnalyticsMetrics.
type LogAnalyticsGetWafLogAnalyticsMetricsResult struct {
	WafMetricsResponse
}

// LogAnalyticsGetWafLogAnalyticsRankingsResponse contains the response from method LogAnalytics.GetWafLogAnalyticsRankings.
type LogAnalyticsGetWafLogAnalyticsRankingsResponse struct {
	LogAnalyticsGetWafLogAnalyticsRankingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsGetWafLogAnalyticsRankingsResult contains the result from method LogAnalytics.GetWafLogAnalyticsRankings.
type LogAnalyticsGetWafLogAnalyticsRankingsResult struct {
	WafRankingsResponse
}

// ManagedRuleSetsListResponse contains the response from method ManagedRuleSets.List.
type ManagedRuleSetsListResponse struct {
	ManagedRuleSetsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRuleSetsListResult contains the result from method ManagedRuleSets.List.
type ManagedRuleSetsListResult struct {
	ManagedRuleSetDefinitionList
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResultEnvelope contains the result from method Operations.List.
type OperationsListResultEnvelope struct {
	OperationsListResult
}

// OriginGroupsCreatePollerResponse contains the response from method OriginGroups.Create.
type OriginGroupsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginGroupsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginGroupsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsCreateResponse, error) {
	respType := OriginGroupsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.OriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginGroupsCreatePollerResponse from the provided client and resume token.
func (l *OriginGroupsCreatePollerResponse) Resume(ctx context.Context, client *OriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginGroupsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &OriginGroupsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginGroupsCreateResponse contains the response from method OriginGroups.Create.
type OriginGroupsCreateResponse struct {
	OriginGroupsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsCreateResult contains the result from method OriginGroups.Create.
type OriginGroupsCreateResult struct {
	OriginGroup
}

// OriginGroupsDeletePollerResponse contains the response from method OriginGroups.Delete.
type OriginGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsDeleteResponse, error) {
	respType := OriginGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginGroupsDeletePollerResponse from the provided client and resume token.
func (l *OriginGroupsDeletePollerResponse) Resume(ctx context.Context, client *OriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &OriginGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginGroupsDeleteResponse contains the response from method OriginGroups.Delete.
type OriginGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsGetResponse contains the response from method OriginGroups.Get.
type OriginGroupsGetResponse struct {
	OriginGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsGetResult contains the result from method OriginGroups.Get.
type OriginGroupsGetResult struct {
	OriginGroup
}

// OriginGroupsListByEndpointResponse contains the response from method OriginGroups.ListByEndpoint.
type OriginGroupsListByEndpointResponse struct {
	OriginGroupsListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsListByEndpointResult contains the result from method OriginGroups.ListByEndpoint.
type OriginGroupsListByEndpointResult struct {
	OriginGroupListResult
}

// OriginGroupsUpdatePollerResponse contains the response from method OriginGroups.Update.
type OriginGroupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginGroupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginGroupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsUpdateResponse, error) {
	respType := OriginGroupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.OriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginGroupsUpdatePollerResponse from the provided client and resume token.
func (l *OriginGroupsUpdatePollerResponse) Resume(ctx context.Context, client *OriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginGroupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &OriginGroupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginGroupsUpdateResponse contains the response from method OriginGroups.Update.
type OriginGroupsUpdateResponse struct {
	OriginGroupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsUpdateResult contains the result from method OriginGroups.Update.
type OriginGroupsUpdateResult struct {
	OriginGroup
}

// OriginsCreatePollerResponse contains the response from method Origins.Create.
type OriginsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginsCreateResponse, error) {
	respType := OriginsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Origin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginsCreatePollerResponse from the provided client and resume token.
func (l *OriginsCreatePollerResponse) Resume(ctx context.Context, client *OriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &OriginsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginsCreateResponse contains the response from method Origins.Create.
type OriginsCreateResponse struct {
	OriginsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsCreateResult contains the result from method Origins.Create.
type OriginsCreateResult struct {
	Origin
}

// OriginsDeletePollerResponse contains the response from method Origins.Delete.
type OriginsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginsDeleteResponse, error) {
	respType := OriginsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginsDeletePollerResponse from the provided client and resume token.
func (l *OriginsDeletePollerResponse) Resume(ctx context.Context, client *OriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &OriginsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginsDeleteResponse contains the response from method Origins.Delete.
type OriginsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsGetResponse contains the response from method Origins.Get.
type OriginsGetResponse struct {
	OriginsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsGetResult contains the result from method Origins.Get.
type OriginsGetResult struct {
	Origin
}

// OriginsListByEndpointResponse contains the response from method Origins.ListByEndpoint.
type OriginsListByEndpointResponse struct {
	OriginsListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsListByEndpointResult contains the result from method Origins.ListByEndpoint.
type OriginsListByEndpointResult struct {
	OriginListResult
}

// OriginsUpdatePollerResponse contains the response from method Origins.Update.
type OriginsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginsUpdateResponse, error) {
	respType := OriginsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Origin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginsUpdatePollerResponse from the provided client and resume token.
func (l *OriginsUpdatePollerResponse) Resume(ctx context.Context, client *OriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &OriginsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginsUpdateResponse contains the response from method Origins.Update.
type OriginsUpdateResponse struct {
	OriginsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsUpdateResult contains the result from method Origins.Update.
type OriginsUpdateResult struct {
	Origin
}

// PoliciesCreateOrUpdatePollerResponse contains the response from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesCreateOrUpdateResponse, error) {
	respType := PoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CdnWebApplicationFirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesCreateOrUpdateResponse contains the response from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdateResponse struct {
	PoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesCreateOrUpdateResult contains the result from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdateResult struct {
	CdnWebApplicationFirewallPolicy
}

// PoliciesDeleteResponse contains the response from method Policies.Delete.
type PoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesGetResponse contains the response from method Policies.Get.
type PoliciesGetResponse struct {
	PoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesGetResult contains the result from method Policies.Get.
type PoliciesGetResult struct {
	CdnWebApplicationFirewallPolicy
}

// PoliciesListResponse contains the response from method Policies.List.
type PoliciesListResponse struct {
	PoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesListResult contains the result from method Policies.List.
type PoliciesListResult struct {
	CdnWebApplicationFirewallPolicyList
}

// PoliciesUpdatePollerResponse contains the response from method Policies.Update.
type PoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesUpdateResponse, error) {
	respType := PoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CdnWebApplicationFirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesUpdatePollerResponse from the provided client and resume token.
func (l *PoliciesUpdatePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &PoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesUpdateResponse contains the response from method Policies.Update.
type PoliciesUpdateResponse struct {
	PoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesUpdateResult contains the result from method Policies.Update.
type PoliciesUpdateResult struct {
	CdnWebApplicationFirewallPolicy
}

// ProfilesCreatePollerResponse contains the response from method Profiles.Create.
type ProfilesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesCreateResponse, error) {
	respType := ProfilesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesCreatePollerResponse from the provided client and resume token.
func (l *ProfilesCreatePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ProfilesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesCreateResponse contains the response from method Profiles.Create.
type ProfilesCreateResponse struct {
	ProfilesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesCreateResult contains the result from method Profiles.Create.
type ProfilesCreateResult struct {
	Profile
}

// ProfilesDeletePollerResponse contains the response from method Profiles.Delete.
type ProfilesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesDeleteResponse, error) {
	respType := ProfilesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesDeletePollerResponse from the provided client and resume token.
func (l *ProfilesDeletePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ProfilesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesDeleteResponse contains the response from method Profiles.Delete.
type ProfilesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesGenerateSsoURIResponse contains the response from method Profiles.GenerateSsoURI.
type ProfilesGenerateSsoURIResponse struct {
	ProfilesGenerateSsoURIResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesGenerateSsoURIResult contains the result from method Profiles.GenerateSsoURI.
type ProfilesGenerateSsoURIResult struct {
	SsoURI
}

// ProfilesGetResponse contains the response from method Profiles.Get.
type ProfilesGetResponse struct {
	ProfilesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesGetResult contains the result from method Profiles.Get.
type ProfilesGetResult struct {
	Profile
}

// ProfilesListByResourceGroupResponse contains the response from method Profiles.ListByResourceGroup.
type ProfilesListByResourceGroupResponse struct {
	ProfilesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesListByResourceGroupResult contains the result from method Profiles.ListByResourceGroup.
type ProfilesListByResourceGroupResult struct {
	ProfileListResult
}

// ProfilesListResourceUsageResponse contains the response from method Profiles.ListResourceUsage.
type ProfilesListResourceUsageResponse struct {
	ProfilesListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesListResourceUsageResult contains the result from method Profiles.ListResourceUsage.
type ProfilesListResourceUsageResult struct {
	ResourceUsageListResult
}

// ProfilesListResponse contains the response from method Profiles.List.
type ProfilesListResponse struct {
	ProfilesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesListResult contains the result from method Profiles.List.
type ProfilesListResult struct {
	ProfileListResult
}

// ProfilesListSupportedOptimizationTypesResponse contains the response from method Profiles.ListSupportedOptimizationTypes.
type ProfilesListSupportedOptimizationTypesResponse struct {
	ProfilesListSupportedOptimizationTypesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesListSupportedOptimizationTypesResult contains the result from method Profiles.ListSupportedOptimizationTypes.
type ProfilesListSupportedOptimizationTypesResult struct {
	SupportedOptimizationTypesListResult
}

// ProfilesUpdatePollerResponse contains the response from method Profiles.Update.
type ProfilesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesUpdateResponse, error) {
	respType := ProfilesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesUpdatePollerResponse from the provided client and resume token.
func (l *ProfilesUpdatePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ProfilesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesUpdateResponse contains the response from method Profiles.Update.
type ProfilesUpdateResponse struct {
	ProfilesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesUpdateResult contains the result from method Profiles.Update.
type ProfilesUpdateResult struct {
	Profile
}

// ResourceUsageListResponse contains the response from method ResourceUsage.List.
type ResourceUsageListResponse struct {
	ResourceUsageListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceUsageListResultEnvelope contains the result from method ResourceUsage.List.
type ResourceUsageListResultEnvelope struct {
	ResourceUsageListResult
}

// RoutesCreatePollerResponse contains the response from method Routes.Create.
type RoutesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesCreateResponse, error) {
	respType := RoutesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesCreatePollerResponse from the provided client and resume token.
func (l *RoutesCreatePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &RoutesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesCreateResponse contains the response from method Routes.Create.
type RoutesCreateResponse struct {
	RoutesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesCreateResult contains the result from method Routes.Create.
type RoutesCreateResult struct {
	Route
}

// RoutesDeletePollerResponse contains the response from method Routes.Delete.
type RoutesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesDeletePollerResponse from the provided client and resume token.
func (l *RoutesDeletePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RoutesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesDeleteResponse contains the response from method Routes.Delete.
type RoutesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesGetResponse contains the response from method Routes.Get.
type RoutesGetResponse struct {
	RoutesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesGetResult contains the result from method Routes.Get.
type RoutesGetResult struct {
	Route
}

// RoutesListByEndpointResponse contains the response from method Routes.ListByEndpoint.
type RoutesListByEndpointResponse struct {
	RoutesListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesListByEndpointResult contains the result from method Routes.ListByEndpoint.
type RoutesListByEndpointResult struct {
	RouteListResult
}

// RoutesUpdatePollerResponse contains the response from method Routes.Update.
type RoutesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesUpdateResponse, error) {
	respType := RoutesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesUpdatePollerResponse from the provided client and resume token.
func (l *RoutesUpdatePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &RoutesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesUpdateResponse contains the response from method Routes.Update.
type RoutesUpdateResponse struct {
	RoutesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesUpdateResult contains the result from method Routes.Update.
type RoutesUpdateResult struct {
	Route
}

// RuleSetsCreatePollerResponse contains the response from method RuleSets.Create.
type RuleSetsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RuleSetsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RuleSetsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RuleSetsCreateResponse, error) {
	respType := RuleSetsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RuleSet)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RuleSetsCreatePollerResponse from the provided client and resume token.
func (l *RuleSetsCreatePollerResponse) Resume(ctx context.Context, client *RuleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RuleSetsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &RuleSetsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RuleSetsCreateResponse contains the response from method RuleSets.Create.
type RuleSetsCreateResponse struct {
	RuleSetsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsCreateResult contains the result from method RuleSets.Create.
type RuleSetsCreateResult struct {
	RuleSet
}

// RuleSetsDeletePollerResponse contains the response from method RuleSets.Delete.
type RuleSetsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RuleSetsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RuleSetsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RuleSetsDeleteResponse, error) {
	respType := RuleSetsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RuleSetsDeletePollerResponse from the provided client and resume token.
func (l *RuleSetsDeletePollerResponse) Resume(ctx context.Context, client *RuleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RuleSetsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RuleSetsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RuleSetsDeleteResponse contains the response from method RuleSets.Delete.
type RuleSetsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsGetResponse contains the response from method RuleSets.Get.
type RuleSetsGetResponse struct {
	RuleSetsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsGetResult contains the result from method RuleSets.Get.
type RuleSetsGetResult struct {
	RuleSet
}

// RuleSetsListByProfileResponse contains the response from method RuleSets.ListByProfile.
type RuleSetsListByProfileResponse struct {
	RuleSetsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsListByProfileResult contains the result from method RuleSets.ListByProfile.
type RuleSetsListByProfileResult struct {
	RuleSetListResult
}

// RuleSetsListResourceUsageResponse contains the response from method RuleSets.ListResourceUsage.
type RuleSetsListResourceUsageResponse struct {
	RuleSetsListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsListResourceUsageResult contains the result from method RuleSets.ListResourceUsage.
type RuleSetsListResourceUsageResult struct {
	UsagesListResult
}

// RulesCreatePollerResponse contains the response from method Rules.Create.
type RulesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesCreateResponse, error) {
	respType := RulesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Rule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesCreatePollerResponse from the provided client and resume token.
func (l *RulesCreatePollerResponse) Resume(ctx context.Context, client *RulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &RulesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesCreateResponse contains the response from method Rules.Create.
type RulesCreateResponse struct {
	RulesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesCreateResult contains the result from method Rules.Create.
type RulesCreateResult struct {
	Rule
}

// RulesDeletePollerResponse contains the response from method Rules.Delete.
type RulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesDeleteResponse, error) {
	respType := RulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesDeletePollerResponse from the provided client and resume token.
func (l *RulesDeletePollerResponse) Resume(ctx context.Context, client *RulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesDeleteResponse contains the response from method Rules.Delete.
type RulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesGetResponse contains the response from method Rules.Get.
type RulesGetResponse struct {
	RulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesGetResult contains the result from method Rules.Get.
type RulesGetResult struct {
	Rule
}

// RulesListByRuleSetResponse contains the response from method Rules.ListByRuleSet.
type RulesListByRuleSetResponse struct {
	RulesListByRuleSetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesListByRuleSetResult contains the result from method Rules.ListByRuleSet.
type RulesListByRuleSetResult struct {
	RuleListResult
}

// RulesUpdatePollerResponse contains the response from method Rules.Update.
type RulesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesUpdateResponse, error) {
	respType := RulesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Rule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesUpdatePollerResponse from the provided client and resume token.
func (l *RulesUpdatePollerResponse) Resume(ctx context.Context, client *RulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &RulesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesUpdateResponse contains the response from method Rules.Update.
type RulesUpdateResponse struct {
	RulesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesUpdateResult contains the result from method Rules.Update.
type RulesUpdateResult struct {
	Rule
}

// SecretsCreatePollerResponse contains the response from method Secrets.Create.
type SecretsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsCreateResponse, error) {
	respType := SecretsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecretsCreatePollerResponse from the provided client and resume token.
func (l *SecretsCreatePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &SecretsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecretsCreateResponse contains the response from method Secrets.Create.
type SecretsCreateResponse struct {
	SecretsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsCreateResult contains the result from method Secrets.Create.
type SecretsCreateResult struct {
	Secret
}

// SecretsDeletePollerResponse contains the response from method Secrets.Delete.
type SecretsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsDeleteResponse, error) {
	respType := SecretsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecretsDeletePollerResponse from the provided client and resume token.
func (l *SecretsDeletePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SecretsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecretsDeleteResponse contains the response from method Secrets.Delete.
type SecretsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsGetResponse contains the response from method Secrets.Get.
type SecretsGetResponse struct {
	SecretsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsGetResult contains the result from method Secrets.Get.
type SecretsGetResult struct {
	Secret
}

// SecretsListByProfileResponse contains the response from method Secrets.ListByProfile.
type SecretsListByProfileResponse struct {
	SecretsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsListByProfileResult contains the result from method Secrets.ListByProfile.
type SecretsListByProfileResult struct {
	SecretListResult
}

// SecretsUpdatePollerResponse contains the response from method Secrets.Update.
type SecretsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsUpdateResponse, error) {
	respType := SecretsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecretsUpdatePollerResponse from the provided client and resume token.
func (l *SecretsUpdatePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &SecretsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecretsUpdateResponse contains the response from method Secrets.Update.
type SecretsUpdateResponse struct {
	SecretsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsUpdateResult contains the result from method Secrets.Update.
type SecretsUpdateResult struct {
	Secret
}

// SecurityPoliciesCreatePollerResponse contains the response from method SecurityPolicies.Create.
type SecurityPoliciesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPoliciesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPoliciesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesCreateResponse, error) {
	respType := SecurityPoliciesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPoliciesCreatePollerResponse from the provided client and resume token.
func (l *SecurityPoliciesCreatePollerResponse) Resume(ctx context.Context, client *SecurityPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPoliciesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityPoliciesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPoliciesCreateResponse contains the response from method SecurityPolicies.Create.
type SecurityPoliciesCreateResponse struct {
	SecurityPoliciesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesCreateResult contains the result from method SecurityPolicies.Create.
type SecurityPoliciesCreateResult struct {
	SecurityPolicy
}

// SecurityPoliciesDeletePollerResponse contains the response from method SecurityPolicies.Delete.
type SecurityPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesDeleteResponse, error) {
	respType := SecurityPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPoliciesDeletePollerResponse from the provided client and resume token.
func (l *SecurityPoliciesDeletePollerResponse) Resume(ctx context.Context, client *SecurityPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPoliciesDeleteResponse contains the response from method SecurityPolicies.Delete.
type SecurityPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesGetResponse contains the response from method SecurityPolicies.Get.
type SecurityPoliciesGetResponse struct {
	SecurityPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesGetResult contains the result from method SecurityPolicies.Get.
type SecurityPoliciesGetResult struct {
	SecurityPolicy
}

// SecurityPoliciesListByProfileResponse contains the response from method SecurityPolicies.ListByProfile.
type SecurityPoliciesListByProfileResponse struct {
	SecurityPoliciesListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesListByProfileResult contains the result from method SecurityPolicies.ListByProfile.
type SecurityPoliciesListByProfileResult struct {
	SecurityPolicyListResult
}

// SecurityPoliciesPatchPollerResponse contains the response from method SecurityPolicies.Patch.
type SecurityPoliciesPatchPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPoliciesPatchPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPoliciesPatchPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesPatchResponse, error) {
	respType := SecurityPoliciesPatchResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPoliciesPatchPollerResponse from the provided client and resume token.
func (l *SecurityPoliciesPatchPollerResponse) Resume(ctx context.Context, client *SecurityPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPoliciesClient.Patch", token, client.pl, client.patchHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityPoliciesPatchPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPoliciesPatchResponse contains the response from method SecurityPolicies.Patch.
type SecurityPoliciesPatchResponse struct {
	SecurityPoliciesPatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesPatchResult contains the result from method SecurityPolicies.Patch.
type SecurityPoliciesPatchResult struct {
	SecurityPolicy
}

// ValidateSecretResponse contains the response from method Validate.Secret.
type ValidateSecretResponse struct {
	ValidateSecretResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ValidateSecretResult contains the result from method Validate.Secret.
type ValidateSecretResult struct {
	ValidateSecretOutput
}
