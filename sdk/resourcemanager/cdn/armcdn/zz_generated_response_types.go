//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AFDCustomDomainsClientCreatePollerResponse contains the response from method AFDCustomDomainsClient.Create.
type AFDCustomDomainsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsClientCreateResponse, error) {
	respType := AFDCustomDomainsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsClientCreatePollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsClientCreatePollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsClientCreateResponse contains the response from method AFDCustomDomainsClient.Create.
type AFDCustomDomainsClientCreateResponse struct {
	AFDCustomDomainsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsClientCreateResult contains the result from method AFDCustomDomainsClient.Create.
type AFDCustomDomainsClientCreateResult struct {
	AFDDomain
}

// AFDCustomDomainsClientDeletePollerResponse contains the response from method AFDCustomDomainsClient.Delete.
type AFDCustomDomainsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsClientDeleteResponse, error) {
	respType := AFDCustomDomainsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsClientDeletePollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsClientDeletePollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsClientDeleteResponse contains the response from method AFDCustomDomainsClient.Delete.
type AFDCustomDomainsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsClientGetResponse contains the response from method AFDCustomDomainsClient.Get.
type AFDCustomDomainsClientGetResponse struct {
	AFDCustomDomainsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsClientGetResult contains the result from method AFDCustomDomainsClient.Get.
type AFDCustomDomainsClientGetResult struct {
	AFDDomain
}

// AFDCustomDomainsClientListByProfileResponse contains the response from method AFDCustomDomainsClient.ListByProfile.
type AFDCustomDomainsClientListByProfileResponse struct {
	AFDCustomDomainsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsClientListByProfileResult contains the result from method AFDCustomDomainsClient.ListByProfile.
type AFDCustomDomainsClientListByProfileResult struct {
	AFDDomainListResult
}

// AFDCustomDomainsClientRefreshValidationTokenPollerResponse contains the response from method AFDCustomDomainsClient.RefreshValidationToken.
type AFDCustomDomainsClientRefreshValidationTokenPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsClientRefreshValidationTokenPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsClientRefreshValidationTokenPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsClientRefreshValidationTokenResponse, error) {
	respType := AFDCustomDomainsClientRefreshValidationTokenResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsClientRefreshValidationTokenPollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsClientRefreshValidationTokenPollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.RefreshValidationToken", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsClientRefreshValidationTokenPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsClientRefreshValidationTokenResponse contains the response from method AFDCustomDomainsClient.RefreshValidationToken.
type AFDCustomDomainsClientRefreshValidationTokenResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsClientUpdatePollerResponse contains the response from method AFDCustomDomainsClient.Update.
type AFDCustomDomainsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDCustomDomainsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDCustomDomainsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsClientUpdateResponse, error) {
	respType := AFDCustomDomainsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDCustomDomainsClientUpdatePollerResponse from the provided client and resume token.
func (l *AFDCustomDomainsClientUpdatePollerResponse) Resume(ctx context.Context, client *AFDCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDCustomDomainsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDCustomDomainsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDCustomDomainsClientUpdateResponse contains the response from method AFDCustomDomainsClient.Update.
type AFDCustomDomainsClientUpdateResponse struct {
	AFDCustomDomainsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDCustomDomainsClientUpdateResult contains the result from method AFDCustomDomainsClient.Update.
type AFDCustomDomainsClientUpdateResult struct {
	AFDDomain
}

// AFDEndpointsClientCreatePollerResponse contains the response from method AFDEndpointsClient.Create.
type AFDEndpointsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsClientCreateResponse, error) {
	respType := AFDEndpointsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsClientCreatePollerResponse from the provided client and resume token.
func (l *AFDEndpointsClientCreatePollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsClientCreateResponse contains the response from method AFDEndpointsClient.Create.
type AFDEndpointsClientCreateResponse struct {
	AFDEndpointsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientCreateResult contains the result from method AFDEndpointsClient.Create.
type AFDEndpointsClientCreateResult struct {
	AFDEndpoint
}

// AFDEndpointsClientDeletePollerResponse contains the response from method AFDEndpointsClient.Delete.
type AFDEndpointsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsClientDeleteResponse, error) {
	respType := AFDEndpointsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsClientDeletePollerResponse from the provided client and resume token.
func (l *AFDEndpointsClientDeletePollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsClientDeleteResponse contains the response from method AFDEndpointsClient.Delete.
type AFDEndpointsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientGetResponse contains the response from method AFDEndpointsClient.Get.
type AFDEndpointsClientGetResponse struct {
	AFDEndpointsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientGetResult contains the result from method AFDEndpointsClient.Get.
type AFDEndpointsClientGetResult struct {
	AFDEndpoint
}

// AFDEndpointsClientListByProfileResponse contains the response from method AFDEndpointsClient.ListByProfile.
type AFDEndpointsClientListByProfileResponse struct {
	AFDEndpointsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientListByProfileResult contains the result from method AFDEndpointsClient.ListByProfile.
type AFDEndpointsClientListByProfileResult struct {
	AFDEndpointListResult
}

// AFDEndpointsClientListResourceUsageResponse contains the response from method AFDEndpointsClient.ListResourceUsage.
type AFDEndpointsClientListResourceUsageResponse struct {
	AFDEndpointsClientListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientListResourceUsageResult contains the result from method AFDEndpointsClient.ListResourceUsage.
type AFDEndpointsClientListResourceUsageResult struct {
	UsagesListResult
}

// AFDEndpointsClientPurgeContentPollerResponse contains the response from method AFDEndpointsClient.PurgeContent.
type AFDEndpointsClientPurgeContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsClientPurgeContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsClientPurgeContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsClientPurgeContentResponse, error) {
	respType := AFDEndpointsClientPurgeContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsClientPurgeContentPollerResponse from the provided client and resume token.
func (l *AFDEndpointsClientPurgeContentPollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.PurgeContent", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsClientPurgeContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsClientPurgeContentResponse contains the response from method AFDEndpointsClient.PurgeContent.
type AFDEndpointsClientPurgeContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientUpdatePollerResponse contains the response from method AFDEndpointsClient.Update.
type AFDEndpointsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDEndpointsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDEndpointsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsClientUpdateResponse, error) {
	respType := AFDEndpointsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDEndpointsClientUpdatePollerResponse from the provided client and resume token.
func (l *AFDEndpointsClientUpdatePollerResponse) Resume(ctx context.Context, client *AFDEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDEndpointsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDEndpointsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDEndpointsClientUpdateResponse contains the response from method AFDEndpointsClient.Update.
type AFDEndpointsClientUpdateResponse struct {
	AFDEndpointsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientUpdateResult contains the result from method AFDEndpointsClient.Update.
type AFDEndpointsClientUpdateResult struct {
	AFDEndpoint
}

// AFDEndpointsClientValidateCustomDomainResponse contains the response from method AFDEndpointsClient.ValidateCustomDomain.
type AFDEndpointsClientValidateCustomDomainResponse struct {
	AFDEndpointsClientValidateCustomDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDEndpointsClientValidateCustomDomainResult contains the result from method AFDEndpointsClient.ValidateCustomDomain.
type AFDEndpointsClientValidateCustomDomainResult struct {
	ValidateCustomDomainOutput
}

// AFDOriginGroupsClientCreatePollerResponse contains the response from method AFDOriginGroupsClient.Create.
type AFDOriginGroupsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginGroupsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginGroupsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsClientCreateResponse, error) {
	respType := AFDOriginGroupsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginGroupsClientCreatePollerResponse from the provided client and resume token.
func (l *AFDOriginGroupsClientCreatePollerResponse) Resume(ctx context.Context, client *AFDOriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginGroupsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDOriginGroupsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginGroupsClientCreateResponse contains the response from method AFDOriginGroupsClient.Create.
type AFDOriginGroupsClientCreateResponse struct {
	AFDOriginGroupsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsClientCreateResult contains the result from method AFDOriginGroupsClient.Create.
type AFDOriginGroupsClientCreateResult struct {
	AFDOriginGroup
}

// AFDOriginGroupsClientDeletePollerResponse contains the response from method AFDOriginGroupsClient.Delete.
type AFDOriginGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsClientDeleteResponse, error) {
	respType := AFDOriginGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *AFDOriginGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *AFDOriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDOriginGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginGroupsClientDeleteResponse contains the response from method AFDOriginGroupsClient.Delete.
type AFDOriginGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsClientGetResponse contains the response from method AFDOriginGroupsClient.Get.
type AFDOriginGroupsClientGetResponse struct {
	AFDOriginGroupsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsClientGetResult contains the result from method AFDOriginGroupsClient.Get.
type AFDOriginGroupsClientGetResult struct {
	AFDOriginGroup
}

// AFDOriginGroupsClientListByProfileResponse contains the response from method AFDOriginGroupsClient.ListByProfile.
type AFDOriginGroupsClientListByProfileResponse struct {
	AFDOriginGroupsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsClientListByProfileResult contains the result from method AFDOriginGroupsClient.ListByProfile.
type AFDOriginGroupsClientListByProfileResult struct {
	AFDOriginGroupListResult
}

// AFDOriginGroupsClientListResourceUsageResponse contains the response from method AFDOriginGroupsClient.ListResourceUsage.
type AFDOriginGroupsClientListResourceUsageResponse struct {
	AFDOriginGroupsClientListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsClientListResourceUsageResult contains the result from method AFDOriginGroupsClient.ListResourceUsage.
type AFDOriginGroupsClientListResourceUsageResult struct {
	UsagesListResult
}

// AFDOriginGroupsClientUpdatePollerResponse contains the response from method AFDOriginGroupsClient.Update.
type AFDOriginGroupsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginGroupsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginGroupsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsClientUpdateResponse, error) {
	respType := AFDOriginGroupsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginGroupsClientUpdatePollerResponse from the provided client and resume token.
func (l *AFDOriginGroupsClientUpdatePollerResponse) Resume(ctx context.Context, client *AFDOriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginGroupsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDOriginGroupsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginGroupsClientUpdateResponse contains the response from method AFDOriginGroupsClient.Update.
type AFDOriginGroupsClientUpdateResponse struct {
	AFDOriginGroupsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginGroupsClientUpdateResult contains the result from method AFDOriginGroupsClient.Update.
type AFDOriginGroupsClientUpdateResult struct {
	AFDOriginGroup
}

// AFDOriginsClientCreatePollerResponse contains the response from method AFDOriginsClient.Create.
type AFDOriginsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsClientCreateResponse, error) {
	respType := AFDOriginsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOrigin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginsClientCreatePollerResponse from the provided client and resume token.
func (l *AFDOriginsClientCreatePollerResponse) Resume(ctx context.Context, client *AFDOriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDOriginsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginsClientCreateResponse contains the response from method AFDOriginsClient.Create.
type AFDOriginsClientCreateResponse struct {
	AFDOriginsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsClientCreateResult contains the result from method AFDOriginsClient.Create.
type AFDOriginsClientCreateResult struct {
	AFDOrigin
}

// AFDOriginsClientDeletePollerResponse contains the response from method AFDOriginsClient.Delete.
type AFDOriginsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsClientDeleteResponse, error) {
	respType := AFDOriginsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginsClientDeletePollerResponse from the provided client and resume token.
func (l *AFDOriginsClientDeletePollerResponse) Resume(ctx context.Context, client *AFDOriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDOriginsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginsClientDeleteResponse contains the response from method AFDOriginsClient.Delete.
type AFDOriginsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsClientGetResponse contains the response from method AFDOriginsClient.Get.
type AFDOriginsClientGetResponse struct {
	AFDOriginsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsClientGetResult contains the result from method AFDOriginsClient.Get.
type AFDOriginsClientGetResult struct {
	AFDOrigin
}

// AFDOriginsClientListByOriginGroupResponse contains the response from method AFDOriginsClient.ListByOriginGroup.
type AFDOriginsClientListByOriginGroupResponse struct {
	AFDOriginsClientListByOriginGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsClientListByOriginGroupResult contains the result from method AFDOriginsClient.ListByOriginGroup.
type AFDOriginsClientListByOriginGroupResult struct {
	AFDOriginListResult
}

// AFDOriginsClientUpdatePollerResponse contains the response from method AFDOriginsClient.Update.
type AFDOriginsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AFDOriginsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AFDOriginsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsClientUpdateResponse, error) {
	respType := AFDOriginsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AFDOrigin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AFDOriginsClientUpdatePollerResponse from the provided client and resume token.
func (l *AFDOriginsClientUpdatePollerResponse) Resume(ctx context.Context, client *AFDOriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AFDOriginsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AFDOriginsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AFDOriginsClientUpdateResponse contains the response from method AFDOriginsClient.Update.
type AFDOriginsClientUpdateResponse struct {
	AFDOriginsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDOriginsClientUpdateResult contains the result from method AFDOriginsClient.Update.
type AFDOriginsClientUpdateResult struct {
	AFDOrigin
}

// AFDProfilesClientCheckHostNameAvailabilityResponse contains the response from method AFDProfilesClient.CheckHostNameAvailability.
type AFDProfilesClientCheckHostNameAvailabilityResponse struct {
	AFDProfilesClientCheckHostNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDProfilesClientCheckHostNameAvailabilityResult contains the result from method AFDProfilesClient.CheckHostNameAvailability.
type AFDProfilesClientCheckHostNameAvailabilityResult struct {
	CheckNameAvailabilityOutput
}

// AFDProfilesClientListResourceUsageResponse contains the response from method AFDProfilesClient.ListResourceUsage.
type AFDProfilesClientListResourceUsageResponse struct {
	AFDProfilesClientListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AFDProfilesClientListResourceUsageResult contains the result from method AFDProfilesClient.ListResourceUsage.
type AFDProfilesClientListResourceUsageResult struct {
	UsagesListResult
}

// CustomDomainsClientCreatePollerResponse contains the response from method CustomDomainsClient.Create.
type CustomDomainsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsClientCreateResponse, error) {
	respType := CustomDomainsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsClientCreatePollerResponse from the provided client and resume token.
func (l *CustomDomainsClientCreatePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomDomainsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsClientCreateResponse contains the response from method CustomDomainsClient.Create.
type CustomDomainsClientCreateResponse struct {
	CustomDomainsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientCreateResult contains the result from method CustomDomainsClient.Create.
type CustomDomainsClientCreateResult struct {
	CustomDomain
}

// CustomDomainsClientDeletePollerResponse contains the response from method CustomDomainsClient.Delete.
type CustomDomainsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsClientDeleteResponse, error) {
	respType := CustomDomainsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsClientDeletePollerResponse from the provided client and resume token.
func (l *CustomDomainsClientDeletePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomDomainsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsClientDeleteResponse contains the response from method CustomDomainsClient.Delete.
type CustomDomainsClientDeleteResponse struct {
	CustomDomainsClientDeleteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientDeleteResult contains the result from method CustomDomainsClient.Delete.
type CustomDomainsClientDeleteResult struct {
	CustomDomain
}

// CustomDomainsClientDisableCustomHTTPSResponse contains the response from method CustomDomainsClient.DisableCustomHTTPS.
type CustomDomainsClientDisableCustomHTTPSResponse struct {
	CustomDomainsClientDisableCustomHTTPSResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientDisableCustomHTTPSResult contains the result from method CustomDomainsClient.DisableCustomHTTPS.
type CustomDomainsClientDisableCustomHTTPSResult struct {
	CustomDomain
}

// CustomDomainsClientEnableCustomHTTPSResponse contains the response from method CustomDomainsClient.EnableCustomHTTPS.
type CustomDomainsClientEnableCustomHTTPSResponse struct {
	CustomDomainsClientEnableCustomHTTPSResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientEnableCustomHTTPSResult contains the result from method CustomDomainsClient.EnableCustomHTTPS.
type CustomDomainsClientEnableCustomHTTPSResult struct {
	CustomDomain
}

// CustomDomainsClientGetResponse contains the response from method CustomDomainsClient.Get.
type CustomDomainsClientGetResponse struct {
	CustomDomainsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientGetResult contains the result from method CustomDomainsClient.Get.
type CustomDomainsClientGetResult struct {
	CustomDomain
}

// CustomDomainsClientListByEndpointResponse contains the response from method CustomDomainsClient.ListByEndpoint.
type CustomDomainsClientListByEndpointResponse struct {
	CustomDomainsClientListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientListByEndpointResult contains the result from method CustomDomainsClient.ListByEndpoint.
type CustomDomainsClientListByEndpointResult struct {
	CustomDomainListResult
}

// EdgeNodesClientListResponse contains the response from method EdgeNodesClient.List.
type EdgeNodesClientListResponse struct {
	EdgeNodesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EdgeNodesClientListResult contains the result from method EdgeNodesClient.List.
type EdgeNodesClientListResult struct {
	EdgenodeResult
}

// EndpointsClientCreatePollerResponse contains the response from method EndpointsClient.Create.
type EndpointsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientCreateResponse, error) {
	respType := EndpointsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientCreatePollerResponse from the provided client and resume token.
func (l *EndpointsClientCreatePollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientCreateResponse contains the response from method EndpointsClient.Create.
type EndpointsClientCreateResponse struct {
	EndpointsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientCreateResult contains the result from method EndpointsClient.Create.
type EndpointsClientCreateResult struct {
	Endpoint
}

// EndpointsClientDeletePollerResponse contains the response from method EndpointsClient.Delete.
type EndpointsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientDeleteResponse, error) {
	respType := EndpointsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientDeletePollerResponse from the provided client and resume token.
func (l *EndpointsClientDeletePollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientDeleteResponse contains the response from method EndpointsClient.Delete.
type EndpointsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientGetResponse contains the response from method EndpointsClient.Get.
type EndpointsClientGetResponse struct {
	EndpointsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientGetResult contains the result from method EndpointsClient.Get.
type EndpointsClientGetResult struct {
	Endpoint
}

// EndpointsClientListByProfileResponse contains the response from method EndpointsClient.ListByProfile.
type EndpointsClientListByProfileResponse struct {
	EndpointsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientListByProfileResult contains the result from method EndpointsClient.ListByProfile.
type EndpointsClientListByProfileResult struct {
	EndpointListResult
}

// EndpointsClientListResourceUsageResponse contains the response from method EndpointsClient.ListResourceUsage.
type EndpointsClientListResourceUsageResponse struct {
	EndpointsClientListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientListResourceUsageResult contains the result from method EndpointsClient.ListResourceUsage.
type EndpointsClientListResourceUsageResult struct {
	ResourceUsageListResult
}

// EndpointsClientLoadContentPollerResponse contains the response from method EndpointsClient.LoadContent.
type EndpointsClientLoadContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientLoadContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientLoadContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientLoadContentResponse, error) {
	respType := EndpointsClientLoadContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientLoadContentPollerResponse from the provided client and resume token.
func (l *EndpointsClientLoadContentPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.LoadContent", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientLoadContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientLoadContentResponse contains the response from method EndpointsClient.LoadContent.
type EndpointsClientLoadContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientPurgeContentPollerResponse contains the response from method EndpointsClient.PurgeContent.
type EndpointsClientPurgeContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientPurgeContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientPurgeContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientPurgeContentResponse, error) {
	respType := EndpointsClientPurgeContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientPurgeContentPollerResponse from the provided client and resume token.
func (l *EndpointsClientPurgeContentPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.PurgeContent", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientPurgeContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientPurgeContentResponse contains the response from method EndpointsClient.PurgeContent.
type EndpointsClientPurgeContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientStartPollerResponse contains the response from method EndpointsClient.Start.
type EndpointsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientStartResponse, error) {
	respType := EndpointsClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientStartPollerResponse from the provided client and resume token.
func (l *EndpointsClientStartPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientStartResponse contains the response from method EndpointsClient.Start.
type EndpointsClientStartResponse struct {
	EndpointsClientStartResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientStartResult contains the result from method EndpointsClient.Start.
type EndpointsClientStartResult struct {
	Endpoint
}

// EndpointsClientStopPollerResponse contains the response from method EndpointsClient.Stop.
type EndpointsClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientStopResponse, error) {
	respType := EndpointsClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientStopPollerResponse from the provided client and resume token.
func (l *EndpointsClientStopPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientStopResponse contains the response from method EndpointsClient.Stop.
type EndpointsClientStopResponse struct {
	EndpointsClientStopResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientStopResult contains the result from method EndpointsClient.Stop.
type EndpointsClientStopResult struct {
	Endpoint
}

// EndpointsClientUpdatePollerResponse contains the response from method EndpointsClient.Update.
type EndpointsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientUpdateResponse, error) {
	respType := EndpointsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientUpdatePollerResponse from the provided client and resume token.
func (l *EndpointsClientUpdatePollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientUpdateResponse contains the response from method EndpointsClient.Update.
type EndpointsClientUpdateResponse struct {
	EndpointsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientUpdateResult contains the result from method EndpointsClient.Update.
type EndpointsClientUpdateResult struct {
	Endpoint
}

// EndpointsClientValidateCustomDomainResponse contains the response from method EndpointsClient.ValidateCustomDomain.
type EndpointsClientValidateCustomDomainResponse struct {
	EndpointsClientValidateCustomDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EndpointsClientValidateCustomDomainResult contains the result from method EndpointsClient.ValidateCustomDomain.
type EndpointsClientValidateCustomDomainResult struct {
	ValidateCustomDomainOutput
}

// LogAnalyticsClientGetLogAnalyticsLocationsResponse contains the response from method LogAnalyticsClient.GetLogAnalyticsLocations.
type LogAnalyticsClientGetLogAnalyticsLocationsResponse struct {
	LogAnalyticsClientGetLogAnalyticsLocationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsClientGetLogAnalyticsLocationsResult contains the result from method LogAnalyticsClient.GetLogAnalyticsLocations.
type LogAnalyticsClientGetLogAnalyticsLocationsResult struct {
	ContinentsResponse
}

// LogAnalyticsClientGetLogAnalyticsMetricsResponse contains the response from method LogAnalyticsClient.GetLogAnalyticsMetrics.
type LogAnalyticsClientGetLogAnalyticsMetricsResponse struct {
	LogAnalyticsClientGetLogAnalyticsMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsClientGetLogAnalyticsMetricsResult contains the result from method LogAnalyticsClient.GetLogAnalyticsMetrics.
type LogAnalyticsClientGetLogAnalyticsMetricsResult struct {
	MetricsResponse
}

// LogAnalyticsClientGetLogAnalyticsRankingsResponse contains the response from method LogAnalyticsClient.GetLogAnalyticsRankings.
type LogAnalyticsClientGetLogAnalyticsRankingsResponse struct {
	LogAnalyticsClientGetLogAnalyticsRankingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsClientGetLogAnalyticsRankingsResult contains the result from method LogAnalyticsClient.GetLogAnalyticsRankings.
type LogAnalyticsClientGetLogAnalyticsRankingsResult struct {
	RankingsResponse
}

// LogAnalyticsClientGetLogAnalyticsResourcesResponse contains the response from method LogAnalyticsClient.GetLogAnalyticsResources.
type LogAnalyticsClientGetLogAnalyticsResourcesResponse struct {
	LogAnalyticsClientGetLogAnalyticsResourcesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsClientGetLogAnalyticsResourcesResult contains the result from method LogAnalyticsClient.GetLogAnalyticsResources.
type LogAnalyticsClientGetLogAnalyticsResourcesResult struct {
	ResourcesResponse
}

// LogAnalyticsClientGetWafLogAnalyticsMetricsResponse contains the response from method LogAnalyticsClient.GetWafLogAnalyticsMetrics.
type LogAnalyticsClientGetWafLogAnalyticsMetricsResponse struct {
	LogAnalyticsClientGetWafLogAnalyticsMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsClientGetWafLogAnalyticsMetricsResult contains the result from method LogAnalyticsClient.GetWafLogAnalyticsMetrics.
type LogAnalyticsClientGetWafLogAnalyticsMetricsResult struct {
	WafMetricsResponse
}

// LogAnalyticsClientGetWafLogAnalyticsRankingsResponse contains the response from method LogAnalyticsClient.GetWafLogAnalyticsRankings.
type LogAnalyticsClientGetWafLogAnalyticsRankingsResponse struct {
	LogAnalyticsClientGetWafLogAnalyticsRankingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogAnalyticsClientGetWafLogAnalyticsRankingsResult contains the result from method LogAnalyticsClient.GetWafLogAnalyticsRankings.
type LogAnalyticsClientGetWafLogAnalyticsRankingsResult struct {
	WafRankingsResponse
}

// ManagedRuleSetsClientListResponse contains the response from method ManagedRuleSetsClient.List.
type ManagedRuleSetsClientListResponse struct {
	ManagedRuleSetsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRuleSetsClientListResult contains the result from method ManagedRuleSetsClient.List.
type ManagedRuleSetsClientListResult struct {
	ManagedRuleSetDefinitionList
}

// ManagementClientCheckNameAvailabilityResponse contains the response from method ManagementClient.CheckNameAvailability.
type ManagementClientCheckNameAvailabilityResponse struct {
	ManagementClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientCheckNameAvailabilityResult contains the result from method ManagementClient.CheckNameAvailability.
type ManagementClientCheckNameAvailabilityResult struct {
	CheckNameAvailabilityOutput
}

// ManagementClientCheckNameAvailabilityWithSubscriptionResponse contains the response from method ManagementClient.CheckNameAvailabilityWithSubscription.
type ManagementClientCheckNameAvailabilityWithSubscriptionResponse struct {
	ManagementClientCheckNameAvailabilityWithSubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientCheckNameAvailabilityWithSubscriptionResult contains the result from method ManagementClient.CheckNameAvailabilityWithSubscription.
type ManagementClientCheckNameAvailabilityWithSubscriptionResult struct {
	CheckNameAvailabilityOutput
}

// ManagementClientValidateProbeResponse contains the response from method ManagementClient.ValidateProbe.
type ManagementClientValidateProbeResponse struct {
	ManagementClientValidateProbeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientValidateProbeResult contains the result from method ManagementClient.ValidateProbe.
type ManagementClientValidateProbeResult struct {
	ValidateProbeOutput
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationsListResult
}

// OriginGroupsClientCreatePollerResponse contains the response from method OriginGroupsClient.Create.
type OriginGroupsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginGroupsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginGroupsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsClientCreateResponse, error) {
	respType := OriginGroupsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.OriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginGroupsClientCreatePollerResponse from the provided client and resume token.
func (l *OriginGroupsClientCreatePollerResponse) Resume(ctx context.Context, client *OriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginGroupsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OriginGroupsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginGroupsClientCreateResponse contains the response from method OriginGroupsClient.Create.
type OriginGroupsClientCreateResponse struct {
	OriginGroupsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsClientCreateResult contains the result from method OriginGroupsClient.Create.
type OriginGroupsClientCreateResult struct {
	OriginGroup
}

// OriginGroupsClientDeletePollerResponse contains the response from method OriginGroupsClient.Delete.
type OriginGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsClientDeleteResponse, error) {
	respType := OriginGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *OriginGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *OriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OriginGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginGroupsClientDeleteResponse contains the response from method OriginGroupsClient.Delete.
type OriginGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsClientGetResponse contains the response from method OriginGroupsClient.Get.
type OriginGroupsClientGetResponse struct {
	OriginGroupsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsClientGetResult contains the result from method OriginGroupsClient.Get.
type OriginGroupsClientGetResult struct {
	OriginGroup
}

// OriginGroupsClientListByEndpointResponse contains the response from method OriginGroupsClient.ListByEndpoint.
type OriginGroupsClientListByEndpointResponse struct {
	OriginGroupsClientListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsClientListByEndpointResult contains the result from method OriginGroupsClient.ListByEndpoint.
type OriginGroupsClientListByEndpointResult struct {
	OriginGroupListResult
}

// OriginGroupsClientUpdatePollerResponse contains the response from method OriginGroupsClient.Update.
type OriginGroupsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginGroupsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginGroupsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsClientUpdateResponse, error) {
	respType := OriginGroupsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.OriginGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginGroupsClientUpdatePollerResponse from the provided client and resume token.
func (l *OriginGroupsClientUpdatePollerResponse) Resume(ctx context.Context, client *OriginGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginGroupsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OriginGroupsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginGroupsClientUpdateResponse contains the response from method OriginGroupsClient.Update.
type OriginGroupsClientUpdateResponse struct {
	OriginGroupsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginGroupsClientUpdateResult contains the result from method OriginGroupsClient.Update.
type OriginGroupsClientUpdateResult struct {
	OriginGroup
}

// OriginsClientCreatePollerResponse contains the response from method OriginsClient.Create.
type OriginsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginsClientCreateResponse, error) {
	respType := OriginsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Origin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginsClientCreatePollerResponse from the provided client and resume token.
func (l *OriginsClientCreatePollerResponse) Resume(ctx context.Context, client *OriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OriginsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginsClientCreateResponse contains the response from method OriginsClient.Create.
type OriginsClientCreateResponse struct {
	OriginsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsClientCreateResult contains the result from method OriginsClient.Create.
type OriginsClientCreateResult struct {
	Origin
}

// OriginsClientDeletePollerResponse contains the response from method OriginsClient.Delete.
type OriginsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginsClientDeleteResponse, error) {
	respType := OriginsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginsClientDeletePollerResponse from the provided client and resume token.
func (l *OriginsClientDeletePollerResponse) Resume(ctx context.Context, client *OriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OriginsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginsClientDeleteResponse contains the response from method OriginsClient.Delete.
type OriginsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsClientGetResponse contains the response from method OriginsClient.Get.
type OriginsClientGetResponse struct {
	OriginsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsClientGetResult contains the result from method OriginsClient.Get.
type OriginsClientGetResult struct {
	Origin
}

// OriginsClientListByEndpointResponse contains the response from method OriginsClient.ListByEndpoint.
type OriginsClientListByEndpointResponse struct {
	OriginsClientListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsClientListByEndpointResult contains the result from method OriginsClient.ListByEndpoint.
type OriginsClientListByEndpointResult struct {
	OriginListResult
}

// OriginsClientUpdatePollerResponse contains the response from method OriginsClient.Update.
type OriginsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OriginsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OriginsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OriginsClientUpdateResponse, error) {
	respType := OriginsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Origin)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OriginsClientUpdatePollerResponse from the provided client and resume token.
func (l *OriginsClientUpdatePollerResponse) Resume(ctx context.Context, client *OriginsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OriginsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OriginsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OriginsClientUpdateResponse contains the response from method OriginsClient.Update.
type OriginsClientUpdateResponse struct {
	OriginsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OriginsClientUpdateResult contains the result from method OriginsClient.Update.
type OriginsClientUpdateResult struct {
	Origin
}

// PoliciesClientCreateOrUpdatePollerResponse contains the response from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesClientCreateOrUpdateResponse, error) {
	respType := PoliciesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WebApplicationFirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PoliciesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PoliciesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesClientCreateOrUpdateResponse contains the response from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdateResponse struct {
	PoliciesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientCreateOrUpdateResult contains the result from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdateResult struct {
	WebApplicationFirewallPolicy
}

// PoliciesClientDeleteResponse contains the response from method PoliciesClient.Delete.
type PoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientGetResponse contains the response from method PoliciesClient.Get.
type PoliciesClientGetResponse struct {
	PoliciesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientGetResult contains the result from method PoliciesClient.Get.
type PoliciesClientGetResult struct {
	WebApplicationFirewallPolicy
}

// PoliciesClientListResponse contains the response from method PoliciesClient.List.
type PoliciesClientListResponse struct {
	PoliciesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientListResult contains the result from method PoliciesClient.List.
type PoliciesClientListResult struct {
	WebApplicationFirewallPolicyList
}

// PoliciesClientUpdatePollerResponse contains the response from method PoliciesClient.Update.
type PoliciesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesClientUpdateResponse, error) {
	respType := PoliciesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WebApplicationFirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesClientUpdatePollerResponse from the provided client and resume token.
func (l *PoliciesClientUpdatePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PoliciesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesClientUpdateResponse contains the response from method PoliciesClient.Update.
type PoliciesClientUpdateResponse struct {
	PoliciesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientUpdateResult contains the result from method PoliciesClient.Update.
type PoliciesClientUpdateResult struct {
	WebApplicationFirewallPolicy
}

// ProfilesClientCreatePollerResponse contains the response from method ProfilesClient.Create.
type ProfilesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesClientCreateResponse, error) {
	respType := ProfilesClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesClientCreatePollerResponse from the provided client and resume token.
func (l *ProfilesClientCreatePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ProfilesClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesClientCreateResponse contains the response from method ProfilesClient.Create.
type ProfilesClientCreateResponse struct {
	ProfilesClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientCreateResult contains the result from method ProfilesClient.Create.
type ProfilesClientCreateResult struct {
	Profile
}

// ProfilesClientDeletePollerResponse contains the response from method ProfilesClient.Delete.
type ProfilesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesClientDeleteResponse, error) {
	respType := ProfilesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesClientDeletePollerResponse from the provided client and resume token.
func (l *ProfilesClientDeletePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ProfilesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesClientDeleteResponse contains the response from method ProfilesClient.Delete.
type ProfilesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientGenerateSsoURIResponse contains the response from method ProfilesClient.GenerateSsoURI.
type ProfilesClientGenerateSsoURIResponse struct {
	ProfilesClientGenerateSsoURIResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientGenerateSsoURIResult contains the result from method ProfilesClient.GenerateSsoURI.
type ProfilesClientGenerateSsoURIResult struct {
	SsoURI
}

// ProfilesClientGetResponse contains the response from method ProfilesClient.Get.
type ProfilesClientGetResponse struct {
	ProfilesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientGetResult contains the result from method ProfilesClient.Get.
type ProfilesClientGetResult struct {
	Profile
}

// ProfilesClientListByResourceGroupResponse contains the response from method ProfilesClient.ListByResourceGroup.
type ProfilesClientListByResourceGroupResponse struct {
	ProfilesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientListByResourceGroupResult contains the result from method ProfilesClient.ListByResourceGroup.
type ProfilesClientListByResourceGroupResult struct {
	ProfileListResult
}

// ProfilesClientListResourceUsageResponse contains the response from method ProfilesClient.ListResourceUsage.
type ProfilesClientListResourceUsageResponse struct {
	ProfilesClientListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientListResourceUsageResult contains the result from method ProfilesClient.ListResourceUsage.
type ProfilesClientListResourceUsageResult struct {
	ResourceUsageListResult
}

// ProfilesClientListResponse contains the response from method ProfilesClient.List.
type ProfilesClientListResponse struct {
	ProfilesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientListResult contains the result from method ProfilesClient.List.
type ProfilesClientListResult struct {
	ProfileListResult
}

// ProfilesClientListSupportedOptimizationTypesResponse contains the response from method ProfilesClient.ListSupportedOptimizationTypes.
type ProfilesClientListSupportedOptimizationTypesResponse struct {
	ProfilesClientListSupportedOptimizationTypesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientListSupportedOptimizationTypesResult contains the result from method ProfilesClient.ListSupportedOptimizationTypes.
type ProfilesClientListSupportedOptimizationTypesResult struct {
	SupportedOptimizationTypesListResult
}

// ProfilesClientUpdatePollerResponse contains the response from method ProfilesClient.Update.
type ProfilesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesClientUpdateResponse, error) {
	respType := ProfilesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesClientUpdatePollerResponse from the provided client and resume token.
func (l *ProfilesClientUpdatePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ProfilesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesClientUpdateResponse contains the response from method ProfilesClient.Update.
type ProfilesClientUpdateResponse struct {
	ProfilesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientUpdateResult contains the result from method ProfilesClient.Update.
type ProfilesClientUpdateResult struct {
	Profile
}

// ResourceUsageClientListResponse contains the response from method ResourceUsageClient.List.
type ResourceUsageClientListResponse struct {
	ResourceUsageClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceUsageClientListResult contains the result from method ResourceUsageClient.List.
type ResourceUsageClientListResult struct {
	ResourceUsageListResult
}

// RoutesClientCreatePollerResponse contains the response from method RoutesClient.Create.
type RoutesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientCreateResponse, error) {
	respType := RoutesClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesClientCreatePollerResponse from the provided client and resume token.
func (l *RoutesClientCreatePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RoutesClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesClientCreateResponse contains the response from method RoutesClient.Create.
type RoutesClientCreateResponse struct {
	RoutesClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientCreateResult contains the result from method RoutesClient.Create.
type RoutesClientCreateResult struct {
	Route
}

// RoutesClientDeletePollerResponse contains the response from method RoutesClient.Delete.
type RoutesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientDeleteResponse, error) {
	respType := RoutesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesClientDeletePollerResponse from the provided client and resume token.
func (l *RoutesClientDeletePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RoutesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesClientDeleteResponse contains the response from method RoutesClient.Delete.
type RoutesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientGetResponse contains the response from method RoutesClient.Get.
type RoutesClientGetResponse struct {
	RoutesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientGetResult contains the result from method RoutesClient.Get.
type RoutesClientGetResult struct {
	Route
}

// RoutesClientListByEndpointResponse contains the response from method RoutesClient.ListByEndpoint.
type RoutesClientListByEndpointResponse struct {
	RoutesClientListByEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientListByEndpointResult contains the result from method RoutesClient.ListByEndpoint.
type RoutesClientListByEndpointResult struct {
	RouteListResult
}

// RoutesClientUpdatePollerResponse contains the response from method RoutesClient.Update.
type RoutesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientUpdateResponse, error) {
	respType := RoutesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesClientUpdatePollerResponse from the provided client and resume token.
func (l *RoutesClientUpdatePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RoutesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesClientUpdateResponse contains the response from method RoutesClient.Update.
type RoutesClientUpdateResponse struct {
	RoutesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientUpdateResult contains the result from method RoutesClient.Update.
type RoutesClientUpdateResult struct {
	Route
}

// RuleSetsClientCreateResponse contains the response from method RuleSetsClient.Create.
type RuleSetsClientCreateResponse struct {
	RuleSetsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsClientCreateResult contains the result from method RuleSetsClient.Create.
type RuleSetsClientCreateResult struct {
	RuleSet
}

// RuleSetsClientDeletePollerResponse contains the response from method RuleSetsClient.Delete.
type RuleSetsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RuleSetsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RuleSetsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RuleSetsClientDeleteResponse, error) {
	respType := RuleSetsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RuleSetsClientDeletePollerResponse from the provided client and resume token.
func (l *RuleSetsClientDeletePollerResponse) Resume(ctx context.Context, client *RuleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RuleSetsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RuleSetsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RuleSetsClientDeleteResponse contains the response from method RuleSetsClient.Delete.
type RuleSetsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsClientGetResponse contains the response from method RuleSetsClient.Get.
type RuleSetsClientGetResponse struct {
	RuleSetsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsClientGetResult contains the result from method RuleSetsClient.Get.
type RuleSetsClientGetResult struct {
	RuleSet
}

// RuleSetsClientListByProfileResponse contains the response from method RuleSetsClient.ListByProfile.
type RuleSetsClientListByProfileResponse struct {
	RuleSetsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsClientListByProfileResult contains the result from method RuleSetsClient.ListByProfile.
type RuleSetsClientListByProfileResult struct {
	RuleSetListResult
}

// RuleSetsClientListResourceUsageResponse contains the response from method RuleSetsClient.ListResourceUsage.
type RuleSetsClientListResourceUsageResponse struct {
	RuleSetsClientListResourceUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuleSetsClientListResourceUsageResult contains the result from method RuleSetsClient.ListResourceUsage.
type RuleSetsClientListResourceUsageResult struct {
	UsagesListResult
}

// RulesClientCreatePollerResponse contains the response from method RulesClient.Create.
type RulesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesClientCreateResponse, error) {
	respType := RulesClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Rule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesClientCreatePollerResponse from the provided client and resume token.
func (l *RulesClientCreatePollerResponse) Resume(ctx context.Context, client *RulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RulesClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesClientCreateResponse contains the response from method RulesClient.Create.
type RulesClientCreateResponse struct {
	RulesClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesClientCreateResult contains the result from method RulesClient.Create.
type RulesClientCreateResult struct {
	Rule
}

// RulesClientDeletePollerResponse contains the response from method RulesClient.Delete.
type RulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesClientDeleteResponse, error) {
	respType := RulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesClientDeletePollerResponse from the provided client and resume token.
func (l *RulesClientDeletePollerResponse) Resume(ctx context.Context, client *RulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesClientDeleteResponse contains the response from method RulesClient.Delete.
type RulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesClientGetResponse contains the response from method RulesClient.Get.
type RulesClientGetResponse struct {
	RulesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesClientGetResult contains the result from method RulesClient.Get.
type RulesClientGetResult struct {
	Rule
}

// RulesClientListByRuleSetResponse contains the response from method RulesClient.ListByRuleSet.
type RulesClientListByRuleSetResponse struct {
	RulesClientListByRuleSetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesClientListByRuleSetResult contains the result from method RulesClient.ListByRuleSet.
type RulesClientListByRuleSetResult struct {
	RuleListResult
}

// RulesClientUpdatePollerResponse contains the response from method RulesClient.Update.
type RulesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesClientUpdateResponse, error) {
	respType := RulesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Rule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesClientUpdatePollerResponse from the provided client and resume token.
func (l *RulesClientUpdatePollerResponse) Resume(ctx context.Context, client *RulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RulesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesClientUpdateResponse contains the response from method RulesClient.Update.
type RulesClientUpdateResponse struct {
	RulesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesClientUpdateResult contains the result from method RulesClient.Update.
type RulesClientUpdateResult struct {
	Rule
}

// SecretsClientCreatePollerResponse contains the response from method SecretsClient.Create.
type SecretsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsClientCreateResponse, error) {
	respType := SecretsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecretsClientCreatePollerResponse from the provided client and resume token.
func (l *SecretsClientCreatePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecretsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecretsClientCreateResponse contains the response from method SecretsClient.Create.
type SecretsClientCreateResponse struct {
	SecretsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsClientCreateResult contains the result from method SecretsClient.Create.
type SecretsClientCreateResult struct {
	Secret
}

// SecretsClientDeletePollerResponse contains the response from method SecretsClient.Delete.
type SecretsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsClientDeleteResponse, error) {
	respType := SecretsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecretsClientDeletePollerResponse from the provided client and resume token.
func (l *SecretsClientDeletePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecretsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecretsClientDeleteResponse contains the response from method SecretsClient.Delete.
type SecretsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsClientGetResponse contains the response from method SecretsClient.Get.
type SecretsClientGetResponse struct {
	SecretsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsClientGetResult contains the result from method SecretsClient.Get.
type SecretsClientGetResult struct {
	Secret
}

// SecretsClientListByProfileResponse contains the response from method SecretsClient.ListByProfile.
type SecretsClientListByProfileResponse struct {
	SecretsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsClientListByProfileResult contains the result from method SecretsClient.ListByProfile.
type SecretsClientListByProfileResult struct {
	SecretListResult
}

// SecurityPoliciesClientCreatePollerResponse contains the response from method SecurityPoliciesClient.Create.
type SecurityPoliciesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPoliciesClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPoliciesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesClientCreateResponse, error) {
	respType := SecurityPoliciesClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPoliciesClientCreatePollerResponse from the provided client and resume token.
func (l *SecurityPoliciesClientCreatePollerResponse) Resume(ctx context.Context, client *SecurityPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPoliciesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityPoliciesClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPoliciesClientCreateResponse contains the response from method SecurityPoliciesClient.Create.
type SecurityPoliciesClientCreateResponse struct {
	SecurityPoliciesClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesClientCreateResult contains the result from method SecurityPoliciesClient.Create.
type SecurityPoliciesClientCreateResult struct {
	SecurityPolicy
}

// SecurityPoliciesClientDeletePollerResponse contains the response from method SecurityPoliciesClient.Delete.
type SecurityPoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesClientDeleteResponse, error) {
	respType := SecurityPoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *SecurityPoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *SecurityPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityPoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPoliciesClientDeleteResponse contains the response from method SecurityPoliciesClient.Delete.
type SecurityPoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesClientGetResponse contains the response from method SecurityPoliciesClient.Get.
type SecurityPoliciesClientGetResponse struct {
	SecurityPoliciesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesClientGetResult contains the result from method SecurityPoliciesClient.Get.
type SecurityPoliciesClientGetResult struct {
	SecurityPolicy
}

// SecurityPoliciesClientListByProfileResponse contains the response from method SecurityPoliciesClient.ListByProfile.
type SecurityPoliciesClientListByProfileResponse struct {
	SecurityPoliciesClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesClientListByProfileResult contains the result from method SecurityPoliciesClient.ListByProfile.
type SecurityPoliciesClientListByProfileResult struct {
	SecurityPolicyListResult
}

// SecurityPoliciesClientPatchPollerResponse contains the response from method SecurityPoliciesClient.Patch.
type SecurityPoliciesClientPatchPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPoliciesClientPatchPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPoliciesClientPatchPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesClientPatchResponse, error) {
	respType := SecurityPoliciesClientPatchResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPoliciesClientPatchPollerResponse from the provided client and resume token.
func (l *SecurityPoliciesClientPatchPollerResponse) Resume(ctx context.Context, client *SecurityPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPoliciesClient.Patch", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityPoliciesClientPatchPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPoliciesClientPatchResponse contains the response from method SecurityPoliciesClient.Patch.
type SecurityPoliciesClientPatchResponse struct {
	SecurityPoliciesClientPatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPoliciesClientPatchResult contains the result from method SecurityPoliciesClient.Patch.
type SecurityPoliciesClientPatchResult struct {
	SecurityPolicy
}

// ValidateClientSecretResponse contains the response from method ValidateClient.Secret.
type ValidateClientSecretResponse struct {
	ValidateClientSecretResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ValidateClientSecretResult contains the result from method ValidateClient.Secret.
type ValidateClientSecretResult struct {
	ValidateSecretOutput
}
