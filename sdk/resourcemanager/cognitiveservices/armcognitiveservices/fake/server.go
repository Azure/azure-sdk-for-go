// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/cognitiveservices/armcognitiveservices/v4"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"sync"
)

// Server is a fake server for instances of the armcognitiveservices.Client type.
type Server struct {
	// AccountCapabilityHostsServer contains the fakes for client AccountCapabilityHostsClient
	AccountCapabilityHostsServer AccountCapabilityHostsServer

	// AccountConnectionsServer contains the fakes for client AccountConnectionsClient
	AccountConnectionsServer AccountConnectionsServer

	// AccountsServer contains the fakes for client AccountsClient
	AccountsServer AccountsServer

	// AgentApplicationsServer contains the fakes for client AgentApplicationsClient
	AgentApplicationsServer AgentApplicationsServer

	// AgentDeploymentsServer contains the fakes for client AgentDeploymentsClient
	AgentDeploymentsServer AgentDeploymentsServer

	// CommitmentPlansServer contains the fakes for client CommitmentPlansClient
	CommitmentPlansServer CommitmentPlansServer

	// CommitmentTiersServer contains the fakes for client CommitmentTiersClient
	CommitmentTiersServer CommitmentTiersServer

	// DefenderForAISettingsServer contains the fakes for client DefenderForAISettingsClient
	DefenderForAISettingsServer DefenderForAISettingsServer

	// DeletedAccountsServer contains the fakes for client DeletedAccountsClient
	DeletedAccountsServer DeletedAccountsServer

	// DeploymentsServer contains the fakes for client DeploymentsClient
	DeploymentsServer DeploymentsServer

	// EncryptionScopesServer contains the fakes for client EncryptionScopesClient
	EncryptionScopesServer EncryptionScopesServer

	// LocationBasedModelCapacitiesServer contains the fakes for client LocationBasedModelCapacitiesClient
	LocationBasedModelCapacitiesServer LocationBasedModelCapacitiesServer

	// ManagedNetworkProvisionsServer contains the fakes for client ManagedNetworkProvisionsClient
	ManagedNetworkProvisionsServer ManagedNetworkProvisionsServer

	// ManagedNetworkSettingsServer contains the fakes for client ManagedNetworkSettingsClient
	ManagedNetworkSettingsServer ManagedNetworkSettingsServer

	// ModelCapacitiesServer contains the fakes for client ModelCapacitiesClient
	ModelCapacitiesServer ModelCapacitiesServer

	// ModelsServer contains the fakes for client ModelsClient
	ModelsServer ModelsServer

	// NetworkSecurityPerimeterConfigurationsServer contains the fakes for client NetworkSecurityPerimeterConfigurationsClient
	NetworkSecurityPerimeterConfigurationsServer NetworkSecurityPerimeterConfigurationsServer

	// OperationsServer contains the fakes for client OperationsClient
	OperationsServer OperationsServer

	// OutboundRuleServer contains the fakes for client OutboundRuleClient
	OutboundRuleServer OutboundRuleServer

	// OutboundRulesServer contains the fakes for client OutboundRulesClient
	OutboundRulesServer OutboundRulesServer

	// PrivateEndpointConnectionsServer contains the fakes for client PrivateEndpointConnectionsClient
	PrivateEndpointConnectionsServer PrivateEndpointConnectionsServer

	// PrivateLinkResourcesServer contains the fakes for client PrivateLinkResourcesClient
	PrivateLinkResourcesServer PrivateLinkResourcesServer

	// ProjectCapabilityHostsServer contains the fakes for client ProjectCapabilityHostsClient
	ProjectCapabilityHostsServer ProjectCapabilityHostsServer

	// ProjectConnectionsServer contains the fakes for client ProjectConnectionsClient
	ProjectConnectionsServer ProjectConnectionsServer

	// ProjectsServer contains the fakes for client ProjectsClient
	ProjectsServer ProjectsServer

	// QuotaTiersServer contains the fakes for client QuotaTiersClient
	QuotaTiersServer QuotaTiersServer

	// RaiBlocklistItemsServer contains the fakes for client RaiBlocklistItemsClient
	RaiBlocklistItemsServer RaiBlocklistItemsServer

	// RaiBlocklistsServer contains the fakes for client RaiBlocklistsClient
	RaiBlocklistsServer RaiBlocklistsServer

	// RaiContentFiltersServer contains the fakes for client RaiContentFiltersClient
	RaiContentFiltersServer RaiContentFiltersServer

	// RaiExternalSafetyProviderServer contains the fakes for client RaiExternalSafetyProviderClient
	RaiExternalSafetyProviderServer RaiExternalSafetyProviderServer

	// RaiExternalSafetyProvidersServer contains the fakes for client RaiExternalSafetyProvidersClient
	RaiExternalSafetyProvidersServer RaiExternalSafetyProvidersServer

	// RaiPoliciesServer contains the fakes for client RaiPoliciesClient
	RaiPoliciesServer RaiPoliciesServer

	// RaiToolLabelsServer contains the fakes for client RaiToolLabelsClient
	RaiToolLabelsServer RaiToolLabelsServer

	// RaiTopicsServer contains the fakes for client RaiTopicsClient
	RaiTopicsServer RaiTopicsServer

	// ResourceSKUsServer contains the fakes for client ResourceSKUsClient
	ResourceSKUsServer ResourceSKUsServer

	// SubscriptionRaiPolicyServer contains the fakes for client SubscriptionRaiPolicyClient
	SubscriptionRaiPolicyServer SubscriptionRaiPolicyServer

	// TestRaiExternalSafetyProviderServer contains the fakes for client TestRaiExternalSafetyProviderClient
	TestRaiExternalSafetyProviderServer TestRaiExternalSafetyProviderServer

	// UsagesServer contains the fakes for client UsagesClient
	UsagesServer UsagesServer

	// CalculateModelCapacity is the fake for method Client.CalculateModelCapacity
	// HTTP status codes to indicate success: http.StatusOK
	CalculateModelCapacity func(ctx context.Context, parameters armcognitiveservices.CalculateModelCapacityParameter, options *armcognitiveservices.ClientCalculateModelCapacityOptions) (resp azfake.Responder[armcognitiveservices.ClientCalculateModelCapacityResponse], errResp azfake.ErrorResponder)

	// CheckDomainAvailability is the fake for method Client.CheckDomainAvailability
	// HTTP status codes to indicate success: http.StatusOK
	CheckDomainAvailability func(ctx context.Context, parameters armcognitiveservices.CheckDomainAvailabilityParameter, options *armcognitiveservices.ClientCheckDomainAvailabilityOptions) (resp azfake.Responder[armcognitiveservices.ClientCheckDomainAvailabilityResponse], errResp azfake.ErrorResponder)

	// CheckSKUAvailability is the fake for method Client.CheckSKUAvailability
	// HTTP status codes to indicate success: http.StatusOK
	CheckSKUAvailability func(ctx context.Context, location string, parameters armcognitiveservices.CheckSKUAvailabilityParameter, options *armcognitiveservices.ClientCheckSKUAvailabilityOptions) (resp azfake.Responder[armcognitiveservices.ClientCheckSKUAvailabilityResponse], errResp azfake.ErrorResponder)
}

// NewServerTransport creates a new instance of ServerTransport with the provided implementation.
// The returned ServerTransport instance is connected to an instance of armcognitiveservices.Client via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewServerTransport(srv *Server) *ServerTransport {
	return &ServerTransport{srv: srv}
}

// ServerTransport connects instances of armcognitiveservices.Client to instances of Server.
// Don't use this type directly, use NewServerTransport instead.
type ServerTransport struct {
	srv                                            *Server
	trMu                                           sync.Mutex
	trAccountCapabilityHostsServer                 *AccountCapabilityHostsServerTransport
	trAccountConnectionsServer                     *AccountConnectionsServerTransport
	trAccountsServer                               *AccountsServerTransport
	trAgentApplicationsServer                      *AgentApplicationsServerTransport
	trAgentDeploymentsServer                       *AgentDeploymentsServerTransport
	trCommitmentPlansServer                        *CommitmentPlansServerTransport
	trCommitmentTiersServer                        *CommitmentTiersServerTransport
	trDefenderForAISettingsServer                  *DefenderForAISettingsServerTransport
	trDeletedAccountsServer                        *DeletedAccountsServerTransport
	trDeploymentsServer                            *DeploymentsServerTransport
	trEncryptionScopesServer                       *EncryptionScopesServerTransport
	trLocationBasedModelCapacitiesServer           *LocationBasedModelCapacitiesServerTransport
	trManagedNetworkProvisionsServer               *ManagedNetworkProvisionsServerTransport
	trManagedNetworkSettingsServer                 *ManagedNetworkSettingsServerTransport
	trModelCapacitiesServer                        *ModelCapacitiesServerTransport
	trModelsServer                                 *ModelsServerTransport
	trNetworkSecurityPerimeterConfigurationsServer *NetworkSecurityPerimeterConfigurationsServerTransport
	trOperationsServer                             *OperationsServerTransport
	trOutboundRuleServer                           *OutboundRuleServerTransport
	trOutboundRulesServer                          *OutboundRulesServerTransport
	trPrivateEndpointConnectionsServer             *PrivateEndpointConnectionsServerTransport
	trPrivateLinkResourcesServer                   *PrivateLinkResourcesServerTransport
	trProjectCapabilityHostsServer                 *ProjectCapabilityHostsServerTransport
	trProjectConnectionsServer                     *ProjectConnectionsServerTransport
	trProjectsServer                               *ProjectsServerTransport
	trQuotaTiersServer                             *QuotaTiersServerTransport
	trRaiBlocklistItemsServer                      *RaiBlocklistItemsServerTransport
	trRaiBlocklistsServer                          *RaiBlocklistsServerTransport
	trRaiContentFiltersServer                      *RaiContentFiltersServerTransport
	trRaiExternalSafetyProviderServer              *RaiExternalSafetyProviderServerTransport
	trRaiExternalSafetyProvidersServer             *RaiExternalSafetyProvidersServerTransport
	trRaiPoliciesServer                            *RaiPoliciesServerTransport
	trRaiToolLabelsServer                          *RaiToolLabelsServerTransport
	trRaiTopicsServer                              *RaiTopicsServerTransport
	trResourceSKUsServer                           *ResourceSKUsServerTransport
	trSubscriptionRaiPolicyServer                  *SubscriptionRaiPolicyServerTransport
	trTestRaiExternalSafetyProviderServer          *TestRaiExternalSafetyProviderServerTransport
	trUsagesServer                                 *UsagesServerTransport
}

// Do implements the policy.Transporter interface for ServerTransport.
func (s *ServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	if client := method[:strings.Index(method, ".")]; client != "Client" {
		return s.dispatchToClientFake(req, client)
	}
	return s.dispatchToMethodFake(req, method)
}

func (s *ServerTransport) dispatchToClientFake(req *http.Request, client string) (*http.Response, error) {
	var resp *http.Response
	var err error

	switch client {
	case "AccountCapabilityHostsClient":
		initServer(&s.trMu, &s.trAccountCapabilityHostsServer, func() *AccountCapabilityHostsServerTransport {
			return NewAccountCapabilityHostsServerTransport(&s.srv.AccountCapabilityHostsServer)
		})
		resp, err = s.trAccountCapabilityHostsServer.Do(req)
	case "AccountConnectionsClient":
		initServer(&s.trMu, &s.trAccountConnectionsServer, func() *AccountConnectionsServerTransport {
			return NewAccountConnectionsServerTransport(&s.srv.AccountConnectionsServer)
		})
		resp, err = s.trAccountConnectionsServer.Do(req)
	case "AccountsClient":
		initServer(&s.trMu, &s.trAccountsServer, func() *AccountsServerTransport {
			return NewAccountsServerTransport(&s.srv.AccountsServer)
		})
		resp, err = s.trAccountsServer.Do(req)
	case "AgentApplicationsClient":
		initServer(&s.trMu, &s.trAgentApplicationsServer, func() *AgentApplicationsServerTransport {
			return NewAgentApplicationsServerTransport(&s.srv.AgentApplicationsServer)
		})
		resp, err = s.trAgentApplicationsServer.Do(req)
	case "AgentDeploymentsClient":
		initServer(&s.trMu, &s.trAgentDeploymentsServer, func() *AgentDeploymentsServerTransport {
			return NewAgentDeploymentsServerTransport(&s.srv.AgentDeploymentsServer)
		})
		resp, err = s.trAgentDeploymentsServer.Do(req)
	case "CommitmentPlansClient":
		initServer(&s.trMu, &s.trCommitmentPlansServer, func() *CommitmentPlansServerTransport {
			return NewCommitmentPlansServerTransport(&s.srv.CommitmentPlansServer)
		})
		resp, err = s.trCommitmentPlansServer.Do(req)
	case "CommitmentTiersClient":
		initServer(&s.trMu, &s.trCommitmentTiersServer, func() *CommitmentTiersServerTransport {
			return NewCommitmentTiersServerTransport(&s.srv.CommitmentTiersServer)
		})
		resp, err = s.trCommitmentTiersServer.Do(req)
	case "DefenderForAISettingsClient":
		initServer(&s.trMu, &s.trDefenderForAISettingsServer, func() *DefenderForAISettingsServerTransport {
			return NewDefenderForAISettingsServerTransport(&s.srv.DefenderForAISettingsServer)
		})
		resp, err = s.trDefenderForAISettingsServer.Do(req)
	case "DeletedAccountsClient":
		initServer(&s.trMu, &s.trDeletedAccountsServer, func() *DeletedAccountsServerTransport {
			return NewDeletedAccountsServerTransport(&s.srv.DeletedAccountsServer)
		})
		resp, err = s.trDeletedAccountsServer.Do(req)
	case "DeploymentsClient":
		initServer(&s.trMu, &s.trDeploymentsServer, func() *DeploymentsServerTransport {
			return NewDeploymentsServerTransport(&s.srv.DeploymentsServer)
		})
		resp, err = s.trDeploymentsServer.Do(req)
	case "EncryptionScopesClient":
		initServer(&s.trMu, &s.trEncryptionScopesServer, func() *EncryptionScopesServerTransport {
			return NewEncryptionScopesServerTransport(&s.srv.EncryptionScopesServer)
		})
		resp, err = s.trEncryptionScopesServer.Do(req)
	case "LocationBasedModelCapacitiesClient":
		initServer(&s.trMu, &s.trLocationBasedModelCapacitiesServer, func() *LocationBasedModelCapacitiesServerTransport {
			return NewLocationBasedModelCapacitiesServerTransport(&s.srv.LocationBasedModelCapacitiesServer)
		})
		resp, err = s.trLocationBasedModelCapacitiesServer.Do(req)
	case "ManagedNetworkProvisionsClient":
		initServer(&s.trMu, &s.trManagedNetworkProvisionsServer, func() *ManagedNetworkProvisionsServerTransport {
			return NewManagedNetworkProvisionsServerTransport(&s.srv.ManagedNetworkProvisionsServer)
		})
		resp, err = s.trManagedNetworkProvisionsServer.Do(req)
	case "ManagedNetworkSettingsClient":
		initServer(&s.trMu, &s.trManagedNetworkSettingsServer, func() *ManagedNetworkSettingsServerTransport {
			return NewManagedNetworkSettingsServerTransport(&s.srv.ManagedNetworkSettingsServer)
		})
		resp, err = s.trManagedNetworkSettingsServer.Do(req)
	case "ModelCapacitiesClient":
		initServer(&s.trMu, &s.trModelCapacitiesServer, func() *ModelCapacitiesServerTransport {
			return NewModelCapacitiesServerTransport(&s.srv.ModelCapacitiesServer)
		})
		resp, err = s.trModelCapacitiesServer.Do(req)
	case "ModelsClient":
		initServer(&s.trMu, &s.trModelsServer, func() *ModelsServerTransport {
			return NewModelsServerTransport(&s.srv.ModelsServer)
		})
		resp, err = s.trModelsServer.Do(req)
	case "NetworkSecurityPerimeterConfigurationsClient":
		initServer(&s.trMu, &s.trNetworkSecurityPerimeterConfigurationsServer, func() *NetworkSecurityPerimeterConfigurationsServerTransport {
			return NewNetworkSecurityPerimeterConfigurationsServerTransport(&s.srv.NetworkSecurityPerimeterConfigurationsServer)
		})
		resp, err = s.trNetworkSecurityPerimeterConfigurationsServer.Do(req)
	case "OperationsClient":
		initServer(&s.trMu, &s.trOperationsServer, func() *OperationsServerTransport {
			return NewOperationsServerTransport(&s.srv.OperationsServer)
		})
		resp, err = s.trOperationsServer.Do(req)
	case "OutboundRuleClient":
		initServer(&s.trMu, &s.trOutboundRuleServer, func() *OutboundRuleServerTransport {
			return NewOutboundRuleServerTransport(&s.srv.OutboundRuleServer)
		})
		resp, err = s.trOutboundRuleServer.Do(req)
	case "OutboundRulesClient":
		initServer(&s.trMu, &s.trOutboundRulesServer, func() *OutboundRulesServerTransport {
			return NewOutboundRulesServerTransport(&s.srv.OutboundRulesServer)
		})
		resp, err = s.trOutboundRulesServer.Do(req)
	case "PrivateEndpointConnectionsClient":
		initServer(&s.trMu, &s.trPrivateEndpointConnectionsServer, func() *PrivateEndpointConnectionsServerTransport {
			return NewPrivateEndpointConnectionsServerTransport(&s.srv.PrivateEndpointConnectionsServer)
		})
		resp, err = s.trPrivateEndpointConnectionsServer.Do(req)
	case "PrivateLinkResourcesClient":
		initServer(&s.trMu, &s.trPrivateLinkResourcesServer, func() *PrivateLinkResourcesServerTransport {
			return NewPrivateLinkResourcesServerTransport(&s.srv.PrivateLinkResourcesServer)
		})
		resp, err = s.trPrivateLinkResourcesServer.Do(req)
	case "ProjectCapabilityHostsClient":
		initServer(&s.trMu, &s.trProjectCapabilityHostsServer, func() *ProjectCapabilityHostsServerTransport {
			return NewProjectCapabilityHostsServerTransport(&s.srv.ProjectCapabilityHostsServer)
		})
		resp, err = s.trProjectCapabilityHostsServer.Do(req)
	case "ProjectConnectionsClient":
		initServer(&s.trMu, &s.trProjectConnectionsServer, func() *ProjectConnectionsServerTransport {
			return NewProjectConnectionsServerTransport(&s.srv.ProjectConnectionsServer)
		})
		resp, err = s.trProjectConnectionsServer.Do(req)
	case "ProjectsClient":
		initServer(&s.trMu, &s.trProjectsServer, func() *ProjectsServerTransport {
			return NewProjectsServerTransport(&s.srv.ProjectsServer)
		})
		resp, err = s.trProjectsServer.Do(req)
	case "QuotaTiersClient":
		initServer(&s.trMu, &s.trQuotaTiersServer, func() *QuotaTiersServerTransport {
			return NewQuotaTiersServerTransport(&s.srv.QuotaTiersServer)
		})
		resp, err = s.trQuotaTiersServer.Do(req)
	case "RaiBlocklistItemsClient":
		initServer(&s.trMu, &s.trRaiBlocklistItemsServer, func() *RaiBlocklistItemsServerTransport {
			return NewRaiBlocklistItemsServerTransport(&s.srv.RaiBlocklistItemsServer)
		})
		resp, err = s.trRaiBlocklistItemsServer.Do(req)
	case "RaiBlocklistsClient":
		initServer(&s.trMu, &s.trRaiBlocklistsServer, func() *RaiBlocklistsServerTransport {
			return NewRaiBlocklistsServerTransport(&s.srv.RaiBlocklistsServer)
		})
		resp, err = s.trRaiBlocklistsServer.Do(req)
	case "RaiContentFiltersClient":
		initServer(&s.trMu, &s.trRaiContentFiltersServer, func() *RaiContentFiltersServerTransport {
			return NewRaiContentFiltersServerTransport(&s.srv.RaiContentFiltersServer)
		})
		resp, err = s.trRaiContentFiltersServer.Do(req)
	case "RaiExternalSafetyProviderClient":
		initServer(&s.trMu, &s.trRaiExternalSafetyProviderServer, func() *RaiExternalSafetyProviderServerTransport {
			return NewRaiExternalSafetyProviderServerTransport(&s.srv.RaiExternalSafetyProviderServer)
		})
		resp, err = s.trRaiExternalSafetyProviderServer.Do(req)
	case "RaiExternalSafetyProvidersClient":
		initServer(&s.trMu, &s.trRaiExternalSafetyProvidersServer, func() *RaiExternalSafetyProvidersServerTransport {
			return NewRaiExternalSafetyProvidersServerTransport(&s.srv.RaiExternalSafetyProvidersServer)
		})
		resp, err = s.trRaiExternalSafetyProvidersServer.Do(req)
	case "RaiPoliciesClient":
		initServer(&s.trMu, &s.trRaiPoliciesServer, func() *RaiPoliciesServerTransport {
			return NewRaiPoliciesServerTransport(&s.srv.RaiPoliciesServer)
		})
		resp, err = s.trRaiPoliciesServer.Do(req)
	case "RaiToolLabelsClient":
		initServer(&s.trMu, &s.trRaiToolLabelsServer, func() *RaiToolLabelsServerTransport {
			return NewRaiToolLabelsServerTransport(&s.srv.RaiToolLabelsServer)
		})
		resp, err = s.trRaiToolLabelsServer.Do(req)
	case "RaiTopicsClient":
		initServer(&s.trMu, &s.trRaiTopicsServer, func() *RaiTopicsServerTransport {
			return NewRaiTopicsServerTransport(&s.srv.RaiTopicsServer)
		})
		resp, err = s.trRaiTopicsServer.Do(req)
	case "ResourceSKUsClient":
		initServer(&s.trMu, &s.trResourceSKUsServer, func() *ResourceSKUsServerTransport {
			return NewResourceSKUsServerTransport(&s.srv.ResourceSKUsServer)
		})
		resp, err = s.trResourceSKUsServer.Do(req)
	case "SubscriptionRaiPolicyClient":
		initServer(&s.trMu, &s.trSubscriptionRaiPolicyServer, func() *SubscriptionRaiPolicyServerTransport {
			return NewSubscriptionRaiPolicyServerTransport(&s.srv.SubscriptionRaiPolicyServer)
		})
		resp, err = s.trSubscriptionRaiPolicyServer.Do(req)
	case "TestRaiExternalSafetyProviderClient":
		initServer(&s.trMu, &s.trTestRaiExternalSafetyProviderServer, func() *TestRaiExternalSafetyProviderServerTransport {
			return NewTestRaiExternalSafetyProviderServerTransport(&s.srv.TestRaiExternalSafetyProviderServer)
		})
		resp, err = s.trTestRaiExternalSafetyProviderServer.Do(req)
	case "UsagesClient":
		initServer(&s.trMu, &s.trUsagesServer, func() *UsagesServerTransport {
			return NewUsagesServerTransport(&s.srv.UsagesServer)
		})
		resp, err = s.trUsagesServer.Do(req)
	default:
		err = fmt.Errorf("unhandled client %s", client)
	}

	return resp, err
}

func (s *ServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if serverTransportInterceptor != nil {
			res.resp, res.err, intercepted = serverTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "Client.CalculateModelCapacity":
				res.resp, res.err = s.dispatchCalculateModelCapacity(req)
			case "Client.CheckDomainAvailability":
				res.resp, res.err = s.dispatchCheckDomainAvailability(req)
			case "Client.CheckSKUAvailability":
				res.resp, res.err = s.dispatchCheckSKUAvailability(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *ServerTransport) dispatchCalculateModelCapacity(req *http.Request) (*http.Response, error) {
	if s.srv.CalculateModelCapacity == nil {
		return nil, &nonRetriableError{errors.New("fake for method CalculateModelCapacity not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.CognitiveServices/calculateModelCapacity`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armcognitiveservices.CalculateModelCapacityParameter](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.CalculateModelCapacity(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CalculateModelCapacityResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchCheckDomainAvailability(req *http.Request) (*http.Response, error) {
	if s.srv.CheckDomainAvailability == nil {
		return nil, &nonRetriableError{errors.New("fake for method CheckDomainAvailability not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.CognitiveServices/checkDomainAvailability`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armcognitiveservices.CheckDomainAvailabilityParameter](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.CheckDomainAvailability(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainAvailability, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchCheckSKUAvailability(req *http.Request) (*http.Response, error) {
	if s.srv.CheckSKUAvailability == nil {
		return nil, &nonRetriableError{errors.New("fake for method CheckSKUAvailability not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.CognitiveServices/locations/(?P<location>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/checkSkuAvailability`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armcognitiveservices.CheckSKUAvailabilityParameter](req)
	if err != nil {
		return nil, err
	}
	locationParam, err := url.PathUnescape(matches[regex.SubexpIndex("location")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.CheckSKUAvailability(req.Context(), locationParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SKUAvailabilityListResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to ServerTransport
var serverTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
