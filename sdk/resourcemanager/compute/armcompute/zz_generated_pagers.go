//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// AvailabilitySetsListBySubscriptionPager provides operations for iterating over paged responses.
type AvailabilitySetsListBySubscriptionPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailabilitySetsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailabilitySetsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailabilitySetsListBySubscriptionResponse page.
func (p *AvailabilitySetsListBySubscriptionPager) PageResponse() AvailabilitySetsListBySubscriptionResponse {
	return p.current
}

// AvailabilitySetsListPager provides operations for iterating over paged responses.
type AvailabilitySetsListPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailabilitySetsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailabilitySetsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailabilitySetsListResponse page.
func (p *AvailabilitySetsListPager) PageResponse() AvailabilitySetsListResponse {
	return p.current
}

// CapacityReservationGroupsListByResourceGroupPager provides operations for iterating over paged responses.
type CapacityReservationGroupsListByResourceGroupPager struct {
	client    *CapacityReservationGroupsClient
	current   CapacityReservationGroupsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CapacityReservationGroupsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CapacityReservationGroupsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CapacityReservationGroupsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CapacityReservationGroupListResult.NextLink == nil || len(*p.current.CapacityReservationGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CapacityReservationGroupsListByResourceGroupResponse page.
func (p *CapacityReservationGroupsListByResourceGroupPager) PageResponse() CapacityReservationGroupsListByResourceGroupResponse {
	return p.current
}

// CapacityReservationGroupsListBySubscriptionPager provides operations for iterating over paged responses.
type CapacityReservationGroupsListBySubscriptionPager struct {
	client    *CapacityReservationGroupsClient
	current   CapacityReservationGroupsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CapacityReservationGroupsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CapacityReservationGroupsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CapacityReservationGroupsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CapacityReservationGroupListResult.NextLink == nil || len(*p.current.CapacityReservationGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CapacityReservationGroupsListBySubscriptionResponse page.
func (p *CapacityReservationGroupsListBySubscriptionPager) PageResponse() CapacityReservationGroupsListBySubscriptionResponse {
	return p.current
}

// CapacityReservationsListByCapacityReservationGroupPager provides operations for iterating over paged responses.
type CapacityReservationsListByCapacityReservationGroupPager struct {
	client    *CapacityReservationsClient
	current   CapacityReservationsListByCapacityReservationGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CapacityReservationsListByCapacityReservationGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CapacityReservationsListByCapacityReservationGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CapacityReservationsListByCapacityReservationGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CapacityReservationListResult.NextLink == nil || len(*p.current.CapacityReservationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByCapacityReservationGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByCapacityReservationGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CapacityReservationsListByCapacityReservationGroupResponse page.
func (p *CapacityReservationsListByCapacityReservationGroupPager) PageResponse() CapacityReservationsListByCapacityReservationGroupResponse {
	return p.current
}

// CloudServiceOperatingSystemsListOSFamiliesPager provides operations for iterating over paged responses.
type CloudServiceOperatingSystemsListOSFamiliesPager struct {
	client    *CloudServiceOperatingSystemsClient
	current   CloudServiceOperatingSystemsListOSFamiliesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceOperatingSystemsListOSFamiliesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServiceOperatingSystemsListOSFamiliesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServiceOperatingSystemsListOSFamiliesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OSFamilyListResult.NextLink == nil || len(*p.current.OSFamilyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listOSFamiliesHandleError(resp)
		return false
	}
	result, err := p.client.listOSFamiliesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServiceOperatingSystemsListOSFamiliesResponse page.
func (p *CloudServiceOperatingSystemsListOSFamiliesPager) PageResponse() CloudServiceOperatingSystemsListOSFamiliesResponse {
	return p.current
}

// CloudServiceOperatingSystemsListOSVersionsPager provides operations for iterating over paged responses.
type CloudServiceOperatingSystemsListOSVersionsPager struct {
	client    *CloudServiceOperatingSystemsClient
	current   CloudServiceOperatingSystemsListOSVersionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceOperatingSystemsListOSVersionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServiceOperatingSystemsListOSVersionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServiceOperatingSystemsListOSVersionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OSVersionListResult.NextLink == nil || len(*p.current.OSVersionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listOSVersionsHandleError(resp)
		return false
	}
	result, err := p.client.listOSVersionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServiceOperatingSystemsListOSVersionsResponse page.
func (p *CloudServiceOperatingSystemsListOSVersionsPager) PageResponse() CloudServiceOperatingSystemsListOSVersionsResponse {
	return p.current
}

// CloudServiceRoleInstancesListPager provides operations for iterating over paged responses.
type CloudServiceRoleInstancesListPager struct {
	client    *CloudServiceRoleInstancesClient
	current   CloudServiceRoleInstancesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceRoleInstancesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServiceRoleInstancesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServiceRoleInstancesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleInstanceListResult.NextLink == nil || len(*p.current.RoleInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServiceRoleInstancesListResponse page.
func (p *CloudServiceRoleInstancesListPager) PageResponse() CloudServiceRoleInstancesListResponse {
	return p.current
}

// CloudServiceRolesListPager provides operations for iterating over paged responses.
type CloudServiceRolesListPager struct {
	client    *CloudServiceRolesClient
	current   CloudServiceRolesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceRolesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServiceRolesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServiceRolesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudServiceRoleListResult.NextLink == nil || len(*p.current.CloudServiceRoleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServiceRolesListResponse page.
func (p *CloudServiceRolesListPager) PageResponse() CloudServiceRolesListResponse {
	return p.current
}

// CloudServicesListAllPager provides operations for iterating over paged responses.
type CloudServicesListAllPager struct {
	client    *CloudServicesClient
	current   CloudServicesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServicesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServicesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServicesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudServiceListResult.NextLink == nil || len(*p.current.CloudServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServicesListAllResponse page.
func (p *CloudServicesListAllPager) PageResponse() CloudServicesListAllResponse {
	return p.current
}

// CloudServicesListPager provides operations for iterating over paged responses.
type CloudServicesListPager struct {
	client    *CloudServicesClient
	current   CloudServicesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServicesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServicesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServicesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudServiceListResult.NextLink == nil || len(*p.current.CloudServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServicesListResponse page.
func (p *CloudServicesListPager) PageResponse() CloudServicesListResponse {
	return p.current
}

// CloudServicesUpdateDomainListUpdateDomainsPager provides operations for iterating over paged responses.
type CloudServicesUpdateDomainListUpdateDomainsPager struct {
	client    *CloudServicesUpdateDomainClient
	current   CloudServicesUpdateDomainListUpdateDomainsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServicesUpdateDomainListUpdateDomainsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CloudServicesUpdateDomainListUpdateDomainsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CloudServicesUpdateDomainListUpdateDomainsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UpdateDomainListResult.NextLink == nil || len(*p.current.UpdateDomainListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listUpdateDomainsHandleError(resp)
		return false
	}
	result, err := p.client.listUpdateDomainsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CloudServicesUpdateDomainListUpdateDomainsResponse page.
func (p *CloudServicesUpdateDomainListUpdateDomainsPager) PageResponse() CloudServicesUpdateDomainListUpdateDomainsResponse {
	return p.current
}

// DedicatedHostGroupsListByResourceGroupPager provides operations for iterating over paged responses.
type DedicatedHostGroupsListByResourceGroupPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DedicatedHostGroupsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DedicatedHostGroupsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DedicatedHostGroupsListByResourceGroupResponse page.
func (p *DedicatedHostGroupsListByResourceGroupPager) PageResponse() DedicatedHostGroupsListByResourceGroupResponse {
	return p.current
}

// DedicatedHostGroupsListBySubscriptionPager provides operations for iterating over paged responses.
type DedicatedHostGroupsListBySubscriptionPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DedicatedHostGroupsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DedicatedHostGroupsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DedicatedHostGroupsListBySubscriptionResponse page.
func (p *DedicatedHostGroupsListBySubscriptionPager) PageResponse() DedicatedHostGroupsListBySubscriptionResponse {
	return p.current
}

// DedicatedHostsListByHostGroupPager provides operations for iterating over paged responses.
type DedicatedHostsListByHostGroupPager struct {
	client    *DedicatedHostsClient
	current   DedicatedHostsListByHostGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostsListByHostGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DedicatedHostsListByHostGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DedicatedHostsListByHostGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostListResult.NextLink == nil || len(*p.current.DedicatedHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHostGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByHostGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DedicatedHostsListByHostGroupResponse page.
func (p *DedicatedHostsListByHostGroupPager) PageResponse() DedicatedHostsListByHostGroupResponse {
	return p.current
}

// DiskAccessesListByResourceGroupPager provides operations for iterating over paged responses.
type DiskAccessesListByResourceGroupPager struct {
	client    *DiskAccessesClient
	current   DiskAccessesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskAccessesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskAccessesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskAccessesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskAccessList.NextLink == nil || len(*p.current.DiskAccessList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskAccessesListByResourceGroupResponse page.
func (p *DiskAccessesListByResourceGroupPager) PageResponse() DiskAccessesListByResourceGroupResponse {
	return p.current
}

// DiskAccessesListPager provides operations for iterating over paged responses.
type DiskAccessesListPager struct {
	client    *DiskAccessesClient
	current   DiskAccessesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskAccessesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskAccessesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskAccessesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskAccessList.NextLink == nil || len(*p.current.DiskAccessList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskAccessesListResponse page.
func (p *DiskAccessesListPager) PageResponse() DiskAccessesListResponse {
	return p.current
}

// DiskAccessesListPrivateEndpointConnectionsPager provides operations for iterating over paged responses.
type DiskAccessesListPrivateEndpointConnectionsPager struct {
	client    *DiskAccessesClient
	current   DiskAccessesListPrivateEndpointConnectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskAccessesListPrivateEndpointConnectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskAccessesListPrivateEndpointConnectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskAccessesListPrivateEndpointConnectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listPrivateEndpointConnectionsHandleError(resp)
		return false
	}
	result, err := p.client.listPrivateEndpointConnectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskAccessesListPrivateEndpointConnectionsResponse page.
func (p *DiskAccessesListPrivateEndpointConnectionsPager) PageResponse() DiskAccessesListPrivateEndpointConnectionsResponse {
	return p.current
}

// DiskEncryptionSetsListAssociatedResourcesPager provides operations for iterating over paged responses.
type DiskEncryptionSetsListAssociatedResourcesPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsListAssociatedResourcesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsListAssociatedResourcesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskEncryptionSetsListAssociatedResourcesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskEncryptionSetsListAssociatedResourcesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceURIList.NextLink == nil || len(*p.current.ResourceURIList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAssociatedResourcesHandleError(resp)
		return false
	}
	result, err := p.client.listAssociatedResourcesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskEncryptionSetsListAssociatedResourcesResponse page.
func (p *DiskEncryptionSetsListAssociatedResourcesPager) PageResponse() DiskEncryptionSetsListAssociatedResourcesResponse {
	return p.current
}

// DiskEncryptionSetsListByResourceGroupPager provides operations for iterating over paged responses.
type DiskEncryptionSetsListByResourceGroupPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskEncryptionSetsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskEncryptionSetsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskEncryptionSetsListByResourceGroupResponse page.
func (p *DiskEncryptionSetsListByResourceGroupPager) PageResponse() DiskEncryptionSetsListByResourceGroupResponse {
	return p.current
}

// DiskEncryptionSetsListPager provides operations for iterating over paged responses.
type DiskEncryptionSetsListPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskEncryptionSetsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskEncryptionSetsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskEncryptionSetsListResponse page.
func (p *DiskEncryptionSetsListPager) PageResponse() DiskEncryptionSetsListResponse {
	return p.current
}

// DiskRestorePointListByRestorePointPager provides operations for iterating over paged responses.
type DiskRestorePointListByRestorePointPager struct {
	client    *DiskRestorePointClient
	current   DiskRestorePointListByRestorePointResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskRestorePointListByRestorePointResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskRestorePointListByRestorePointPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskRestorePointListByRestorePointPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskRestorePointList.NextLink == nil || len(*p.current.DiskRestorePointList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRestorePointHandleError(resp)
		return false
	}
	result, err := p.client.listByRestorePointHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskRestorePointListByRestorePointResponse page.
func (p *DiskRestorePointListByRestorePointPager) PageResponse() DiskRestorePointListByRestorePointResponse {
	return p.current
}

// DisksListByResourceGroupPager provides operations for iterating over paged responses.
type DisksListByResourceGroupPager struct {
	client    *DisksClient
	current   DisksListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DisksListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DisksListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DisksListByResourceGroupResponse page.
func (p *DisksListByResourceGroupPager) PageResponse() DisksListByResourceGroupResponse {
	return p.current
}

// DisksListPager provides operations for iterating over paged responses.
type DisksListPager struct {
	client    *DisksClient
	current   DisksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DisksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DisksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DisksListResponse page.
func (p *DisksListPager) PageResponse() DisksListResponse {
	return p.current
}

// GalleriesListByResourceGroupPager provides operations for iterating over paged responses.
type GalleriesListByResourceGroupPager struct {
	client    *GalleriesClient
	current   GalleriesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleriesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleriesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleriesListByResourceGroupResponse page.
func (p *GalleriesListByResourceGroupPager) PageResponse() GalleriesListByResourceGroupResponse {
	return p.current
}

// GalleriesListPager provides operations for iterating over paged responses.
type GalleriesListPager struct {
	client    *GalleriesClient
	current   GalleriesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleriesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleriesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleriesListResponse page.
func (p *GalleriesListPager) PageResponse() GalleriesListResponse {
	return p.current
}

// GalleryApplicationVersionsListByGalleryApplicationPager provides operations for iterating over paged responses.
type GalleryApplicationVersionsListByGalleryApplicationPager struct {
	client    *GalleryApplicationVersionsClient
	current   GalleryApplicationVersionsListByGalleryApplicationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationVersionsListByGalleryApplicationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryApplicationVersionsListByGalleryApplicationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryApplicationVersionsListByGalleryApplicationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationVersionList.NextLink == nil || len(*p.current.GalleryApplicationVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryApplicationHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryApplicationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryApplicationVersionsListByGalleryApplicationResponse page.
func (p *GalleryApplicationVersionsListByGalleryApplicationPager) PageResponse() GalleryApplicationVersionsListByGalleryApplicationResponse {
	return p.current
}

// GalleryApplicationsListByGalleryPager provides operations for iterating over paged responses.
type GalleryApplicationsListByGalleryPager struct {
	client    *GalleryApplicationsClient
	current   GalleryApplicationsListByGalleryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationsListByGalleryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryApplicationsListByGalleryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryApplicationsListByGalleryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationList.NextLink == nil || len(*p.current.GalleryApplicationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryApplicationsListByGalleryResponse page.
func (p *GalleryApplicationsListByGalleryPager) PageResponse() GalleryApplicationsListByGalleryResponse {
	return p.current
}

// GalleryImageVersionsListByGalleryImagePager provides operations for iterating over paged responses.
type GalleryImageVersionsListByGalleryImagePager struct {
	client    *GalleryImageVersionsClient
	current   GalleryImageVersionsListByGalleryImageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImageVersionsListByGalleryImageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryImageVersionsListByGalleryImagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryImageVersionsListByGalleryImagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageVersionList.NextLink == nil || len(*p.current.GalleryImageVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryImageHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryImageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryImageVersionsListByGalleryImageResponse page.
func (p *GalleryImageVersionsListByGalleryImagePager) PageResponse() GalleryImageVersionsListByGalleryImageResponse {
	return p.current
}

// GalleryImagesListByGalleryPager provides operations for iterating over paged responses.
type GalleryImagesListByGalleryPager struct {
	client    *GalleryImagesClient
	current   GalleryImagesListByGalleryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImagesListByGalleryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryImagesListByGalleryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryImagesListByGalleryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryImagesListByGalleryResponse page.
func (p *GalleryImagesListByGalleryPager) PageResponse() GalleryImagesListByGalleryResponse {
	return p.current
}

// ImagesListByResourceGroupPager provides operations for iterating over paged responses.
type ImagesListByResourceGroupPager struct {
	client    *ImagesClient
	current   ImagesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ImagesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ImagesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ImagesListByResourceGroupResponse page.
func (p *ImagesListByResourceGroupPager) PageResponse() ImagesListByResourceGroupResponse {
	return p.current
}

// ImagesListPager provides operations for iterating over paged responses.
type ImagesListPager struct {
	client    *ImagesClient
	current   ImagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ImagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ImagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ImagesListResponse page.
func (p *ImagesListPager) PageResponse() ImagesListResponse {
	return p.current
}

// ProximityPlacementGroupsListByResourceGroupPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsListByResourceGroupPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProximityPlacementGroupsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProximityPlacementGroupsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProximityPlacementGroupsListByResourceGroupResponse page.
func (p *ProximityPlacementGroupsListByResourceGroupPager) PageResponse() ProximityPlacementGroupsListByResourceGroupResponse {
	return p.current
}

// ProximityPlacementGroupsListBySubscriptionPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsListBySubscriptionPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProximityPlacementGroupsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProximityPlacementGroupsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProximityPlacementGroupsListBySubscriptionResponse page.
func (p *ProximityPlacementGroupsListBySubscriptionPager) PageResponse() ProximityPlacementGroupsListBySubscriptionResponse {
	return p.current
}

// ResourceSKUsListPager provides operations for iterating over paged responses.
type ResourceSKUsListPager struct {
	client    *ResourceSKUsClient
	current   ResourceSKUsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceSKUsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceSKUsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceSKUsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUsResult.NextLink == nil || len(*p.current.ResourceSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceSKUsListResponse page.
func (p *ResourceSKUsListPager) PageResponse() ResourceSKUsListResponse {
	return p.current
}

// RestorePointCollectionsListAllPager provides operations for iterating over paged responses.
type RestorePointCollectionsListAllPager struct {
	client    *RestorePointCollectionsClient
	current   RestorePointCollectionsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorePointCollectionsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorePointCollectionsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorePointCollectionsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointCollectionListResult.NextLink == nil || len(*p.current.RestorePointCollectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorePointCollectionsListAllResponse page.
func (p *RestorePointCollectionsListAllPager) PageResponse() RestorePointCollectionsListAllResponse {
	return p.current
}

// RestorePointCollectionsListPager provides operations for iterating over paged responses.
type RestorePointCollectionsListPager struct {
	client    *RestorePointCollectionsClient
	current   RestorePointCollectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorePointCollectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorePointCollectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorePointCollectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointCollectionListResult.NextLink == nil || len(*p.current.RestorePointCollectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorePointCollectionsListResponse page.
func (p *RestorePointCollectionsListPager) PageResponse() RestorePointCollectionsListResponse {
	return p.current
}

// SSHPublicKeysListByResourceGroupPager provides operations for iterating over paged responses.
type SSHPublicKeysListByResourceGroupPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SSHPublicKeysListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SSHPublicKeysListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SSHPublicKeysListByResourceGroupResponse page.
func (p *SSHPublicKeysListByResourceGroupPager) PageResponse() SSHPublicKeysListByResourceGroupResponse {
	return p.current
}

// SSHPublicKeysListBySubscriptionPager provides operations for iterating over paged responses.
type SSHPublicKeysListBySubscriptionPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SSHPublicKeysListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SSHPublicKeysListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SSHPublicKeysListBySubscriptionResponse page.
func (p *SSHPublicKeysListBySubscriptionPager) PageResponse() SSHPublicKeysListBySubscriptionResponse {
	return p.current
}

// SharedGalleriesListPager provides operations for iterating over paged responses.
type SharedGalleriesListPager struct {
	client    *SharedGalleriesClient
	current   SharedGalleriesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharedGalleriesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharedGalleriesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharedGalleriesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SharedGalleryList.NextLink == nil || len(*p.current.SharedGalleryList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharedGalleriesListResponse page.
func (p *SharedGalleriesListPager) PageResponse() SharedGalleriesListResponse {
	return p.current
}

// SharedGalleryImageVersionsListPager provides operations for iterating over paged responses.
type SharedGalleryImageVersionsListPager struct {
	client    *SharedGalleryImageVersionsClient
	current   SharedGalleryImageVersionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharedGalleryImageVersionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharedGalleryImageVersionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharedGalleryImageVersionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SharedGalleryImageVersionList.NextLink == nil || len(*p.current.SharedGalleryImageVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharedGalleryImageVersionsListResponse page.
func (p *SharedGalleryImageVersionsListPager) PageResponse() SharedGalleryImageVersionsListResponse {
	return p.current
}

// SharedGalleryImagesListPager provides operations for iterating over paged responses.
type SharedGalleryImagesListPager struct {
	client    *SharedGalleryImagesClient
	current   SharedGalleryImagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharedGalleryImagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharedGalleryImagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharedGalleryImagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SharedGalleryImageList.NextLink == nil || len(*p.current.SharedGalleryImageList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharedGalleryImagesListResponse page.
func (p *SharedGalleryImagesListPager) PageResponse() SharedGalleryImagesListResponse {
	return p.current
}

// SnapshotsListByResourceGroupPager provides operations for iterating over paged responses.
type SnapshotsListByResourceGroupPager struct {
	client    *SnapshotsClient
	current   SnapshotsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SnapshotsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SnapshotsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SnapshotsListByResourceGroupResponse page.
func (p *SnapshotsListByResourceGroupPager) PageResponse() SnapshotsListByResourceGroupResponse {
	return p.current
}

// SnapshotsListPager provides operations for iterating over paged responses.
type SnapshotsListPager struct {
	client    *SnapshotsClient
	current   SnapshotsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SnapshotsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SnapshotsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SnapshotsListResponse page.
func (p *SnapshotsListPager) PageResponse() SnapshotsListResponse {
	return p.current
}

// UsageListPager provides operations for iterating over paged responses.
type UsageListPager struct {
	client    *UsageClient
	current   UsageListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsageListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsageListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsageListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListUsagesResult.NextLink == nil || len(*p.current.ListUsagesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsageListResponse page.
func (p *UsageListPager) PageResponse() UsageListResponse {
	return p.current
}

// VirtualMachineRunCommandsListByVirtualMachinePager provides operations for iterating over paged responses.
type VirtualMachineRunCommandsListByVirtualMachinePager struct {
	client    *VirtualMachineRunCommandsClient
	current   VirtualMachineRunCommandsListByVirtualMachineResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineRunCommandsListByVirtualMachineResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineRunCommandsListByVirtualMachinePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineRunCommandsListByVirtualMachinePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineRunCommandsListResult.NextLink == nil || len(*p.current.VirtualMachineRunCommandsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVirtualMachineHandleError(resp)
		return false
	}
	result, err := p.client.listByVirtualMachineHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineRunCommandsListByVirtualMachineResponse page.
func (p *VirtualMachineRunCommandsListByVirtualMachinePager) PageResponse() VirtualMachineRunCommandsListByVirtualMachineResponse {
	return p.current
}

// VirtualMachineRunCommandsListPager provides operations for iterating over paged responses.
type VirtualMachineRunCommandsListPager struct {
	client    *VirtualMachineRunCommandsClient
	current   VirtualMachineRunCommandsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineRunCommandsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineRunCommandsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineRunCommandsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunCommandListResult.NextLink == nil || len(*p.current.RunCommandListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineRunCommandsListResponse page.
func (p *VirtualMachineRunCommandsListPager) PageResponse() VirtualMachineRunCommandsListResponse {
	return p.current
}

// VirtualMachineScaleSetExtensionsListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetExtensionsListPager struct {
	client    *VirtualMachineScaleSetExtensionsClient
	current   VirtualMachineScaleSetExtensionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetExtensionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetExtensionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetExtensionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetExtensionListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetExtensionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetExtensionsListResponse page.
func (p *VirtualMachineScaleSetExtensionsListPager) PageResponse() VirtualMachineScaleSetExtensionsListResponse {
	return p.current
}

// VirtualMachineScaleSetVMRunCommandsListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetVMRunCommandsListPager struct {
	client    *VirtualMachineScaleSetVMRunCommandsClient
	current   VirtualMachineScaleSetVMRunCommandsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetVMRunCommandsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetVMRunCommandsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetVMRunCommandsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineRunCommandsListResult.NextLink == nil || len(*p.current.VirtualMachineRunCommandsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetVMRunCommandsListResponse page.
func (p *VirtualMachineScaleSetVMRunCommandsListPager) PageResponse() VirtualMachineScaleSetVMRunCommandsListResponse {
	return p.current
}

// VirtualMachineScaleSetVMsListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetVMsListPager struct {
	client    *VirtualMachineScaleSetVMsClient
	current   VirtualMachineScaleSetVMsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetVMsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetVMsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetVMsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetVMListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetVMListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetVMsListResponse page.
func (p *VirtualMachineScaleSetVMsListPager) PageResponse() VirtualMachineScaleSetVMsListResponse {
	return p.current
}

// VirtualMachineScaleSetsGetOSUpgradeHistoryPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsGetOSUpgradeHistoryPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsGetOSUpgradeHistoryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsGetOSUpgradeHistoryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsGetOSUpgradeHistoryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsGetOSUpgradeHistoryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink == nil || len(*p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.getOSUpgradeHistoryHandleError(resp)
		return false
	}
	result, err := p.client.getOSUpgradeHistoryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsGetOSUpgradeHistoryResponse page.
func (p *VirtualMachineScaleSetsGetOSUpgradeHistoryPager) PageResponse() VirtualMachineScaleSetsGetOSUpgradeHistoryResponse {
	return p.current
}

// VirtualMachineScaleSetsListAllPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsListAllPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListWithLinkResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListWithLinkResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsListAllResponse page.
func (p *VirtualMachineScaleSetsListAllPager) PageResponse() VirtualMachineScaleSetsListAllResponse {
	return p.current
}

// VirtualMachineScaleSetsListByLocationPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsListByLocationPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsListByLocationResponse page.
func (p *VirtualMachineScaleSetsListByLocationPager) PageResponse() VirtualMachineScaleSetsListByLocationResponse {
	return p.current
}

// VirtualMachineScaleSetsListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsListPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsListResponse page.
func (p *VirtualMachineScaleSetsListPager) PageResponse() VirtualMachineScaleSetsListResponse {
	return p.current
}

// VirtualMachineScaleSetsListSKUsPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsListSKUsPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsListSKUsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsListSKUsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsListSKUsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsListSKUsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListSKUsResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listSKUsHandleError(resp)
		return false
	}
	result, err := p.client.listSKUsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsListSKUsResponse page.
func (p *VirtualMachineScaleSetsListSKUsPager) PageResponse() VirtualMachineScaleSetsListSKUsResponse {
	return p.current
}

// VirtualMachinesListAllPager provides operations for iterating over paged responses.
type VirtualMachinesListAllPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesListAllResponse page.
func (p *VirtualMachinesListAllPager) PageResponse() VirtualMachinesListAllResponse {
	return p.current
}

// VirtualMachinesListByLocationPager provides operations for iterating over paged responses.
type VirtualMachinesListByLocationPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesListByLocationResponse page.
func (p *VirtualMachinesListByLocationPager) PageResponse() VirtualMachinesListByLocationResponse {
	return p.current
}

// VirtualMachinesListPager provides operations for iterating over paged responses.
type VirtualMachinesListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesListResponse page.
func (p *VirtualMachinesListPager) PageResponse() VirtualMachinesListResponse {
	return p.current
}
