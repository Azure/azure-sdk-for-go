// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armconnectedcache

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime/datetime"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type AdditionalCacheNodeProperties.
func (a AdditionalCacheNodeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aggregatedStatusCode", a.AggregatedStatusCode)
	populate(objectMap, "aggregatedStatusDetails", a.AggregatedStatusDetails)
	populate(objectMap, "aggregatedStatusText", a.AggregatedStatusText)
	populate(objectMap, "autoUpdateAppliedVersion", a.AutoUpdateAppliedVersion)
	populateTime[datetime.RFC3339](objectMap, "autoUpdateLastAppliedDateTime", a.AutoUpdateLastAppliedDateTime)
	populate(objectMap, "autoUpdateLastAppliedDetails", a.AutoUpdateLastAppliedDetails)
	populate(objectMap, "autoUpdateLastAppliedState", a.AutoUpdateLastAppliedState)
	populateTime[datetime.RFC3339](objectMap, "autoUpdateLastTriggeredDateTime", a.AutoUpdateLastTriggeredDateTime)
	populateTime[datetime.RFC3339](objectMap, "autoUpdateNextAvailableDateTime", a.AutoUpdateNextAvailableDateTime)
	populate(objectMap, "autoUpdateNextAvailableVersion", a.AutoUpdateNextAvailableVersion)
	populate(objectMap, "autoUpdateVersion", a.AutoUpdateVersion)
	populate(objectMap, "bgpConfiguration", a.BgpConfiguration)
	populate(objectMap, "cacheNodePropertiesDetailsIssuesList", a.CacheNodePropertiesDetailsIssuesList)
	populate(objectMap, "cacheNodeState", a.CacheNodeState)
	populate(objectMap, "cacheNodeStateDetailedText", a.CacheNodeStateDetailedText)
	populate(objectMap, "cacheNodeStateShortText", a.CacheNodeStateShortText)
	populate(objectMap, "creationMethod", a.CreationMethod)
	populate(objectMap, "currentTlsCertificate", a.CurrentTLSCertificate)
	populate(objectMap, "driveConfiguration", a.DriveConfiguration)
	populate(objectMap, "isProvisioned", a.IsProvisioned)
	populate(objectMap, "isProxyRequired", a.IsProxyRequired)
	populate(objectMap, "issuesCount", a.IssuesCount)
	populate(objectMap, "issuesList", a.IssuesList)
	populate(objectMap, "lastAutoUpdateInfo", a.LastAutoUpdateInfo)
	populate(objectMap, "osType", a.OSType)
	populate(objectMap, "optionalProperty1", a.OptionalProperty1)
	populate(objectMap, "optionalProperty2", a.OptionalProperty2)
	populate(objectMap, "optionalProperty3", a.OptionalProperty3)
	populate(objectMap, "optionalProperty4", a.OptionalProperty4)
	populate(objectMap, "optionalProperty5", a.OptionalProperty5)
	populate(objectMap, "productVersion", a.ProductVersion)
	populate(objectMap, "proxyUrlConfiguration", a.ProxyURLConfiguration)
	populate(objectMap, "tlsStatus", a.TLSStatus)
	populate(objectMap, "updateInfoDetails", a.UpdateInfoDetails)
	populateTime[datetime.RFC3339](objectMap, "updateRequestedDateTime", a.UpdateRequestedDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdditionalCacheNodeProperties.
func (a *AdditionalCacheNodeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregatedStatusCode":
			err = unpopulate(val, "AggregatedStatusCode", &a.AggregatedStatusCode)
			delete(rawMsg, key)
		case "aggregatedStatusDetails":
			err = unpopulate(val, "AggregatedStatusDetails", &a.AggregatedStatusDetails)
			delete(rawMsg, key)
		case "aggregatedStatusText":
			err = unpopulate(val, "AggregatedStatusText", &a.AggregatedStatusText)
			delete(rawMsg, key)
		case "autoUpdateAppliedVersion":
			err = unpopulate(val, "AutoUpdateAppliedVersion", &a.AutoUpdateAppliedVersion)
			delete(rawMsg, key)
		case "autoUpdateLastAppliedDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "AutoUpdateLastAppliedDateTime", &a.AutoUpdateLastAppliedDateTime)
			delete(rawMsg, key)
		case "autoUpdateLastAppliedDetails":
			err = unpopulate(val, "AutoUpdateLastAppliedDetails", &a.AutoUpdateLastAppliedDetails)
			delete(rawMsg, key)
		case "autoUpdateLastAppliedState":
			err = unpopulate(val, "AutoUpdateLastAppliedState", &a.AutoUpdateLastAppliedState)
			delete(rawMsg, key)
		case "autoUpdateLastTriggeredDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "AutoUpdateLastTriggeredDateTime", &a.AutoUpdateLastTriggeredDateTime)
			delete(rawMsg, key)
		case "autoUpdateNextAvailableDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "AutoUpdateNextAvailableDateTime", &a.AutoUpdateNextAvailableDateTime)
			delete(rawMsg, key)
		case "autoUpdateNextAvailableVersion":
			err = unpopulate(val, "AutoUpdateNextAvailableVersion", &a.AutoUpdateNextAvailableVersion)
			delete(rawMsg, key)
		case "autoUpdateVersion":
			err = unpopulate(val, "AutoUpdateVersion", &a.AutoUpdateVersion)
			delete(rawMsg, key)
		case "bgpConfiguration":
			err = unpopulate(val, "BgpConfiguration", &a.BgpConfiguration)
			delete(rawMsg, key)
		case "cacheNodePropertiesDetailsIssuesList":
			err = unpopulate(val, "CacheNodePropertiesDetailsIssuesList", &a.CacheNodePropertiesDetailsIssuesList)
			delete(rawMsg, key)
		case "cacheNodeState":
			err = unpopulate(val, "CacheNodeState", &a.CacheNodeState)
			delete(rawMsg, key)
		case "cacheNodeStateDetailedText":
			err = unpopulate(val, "CacheNodeStateDetailedText", &a.CacheNodeStateDetailedText)
			delete(rawMsg, key)
		case "cacheNodeStateShortText":
			err = unpopulate(val, "CacheNodeStateShortText", &a.CacheNodeStateShortText)
			delete(rawMsg, key)
		case "creationMethod":
			err = unpopulate(val, "CreationMethod", &a.CreationMethod)
			delete(rawMsg, key)
		case "currentTlsCertificate":
			err = unpopulate(val, "CurrentTLSCertificate", &a.CurrentTLSCertificate)
			delete(rawMsg, key)
		case "driveConfiguration":
			err = unpopulate(val, "DriveConfiguration", &a.DriveConfiguration)
			delete(rawMsg, key)
		case "isProvisioned":
			err = unpopulate(val, "IsProvisioned", &a.IsProvisioned)
			delete(rawMsg, key)
		case "isProxyRequired":
			err = unpopulate(val, "IsProxyRequired", &a.IsProxyRequired)
			delete(rawMsg, key)
		case "issuesCount":
			err = unpopulate(val, "IssuesCount", &a.IssuesCount)
			delete(rawMsg, key)
		case "issuesList":
			err = unpopulate(val, "IssuesList", &a.IssuesList)
			delete(rawMsg, key)
		case "lastAutoUpdateInfo":
			err = unpopulate(val, "LastAutoUpdateInfo", &a.LastAutoUpdateInfo)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &a.OSType)
			delete(rawMsg, key)
		case "optionalProperty1":
			err = unpopulate(val, "OptionalProperty1", &a.OptionalProperty1)
			delete(rawMsg, key)
		case "optionalProperty2":
			err = unpopulate(val, "OptionalProperty2", &a.OptionalProperty2)
			delete(rawMsg, key)
		case "optionalProperty3":
			err = unpopulate(val, "OptionalProperty3", &a.OptionalProperty3)
			delete(rawMsg, key)
		case "optionalProperty4":
			err = unpopulate(val, "OptionalProperty4", &a.OptionalProperty4)
			delete(rawMsg, key)
		case "optionalProperty5":
			err = unpopulate(val, "OptionalProperty5", &a.OptionalProperty5)
			delete(rawMsg, key)
		case "productVersion":
			err = unpopulate(val, "ProductVersion", &a.ProductVersion)
			delete(rawMsg, key)
		case "proxyUrlConfiguration":
			err = unpopulate(val, "ProxyURLConfiguration", &a.ProxyURLConfiguration)
			delete(rawMsg, key)
		case "tlsStatus":
			err = unpopulate(val, "TLSStatus", &a.TLSStatus)
			delete(rawMsg, key)
		case "updateInfoDetails":
			err = unpopulate(val, "UpdateInfoDetails", &a.UpdateInfoDetails)
			delete(rawMsg, key)
		case "updateRequestedDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "UpdateRequestedDateTime", &a.UpdateRequestedDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdditionalCustomerProperties.
func (a AdditionalCustomerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customerAsn", a.CustomerAsn)
	populate(objectMap, "customerAsnEstimatedEgressPeekGbps", a.CustomerAsnEstimatedEgressPeekGbps)
	populate(objectMap, "customerEmail", a.CustomerEmail)
	populateTime[datetime.RFC3339](objectMap, "customerEntitlementExpiration", a.CustomerEntitlementExpiration)
	populate(objectMap, "customerEntitlementSkuGuid", a.CustomerEntitlementSKUGUID)
	populate(objectMap, "customerEntitlementSkuId", a.CustomerEntitlementSKUID)
	populate(objectMap, "customerEntitlementSkuName", a.CustomerEntitlementSKUName)
	populate(objectMap, "customerOrgName", a.CustomerOrgName)
	populate(objectMap, "customerPropertiesOverviewAverageEgressMbps", a.CustomerPropertiesOverviewAverageEgressMbps)
	populate(objectMap, "customerPropertiesOverviewAverageMissMbps", a.CustomerPropertiesOverviewAverageMissMbps)
	populate(objectMap, "customerPropertiesOverviewCacheEfficiency", a.CustomerPropertiesOverviewCacheEfficiency)
	populate(objectMap, "customerPropertiesOverviewCacheNodesHealthyCount", a.CustomerPropertiesOverviewCacheNodesHealthyCount)
	populate(objectMap, "customerPropertiesOverviewCacheNodesUnhealthyCount", a.CustomerPropertiesOverviewCacheNodesUnhealthyCount)
	populate(objectMap, "customerPropertiesOverviewEgressMbpsMax", a.CustomerPropertiesOverviewEgressMbpsMax)
	populateTime[datetime.RFC3339](objectMap, "customerPropertiesOverviewEgressMbpsMaxDateTime", a.CustomerPropertiesOverviewEgressMbpsMaxDateTime)
	populate(objectMap, "customerPropertiesOverviewMissMbpsMax", a.CustomerPropertiesOverviewMissMbpsMax)
	populateTime[datetime.RFC3339](objectMap, "customerPropertiesOverviewMissMbpsMaxDateTime", a.CustomerPropertiesOverviewMissMbpsMaxDateTime)
	populate(objectMap, "customerTransitAsn", a.CustomerTransitAsn)
	populate(objectMap, "customerTransitState", a.CustomerTransitState)
	populate(objectMap, "optionalProperty1", a.OptionalProperty1)
	populate(objectMap, "optionalProperty2", a.OptionalProperty2)
	populate(objectMap, "optionalProperty3", a.OptionalProperty3)
	populate(objectMap, "optionalProperty4", a.OptionalProperty4)
	populate(objectMap, "optionalProperty5", a.OptionalProperty5)
	populateTime[datetime.RFC3339](objectMap, "peeringDbLastUpdateDate", a.PeeringDbLastUpdateDate)
	populate(objectMap, "signupPhaseStatusCode", a.SignupPhaseStatusCode)
	populate(objectMap, "signupPhaseStatusText", a.SignupPhaseStatusText)
	populate(objectMap, "signupStatus", a.SignupStatus)
	populate(objectMap, "signupStatusCode", a.SignupStatusCode)
	populate(objectMap, "signupStatusText", a.SignupStatusText)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdditionalCustomerProperties.
func (a *AdditionalCustomerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customerAsn":
			err = unpopulate(val, "CustomerAsn", &a.CustomerAsn)
			delete(rawMsg, key)
		case "customerAsnEstimatedEgressPeekGbps":
			err = unpopulate(val, "CustomerAsnEstimatedEgressPeekGbps", &a.CustomerAsnEstimatedEgressPeekGbps)
			delete(rawMsg, key)
		case "customerEmail":
			err = unpopulate(val, "CustomerEmail", &a.CustomerEmail)
			delete(rawMsg, key)
		case "customerEntitlementExpiration":
			err = unpopulateTime[datetime.RFC3339](val, "CustomerEntitlementExpiration", &a.CustomerEntitlementExpiration)
			delete(rawMsg, key)
		case "customerEntitlementSkuGuid":
			err = unpopulate(val, "CustomerEntitlementSKUGUID", &a.CustomerEntitlementSKUGUID)
			delete(rawMsg, key)
		case "customerEntitlementSkuId":
			err = unpopulate(val, "CustomerEntitlementSKUID", &a.CustomerEntitlementSKUID)
			delete(rawMsg, key)
		case "customerEntitlementSkuName":
			err = unpopulate(val, "CustomerEntitlementSKUName", &a.CustomerEntitlementSKUName)
			delete(rawMsg, key)
		case "customerOrgName":
			err = unpopulate(val, "CustomerOrgName", &a.CustomerOrgName)
			delete(rawMsg, key)
		case "customerPropertiesOverviewAverageEgressMbps":
			err = unpopulate(val, "CustomerPropertiesOverviewAverageEgressMbps", &a.CustomerPropertiesOverviewAverageEgressMbps)
			delete(rawMsg, key)
		case "customerPropertiesOverviewAverageMissMbps":
			err = unpopulate(val, "CustomerPropertiesOverviewAverageMissMbps", &a.CustomerPropertiesOverviewAverageMissMbps)
			delete(rawMsg, key)
		case "customerPropertiesOverviewCacheEfficiency":
			err = unpopulate(val, "CustomerPropertiesOverviewCacheEfficiency", &a.CustomerPropertiesOverviewCacheEfficiency)
			delete(rawMsg, key)
		case "customerPropertiesOverviewCacheNodesHealthyCount":
			err = unpopulate(val, "CustomerPropertiesOverviewCacheNodesHealthyCount", &a.CustomerPropertiesOverviewCacheNodesHealthyCount)
			delete(rawMsg, key)
		case "customerPropertiesOverviewCacheNodesUnhealthyCount":
			err = unpopulate(val, "CustomerPropertiesOverviewCacheNodesUnhealthyCount", &a.CustomerPropertiesOverviewCacheNodesUnhealthyCount)
			delete(rawMsg, key)
		case "customerPropertiesOverviewEgressMbpsMax":
			err = unpopulate(val, "CustomerPropertiesOverviewEgressMbpsMax", &a.CustomerPropertiesOverviewEgressMbpsMax)
			delete(rawMsg, key)
		case "customerPropertiesOverviewEgressMbpsMaxDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "CustomerPropertiesOverviewEgressMbpsMaxDateTime", &a.CustomerPropertiesOverviewEgressMbpsMaxDateTime)
			delete(rawMsg, key)
		case "customerPropertiesOverviewMissMbpsMax":
			err = unpopulate(val, "CustomerPropertiesOverviewMissMbpsMax", &a.CustomerPropertiesOverviewMissMbpsMax)
			delete(rawMsg, key)
		case "customerPropertiesOverviewMissMbpsMaxDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "CustomerPropertiesOverviewMissMbpsMaxDateTime", &a.CustomerPropertiesOverviewMissMbpsMaxDateTime)
			delete(rawMsg, key)
		case "customerTransitAsn":
			err = unpopulate(val, "CustomerTransitAsn", &a.CustomerTransitAsn)
			delete(rawMsg, key)
		case "customerTransitState":
			err = unpopulate(val, "CustomerTransitState", &a.CustomerTransitState)
			delete(rawMsg, key)
		case "optionalProperty1":
			err = unpopulate(val, "OptionalProperty1", &a.OptionalProperty1)
			delete(rawMsg, key)
		case "optionalProperty2":
			err = unpopulate(val, "OptionalProperty2", &a.OptionalProperty2)
			delete(rawMsg, key)
		case "optionalProperty3":
			err = unpopulate(val, "OptionalProperty3", &a.OptionalProperty3)
			delete(rawMsg, key)
		case "optionalProperty4":
			err = unpopulate(val, "OptionalProperty4", &a.OptionalProperty4)
			delete(rawMsg, key)
		case "optionalProperty5":
			err = unpopulate(val, "OptionalProperty5", &a.OptionalProperty5)
			delete(rawMsg, key)
		case "peeringDbLastUpdateDate":
			err = unpopulateTime[datetime.RFC3339](val, "PeeringDbLastUpdateDate", &a.PeeringDbLastUpdateDate)
			delete(rawMsg, key)
		case "signupPhaseStatusCode":
			err = unpopulate(val, "SignupPhaseStatusCode", &a.SignupPhaseStatusCode)
			delete(rawMsg, key)
		case "signupPhaseStatusText":
			err = unpopulate(val, "SignupPhaseStatusText", &a.SignupPhaseStatusText)
			delete(rawMsg, key)
		case "signupStatus":
			err = unpopulate(val, "SignupStatus", &a.SignupStatus)
			delete(rawMsg, key)
		case "signupStatusCode":
			err = unpopulate(val, "SignupStatusCode", &a.SignupStatusCode)
			delete(rawMsg, key)
		case "signupStatusText":
			err = unpopulate(val, "SignupStatusText", &a.SignupStatusText)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BgpCidrsConfiguration.
func (b BgpCidrsConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bgpCidrs", b.BgpCidrs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BgpCidrsConfiguration.
func (b *BgpCidrsConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bgpCidrs":
			err = unpopulate(val, "BgpCidrs", &b.BgpCidrs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BgpConfiguration.
func (b BgpConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "asnToIpAddressMapping", b.AsnToIPAddressMapping)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BgpConfiguration.
func (b *BgpConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "asnToIpAddressMapping":
			err = unpopulate(val, "AsnToIPAddressMapping", &b.AsnToIPAddressMapping)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CacheNodeDriveConfiguration.
func (c CacheNodeDriveConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cacheNumber", c.CacheNumber)
	populate(objectMap, "nginxMapping", c.NginxMapping)
	populate(objectMap, "physicalPath", c.PhysicalPath)
	populate(objectMap, "sizeInGb", c.SizeInGb)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CacheNodeDriveConfiguration.
func (c *CacheNodeDriveConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cacheNumber":
			err = unpopulate(val, "CacheNumber", &c.CacheNumber)
			delete(rawMsg, key)
		case "nginxMapping":
			err = unpopulate(val, "NginxMapping", &c.NginxMapping)
			delete(rawMsg, key)
		case "physicalPath":
			err = unpopulate(val, "PhysicalPath", &c.PhysicalPath)
			delete(rawMsg, key)
		case "sizeInGb":
			err = unpopulate(val, "SizeInGb", &c.SizeInGb)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CacheNodeEntity.
func (c CacheNodeEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addressSpace", c.AddressSpace)
	populate(objectMap, "autoUpdateRequestedDay", c.AutoUpdateRequestedDay)
	populate(objectMap, "autoUpdateRequestedTime", c.AutoUpdateRequestedTime)
	populate(objectMap, "autoUpdateRequestedWeek", c.AutoUpdateRequestedWeek)
	populate(objectMap, "autoUpdateRingType", c.AutoUpdateRingType)
	populate(objectMap, "bgpAddressSpace", c.BgpAddressSpace)
	populate(objectMap, "bgpCidrBlocksCount", c.BgpCidrBlocksCount)
	populateTime[datetime.RFC3339](objectMap, "bgpCidrCsvLastUpdateTime", c.BgpCidrCSVLastUpdateTime)
	populate(objectMap, "bgpFileBytesTruncated", c.BgpFileBytesTruncated)
	populateTime[datetime.RFC3339](objectMap, "bgpLastReportedTime", c.BgpLastReportedTime)
	populate(objectMap, "bgpNumberOfRecords", c.BgpNumberOfRecords)
	populate(objectMap, "bgpNumberOfTimesUpdated", c.BgpNumberOfTimesUpdated)
	populate(objectMap, "bgpReviewFeedback", c.BgpReviewFeedback)
	populate(objectMap, "bgpReviewState", c.BgpReviewState)
	populate(objectMap, "bgpReviewStateText", c.BgpReviewStateText)
	populate(objectMap, "cacheNodeId", c.CacheNodeID)
	populate(objectMap, "cacheNodeName", c.CacheNodeName)
	populate(objectMap, "category", c.Category)
	populate(objectMap, "cidrCsv", c.CidrCSV)
	populateTime[datetime.RFC3339](objectMap, "cidrCsvLastUpdateTime", c.CidrCSVLastUpdateTime)
	populate(objectMap, "cidrSelectionType", c.CidrSelectionType)
	populate(objectMap, "clientTenantId", c.ClientTenantID)
	populate(objectMap, "configurationState", c.ConfigurationState)
	populate(objectMap, "configurationStateText", c.ConfigurationStateText)
	populate(objectMap, "containerConfigurations", c.ContainerConfigurations)
	populate(objectMap, "containerResyncTrigger", c.ContainerResyncTrigger)
	populate(objectMap, "createAsyncOperationId", c.CreateAsyncOperationID)
	populate(objectMap, "customerAsn", c.CustomerAsn)
	populate(objectMap, "customerId", c.CustomerID)
	populate(objectMap, "customerIndex", c.CustomerIndex)
	populate(objectMap, "customerName", c.CustomerName)
	populate(objectMap, "deleteAsyncOperationId", c.DeleteAsyncOperationID)
	populate(objectMap, "fullyQualifiedDomainName", c.FullyQualifiedDomainName)
	populate(objectMap, "fullyQualifiedResourceId", c.FullyQualifiedResourceID)
	populate(objectMap, "ipAddress", c.IPAddress)
	populate(objectMap, "imageUri", c.ImageURI)
	populate(objectMap, "isEnabled", c.IsEnabled)
	populate(objectMap, "isEnterpriseManaged", c.IsEnterpriseManaged)
	populate(objectMap, "isFrozen", c.IsFrozen)
	populateTime[datetime.RFC3339](objectMap, "lastSyncWithAzureTimestamp", c.LastSyncWithAzureTimestamp)
	populateTime[datetime.RFC3339](objectMap, "lastUpdatedTimestamp", c.LastUpdatedTimestamp)
	populate(objectMap, "maxAllowableEgressInMbps", c.MaxAllowableEgressInMbps)
	populate(objectMap, "maxAllowableProbability", c.MaxAllowableProbability)
	populate(objectMap, "releaseVersion", c.ReleaseVersion)
	populate(objectMap, "reviewFeedback", c.ReviewFeedback)
	populate(objectMap, "reviewState", c.ReviewState)
	populate(objectMap, "reviewStateText", c.ReviewStateText)
	populate(objectMap, "shouldMigrate", c.ShouldMigrate)
	populate(objectMap, "synchWithAzureAttemptsCount", c.SynchWithAzureAttemptsCount)
	populate(objectMap, "workerConnections", c.WorkerConnections)
	populateTime[datetime.RFC3339](objectMap, "workerConnectionsLastUpdatedDateTime", c.WorkerConnectionsLastUpdatedDateTime)
	populate(objectMap, "xCid", c.XCid)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CacheNodeEntity.
func (c *CacheNodeEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addressSpace":
			err = unpopulate(val, "AddressSpace", &c.AddressSpace)
			delete(rawMsg, key)
		case "autoUpdateRequestedDay":
			err = unpopulate(val, "AutoUpdateRequestedDay", &c.AutoUpdateRequestedDay)
			delete(rawMsg, key)
		case "autoUpdateRequestedTime":
			err = unpopulate(val, "AutoUpdateRequestedTime", &c.AutoUpdateRequestedTime)
			delete(rawMsg, key)
		case "autoUpdateRequestedWeek":
			err = unpopulate(val, "AutoUpdateRequestedWeek", &c.AutoUpdateRequestedWeek)
			delete(rawMsg, key)
		case "autoUpdateRingType":
			err = unpopulate(val, "AutoUpdateRingType", &c.AutoUpdateRingType)
			delete(rawMsg, key)
		case "bgpAddressSpace":
			err = unpopulate(val, "BgpAddressSpace", &c.BgpAddressSpace)
			delete(rawMsg, key)
		case "bgpCidrBlocksCount":
			err = unpopulate(val, "BgpCidrBlocksCount", &c.BgpCidrBlocksCount)
			delete(rawMsg, key)
		case "bgpCidrCsvLastUpdateTime":
			err = unpopulateTime[datetime.RFC3339](val, "BgpCidrCSVLastUpdateTime", &c.BgpCidrCSVLastUpdateTime)
			delete(rawMsg, key)
		case "bgpFileBytesTruncated":
			err = unpopulate(val, "BgpFileBytesTruncated", &c.BgpFileBytesTruncated)
			delete(rawMsg, key)
		case "bgpLastReportedTime":
			err = unpopulateTime[datetime.RFC3339](val, "BgpLastReportedTime", &c.BgpLastReportedTime)
			delete(rawMsg, key)
		case "bgpNumberOfRecords":
			err = unpopulate(val, "BgpNumberOfRecords", &c.BgpNumberOfRecords)
			delete(rawMsg, key)
		case "bgpNumberOfTimesUpdated":
			err = unpopulate(val, "BgpNumberOfTimesUpdated", &c.BgpNumberOfTimesUpdated)
			delete(rawMsg, key)
		case "bgpReviewFeedback":
			err = unpopulate(val, "BgpReviewFeedback", &c.BgpReviewFeedback)
			delete(rawMsg, key)
		case "bgpReviewState":
			err = unpopulate(val, "BgpReviewState", &c.BgpReviewState)
			delete(rawMsg, key)
		case "bgpReviewStateText":
			err = unpopulate(val, "BgpReviewStateText", &c.BgpReviewStateText)
			delete(rawMsg, key)
		case "cacheNodeId":
			err = unpopulate(val, "CacheNodeID", &c.CacheNodeID)
			delete(rawMsg, key)
		case "cacheNodeName":
			err = unpopulate(val, "CacheNodeName", &c.CacheNodeName)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &c.Category)
			delete(rawMsg, key)
		case "cidrCsv":
			err = unpopulate(val, "CidrCSV", &c.CidrCSV)
			delete(rawMsg, key)
		case "cidrCsvLastUpdateTime":
			err = unpopulateTime[datetime.RFC3339](val, "CidrCSVLastUpdateTime", &c.CidrCSVLastUpdateTime)
			delete(rawMsg, key)
		case "cidrSelectionType":
			err = unpopulate(val, "CidrSelectionType", &c.CidrSelectionType)
			delete(rawMsg, key)
		case "clientTenantId":
			err = unpopulate(val, "ClientTenantID", &c.ClientTenantID)
			delete(rawMsg, key)
		case "configurationState":
			err = unpopulate(val, "ConfigurationState", &c.ConfigurationState)
			delete(rawMsg, key)
		case "configurationStateText":
			err = unpopulate(val, "ConfigurationStateText", &c.ConfigurationStateText)
			delete(rawMsg, key)
		case "containerConfigurations":
			err = unpopulate(val, "ContainerConfigurations", &c.ContainerConfigurations)
			delete(rawMsg, key)
		case "containerResyncTrigger":
			err = unpopulate(val, "ContainerResyncTrigger", &c.ContainerResyncTrigger)
			delete(rawMsg, key)
		case "createAsyncOperationId":
			err = unpopulate(val, "CreateAsyncOperationID", &c.CreateAsyncOperationID)
			delete(rawMsg, key)
		case "customerAsn":
			err = unpopulate(val, "CustomerAsn", &c.CustomerAsn)
			delete(rawMsg, key)
		case "customerId":
			err = unpopulate(val, "CustomerID", &c.CustomerID)
			delete(rawMsg, key)
		case "customerIndex":
			err = unpopulate(val, "CustomerIndex", &c.CustomerIndex)
			delete(rawMsg, key)
		case "customerName":
			err = unpopulate(val, "CustomerName", &c.CustomerName)
			delete(rawMsg, key)
		case "deleteAsyncOperationId":
			err = unpopulate(val, "DeleteAsyncOperationID", &c.DeleteAsyncOperationID)
			delete(rawMsg, key)
		case "fullyQualifiedDomainName":
			err = unpopulate(val, "FullyQualifiedDomainName", &c.FullyQualifiedDomainName)
			delete(rawMsg, key)
		case "fullyQualifiedResourceId":
			err = unpopulate(val, "FullyQualifiedResourceID", &c.FullyQualifiedResourceID)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &c.IPAddress)
			delete(rawMsg, key)
		case "imageUri":
			err = unpopulate(val, "ImageURI", &c.ImageURI)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &c.IsEnabled)
			delete(rawMsg, key)
		case "isEnterpriseManaged":
			err = unpopulate(val, "IsEnterpriseManaged", &c.IsEnterpriseManaged)
			delete(rawMsg, key)
		case "isFrozen":
			err = unpopulate(val, "IsFrozen", &c.IsFrozen)
			delete(rawMsg, key)
		case "lastSyncWithAzureTimestamp":
			err = unpopulateTime[datetime.RFC3339](val, "LastSyncWithAzureTimestamp", &c.LastSyncWithAzureTimestamp)
			delete(rawMsg, key)
		case "lastUpdatedTimestamp":
			err = unpopulateTime[datetime.RFC3339](val, "LastUpdatedTimestamp", &c.LastUpdatedTimestamp)
			delete(rawMsg, key)
		case "maxAllowableEgressInMbps":
			err = unpopulate(val, "MaxAllowableEgressInMbps", &c.MaxAllowableEgressInMbps)
			delete(rawMsg, key)
		case "maxAllowableProbability":
			err = unpopulate(val, "MaxAllowableProbability", &c.MaxAllowableProbability)
			delete(rawMsg, key)
		case "releaseVersion":
			err = unpopulate(val, "ReleaseVersion", &c.ReleaseVersion)
			delete(rawMsg, key)
		case "reviewFeedback":
			err = unpopulate(val, "ReviewFeedback", &c.ReviewFeedback)
			delete(rawMsg, key)
		case "reviewState":
			err = unpopulate(val, "ReviewState", &c.ReviewState)
			delete(rawMsg, key)
		case "reviewStateText":
			err = unpopulate(val, "ReviewStateText", &c.ReviewStateText)
			delete(rawMsg, key)
		case "shouldMigrate":
			err = unpopulate(val, "ShouldMigrate", &c.ShouldMigrate)
			delete(rawMsg, key)
		case "synchWithAzureAttemptsCount":
			err = unpopulate(val, "SynchWithAzureAttemptsCount", &c.SynchWithAzureAttemptsCount)
			delete(rawMsg, key)
		case "workerConnections":
			err = unpopulate(val, "WorkerConnections", &c.WorkerConnections)
			delete(rawMsg, key)
		case "workerConnectionsLastUpdatedDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "WorkerConnectionsLastUpdatedDateTime", &c.WorkerConnectionsLastUpdatedDateTime)
			delete(rawMsg, key)
		case "xCid":
			err = unpopulate(val, "XCid", &c.XCid)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CacheNodeInstallProperties.
func (c CacheNodeInstallProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cacheNodeId", c.CacheNodeID)
	populate(objectMap, "customerId", c.CustomerID)
	populate(objectMap, "driveConfiguration", c.DriveConfiguration)
	populate(objectMap, "primaryAccountKey", c.PrimaryAccountKey)
	populate(objectMap, "proxyUrlConfiguration", c.ProxyURLConfiguration)
	populate(objectMap, "registrationKey", c.RegistrationKey)
	populate(objectMap, "secondaryAccountKey", c.SecondaryAccountKey)
	populate(objectMap, "tlsCertificateProvisioningKey", c.TLSCertificateProvisioningKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CacheNodeInstallProperties.
func (c *CacheNodeInstallProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cacheNodeId":
			err = unpopulate(val, "CacheNodeID", &c.CacheNodeID)
			delete(rawMsg, key)
		case "customerId":
			err = unpopulate(val, "CustomerID", &c.CustomerID)
			delete(rawMsg, key)
		case "driveConfiguration":
			err = unpopulate(val, "DriveConfiguration", &c.DriveConfiguration)
			delete(rawMsg, key)
		case "primaryAccountKey":
			err = unpopulate(val, "PrimaryAccountKey", &c.PrimaryAccountKey)
			delete(rawMsg, key)
		case "proxyUrlConfiguration":
			err = unpopulate(val, "ProxyURLConfiguration", &c.ProxyURLConfiguration)
			delete(rawMsg, key)
		case "registrationKey":
			err = unpopulate(val, "RegistrationKey", &c.RegistrationKey)
			delete(rawMsg, key)
		case "secondaryAccountKey":
			err = unpopulate(val, "SecondaryAccountKey", &c.SecondaryAccountKey)
			delete(rawMsg, key)
		case "tlsCertificateProvisioningKey":
			err = unpopulate(val, "TLSCertificateProvisioningKey", &c.TLSCertificateProvisioningKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CacheNodeProperty.
func (c CacheNodeProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalCacheNodeProperties", c.AdditionalCacheNodeProperties)
	populate(objectMap, "cacheNode", c.CacheNode)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "statusCode", c.StatusCode)
	populate(objectMap, "statusDetails", c.StatusDetails)
	populate(objectMap, "statusText", c.StatusText)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CacheNodeProperty.
func (c *CacheNodeProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCacheNodeProperties":
			err = unpopulate(val, "AdditionalCacheNodeProperties", &c.AdditionalCacheNodeProperties)
			delete(rawMsg, key)
		case "cacheNode":
			err = unpopulate(val, "CacheNode", &c.CacheNode)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "statusCode":
			err = unpopulate(val, "StatusCode", &c.StatusCode)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, "StatusDetails", &c.StatusDetails)
			delete(rawMsg, key)
		case "statusText":
			err = unpopulate(val, "StatusText", &c.StatusText)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerEntity.
func (c CustomerEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientTenantId", c.ClientTenantID)
	populate(objectMap, "contactEmail", c.ContactEmail)
	populate(objectMap, "contactName", c.ContactName)
	populate(objectMap, "contactPhone", c.ContactPhone)
	populate(objectMap, "createAsyncOperationId", c.CreateAsyncOperationID)
	populate(objectMap, "customerId", c.CustomerID)
	populate(objectMap, "customerName", c.CustomerName)
	populate(objectMap, "deleteAsyncOperationId", c.DeleteAsyncOperationID)
	populate(objectMap, "fullyQualifiedResourceId", c.FullyQualifiedResourceID)
	populate(objectMap, "isEnterpriseManaged", c.IsEnterpriseManaged)
	populate(objectMap, "isEntitled", c.IsEntitled)
	populateTime[datetime.RFC3339](objectMap, "lastSyncWithAzureTimestamp", c.LastSyncWithAzureTimestamp)
	populate(objectMap, "releaseVersion", c.ReleaseVersion)
	populate(objectMap, "resendSignupCode", c.ResendSignupCode)
	populate(objectMap, "shouldMigrate", c.ShouldMigrate)
	populate(objectMap, "synchWithAzureAttemptsCount", c.SynchWithAzureAttemptsCount)
	populate(objectMap, "verifySignupCode", c.VerifySignupCode)
	populate(objectMap, "verifySignupPhrase", c.VerifySignupPhrase)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerEntity.
func (c *CustomerEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientTenantId":
			err = unpopulate(val, "ClientTenantID", &c.ClientTenantID)
			delete(rawMsg, key)
		case "contactEmail":
			err = unpopulate(val, "ContactEmail", &c.ContactEmail)
			delete(rawMsg, key)
		case "contactName":
			err = unpopulate(val, "ContactName", &c.ContactName)
			delete(rawMsg, key)
		case "contactPhone":
			err = unpopulate(val, "ContactPhone", &c.ContactPhone)
			delete(rawMsg, key)
		case "createAsyncOperationId":
			err = unpopulate(val, "CreateAsyncOperationID", &c.CreateAsyncOperationID)
			delete(rawMsg, key)
		case "customerId":
			err = unpopulate(val, "CustomerID", &c.CustomerID)
			delete(rawMsg, key)
		case "customerName":
			err = unpopulate(val, "CustomerName", &c.CustomerName)
			delete(rawMsg, key)
		case "deleteAsyncOperationId":
			err = unpopulate(val, "DeleteAsyncOperationID", &c.DeleteAsyncOperationID)
			delete(rawMsg, key)
		case "fullyQualifiedResourceId":
			err = unpopulate(val, "FullyQualifiedResourceID", &c.FullyQualifiedResourceID)
			delete(rawMsg, key)
		case "isEnterpriseManaged":
			err = unpopulate(val, "IsEnterpriseManaged", &c.IsEnterpriseManaged)
			delete(rawMsg, key)
		case "isEntitled":
			err = unpopulate(val, "IsEntitled", &c.IsEntitled)
			delete(rawMsg, key)
		case "lastSyncWithAzureTimestamp":
			err = unpopulateTime[datetime.RFC3339](val, "LastSyncWithAzureTimestamp", &c.LastSyncWithAzureTimestamp)
			delete(rawMsg, key)
		case "releaseVersion":
			err = unpopulate(val, "ReleaseVersion", &c.ReleaseVersion)
			delete(rawMsg, key)
		case "resendSignupCode":
			err = unpopulate(val, "ResendSignupCode", &c.ResendSignupCode)
			delete(rawMsg, key)
		case "shouldMigrate":
			err = unpopulate(val, "ShouldMigrate", &c.ShouldMigrate)
			delete(rawMsg, key)
		case "synchWithAzureAttemptsCount":
			err = unpopulate(val, "SynchWithAzureAttemptsCount", &c.SynchWithAzureAttemptsCount)
			delete(rawMsg, key)
		case "verifySignupCode":
			err = unpopulate(val, "VerifySignupCode", &c.VerifySignupCode)
			delete(rawMsg, key)
		case "verifySignupPhrase":
			err = unpopulate(val, "VerifySignupPhrase", &c.VerifySignupPhrase)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerProperty.
func (c CustomerProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalCustomerProperties", c.AdditionalCustomerProperties)
	populate(objectMap, "customer", c.Customer)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "statusCode", c.StatusCode)
	populate(objectMap, "statusDetails", c.StatusDetails)
	populate(objectMap, "statusText", c.StatusText)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerProperty.
func (c *CustomerProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCustomerProperties":
			err = unpopulate(val, "AdditionalCustomerProperties", &c.AdditionalCustomerProperties)
			delete(rawMsg, key)
		case "customer":
			err = unpopulate(val, "Customer", &c.Customer)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "statusCode":
			err = unpopulate(val, "StatusCode", &c.StatusCode)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, "StatusDetails", &c.StatusDetails)
			delete(rawMsg, key)
		case "statusText":
			err = unpopulate(val, "StatusText", &c.StatusText)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnterpriseMccCacheNodeResource.
func (e EnterpriseMccCacheNodeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnterpriseMccCacheNodeResource.
func (e *EnterpriseMccCacheNodeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnterpriseMccCacheNodeResourceListResult.
func (e EnterpriseMccCacheNodeResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnterpriseMccCacheNodeResourceListResult.
func (e *EnterpriseMccCacheNodeResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnterpriseMccCustomerResource.
func (e EnterpriseMccCustomerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnterpriseMccCustomerResource.
func (e *EnterpriseMccCustomerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnterpriseMccCustomerResourceListResult.
func (e EnterpriseMccCustomerResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnterpriseMccCustomerResourceListResult.
func (e *EnterpriseMccCustomerResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
			err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IspCacheNodeResource.
func (i IspCacheNodeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IspCacheNodeResource.
func (i *IspCacheNodeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IspCacheNodeResourceListResult.
func (i IspCacheNodeResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IspCacheNodeResourceListResult.
func (i *IspCacheNodeResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IspCustomerResource.
func (i IspCustomerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IspCustomerResource.
func (i *IspCustomerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IspCustomerResourceListResult.
func (i IspCustomerResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IspCustomerResourceListResult.
func (i *IspCustomerResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeAutoUpdateHistory.
func (m MccCacheNodeAutoUpdateHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeAutoUpdateHistory.
func (m *MccCacheNodeAutoUpdateHistory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeAutoUpdateHistoryProperties.
func (m MccCacheNodeAutoUpdateHistoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpdateHistory", m.AutoUpdateHistory)
	populate(objectMap, "cacheNodeId", m.CacheNodeID)
	populate(objectMap, "customerId", m.CustomerID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeAutoUpdateHistoryProperties.
func (m *MccCacheNodeAutoUpdateHistoryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpdateHistory":
			err = unpopulate(val, "AutoUpdateHistory", &m.AutoUpdateHistory)
			delete(rawMsg, key)
		case "cacheNodeId":
			err = unpopulate(val, "CacheNodeID", &m.CacheNodeID)
			delete(rawMsg, key)
		case "customerId":
			err = unpopulate(val, "CustomerID", &m.CustomerID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeAutoUpdateInfo.
func (m MccCacheNodeAutoUpdateInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpdateLastAppliedStatus", m.AutoUpdateLastAppliedStatus)
	populate(objectMap, "autoUpdateLastAppliedStatusDetailedText", m.AutoUpdateLastAppliedStatusDetailedText)
	populate(objectMap, "autoUpdateLastAppliedStatusText", m.AutoUpdateLastAppliedStatusText)
	populate(objectMap, "autoUpdateRingType", m.AutoUpdateRingType)
	populateTime[datetime.RFC3339](objectMap, "createdDateTimeUtc", m.CreatedDateTimeUTC)
	populate(objectMap, "imageUriBeforeUpdate", m.ImageURIBeforeUpdate)
	populate(objectMap, "imageUriTargeted", m.ImageURITargeted)
	populate(objectMap, "imageUriTerminal", m.ImageURITerminal)
	populateTime[datetime.RFC3339](objectMap, "movedToTerminalStateDateTime", m.MovedToTerminalStateDateTime)
	populate(objectMap, "planChangeLogText", m.PlanChangeLogText)
	populate(objectMap, "planId", m.PlanID)
	populate(objectMap, "ruleRequestedDay", m.RuleRequestedDay)
	populate(objectMap, "ruleRequestedHour", m.RuleRequestedHour)
	populate(objectMap, "ruleRequestedMinute", m.RuleRequestedMinute)
	populate(objectMap, "ruleRequestedWeek", m.RuleRequestedWeek)
	populate(objectMap, "timeToGoLiveDateTime", m.TimeToGoLiveDateTime)
	populateTime[datetime.RFC3339](objectMap, "updatedRegistryDateTimeUtc", m.UpdatedRegistryDateTimeUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeAutoUpdateInfo.
func (m *MccCacheNodeAutoUpdateInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpdateLastAppliedStatus":
			err = unpopulate(val, "AutoUpdateLastAppliedStatus", &m.AutoUpdateLastAppliedStatus)
			delete(rawMsg, key)
		case "autoUpdateLastAppliedStatusDetailedText":
			err = unpopulate(val, "AutoUpdateLastAppliedStatusDetailedText", &m.AutoUpdateLastAppliedStatusDetailedText)
			delete(rawMsg, key)
		case "autoUpdateLastAppliedStatusText":
			err = unpopulate(val, "AutoUpdateLastAppliedStatusText", &m.AutoUpdateLastAppliedStatusText)
			delete(rawMsg, key)
		case "autoUpdateRingType":
			err = unpopulate(val, "AutoUpdateRingType", &m.AutoUpdateRingType)
			delete(rawMsg, key)
		case "createdDateTimeUtc":
			err = unpopulateTime[datetime.RFC3339](val, "CreatedDateTimeUTC", &m.CreatedDateTimeUTC)
			delete(rawMsg, key)
		case "imageUriBeforeUpdate":
			err = unpopulate(val, "ImageURIBeforeUpdate", &m.ImageURIBeforeUpdate)
			delete(rawMsg, key)
		case "imageUriTargeted":
			err = unpopulate(val, "ImageURITargeted", &m.ImageURITargeted)
			delete(rawMsg, key)
		case "imageUriTerminal":
			err = unpopulate(val, "ImageURITerminal", &m.ImageURITerminal)
			delete(rawMsg, key)
		case "movedToTerminalStateDateTime":
			err = unpopulateTime[datetime.RFC3339](val, "MovedToTerminalStateDateTime", &m.MovedToTerminalStateDateTime)
			delete(rawMsg, key)
		case "planChangeLogText":
			err = unpopulate(val, "PlanChangeLogText", &m.PlanChangeLogText)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, "PlanID", &m.PlanID)
			delete(rawMsg, key)
		case "ruleRequestedDay":
			err = unpopulate(val, "RuleRequestedDay", &m.RuleRequestedDay)
			delete(rawMsg, key)
		case "ruleRequestedHour":
			err = unpopulate(val, "RuleRequestedHour", &m.RuleRequestedHour)
			delete(rawMsg, key)
		case "ruleRequestedMinute":
			err = unpopulate(val, "RuleRequestedMinute", &m.RuleRequestedMinute)
			delete(rawMsg, key)
		case "ruleRequestedWeek":
			err = unpopulate(val, "RuleRequestedWeek", &m.RuleRequestedWeek)
			delete(rawMsg, key)
		case "timeToGoLiveDateTime":
			err = unpopulate(val, "TimeToGoLiveDateTime", &m.TimeToGoLiveDateTime)
			delete(rawMsg, key)
		case "updatedRegistryDateTimeUtc":
			err = unpopulateTime[datetime.RFC3339](val, "UpdatedRegistryDateTimeUTC", &m.UpdatedRegistryDateTimeUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeBgpCidrDetails.
func (m MccCacheNodeBgpCidrDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeBgpCidrDetails.
func (m *MccCacheNodeBgpCidrDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeInstallDetails.
func (m MccCacheNodeInstallDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeInstallDetails.
func (m *MccCacheNodeInstallDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeIssueHistory.
func (m MccCacheNodeIssueHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeIssueHistory.
func (m *MccCacheNodeIssueHistory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeIssueHistoryProperties.
func (m MccCacheNodeIssueHistoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cacheNodeId", m.CacheNodeID)
	populate(objectMap, "customerId", m.CustomerID)
	populate(objectMap, "mccIssueHistory", m.MccIssueHistory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeIssueHistoryProperties.
func (m *MccCacheNodeIssueHistoryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cacheNodeId":
			err = unpopulate(val, "CacheNodeID", &m.CacheNodeID)
			delete(rawMsg, key)
		case "customerId":
			err = unpopulate(val, "CustomerID", &m.CustomerID)
			delete(rawMsg, key)
		case "mccIssueHistory":
			err = unpopulate(val, "MccIssueHistory", &m.MccIssueHistory)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeTLSCertificate.
func (m MccCacheNodeTLSCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionRequired", m.ActionRequired)
	populate(objectMap, "certificateFileName", m.CertificateFileName)
	populateTime[datetime.RFC3339](objectMap, "expiryDate", m.ExpiryDate)
	populateTime[datetime.RFC3339](objectMap, "notBeforeDate", m.NotBeforeDate)
	populate(objectMap, "subject", m.Subject)
	populate(objectMap, "subjectAltName", m.SubjectAltName)
	populate(objectMap, "thumbprint", m.Thumbprint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeTLSCertificate.
func (m *MccCacheNodeTLSCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionRequired":
			err = unpopulate(val, "ActionRequired", &m.ActionRequired)
			delete(rawMsg, key)
		case "certificateFileName":
			err = unpopulate(val, "CertificateFileName", &m.CertificateFileName)
			delete(rawMsg, key)
		case "expiryDate":
			err = unpopulateTime[datetime.RFC3339](val, "ExpiryDate", &m.ExpiryDate)
			delete(rawMsg, key)
		case "notBeforeDate":
			err = unpopulateTime[datetime.RFC3339](val, "NotBeforeDate", &m.NotBeforeDate)
			delete(rawMsg, key)
		case "subject":
			err = unpopulate(val, "Subject", &m.Subject)
			delete(rawMsg, key)
		case "subjectAltName":
			err = unpopulate(val, "SubjectAltName", &m.SubjectAltName)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, "Thumbprint", &m.Thumbprint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeTLSCertificateHistory.
func (m MccCacheNodeTLSCertificateHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeTLSCertificateHistory.
func (m *MccCacheNodeTLSCertificateHistory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccCacheNodeTLSCertificateProperties.
func (m MccCacheNodeTLSCertificateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cacheNodeId", m.CacheNodeID)
	populate(objectMap, "customerId", m.CustomerID)
	populate(objectMap, "tlsCertificateHistory", m.TLSCertificateHistory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccCacheNodeTLSCertificateProperties.
func (m *MccCacheNodeTLSCertificateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cacheNodeId":
			err = unpopulate(val, "CacheNodeID", &m.CacheNodeID)
			delete(rawMsg, key)
		case "customerId":
			err = unpopulate(val, "CustomerID", &m.CustomerID)
			delete(rawMsg, key)
		case "tlsCertificateHistory":
			err = unpopulate(val, "TLSCertificateHistory", &m.TLSCertificateHistory)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MccIssue.
func (m MccIssue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detailString", m.DetailString)
	populate(objectMap, "helpLink", m.HelpLink)
	populateTime[datetime.RFC3339](objectMap, "issueEndDate", m.IssueEndDate)
	populateTime[datetime.RFC3339](objectMap, "issueStartDate", m.IssueStartDate)
	populate(objectMap, "mccIssueType", m.MccIssueType)
	populate(objectMap, "toastString", m.ToastString)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MccIssue.
func (m *MccIssue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detailString":
			err = unpopulate(val, "DetailString", &m.DetailString)
			delete(rawMsg, key)
		case "helpLink":
			err = unpopulate(val, "HelpLink", &m.HelpLink)
			delete(rawMsg, key)
		case "issueEndDate":
			err = unpopulateTime[datetime.RFC3339](val, "IssueEndDate", &m.IssueEndDate)
			delete(rawMsg, key)
		case "issueStartDate":
			err = unpopulateTime[datetime.RFC3339](val, "IssueStartDate", &m.IssueStartDate)
			delete(rawMsg, key)
		case "mccIssueType":
			err = unpopulate(val, "MccIssueType", &m.MccIssueType)
			delete(rawMsg, key)
		case "toastString":
			err = unpopulate(val, "ToastString", &m.ToastString)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PatchResource.
func (p PatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PatchResource.
func (p *PatchResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProxyURLConfiguration.
func (p ProxyURLConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "proxyUrl", p.ProxyURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProxyURLConfiguration.
func (p *ProxyURLConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "proxyUrl":
			err = unpopulate(val, "ProxyURL", &p.ProxyURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTime[datetime.RFC3339](objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTime[datetime.RFC3339](val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTime[datetime.RFC3339](val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateTime[T dateTimeConstraints](m map[string]any, k string, t *time.Time) {
	if t == nil {
		return
	} else if azcore.IsNullValue(t) {
		m[k] = nil
	} else if !reflect.ValueOf(t).IsNil() {
		newTime := T(*t)
		m[k] = (*T)(&newTime)
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

func unpopulateTime[T dateTimeConstraints](data json.RawMessage, fn string, t **time.Time) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	var aux T
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	newTime := time.Time(aux)
	*t = &newTime
	return nil
}

type dateTimeConstraints interface {
	datetime.PlainDate | datetime.PlainTime | datetime.RFC1123 | datetime.RFC3339 | datetime.Unix
}
