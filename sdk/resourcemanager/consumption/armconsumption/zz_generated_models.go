//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armconsumption

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AggregatedCostGetByManagementGroupOptions contains the optional parameters for the AggregatedCost.GetByManagementGroup method.
type AggregatedCostGetByManagementGroupOptions struct {
	// May be used to filter aggregated cost by properties/usageStart (Utc time), properties/usageEnd (Utc time). The filter supports 'eq', 'lt', 'gt', 'le',
	// 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon
	// (:).
	Filter *string
}

// AggregatedCostGetForBillingPeriodByManagementGroupOptions contains the optional parameters for the AggregatedCost.GetForBillingPeriodByManagementGroup
// method.
type AggregatedCostGetForBillingPeriodByManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// Amount - The amount plus currency .
type Amount struct {
	// READ-ONLY; Amount currency.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; Amount.
	Value *float64 `json:"value,omitempty" azure:"ro"`
}

// AmountWithExchangeRate - The amount with exchange rate.
type AmountWithExchangeRate struct {
	Amount
	// READ-ONLY; The exchange rate.
	ExchangeRate *float64 `json:"exchangeRate,omitempty" azure:"ro"`

	// READ-ONLY; The exchange rate month.
	ExchangeRateMonth *int32 `json:"exchangeRateMonth,omitempty" azure:"ro"`
}

// Balance - A balance resource.
type Balance struct {
	Resource
	// The properties of the balance.
	Properties *BalanceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Balance.
func (b Balance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Balance.
func (b *Balance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BalanceProperties - The properties of the balance.
type BalanceProperties struct {
	// The billing frequency.
	BillingFrequency *BillingFrequency `json:"billingFrequency,omitempty"`

	// READ-ONLY; List of Adjustments (Promo credit, SIE credit etc.).
	AdjustmentDetails []*BalancePropertiesAdjustmentDetailsItem `json:"adjustmentDetails,omitempty" azure:"ro"`

	// READ-ONLY; Total adjustment amount.
	Adjustments *float64 `json:"adjustments,omitempty" azure:"ro"`

	// READ-ONLY; Total charges for Azure Marketplace.
	AzureMarketplaceServiceCharges *float64 `json:"azureMarketplaceServiceCharges,omitempty" azure:"ro"`

	// READ-ONLY; The beginning balance for the billing period.
	BeginningBalance *float64 `json:"beginningBalance,omitempty" azure:"ro"`

	// READ-ONLY; Charges Billed separately.
	ChargesBilledSeparately *float64 `json:"chargesBilledSeparately,omitempty" azure:"ro"`

	// READ-ONLY; The ISO currency in which the meter is charged, for example, USD.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; The ending balance for the billing period (for open periods this will be updated daily).
	EndingBalance *float64 `json:"endingBalance,omitempty" azure:"ro"`

	// READ-ONLY; Total new purchase amount.
	NewPurchases *float64 `json:"newPurchases,omitempty" azure:"ro"`

	// READ-ONLY; List of new purchases.
	NewPurchasesDetails []*BalancePropertiesNewPurchasesDetailsItem `json:"newPurchasesDetails,omitempty" azure:"ro"`

	// READ-ONLY; Price is hidden or not.
	PriceHidden *bool `json:"priceHidden,omitempty" azure:"ro"`

	// READ-ONLY; Overage for Azure services.
	ServiceOverage *float64 `json:"serviceOverage,omitempty" azure:"ro"`

	// READ-ONLY; serviceOverage + chargesBilledSeparately.
	TotalOverage *float64 `json:"totalOverage,omitempty" azure:"ro"`

	// READ-ONLY; Azure service commitment + total Overage.
	TotalUsage *float64 `json:"totalUsage,omitempty" azure:"ro"`

	// READ-ONLY; Total Commitment usage.
	Utilized *float64 `json:"utilized,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BalanceProperties.
func (b BalanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adjustmentDetails", b.AdjustmentDetails)
	populate(objectMap, "adjustments", b.Adjustments)
	populate(objectMap, "azureMarketplaceServiceCharges", b.AzureMarketplaceServiceCharges)
	populate(objectMap, "beginningBalance", b.BeginningBalance)
	populate(objectMap, "billingFrequency", b.BillingFrequency)
	populate(objectMap, "chargesBilledSeparately", b.ChargesBilledSeparately)
	populate(objectMap, "currency", b.Currency)
	populate(objectMap, "endingBalance", b.EndingBalance)
	populate(objectMap, "newPurchases", b.NewPurchases)
	populate(objectMap, "newPurchasesDetails", b.NewPurchasesDetails)
	populate(objectMap, "priceHidden", b.PriceHidden)
	populate(objectMap, "serviceOverage", b.ServiceOverage)
	populate(objectMap, "totalOverage", b.TotalOverage)
	populate(objectMap, "totalUsage", b.TotalUsage)
	populate(objectMap, "utilized", b.Utilized)
	return json.Marshal(objectMap)
}

type BalancePropertiesAdjustmentDetailsItem struct {
	// READ-ONLY; the name of new adjustment.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; the value of new adjustment.
	Value *float64 `json:"value,omitempty" azure:"ro"`
}

type BalancePropertiesNewPurchasesDetailsItem struct {
	// READ-ONLY; the name of new purchase.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; the value of new purchase.
	Value *float64 `json:"value,omitempty" azure:"ro"`
}

// BalancesGetByBillingAccountOptions contains the optional parameters for the Balances.GetByBillingAccount method.
type BalancesGetByBillingAccountOptions struct {
	// placeholder for future optional parameters
}

// BalancesGetForBillingPeriodByBillingAccountOptions contains the optional parameters for the Balances.GetForBillingPeriodByBillingAccount method.
type BalancesGetForBillingPeriodByBillingAccountOptions struct {
	// placeholder for future optional parameters
}

// Budget - A budget resource.
type Budget struct {
	ProxyResource
	// The properties of the budget.
	Properties *BudgetProperties `json:"properties,omitempty"`
}

// BudgetComparisonExpression - The comparison expression to be used in the budgets.
type BudgetComparisonExpression struct {
	// REQUIRED; The name of the column to use in comparison.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The operator to use for comparison.
	Operator *BudgetOperatorType `json:"operator,omitempty"`

	// REQUIRED; Array of values to use for comparison
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BudgetComparisonExpression.
func (b BudgetComparisonExpression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", b.Name)
	populate(objectMap, "operator", b.Operator)
	populate(objectMap, "values", b.Values)
	return json.Marshal(objectMap)
}

// BudgetFilter - May be used to filter budgets by resource group, resource, or meter.
type BudgetFilter struct {
	// The logical "AND" expression. Must have at least 2 items.
	And []*BudgetFilterProperties `json:"and,omitempty"`

	// Has comparison expression for a dimension
	Dimensions *BudgetComparisonExpression `json:"dimensions,omitempty"`

	// The logical "NOT" expression.
	Not *BudgetFilterProperties `json:"not,omitempty"`

	// Has comparison expression for a tag
	Tags *BudgetComparisonExpression `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BudgetFilter.
func (b BudgetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "and", b.And)
	populate(objectMap, "dimensions", b.Dimensions)
	populate(objectMap, "not", b.Not)
	populate(objectMap, "tags", b.Tags)
	return json.Marshal(objectMap)
}

// BudgetFilterProperties - The Dimensions or Tags to filter a budget by.
type BudgetFilterProperties struct {
	// Has comparison expression for a dimension
	Dimensions *BudgetComparisonExpression `json:"dimensions,omitempty"`

	// Has comparison expression for a tag
	Tags *BudgetComparisonExpression `json:"tags,omitempty"`
}

// BudgetProperties - The properties of the budget.
type BudgetProperties struct {
	// REQUIRED; The total amount of cost to track with the budget
	Amount *float64 `json:"amount,omitempty"`

	// REQUIRED; The category of the budget, whether the budget tracks cost or usage.
	Category *CategoryType `json:"category,omitempty"`

	// REQUIRED; The time covered by a budget. Tracking of the amount will be reset based on the time grain. BillingMonth, BillingQuarter, and BillingAnnual
	// are only supported by WD customers
	TimeGrain *TimeGrainType `json:"timeGrain,omitempty"`

	// REQUIRED; Has start and end date of the budget. The start date must be first of the month and should be less than the end date. Budget start date must
	// be on or after June 1, 2017. Future start date should not
	// be more than twelve months. Past start date should be selected within the timegrain period. There are no restrictions on the end date.
	TimePeriod *BudgetTimePeriod `json:"timePeriod,omitempty"`

	// May be used to filter budgets by user-specified dimensions and/or tags.
	Filter *BudgetFilter `json:"filter,omitempty"`

	// Dictionary of notifications associated with the budget. Budget can have up to five notifications.
	Notifications map[string]*Notification `json:"notifications,omitempty"`

	// READ-ONLY; The current amount of cost which is being tracked for a budget.
	CurrentSpend *CurrentSpend `json:"currentSpend,omitempty" azure:"ro"`

	// READ-ONLY; The forecasted cost which is being tracked for a budget.
	ForecastSpend *ForecastSpend `json:"forecastSpend,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BudgetProperties.
func (b BudgetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "amount", b.Amount)
	populate(objectMap, "category", b.Category)
	populate(objectMap, "currentSpend", b.CurrentSpend)
	populate(objectMap, "filter", b.Filter)
	populate(objectMap, "forecastSpend", b.ForecastSpend)
	populate(objectMap, "notifications", b.Notifications)
	populate(objectMap, "timeGrain", b.TimeGrain)
	populate(objectMap, "timePeriod", b.TimePeriod)
	return json.Marshal(objectMap)
}

// BudgetTimePeriod - The start and end date for a budget.
type BudgetTimePeriod struct {
	// REQUIRED; The start date for the budget.
	StartDate *time.Time `json:"startDate,omitempty"`

	// The end date for the budget. If not provided, we default this to 10 years from the start date.
	EndDate *time.Time `json:"endDate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BudgetTimePeriod.
func (b BudgetTimePeriod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endDate", b.EndDate)
	populateTimeRFC3339(objectMap, "startDate", b.StartDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BudgetTimePeriod.
func (b *BudgetTimePeriod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDate":
			err = unpopulateTimeRFC3339(val, &b.EndDate)
			delete(rawMsg, key)
		case "startDate":
			err = unpopulateTimeRFC3339(val, &b.StartDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BudgetsCreateOrUpdateOptions contains the optional parameters for the Budgets.CreateOrUpdate method.
type BudgetsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// BudgetsDeleteOptions contains the optional parameters for the Budgets.Delete method.
type BudgetsDeleteOptions struct {
	// placeholder for future optional parameters
}

// BudgetsGetOptions contains the optional parameters for the Budgets.Get method.
type BudgetsGetOptions struct {
	// placeholder for future optional parameters
}

// BudgetsListOptions contains the optional parameters for the Budgets.List method.
type BudgetsListOptions struct {
	// placeholder for future optional parameters
}

// BudgetsListResult - Result of listing budgets. It contains a list of available budgets in the scope provided.
type BudgetsListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of budgets.
	Value []*Budget `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BudgetsListResult.
func (b BudgetsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// ChargeSummaryClassification provides polymorphic access to related types.
// Call the interface's GetChargeSummary() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ChargeSummary, *LegacyChargeSummary, *ModernChargeSummary
type ChargeSummaryClassification interface {
	// GetChargeSummary returns the ChargeSummary content of the underlying type.
	GetChargeSummary() *ChargeSummary
}

// ChargeSummary - A charge summary resource.
type ChargeSummary struct {
	Resource
	// REQUIRED; Specifies the kind of charge summary.
	Kind *ChargeSummaryKind `json:"kind,omitempty"`
}

// GetChargeSummary implements the ChargeSummaryClassification interface for type ChargeSummary.
func (c *ChargeSummary) GetChargeSummary() *ChargeSummary { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type ChargeSummary.
func (c *ChargeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ChargeSummary) marshalInternal(objectMap map[string]interface{}, discValue ChargeSummaryKind) {
	c.Resource.marshalInternal(objectMap)
	c.Kind = &discValue
	objectMap["kind"] = c.Kind
}

func (c *ChargeSummary) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &c.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ChargesListOptions contains the optional parameters for the Charges.List method.
type ChargesListOptions struct {
	// May be used to group charges for billingAccount scope by properties/billingProfileId, properties/invoiceSectionId, properties/customerId (specific for
	// Partner Led), or for billingProfile scope by properties/invoiceSectionId.
	Apply *string
	// End date
	EndDate *string
	// May be used to filter charges by properties/usageEnd (Utc time), properties/usageStart (Utc time). The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
	// and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
	Filter *string
	// Start date
	StartDate *string
}

// ChargesListResult - Result of listing charge summary.
type ChargesListResult struct {
	// READ-ONLY; The list of charge summary
	Value []ChargeSummaryClassification `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ChargesListResult.
func (c ChargesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChargesListResult.
func (c *ChargesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			c.Value, err = unmarshalChargeSummaryClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CreditBalanceSummary - Summary of credit balances.
type CreditBalanceSummary struct {
	// READ-ONLY; Current balance.
	CurrentBalance *Amount `json:"currentBalance,omitempty" azure:"ro"`

	// READ-ONLY; Estimated balance.
	EstimatedBalance *Amount `json:"estimatedBalance,omitempty" azure:"ro"`

	// READ-ONLY; Estimated balance in billing currency.
	EstimatedBalanceInBillingCurrency *AmountWithExchangeRate `json:"estimatedBalanceInBillingCurrency,omitempty" azure:"ro"`
}

// CreditSummary - A credit summary resource.
type CreditSummary struct {
	Resource
	// The properties of the credit summary.
	Properties *CreditSummaryProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CreditSummary.
func (c CreditSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreditSummary.
func (c *CreditSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CreditSummaryProperties - The properties of the credit summary.
type CreditSummaryProperties struct {
	// READ-ONLY; Summary of balances associated with this credit summary.
	BalanceSummary *CreditBalanceSummary `json:"balanceSummary,omitempty" azure:"ro"`

	// READ-ONLY; The billing currency.
	BillingCurrency *string `json:"billingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The credit currency.
	CreditCurrency *string `json:"creditCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The eTag for the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; Expired credit.
	ExpiredCredit *Amount `json:"expiredCredit,omitempty" azure:"ro"`

	// READ-ONLY; Pending credit adjustments.
	PendingCreditAdjustments *Amount `json:"pendingCreditAdjustments,omitempty" azure:"ro"`

	// READ-ONLY; Pending eligible charges.
	PendingEligibleCharges *Amount `json:"pendingEligibleCharges,omitempty" azure:"ro"`

	// READ-ONLY; Credit's reseller.
	Reseller *Reseller `json:"reseller,omitempty" azure:"ro"`
}

// CreditsGetOptions contains the optional parameters for the Credits.Get method.
type CreditsGetOptions struct {
	// placeholder for future optional parameters
}

// CurrentSpend - The current amount of cost which is being tracked for a budget.
type CurrentSpend struct {
	// READ-ONLY; The total amount of cost which is being tracked by the budget.
	Amount *float64 `json:"amount,omitempty" azure:"ro"`

	// READ-ONLY; The unit of measure for the budget amount.
	Unit *string `json:"unit,omitempty" azure:"ro"`
}

// DownloadProperties - The properties of the price sheet download.
type DownloadProperties struct {
	// READ-ONLY; The link (url) to download the pricesheet.
	DownloadURL *string `json:"downloadUrl,omitempty" azure:"ro"`

	// READ-ONLY; Download link validity.
	ValidTill *string `json:"validTill,omitempty" azure:"ro"`
}

// ErrorDetails - The details of the error.
type ErrorDetails struct {
	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ErrorResponse - Error response indicates that the service is not able to process the incoming request. The reason is provided in the error message.
// Some Error responses:
// * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after" header.
//
//
// * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After" header.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The details of the error.
	InnerError *ErrorDetails `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// EventProperties - The event properties.
type EventProperties struct {
	// Identifies the type of the event.
	EventType *EventType `json:"eventType,omitempty"`

	// READ-ONLY; The amount of balance adjustment. The property is not available for ConsumptionCommitment lots.
	Adjustments *Amount `json:"adjustments,omitempty" azure:"ro"`

	// READ-ONLY; The amount of balance adjustment in billing currency.
	AdjustmentsInBillingCurrency *AmountWithExchangeRate `json:"adjustmentsInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The billing currency of the event.
	BillingCurrency *string `json:"billingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The display name of the billing profile for which the event happened. The property is only available for billing account of type MicrosoftCustomerAgreement.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty" azure:"ro"`

	// READ-ONLY; The ID that uniquely identifies the billing profile for which the event happened. The property is only available for billing account of type
	// MicrosoftCustomerAgreement.
	BillingProfileID *string `json:"billingProfileId,omitempty" azure:"ro"`

	// READ-ONLY; Amount of canceled credit.
	CanceledCredit *Amount `json:"canceledCredit,omitempty" azure:"ro"`

	// READ-ONLY; The amount of charges for events of type SettleCharges and PendingEligibleCharges.
	Charges *Amount `json:"charges,omitempty" azure:"ro"`

	// READ-ONLY; The amount of charges for events of type SettleCharges and PendingEligibleCharges in billing currency.
	ChargesInBillingCurrency *AmountWithExchangeRate `json:"chargesInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The balance after the event.
	ClosedBalance *Amount `json:"closedBalance,omitempty" azure:"ro"`

	// READ-ONLY; The balance in billing currency after the event.
	ClosedBalanceInBillingCurrency *AmountWithExchangeRate `json:"closedBalanceInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The credit currency of the event.
	CreditCurrency *string `json:"creditCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The amount of expired credit or commitment for NewCredit or SettleCharges event.
	CreditExpired *Amount `json:"creditExpired,omitempty" azure:"ro"`

	// READ-ONLY; The amount of expired credit or commitment for NewCredit or SettleCharges event in billing currency.
	CreditExpiredInBillingCurrency *AmountWithExchangeRate `json:"creditExpiredInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The description of the event.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The eTag for the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; The number which uniquely identifies the invoice on which the event was billed. This will be empty for unbilled events.
	InvoiceNumber *string `json:"invoiceNumber,omitempty" azure:"ro"`

	// READ-ONLY; The ID that uniquely identifies the lot for which the event happened.
	LotID *string `json:"lotId,omitempty" azure:"ro"`

	// READ-ONLY; Identifies the source of the lot for which the event happened.
	LotSource *string `json:"lotSource,omitempty" azure:"ro"`

	// READ-ONLY; The amount of new credit or commitment for NewCredit or SettleCharges event.
	NewCredit *Amount `json:"newCredit,omitempty" azure:"ro"`

	// READ-ONLY; The amount of new credit or commitment for NewCredit or SettleCharges event in billing currency.
	NewCreditInBillingCurrency *AmountWithExchangeRate `json:"newCreditInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The reseller of the event.
	Reseller *Reseller `json:"reseller,omitempty" azure:"ro"`

	// READ-ONLY; The date of the event.
	TransactionDate *time.Time `json:"transactionDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventProperties.
func (e EventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adjustments", e.Adjustments)
	populate(objectMap, "adjustmentsInBillingCurrency", e.AdjustmentsInBillingCurrency)
	populate(objectMap, "billingCurrency", e.BillingCurrency)
	populate(objectMap, "billingProfileDisplayName", e.BillingProfileDisplayName)
	populate(objectMap, "billingProfileId", e.BillingProfileID)
	populate(objectMap, "canceledCredit", e.CanceledCredit)
	populate(objectMap, "charges", e.Charges)
	populate(objectMap, "chargesInBillingCurrency", e.ChargesInBillingCurrency)
	populate(objectMap, "closedBalance", e.ClosedBalance)
	populate(objectMap, "closedBalanceInBillingCurrency", e.ClosedBalanceInBillingCurrency)
	populate(objectMap, "creditCurrency", e.CreditCurrency)
	populate(objectMap, "creditExpired", e.CreditExpired)
	populate(objectMap, "creditExpiredInBillingCurrency", e.CreditExpiredInBillingCurrency)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "eTag", e.ETag)
	populate(objectMap, "eventType", e.EventType)
	populate(objectMap, "invoiceNumber", e.InvoiceNumber)
	populate(objectMap, "lotId", e.LotID)
	populate(objectMap, "lotSource", e.LotSource)
	populate(objectMap, "newCredit", e.NewCredit)
	populate(objectMap, "newCreditInBillingCurrency", e.NewCreditInBillingCurrency)
	populate(objectMap, "reseller", e.Reseller)
	populateTimeRFC3339(objectMap, "transactionDate", e.TransactionDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventProperties.
func (e *EventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adjustments":
			err = unpopulate(val, &e.Adjustments)
			delete(rawMsg, key)
		case "adjustmentsInBillingCurrency":
			err = unpopulate(val, &e.AdjustmentsInBillingCurrency)
			delete(rawMsg, key)
		case "billingCurrency":
			err = unpopulate(val, &e.BillingCurrency)
			delete(rawMsg, key)
		case "billingProfileDisplayName":
			err = unpopulate(val, &e.BillingProfileDisplayName)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &e.BillingProfileID)
			delete(rawMsg, key)
		case "canceledCredit":
			err = unpopulate(val, &e.CanceledCredit)
			delete(rawMsg, key)
		case "charges":
			err = unpopulate(val, &e.Charges)
			delete(rawMsg, key)
		case "chargesInBillingCurrency":
			err = unpopulate(val, &e.ChargesInBillingCurrency)
			delete(rawMsg, key)
		case "closedBalance":
			err = unpopulate(val, &e.ClosedBalance)
			delete(rawMsg, key)
		case "closedBalanceInBillingCurrency":
			err = unpopulate(val, &e.ClosedBalanceInBillingCurrency)
			delete(rawMsg, key)
		case "creditCurrency":
			err = unpopulate(val, &e.CreditCurrency)
			delete(rawMsg, key)
		case "creditExpired":
			err = unpopulate(val, &e.CreditExpired)
			delete(rawMsg, key)
		case "creditExpiredInBillingCurrency":
			err = unpopulate(val, &e.CreditExpiredInBillingCurrency)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, &e.ETag)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, &e.EventType)
			delete(rawMsg, key)
		case "invoiceNumber":
			err = unpopulate(val, &e.InvoiceNumber)
			delete(rawMsg, key)
		case "lotId":
			err = unpopulate(val, &e.LotID)
			delete(rawMsg, key)
		case "lotSource":
			err = unpopulate(val, &e.LotSource)
			delete(rawMsg, key)
		case "newCredit":
			err = unpopulate(val, &e.NewCredit)
			delete(rawMsg, key)
		case "newCreditInBillingCurrency":
			err = unpopulate(val, &e.NewCreditInBillingCurrency)
			delete(rawMsg, key)
		case "reseller":
			err = unpopulate(val, &e.Reseller)
			delete(rawMsg, key)
		case "transactionDate":
			err = unpopulateTimeRFC3339(val, &e.TransactionDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSummary - An event summary resource.
type EventSummary struct {
	Resource
	// The event properties.
	Properties *EventProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSummary.
func (e EventSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSummary.
func (e *EventSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Events - Result of listing event summary.
type Events struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of event summary.
	Value []*EventSummary `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Events.
func (e Events) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EventsListByBillingAccountOptions contains the optional parameters for the Events.ListByBillingAccount method.
type EventsListByBillingAccountOptions struct {
	// May be used to filter the events by lotId, lotSource etc. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support
	// 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
	Filter *string
}

// EventsListByBillingProfileOptions contains the optional parameters for the Events.ListByBillingProfile method.
type EventsListByBillingProfileOptions struct {
	// placeholder for future optional parameters
}

// ForecastSpend - The forecasted cost which is being tracked for a budget.
type ForecastSpend struct {
	// READ-ONLY; The forecasted cost for the total time period which is being tracked by the budget. This value is only provided if the budget contains a forecast
	// alert type.
	Amount *float64 `json:"amount,omitempty" azure:"ro"`

	// READ-ONLY; The unit of measure for the budget amount.
	Unit *string `json:"unit,omitempty" azure:"ro"`
}

// HighCasedErrorDetails - The details of the error.
type HighCasedErrorDetails struct {
	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// HighCasedErrorResponse - Error response indicates that the service is not able to process the incoming request. The reason is provided in the error message.
// Some Error responses:
// * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after" header.
//
//
// * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After" header.
// Implements the error and azcore.HTTPResponse interfaces.
type HighCasedErrorResponse struct {
	raw string
	// The details of the error.
	InnerError *HighCasedErrorDetails `json:"error,omitempty"`
}

// Error implements the error interface for type HighCasedErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e HighCasedErrorResponse) Error() string {
	return e.raw
}

// LegacyChargeSummary - Legacy charge summary.
type LegacyChargeSummary struct {
	ChargeSummary
	// REQUIRED; Properties for legacy charge summary
	Properties *LegacyChargeSummaryProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LegacyChargeSummary.
func (l LegacyChargeSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.ChargeSummary.marshalInternal(objectMap, ChargeSummaryKindLegacy)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyChargeSummary.
func (l *LegacyChargeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.ChargeSummary.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// LegacyChargeSummaryProperties - The properties of legacy charge summary.
type LegacyChargeSummaryProperties struct {
	// READ-ONLY; Azure Charges.
	AzureCharges *float64 `json:"azureCharges,omitempty" azure:"ro"`

	// READ-ONLY; The id of the billing period resource that the charge belongs to.
	BillingPeriodID *string `json:"billingPeriodId,omitempty" azure:"ro"`

	// READ-ONLY; Charges Billed separately.
	ChargesBilledSeparately *float64 `json:"chargesBilledSeparately,omitempty" azure:"ro"`

	// READ-ONLY; Currency Code
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; Marketplace Charges.
	MarketplaceCharges *float64 `json:"marketplaceCharges,omitempty" azure:"ro"`

	// READ-ONLY; Usage end date.
	UsageEnd *string `json:"usageEnd,omitempty" azure:"ro"`

	// READ-ONLY; Usage start date.
	UsageStart *string `json:"usageStart,omitempty" azure:"ro"`
}

// LegacyReservationRecommendation - Legacy reservation recommendation.
type LegacyReservationRecommendation struct {
	ReservationRecommendation
	// REQUIRED; Properties for legacy reservation recommendation
	Properties *LegacyReservationRecommendationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationRecommendation.
func (l LegacyReservationRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.ReservationRecommendation.marshalInternal(objectMap, ReservationRecommendationKindLegacy)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyReservationRecommendation.
func (l *LegacyReservationRecommendation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.ReservationRecommendation.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// LegacyReservationRecommendationProperties - The properties of the reservation recommendation.
type LegacyReservationRecommendationProperties struct {
	// READ-ONLY; The total amount of cost without reserved instances.
	CostWithNoReservedInstances *float64 `json:"costWithNoReservedInstances,omitempty" azure:"ro"`

	// READ-ONLY; The usage date for looking back.
	FirstUsageDate *time.Time `json:"firstUsageDate,omitempty" azure:"ro"`

	// READ-ONLY; The instance Flexibility Group.
	InstanceFlexibilityGroup *string `json:"instanceFlexibilityGroup,omitempty" azure:"ro"`

	// READ-ONLY; The instance Flexibility Ratio.
	InstanceFlexibilityRatio *float32 `json:"instanceFlexibilityRatio,omitempty" azure:"ro"`

	// READ-ONLY; The number of days of usage to look back for recommendation.
	LookBackPeriod *string `json:"lookBackPeriod,omitempty" azure:"ro"`

	// READ-ONLY; The meter id (GUID)
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; Total estimated savings with reserved instances.
	NetSavings *float64 `json:"netSavings,omitempty" azure:"ro"`

	// READ-ONLY; The normalized Size.
	NormalizedSize *string `json:"normalizedSize,omitempty" azure:"ro"`

	// READ-ONLY; Recommended quality for reserved instances.
	RecommendedQuantity *float64 `json:"recommendedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; The recommended Quantity Normalized.
	RecommendedQuantityNormalized *float32 `json:"recommendedQuantityNormalized,omitempty" azure:"ro"`

	// READ-ONLY; The azure resource type.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; List of sku properties
	SKUProperties []*SKUProperty `json:"skuProperties,omitempty" azure:"ro"`

	// READ-ONLY; Shared or single recommendation.
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; RI recommendations in one or three year terms.
	Term *string `json:"term,omitempty" azure:"ro"`

	// READ-ONLY; The total amount of cost with reserved instances.
	TotalCostWithReservedInstances *float64 `json:"totalCostWithReservedInstances,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationRecommendationProperties.
func (l LegacyReservationRecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costWithNoReservedInstances", l.CostWithNoReservedInstances)
	populateTimeRFC3339(objectMap, "firstUsageDate", l.FirstUsageDate)
	populate(objectMap, "instanceFlexibilityGroup", l.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", l.InstanceFlexibilityRatio)
	populate(objectMap, "lookBackPeriod", l.LookBackPeriod)
	populate(objectMap, "meterId", l.MeterID)
	populate(objectMap, "netSavings", l.NetSavings)
	populate(objectMap, "normalizedSize", l.NormalizedSize)
	populate(objectMap, "recommendedQuantity", l.RecommendedQuantity)
	populate(objectMap, "recommendedQuantityNormalized", l.RecommendedQuantityNormalized)
	populate(objectMap, "resourceType", l.ResourceType)
	populate(objectMap, "skuProperties", l.SKUProperties)
	populate(objectMap, "scope", l.Scope)
	populate(objectMap, "term", l.Term)
	populate(objectMap, "totalCostWithReservedInstances", l.TotalCostWithReservedInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyReservationRecommendationProperties.
func (l *LegacyReservationRecommendationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costWithNoReservedInstances":
			err = unpopulate(val, &l.CostWithNoReservedInstances)
			delete(rawMsg, key)
		case "firstUsageDate":
			err = unpopulateTimeRFC3339(val, &l.FirstUsageDate)
			delete(rawMsg, key)
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &l.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &l.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "lookBackPeriod":
			err = unpopulate(val, &l.LookBackPeriod)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &l.MeterID)
			delete(rawMsg, key)
		case "netSavings":
			err = unpopulate(val, &l.NetSavings)
			delete(rawMsg, key)
		case "normalizedSize":
			err = unpopulate(val, &l.NormalizedSize)
			delete(rawMsg, key)
		case "recommendedQuantity":
			err = unpopulate(val, &l.RecommendedQuantity)
			delete(rawMsg, key)
		case "recommendedQuantityNormalized":
			err = unpopulate(val, &l.RecommendedQuantityNormalized)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, &l.ResourceType)
			delete(rawMsg, key)
		case "skuProperties":
			err = unpopulate(val, &l.SKUProperties)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &l.Scope)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		case "totalCostWithReservedInstances":
			err = unpopulate(val, &l.TotalCostWithReservedInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LegacyReservationTransaction - Legacy Reservation transaction resource.
type LegacyReservationTransaction struct {
	ReservationTransaction
}

// LegacyReservationTransactionProperties - The properties of a legacy reservation transaction.
type LegacyReservationTransactionProperties struct {
	// READ-ONLY; The name of the account that makes the transaction.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; The email of the account owner that makes the transaction.
	AccountOwnerEmail *string `json:"accountOwnerEmail,omitempty" azure:"ro"`

	// READ-ONLY; The charge of the transaction.
	Amount *float64 `json:"amount,omitempty" azure:"ro"`

	// READ-ONLY; This is the ARM Sku name. It can be used to join with the serviceType field in additional info in usage records.
	ArmSKUName *string `json:"armSkuName,omitempty" azure:"ro"`

	// READ-ONLY; The billing frequency, which can be either one-time or recurring.
	BillingFrequency *string `json:"billingFrequency,omitempty" azure:"ro"`

	// READ-ONLY; The cost center of this department if it is a department and a cost center is provided.
	CostCenter *string `json:"costCenter,omitempty" azure:"ro"`

	// READ-ONLY; The ISO currency in which the transaction is charged, for example, USD.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; The current enrollment.
	CurrentEnrollment *string `json:"currentEnrollment,omitempty" azure:"ro"`

	// READ-ONLY; The department name.
	DepartmentName *string `json:"departmentName,omitempty" azure:"ro"`

	// READ-ONLY; The description of the transaction.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The date of the transaction
	EventDate *time.Time `json:"eventDate,omitempty" azure:"ro"`

	// READ-ONLY; The type of the transaction (Purchase, Cancel, etc.)
	EventType *string `json:"eventType,omitempty" azure:"ro"`

	// READ-ONLY; The purchasing enrollment.
	PurchasingEnrollment *string `json:"purchasingEnrollment,omitempty" azure:"ro"`

	// READ-ONLY; The subscription guid that makes the transaction.
	PurchasingSubscriptionGUID *string `json:"purchasingSubscriptionGuid,omitempty" azure:"ro"`

	// READ-ONLY; The subscription name that makes the transaction.
	PurchasingSubscriptionName *string `json:"purchasingSubscriptionName,omitempty" azure:"ro"`

	// READ-ONLY; The quantity of the transaction.
	Quantity *float64 `json:"quantity,omitempty" azure:"ro"`

	// READ-ONLY; The region of the transaction.
	Region *string `json:"region,omitempty" azure:"ro"`

	// READ-ONLY; The reservation order ID is the identifier for a reservation purchase. Each reservation order ID represents a single purchase transaction.
	// A reservation order contains reservations. The reservation
	// order specifies the VM size and region for the reservations.
	ReservationOrderID *string `json:"reservationOrderId,omitempty" azure:"ro"`

	// READ-ONLY; The name of the reservation order.
	ReservationOrderName *string `json:"reservationOrderName,omitempty" azure:"ro"`

	// READ-ONLY; This is the term of the transaction.
	Term *string `json:"term,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationTransactionProperties.
func (l LegacyReservationTransactionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", l.AccountName)
	populate(objectMap, "accountOwnerEmail", l.AccountOwnerEmail)
	populate(objectMap, "amount", l.Amount)
	populate(objectMap, "armSkuName", l.ArmSKUName)
	populate(objectMap, "billingFrequency", l.BillingFrequency)
	populate(objectMap, "costCenter", l.CostCenter)
	populate(objectMap, "currency", l.Currency)
	populate(objectMap, "currentEnrollment", l.CurrentEnrollment)
	populate(objectMap, "departmentName", l.DepartmentName)
	populate(objectMap, "description", l.Description)
	populateTimeRFC3339(objectMap, "eventDate", l.EventDate)
	populate(objectMap, "eventType", l.EventType)
	populate(objectMap, "purchasingEnrollment", l.PurchasingEnrollment)
	populate(objectMap, "purchasingSubscriptionGuid", l.PurchasingSubscriptionGUID)
	populate(objectMap, "purchasingSubscriptionName", l.PurchasingSubscriptionName)
	populate(objectMap, "quantity", l.Quantity)
	populate(objectMap, "region", l.Region)
	populate(objectMap, "reservationOrderId", l.ReservationOrderID)
	populate(objectMap, "reservationOrderName", l.ReservationOrderName)
	populate(objectMap, "term", l.Term)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyReservationTransactionProperties.
func (l *LegacyReservationTransactionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &l.AccountName)
			delete(rawMsg, key)
		case "accountOwnerEmail":
			err = unpopulate(val, &l.AccountOwnerEmail)
			delete(rawMsg, key)
		case "amount":
			err = unpopulate(val, &l.Amount)
			delete(rawMsg, key)
		case "armSkuName":
			err = unpopulate(val, &l.ArmSKUName)
			delete(rawMsg, key)
		case "billingFrequency":
			err = unpopulate(val, &l.BillingFrequency)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &l.CostCenter)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &l.Currency)
			delete(rawMsg, key)
		case "currentEnrollment":
			err = unpopulate(val, &l.CurrentEnrollment)
			delete(rawMsg, key)
		case "departmentName":
			err = unpopulate(val, &l.DepartmentName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "eventDate":
			err = unpopulateTimeRFC3339(val, &l.EventDate)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, &l.EventType)
			delete(rawMsg, key)
		case "purchasingEnrollment":
			err = unpopulate(val, &l.PurchasingEnrollment)
			delete(rawMsg, key)
		case "purchasingSubscriptionGuid":
			err = unpopulate(val, &l.PurchasingSubscriptionGUID)
			delete(rawMsg, key)
		case "purchasingSubscriptionName":
			err = unpopulate(val, &l.PurchasingSubscriptionName)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &l.Quantity)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &l.Region)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &l.ReservationOrderID)
			delete(rawMsg, key)
		case "reservationOrderName":
			err = unpopulate(val, &l.ReservationOrderName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LegacyUsageDetail - Legacy usage detail.
type LegacyUsageDetail struct {
	UsageDetail
	// REQUIRED; Properties for legacy usage details
	Properties *LegacyUsageDetailProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LegacyUsageDetail.
func (l LegacyUsageDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.UsageDetail.marshalInternal(objectMap, UsageDetailsKindLegacy)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyUsageDetail.
func (l *LegacyUsageDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.UsageDetail.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// LegacyUsageDetailProperties - The properties of the legacy usage detail.
type LegacyUsageDetailProperties struct {
	// READ-ONLY; Account Name.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; Account Owner Id.
	AccountOwnerID *string `json:"accountOwnerId,omitempty" azure:"ro"`

	// READ-ONLY; Additional details of this usage item. By default this is not populated, unless it's specified in $expand. Use this field to get usage line
	// item specific details such as the actual VM Size
	// (ServiceType) or the ratio in which the reservation discount is applied.
	AdditionalInfo *string `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; Billing Account identifier.
	BillingAccountID *string `json:"billingAccountId,omitempty" azure:"ro"`

	// READ-ONLY; Billing Account Name.
	BillingAccountName *string `json:"billingAccountName,omitempty" azure:"ro"`

	// READ-ONLY; Billing Currency.
	BillingCurrency *string `json:"billingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The billing period end date.
	BillingPeriodEndDate *time.Time `json:"billingPeriodEndDate,omitempty" azure:"ro"`

	// READ-ONLY; The billing period start date.
	BillingPeriodStartDate *time.Time `json:"billingPeriodStartDate,omitempty" azure:"ro"`

	// READ-ONLY; Billing Profile identifier.
	BillingProfileID *string `json:"billingProfileId,omitempty" azure:"ro"`

	// READ-ONLY; Billing Profile Name.
	BillingProfileName *string `json:"billingProfileName,omitempty" azure:"ro"`

	// READ-ONLY; Indicates a charge represents credits, usage, a Marketplace purchase, a reservation fee, or a refund.
	ChargeType *string `json:"chargeType,omitempty" azure:"ro"`

	// READ-ONLY; Consumed service name. Name of the azure resource provider that emits the usage or was purchased. This value is not provided for marketplace
	// usage.
	ConsumedService *string `json:"consumedService,omitempty" azure:"ro"`

	// READ-ONLY; The amount of cost before tax.
	Cost *float64 `json:"cost,omitempty" azure:"ro"`

	// READ-ONLY; The cost center of this department if it is a department and a cost center is provided.
	CostCenter *string `json:"costCenter,omitempty" azure:"ro"`

	// READ-ONLY; Date for the usage record.
	Date *time.Time `json:"date,omitempty" azure:"ro"`

	// READ-ONLY; Effective Price that's charged for the usage.
	EffectivePrice *float64 `json:"effectivePrice,omitempty" azure:"ro"`

	// READ-ONLY; Indicates how frequently this charge will occur. OneTime for purchases which only happen once, Monthly for fees which recur every month, and
	// UsageBased for charges based on how much a service is used.
	Frequency *string `json:"frequency,omitempty" azure:"ro"`

	// READ-ONLY; Invoice Section Name.
	InvoiceSection *string `json:"invoiceSection,omitempty" azure:"ro"`

	// READ-ONLY; Is Azure Credit Eligible.
	IsAzureCreditEligible *bool `json:"isAzureCreditEligible,omitempty" azure:"ro"`

	// READ-ONLY; The details about the meter. By default this is not populated, unless it's specified in $expand.
	MeterDetails *MeterDetailsResponse `json:"meterDetails,omitempty" azure:"ro"`

	// READ-ONLY; The meter id (GUID). Not available for marketplace. For reserved instance this represents the primary meter for which the reservation was
	// purchased. For the actual VM Size for which the reservation is
	// purchased see productOrderName.
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; Offer Id. Ex: MS-AZR-0017P, MS-AZR-0148P.
	OfferID *string `json:"offerId,omitempty" azure:"ro"`

	// READ-ONLY; Part Number of the service used. Can be used to join with the price sheet. Not available for marketplace.
	PartNumber *string `json:"partNumber,omitempty" azure:"ro"`

	// READ-ONLY; Retail price for the resource.
	PayGPrice *float64 `json:"payGPrice,omitempty" azure:"ro"`

	// READ-ONLY; Plan Name.
	PlanName *string `json:"planName,omitempty" azure:"ro"`

	// READ-ONLY; Identifier that indicates how the meter is priced.
	PricingModel *PricingModelType `json:"pricingModel,omitempty" azure:"ro"`

	// READ-ONLY; Product name for the consumed service or purchase. Not available for Marketplace.
	Product *string `json:"product,omitempty" azure:"ro"`

	// READ-ONLY; Product Order Id. For reservations this is the Reservation Order ID.
	ProductOrderID *string `json:"productOrderId,omitempty" azure:"ro"`

	// READ-ONLY; Product Order Name. For reservations this is the SKU that was purchased.
	ProductOrderName *string `json:"productOrderName,omitempty" azure:"ro"`

	// READ-ONLY; Publisher Name.
	PublisherName *string `json:"publisherName,omitempty" azure:"ro"`

	// READ-ONLY; Publisher Type.
	PublisherType *string `json:"publisherType,omitempty" azure:"ro"`

	// READ-ONLY; The usage quantity.
	Quantity *float64 `json:"quantity,omitempty" azure:"ro"`

	// READ-ONLY; ARM resource id of the reservation. Only applies to records relevant to reservations.
	ReservationID *string `json:"reservationId,omitempty" azure:"ro"`

	// READ-ONLY; User provided display name of the reservation. Last known name for a particular day is populated in the daily data. Only applies to records
	// relevant to reservations.
	ReservationName *string `json:"reservationName,omitempty" azure:"ro"`

	// READ-ONLY; Resource Group Name.
	ResourceGroup *string `json:"resourceGroup,omitempty" azure:"ro"`

	// READ-ONLY; Unique identifier of the Azure Resource Manager usage detail resource.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; Resource Location.
	ResourceLocation *string `json:"resourceLocation,omitempty" azure:"ro"`

	// READ-ONLY; Resource Name.
	ResourceName *string `json:"resourceName,omitempty" azure:"ro"`

	// READ-ONLY; Service-specific metadata.
	ServiceInfo1 *string `json:"serviceInfo1,omitempty" azure:"ro"`

	// READ-ONLY; Legacy field with optional service-specific metadata.
	ServiceInfo2 *string `json:"serviceInfo2,omitempty" azure:"ro"`

	// READ-ONLY; Subscription guid.
	SubscriptionID *string `json:"subscriptionId,omitempty" azure:"ro"`

	// READ-ONLY; Subscription name.
	SubscriptionName *string `json:"subscriptionName,omitempty" azure:"ro"`

	// READ-ONLY; Term (in months). 1 month for monthly recurring purchase. 12 months for a 1 year reservation. 36 months for a 3 year reservation.
	Term *string `json:"term,omitempty" azure:"ro"`

	// READ-ONLY; Unit Price is the price applicable to you. (your EA or other contract price).
	UnitPrice *float64 `json:"unitPrice,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LegacyUsageDetailProperties.
func (l LegacyUsageDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", l.AccountName)
	populate(objectMap, "accountOwnerId", l.AccountOwnerID)
	populate(objectMap, "additionalInfo", l.AdditionalInfo)
	populate(objectMap, "billingAccountId", l.BillingAccountID)
	populate(objectMap, "billingAccountName", l.BillingAccountName)
	populate(objectMap, "billingCurrency", l.BillingCurrency)
	populateTimeRFC3339(objectMap, "billingPeriodEndDate", l.BillingPeriodEndDate)
	populateTimeRFC3339(objectMap, "billingPeriodStartDate", l.BillingPeriodStartDate)
	populate(objectMap, "billingProfileId", l.BillingProfileID)
	populate(objectMap, "billingProfileName", l.BillingProfileName)
	populate(objectMap, "chargeType", l.ChargeType)
	populate(objectMap, "consumedService", l.ConsumedService)
	populate(objectMap, "cost", l.Cost)
	populate(objectMap, "costCenter", l.CostCenter)
	populateTimeRFC3339(objectMap, "date", l.Date)
	populate(objectMap, "effectivePrice", l.EffectivePrice)
	populate(objectMap, "frequency", l.Frequency)
	populate(objectMap, "invoiceSection", l.InvoiceSection)
	populate(objectMap, "isAzureCreditEligible", l.IsAzureCreditEligible)
	populate(objectMap, "meterDetails", l.MeterDetails)
	populate(objectMap, "meterId", l.MeterID)
	populate(objectMap, "offerId", l.OfferID)
	populate(objectMap, "partNumber", l.PartNumber)
	populate(objectMap, "payGPrice", l.PayGPrice)
	populate(objectMap, "planName", l.PlanName)
	populate(objectMap, "pricingModel", l.PricingModel)
	populate(objectMap, "product", l.Product)
	populate(objectMap, "productOrderId", l.ProductOrderID)
	populate(objectMap, "productOrderName", l.ProductOrderName)
	populate(objectMap, "publisherName", l.PublisherName)
	populate(objectMap, "publisherType", l.PublisherType)
	populate(objectMap, "quantity", l.Quantity)
	populate(objectMap, "reservationId", l.ReservationID)
	populate(objectMap, "reservationName", l.ReservationName)
	populate(objectMap, "resourceGroup", l.ResourceGroup)
	populate(objectMap, "resourceId", l.ResourceID)
	populate(objectMap, "resourceLocation", l.ResourceLocation)
	populate(objectMap, "resourceName", l.ResourceName)
	populate(objectMap, "serviceInfo1", l.ServiceInfo1)
	populate(objectMap, "serviceInfo2", l.ServiceInfo2)
	populate(objectMap, "subscriptionId", l.SubscriptionID)
	populate(objectMap, "subscriptionName", l.SubscriptionName)
	populate(objectMap, "term", l.Term)
	populate(objectMap, "unitPrice", l.UnitPrice)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyUsageDetailProperties.
func (l *LegacyUsageDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &l.AccountName)
			delete(rawMsg, key)
		case "accountOwnerId":
			err = unpopulate(val, &l.AccountOwnerID)
			delete(rawMsg, key)
		case "additionalInfo":
			err = unpopulate(val, &l.AdditionalInfo)
			delete(rawMsg, key)
		case "billingAccountId":
			err = unpopulate(val, &l.BillingAccountID)
			delete(rawMsg, key)
		case "billingAccountName":
			err = unpopulate(val, &l.BillingAccountName)
			delete(rawMsg, key)
		case "billingCurrency":
			err = unpopulate(val, &l.BillingCurrency)
			delete(rawMsg, key)
		case "billingPeriodEndDate":
			err = unpopulateTimeRFC3339(val, &l.BillingPeriodEndDate)
			delete(rawMsg, key)
		case "billingPeriodStartDate":
			err = unpopulateTimeRFC3339(val, &l.BillingPeriodStartDate)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &l.BillingProfileID)
			delete(rawMsg, key)
		case "billingProfileName":
			err = unpopulate(val, &l.BillingProfileName)
			delete(rawMsg, key)
		case "chargeType":
			err = unpopulate(val, &l.ChargeType)
			delete(rawMsg, key)
		case "consumedService":
			err = unpopulate(val, &l.ConsumedService)
			delete(rawMsg, key)
		case "cost":
			err = unpopulate(val, &l.Cost)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &l.CostCenter)
			delete(rawMsg, key)
		case "date":
			err = unpopulateTimeRFC3339(val, &l.Date)
			delete(rawMsg, key)
		case "effectivePrice":
			err = unpopulate(val, &l.EffectivePrice)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &l.Frequency)
			delete(rawMsg, key)
		case "invoiceSection":
			err = unpopulate(val, &l.InvoiceSection)
			delete(rawMsg, key)
		case "isAzureCreditEligible":
			err = unpopulate(val, &l.IsAzureCreditEligible)
			delete(rawMsg, key)
		case "meterDetails":
			err = unpopulate(val, &l.MeterDetails)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &l.MeterID)
			delete(rawMsg, key)
		case "offerId":
			err = unpopulate(val, &l.OfferID)
			delete(rawMsg, key)
		case "partNumber":
			err = unpopulate(val, &l.PartNumber)
			delete(rawMsg, key)
		case "payGPrice":
			err = unpopulate(val, &l.PayGPrice)
			delete(rawMsg, key)
		case "planName":
			err = unpopulate(val, &l.PlanName)
			delete(rawMsg, key)
		case "pricingModel":
			err = unpopulate(val, &l.PricingModel)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, &l.Product)
			delete(rawMsg, key)
		case "productOrderId":
			err = unpopulate(val, &l.ProductOrderID)
			delete(rawMsg, key)
		case "productOrderName":
			err = unpopulate(val, &l.ProductOrderName)
			delete(rawMsg, key)
		case "publisherName":
			err = unpopulate(val, &l.PublisherName)
			delete(rawMsg, key)
		case "publisherType":
			err = unpopulate(val, &l.PublisherType)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &l.Quantity)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &l.ReservationID)
			delete(rawMsg, key)
		case "reservationName":
			err = unpopulate(val, &l.ReservationName)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, &l.ResourceGroup)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &l.ResourceID)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, &l.ResourceLocation)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, &l.ResourceName)
			delete(rawMsg, key)
		case "serviceInfo1":
			err = unpopulate(val, &l.ServiceInfo1)
			delete(rawMsg, key)
		case "serviceInfo2":
			err = unpopulate(val, &l.ServiceInfo2)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &l.SubscriptionID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, &l.SubscriptionName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		case "unitPrice":
			err = unpopulate(val, &l.UnitPrice)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LotProperties - The lot properties.
type LotProperties struct {
	// READ-ONLY; The billing currency of the lot.
	BillingCurrency *string `json:"billingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The balance as of the last invoice.
	ClosedBalance *Amount `json:"closedBalance,omitempty" azure:"ro"`

	// READ-ONLY; The balance as of the last invoice in billing currency.
	ClosedBalanceInBillingCurrency *AmountWithExchangeRate `json:"closedBalanceInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The currency of the lot.
	CreditCurrency *string `json:"creditCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The eTag for the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; The expiration date of a lot.
	ExpirationDate *time.Time `json:"expirationDate,omitempty" azure:"ro"`

	// READ-ONLY; The original amount of a lot.
	OriginalAmount *Amount `json:"originalAmount,omitempty" azure:"ro"`

	// READ-ONLY; The original amount of a lot in billing currency.
	OriginalAmountInBillingCurrency *AmountWithExchangeRate `json:"originalAmountInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The po number of the invoice on which the lot was added. This property is not available for ConsumptionCommitment lots.
	PoNumber *string `json:"poNumber,omitempty" azure:"ro"`

	// READ-ONLY; The date when the lot was added.
	PurchasedDate *time.Time `json:"purchasedDate,omitempty" azure:"ro"`

	// READ-ONLY; The reseller of the lot.
	Reseller *Reseller `json:"reseller,omitempty" azure:"ro"`

	// READ-ONLY; The source of the lot.
	Source *LotSource `json:"source,omitempty" azure:"ro"`

	// READ-ONLY; The date when the lot became effective.
	StartDate *time.Time `json:"startDate,omitempty" azure:"ro"`

	// READ-ONLY; The status of the lot.
	Status *Status `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LotProperties.
func (l LotProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "billingCurrency", l.BillingCurrency)
	populate(objectMap, "closedBalance", l.ClosedBalance)
	populate(objectMap, "closedBalanceInBillingCurrency", l.ClosedBalanceInBillingCurrency)
	populate(objectMap, "creditCurrency", l.CreditCurrency)
	populate(objectMap, "eTag", l.ETag)
	populateTimeRFC3339(objectMap, "expirationDate", l.ExpirationDate)
	populate(objectMap, "originalAmount", l.OriginalAmount)
	populate(objectMap, "originalAmountInBillingCurrency", l.OriginalAmountInBillingCurrency)
	populate(objectMap, "poNumber", l.PoNumber)
	populateTimeRFC3339(objectMap, "purchasedDate", l.PurchasedDate)
	populate(objectMap, "reseller", l.Reseller)
	populate(objectMap, "source", l.Source)
	populateTimeRFC3339(objectMap, "startDate", l.StartDate)
	populate(objectMap, "status", l.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LotProperties.
func (l *LotProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "billingCurrency":
			err = unpopulate(val, &l.BillingCurrency)
			delete(rawMsg, key)
		case "closedBalance":
			err = unpopulate(val, &l.ClosedBalance)
			delete(rawMsg, key)
		case "closedBalanceInBillingCurrency":
			err = unpopulate(val, &l.ClosedBalanceInBillingCurrency)
			delete(rawMsg, key)
		case "creditCurrency":
			err = unpopulate(val, &l.CreditCurrency)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, &l.ETag)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &l.ExpirationDate)
			delete(rawMsg, key)
		case "originalAmount":
			err = unpopulate(val, &l.OriginalAmount)
			delete(rawMsg, key)
		case "originalAmountInBillingCurrency":
			err = unpopulate(val, &l.OriginalAmountInBillingCurrency)
			delete(rawMsg, key)
		case "poNumber":
			err = unpopulate(val, &l.PoNumber)
			delete(rawMsg, key)
		case "purchasedDate":
			err = unpopulateTimeRFC3339(val, &l.PurchasedDate)
			delete(rawMsg, key)
		case "reseller":
			err = unpopulate(val, &l.Reseller)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &l.Source)
			delete(rawMsg, key)
		case "startDate":
			err = unpopulateTimeRFC3339(val, &l.StartDate)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &l.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LotSummary - A lot summary resource.
type LotSummary struct {
	Resource
	// The lot properties.
	Properties *LotProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LotSummary.
func (l LotSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LotSummary.
func (l *LotSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Lots - Result of listing lot summary.
type Lots struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of lot summary.
	Value []*LotSummary `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Lots.
func (l Lots) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LotsListByBillingAccountOptions contains the optional parameters for the Lots.ListByBillingAccount method.
type LotsListByBillingAccountOptions struct {
	// May be used to filter the lots by Status, Source etc. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne',
	// 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
	Filter *string
}

// LotsListByBillingProfileOptions contains the optional parameters for the Lots.ListByBillingProfile method.
type LotsListByBillingProfileOptions struct {
	// placeholder for future optional parameters
}

// ManagementGroupAggregatedCostProperties - The properties of the Management Group Aggregated Cost.
type ManagementGroupAggregatedCostProperties struct {
	// Children of a management group
	Children []*ManagementGroupAggregatedCostResult `json:"children,omitempty"`

	// List of subscription Guids excluded from the calculation of aggregated cost
	ExcludedSubscriptions []*string `json:"excludedSubscriptions,omitempty"`

	// List of subscription Guids included in the calculation of aggregated cost
	IncludedSubscriptions []*string `json:"includedSubscriptions,omitempty"`

	// READ-ONLY; Azure Charges.
	AzureCharges *float64 `json:"azureCharges,omitempty" azure:"ro"`

	// READ-ONLY; The id of the billing period resource that the aggregated cost belongs to.
	BillingPeriodID *string `json:"billingPeriodId,omitempty" azure:"ro"`

	// READ-ONLY; Charges Billed Separately.
	ChargesBilledSeparately *float64 `json:"chargesBilledSeparately,omitempty" azure:"ro"`

	// READ-ONLY; The ISO currency in which the meter is charged, for example, USD.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; Marketplace Charges.
	MarketplaceCharges *float64 `json:"marketplaceCharges,omitempty" azure:"ro"`

	// READ-ONLY; The end of the date time range covered by the aggregated cost.
	UsageEnd *time.Time `json:"usageEnd,omitempty" azure:"ro"`

	// READ-ONLY; The start of the date time range covered by aggregated cost.
	UsageStart *time.Time `json:"usageStart,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagementGroupAggregatedCostProperties.
func (m ManagementGroupAggregatedCostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureCharges", m.AzureCharges)
	populate(objectMap, "billingPeriodId", m.BillingPeriodID)
	populate(objectMap, "chargesBilledSeparately", m.ChargesBilledSeparately)
	populate(objectMap, "children", m.Children)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "excludedSubscriptions", m.ExcludedSubscriptions)
	populate(objectMap, "includedSubscriptions", m.IncludedSubscriptions)
	populate(objectMap, "marketplaceCharges", m.MarketplaceCharges)
	populateTimeRFC3339(objectMap, "usageEnd", m.UsageEnd)
	populateTimeRFC3339(objectMap, "usageStart", m.UsageStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementGroupAggregatedCostProperties.
func (m *ManagementGroupAggregatedCostProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureCharges":
			err = unpopulate(val, &m.AzureCharges)
			delete(rawMsg, key)
		case "billingPeriodId":
			err = unpopulate(val, &m.BillingPeriodID)
			delete(rawMsg, key)
		case "chargesBilledSeparately":
			err = unpopulate(val, &m.ChargesBilledSeparately)
			delete(rawMsg, key)
		case "children":
			err = unpopulate(val, &m.Children)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &m.Currency)
			delete(rawMsg, key)
		case "excludedSubscriptions":
			err = unpopulate(val, &m.ExcludedSubscriptions)
			delete(rawMsg, key)
		case "includedSubscriptions":
			err = unpopulate(val, &m.IncludedSubscriptions)
			delete(rawMsg, key)
		case "marketplaceCharges":
			err = unpopulate(val, &m.MarketplaceCharges)
			delete(rawMsg, key)
		case "usageEnd":
			err = unpopulateTimeRFC3339(val, &m.UsageEnd)
			delete(rawMsg, key)
		case "usageStart":
			err = unpopulateTimeRFC3339(val, &m.UsageStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagementGroupAggregatedCostResult - A management group aggregated cost resource.
type ManagementGroupAggregatedCostResult struct {
	Resource
	// The properties of the Management Group Aggregated Cost.
	Properties *ManagementGroupAggregatedCostProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagementGroupAggregatedCostResult.
func (m ManagementGroupAggregatedCostResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementGroupAggregatedCostResult.
func (m *ManagementGroupAggregatedCostResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Marketplace - A marketplace resource.
type Marketplace struct {
	Resource
	// The properties of the marketplace usage detail.
	Properties *MarketplaceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Marketplace.
func (m Marketplace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Marketplace.
func (m *Marketplace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MarketplaceProperties - The properties of the marketplace usage detail.
type MarketplaceProperties struct {
	// READ-ONLY; Account name.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; Additional information.
	AdditionalInfo *string `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; Additional details of this usage item. By default this is not populated, unless it's specified in $expand.
	AdditionalProperties *string `json:"additionalProperties,omitempty" azure:"ro"`

	// READ-ONLY; The id of the billing period resource that the usage belongs to.
	BillingPeriodID *string `json:"billingPeriodId,omitempty" azure:"ro"`

	// READ-ONLY; The quantity of usage.
	ConsumedQuantity *float64 `json:"consumedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; Consumed service name.
	ConsumedService *string `json:"consumedService,omitempty" azure:"ro"`

	// READ-ONLY; The cost center of this department if it is a department and a costcenter exists
	CostCenter *string `json:"costCenter,omitempty" azure:"ro"`

	// READ-ONLY; The ISO currency in which the meter is charged, for example, USD.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; Department name.
	DepartmentName *string `json:"departmentName,omitempty" azure:"ro"`

	// READ-ONLY; The uri of the resource instance that the usage is about.
	InstanceID *string `json:"instanceId,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource instance that the usage is about.
	InstanceName *string `json:"instanceName,omitempty" azure:"ro"`

	// READ-ONLY; The estimated usage is subject to change.
	IsEstimated *bool `json:"isEstimated,omitempty" azure:"ro"`

	// READ-ONLY; Flag indicating whether this is a recurring charge or not.
	IsRecurringCharge *bool `json:"isRecurringCharge,omitempty" azure:"ro"`

	// READ-ONLY; The meter id (GUID).
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; The type of offer.
	OfferName *string `json:"offerName,omitempty" azure:"ro"`

	// READ-ONLY; The order number.
	OrderNumber *string `json:"orderNumber,omitempty" azure:"ro"`

	// READ-ONLY; The name of plan.
	PlanName *string `json:"planName,omitempty" azure:"ro"`

	// READ-ONLY; The amount of cost before tax.
	PretaxCost *float64 `json:"pretaxCost,omitempty" azure:"ro"`

	// READ-ONLY; The name of publisher.
	PublisherName *string `json:"publisherName,omitempty" azure:"ro"`

	// READ-ONLY; The name of resource group.
	ResourceGroup *string `json:"resourceGroup,omitempty" azure:"ro"`

	// READ-ONLY; The marketplace resource rate.
	ResourceRate *float64 `json:"resourceRate,omitempty" azure:"ro"`

	// READ-ONLY; Subscription guid.
	SubscriptionGUID *string `json:"subscriptionGuid,omitempty" azure:"ro"`

	// READ-ONLY; Subscription name.
	SubscriptionName *string `json:"subscriptionName,omitempty" azure:"ro"`

	// READ-ONLY; The unit of measure.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty" azure:"ro"`

	// READ-ONLY; The end of the date time range covered by the usage detail.
	UsageEnd *time.Time `json:"usageEnd,omitempty" azure:"ro"`

	// READ-ONLY; The start of the date time range covered by the usage detail.
	UsageStart *time.Time `json:"usageStart,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketplaceProperties.
func (m MarketplaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", m.AccountName)
	populate(objectMap, "additionalInfo", m.AdditionalInfo)
	populate(objectMap, "additionalProperties", m.AdditionalProperties)
	populate(objectMap, "billingPeriodId", m.BillingPeriodID)
	populate(objectMap, "consumedQuantity", m.ConsumedQuantity)
	populate(objectMap, "consumedService", m.ConsumedService)
	populate(objectMap, "costCenter", m.CostCenter)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "departmentName", m.DepartmentName)
	populate(objectMap, "instanceId", m.InstanceID)
	populate(objectMap, "instanceName", m.InstanceName)
	populate(objectMap, "isEstimated", m.IsEstimated)
	populate(objectMap, "isRecurringCharge", m.IsRecurringCharge)
	populate(objectMap, "meterId", m.MeterID)
	populate(objectMap, "offerName", m.OfferName)
	populate(objectMap, "orderNumber", m.OrderNumber)
	populate(objectMap, "planName", m.PlanName)
	populate(objectMap, "pretaxCost", m.PretaxCost)
	populate(objectMap, "publisherName", m.PublisherName)
	populate(objectMap, "resourceGroup", m.ResourceGroup)
	populate(objectMap, "resourceRate", m.ResourceRate)
	populate(objectMap, "subscriptionGuid", m.SubscriptionGUID)
	populate(objectMap, "subscriptionName", m.SubscriptionName)
	populate(objectMap, "unitOfMeasure", m.UnitOfMeasure)
	populateTimeRFC3339(objectMap, "usageEnd", m.UsageEnd)
	populateTimeRFC3339(objectMap, "usageStart", m.UsageStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketplaceProperties.
func (m *MarketplaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &m.AccountName)
			delete(rawMsg, key)
		case "additionalInfo":
			err = unpopulate(val, &m.AdditionalInfo)
			delete(rawMsg, key)
		case "additionalProperties":
			err = unpopulate(val, &m.AdditionalProperties)
			delete(rawMsg, key)
		case "billingPeriodId":
			err = unpopulate(val, &m.BillingPeriodID)
			delete(rawMsg, key)
		case "consumedQuantity":
			err = unpopulate(val, &m.ConsumedQuantity)
			delete(rawMsg, key)
		case "consumedService":
			err = unpopulate(val, &m.ConsumedService)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &m.CostCenter)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &m.Currency)
			delete(rawMsg, key)
		case "departmentName":
			err = unpopulate(val, &m.DepartmentName)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, &m.InstanceID)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, &m.InstanceName)
			delete(rawMsg, key)
		case "isEstimated":
			err = unpopulate(val, &m.IsEstimated)
			delete(rawMsg, key)
		case "isRecurringCharge":
			err = unpopulate(val, &m.IsRecurringCharge)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &m.MeterID)
			delete(rawMsg, key)
		case "offerName":
			err = unpopulate(val, &m.OfferName)
			delete(rawMsg, key)
		case "orderNumber":
			err = unpopulate(val, &m.OrderNumber)
			delete(rawMsg, key)
		case "planName":
			err = unpopulate(val, &m.PlanName)
			delete(rawMsg, key)
		case "pretaxCost":
			err = unpopulate(val, &m.PretaxCost)
			delete(rawMsg, key)
		case "publisherName":
			err = unpopulate(val, &m.PublisherName)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, &m.ResourceGroup)
			delete(rawMsg, key)
		case "resourceRate":
			err = unpopulate(val, &m.ResourceRate)
			delete(rawMsg, key)
		case "subscriptionGuid":
			err = unpopulate(val, &m.SubscriptionGUID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, &m.SubscriptionName)
			delete(rawMsg, key)
		case "unitOfMeasure":
			err = unpopulate(val, &m.UnitOfMeasure)
			delete(rawMsg, key)
		case "usageEnd":
			err = unpopulateTimeRFC3339(val, &m.UsageEnd)
			delete(rawMsg, key)
		case "usageStart":
			err = unpopulateTimeRFC3339(val, &m.UsageStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarketplacesListOptions contains the optional parameters for the Marketplaces.List method.
type MarketplacesListOptions struct {
	// May be used to filter marketplaces by properties/usageEnd (Utc time), properties/usageStart (Utc time), properties/resourceGroup, properties/instanceName
	// or properties/instanceId. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'.
	Filter *string
	// Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink
	// element will include a skiptoken parameter that specifies a starting point to use for subsequent calls.
	Skiptoken *string
	// May be used to limit the number of results to the most recent N marketplaces.
	Top *int32
}

// MarketplacesListResult - Result of listing marketplaces. It contains a list of available marketplaces in reverse chronological order by billing period.
type MarketplacesListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of marketplaces.
	Value []*Marketplace `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketplacesListResult.
func (m MarketplacesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MeterDetails - The properties of the meter detail.
type MeterDetails struct {
	// READ-ONLY; The category of the meter, for example, 'Cloud services', 'Networking', etc..
	MeterCategory *string `json:"meterCategory,omitempty" azure:"ro"`

	// READ-ONLY; The location in which the Azure service is available.
	MeterLocation *string `json:"meterLocation,omitempty" azure:"ro"`

	// READ-ONLY; The name of the meter, within the given meter category
	MeterName *string `json:"meterName,omitempty" azure:"ro"`

	// READ-ONLY; The subcategory of the meter, for example, 'A6 Cloud services', 'ExpressRoute (IXP)', etc..
	MeterSubCategory *string `json:"meterSubCategory,omitempty" azure:"ro"`

	// READ-ONLY; The pretax listing price.
	PretaxStandardRate *float64 `json:"pretaxStandardRate,omitempty" azure:"ro"`

	// READ-ONLY; The name of the service.
	ServiceName *string `json:"serviceName,omitempty" azure:"ro"`

	// READ-ONLY; The service tier.
	ServiceTier *string `json:"serviceTier,omitempty" azure:"ro"`

	// READ-ONLY; The total included quantity associated with the offer.
	TotalIncludedQuantity *float64 `json:"totalIncludedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; The unit in which the meter consumption is charged, for example, 'Hours', 'GB', etc.
	Unit *string `json:"unit,omitempty" azure:"ro"`
}

// MeterDetailsResponse - The properties of the meter detail.
type MeterDetailsResponse struct {
	// READ-ONLY; The category of the meter, for example, 'Cloud services', 'Networking', etc..
	MeterCategory *string `json:"meterCategory,omitempty" azure:"ro"`

	// READ-ONLY; The name of the meter, within the given meter category
	MeterName *string `json:"meterName,omitempty" azure:"ro"`

	// READ-ONLY; The subcategory of the meter, for example, 'A6 Cloud services', 'ExpressRoute (IXP)', etc..
	MeterSubCategory *string `json:"meterSubCategory,omitempty" azure:"ro"`

	// READ-ONLY; The service family.
	ServiceFamily *string `json:"serviceFamily,omitempty" azure:"ro"`

	// READ-ONLY; The unit in which the meter consumption is charged, for example, 'Hours', 'GB', etc.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty" azure:"ro"`
}

// ModernChargeSummary - Modern charge summary.
type ModernChargeSummary struct {
	ChargeSummary
	// REQUIRED; Properties for modern charge summary
	Properties *ModernChargeSummaryProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernChargeSummary.
func (m ModernChargeSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ChargeSummary.marshalInternal(objectMap, ChargeSummaryKindModern)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernChargeSummary.
func (m *ModernChargeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ChargeSummary.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ModernChargeSummaryProperties - The properties of modern charge summary.
type ModernChargeSummaryProperties struct {
	// READ-ONLY; Azure Charges.
	AzureCharges *Amount `json:"azureCharges,omitempty" azure:"ro"`

	// READ-ONLY; Billing Account Id
	BillingAccountID *string `json:"billingAccountId,omitempty" azure:"ro"`

	// READ-ONLY; The id of the billing period resource that the charge belongs to.
	BillingPeriodID *string `json:"billingPeriodId,omitempty" azure:"ro"`

	// READ-ONLY; Billing Profile Id
	BillingProfileID *string `json:"billingProfileId,omitempty" azure:"ro"`

	// READ-ONLY; Charges Billed separately.
	ChargesBilledSeparately *Amount `json:"chargesBilledSeparately,omitempty" azure:"ro"`

	// READ-ONLY; Customer Id
	CustomerID *string `json:"customerId,omitempty" azure:"ro"`

	// READ-ONLY; Invoice Section Id
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty" azure:"ro"`

	// READ-ONLY; Is charge Invoiced
	IsInvoiced *bool `json:"isInvoiced,omitempty" azure:"ro"`

	// READ-ONLY; Marketplace Charges.
	MarketplaceCharges *Amount `json:"marketplaceCharges,omitempty" azure:"ro"`

	// READ-ONLY; Usage end date.
	UsageEnd *string `json:"usageEnd,omitempty" azure:"ro"`

	// READ-ONLY; Usage start date.
	UsageStart *string `json:"usageStart,omitempty" azure:"ro"`
}

// ModernReservationRecommendation - Modern reservation recommendation.
type ModernReservationRecommendation struct {
	ReservationRecommendation
	// REQUIRED; Properties for modern reservation recommendation
	Properties *ModernReservationRecommendationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationRecommendation.
func (m ModernReservationRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ReservationRecommendation.marshalInternal(objectMap, ReservationRecommendationKindModern)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernReservationRecommendation.
func (m *ModernReservationRecommendation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ReservationRecommendation.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ModernReservationRecommendationProperties - The properties of the reservation recommendation.
type ModernReservationRecommendationProperties struct {
	// READ-ONLY; The total amount of cost without reserved instances.
	CostWithNoReservedInstances *Amount `json:"costWithNoReservedInstances,omitempty" azure:"ro"`

	// READ-ONLY; The usage date for looking back.
	FirstUsageDate *time.Time `json:"firstUsageDate,omitempty" azure:"ro"`

	// READ-ONLY; The instance Flexibility Group.
	InstanceFlexibilityGroup *string `json:"instanceFlexibilityGroup,omitempty" azure:"ro"`

	// READ-ONLY; The instance Flexibility Ratio.
	InstanceFlexibilityRatio *float32 `json:"instanceFlexibilityRatio,omitempty" azure:"ro"`

	// READ-ONLY; Resource Location.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The number of days of usage to look back for recommendation.
	LookBackPeriod *int32 `json:"lookBackPeriod,omitempty" azure:"ro"`

	// READ-ONLY; The meter id (GUID)
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; Total estimated savings with reserved instances.
	NetSavings *Amount `json:"netSavings,omitempty" azure:"ro"`

	// READ-ONLY; The normalized Size.
	NormalizedSize *string `json:"normalizedSize,omitempty" azure:"ro"`

	// READ-ONLY; Recommended quality for reserved instances.
	RecommendedQuantity *float64 `json:"recommendedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; The recommended Quantity Normalized.
	RecommendedQuantityNormalized *float32 `json:"recommendedQuantityNormalized,omitempty" azure:"ro"`

	// READ-ONLY; This is the ARM Sku name.
	SKUName *string `json:"skuName,omitempty" azure:"ro"`

	// READ-ONLY; List of sku properties
	SKUProperties []*SKUProperty `json:"skuProperties,omitempty" azure:"ro"`

	// READ-ONLY; Shared or single recommendation.
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; RI recommendations in one or three year terms.
	Term *string `json:"term,omitempty" azure:"ro"`

	// READ-ONLY; The total amount of cost with reserved instances.
	TotalCostWithReservedInstances *Amount `json:"totalCostWithReservedInstances,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationRecommendationProperties.
func (m ModernReservationRecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costWithNoReservedInstances", m.CostWithNoReservedInstances)
	populateTimeRFC3339(objectMap, "firstUsageDate", m.FirstUsageDate)
	populate(objectMap, "instanceFlexibilityGroup", m.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", m.InstanceFlexibilityRatio)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "lookBackPeriod", m.LookBackPeriod)
	populate(objectMap, "meterId", m.MeterID)
	populate(objectMap, "netSavings", m.NetSavings)
	populate(objectMap, "normalizedSize", m.NormalizedSize)
	populate(objectMap, "recommendedQuantity", m.RecommendedQuantity)
	populate(objectMap, "recommendedQuantityNormalized", m.RecommendedQuantityNormalized)
	populate(objectMap, "skuName", m.SKUName)
	populate(objectMap, "skuProperties", m.SKUProperties)
	populate(objectMap, "scope", m.Scope)
	populate(objectMap, "term", m.Term)
	populate(objectMap, "totalCostWithReservedInstances", m.TotalCostWithReservedInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernReservationRecommendationProperties.
func (m *ModernReservationRecommendationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costWithNoReservedInstances":
			err = unpopulate(val, &m.CostWithNoReservedInstances)
			delete(rawMsg, key)
		case "firstUsageDate":
			err = unpopulateTimeRFC3339(val, &m.FirstUsageDate)
			delete(rawMsg, key)
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &m.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &m.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &m.Location)
			delete(rawMsg, key)
		case "lookBackPeriod":
			err = unpopulate(val, &m.LookBackPeriod)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &m.MeterID)
			delete(rawMsg, key)
		case "netSavings":
			err = unpopulate(val, &m.NetSavings)
			delete(rawMsg, key)
		case "normalizedSize":
			err = unpopulate(val, &m.NormalizedSize)
			delete(rawMsg, key)
		case "recommendedQuantity":
			err = unpopulate(val, &m.RecommendedQuantity)
			delete(rawMsg, key)
		case "recommendedQuantityNormalized":
			err = unpopulate(val, &m.RecommendedQuantityNormalized)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &m.SKUName)
			delete(rawMsg, key)
		case "skuProperties":
			err = unpopulate(val, &m.SKUProperties)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &m.Scope)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &m.Term)
			delete(rawMsg, key)
		case "totalCostWithReservedInstances":
			err = unpopulate(val, &m.TotalCostWithReservedInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ModernReservationTransaction - Modern Reservation transaction resource.
type ModernReservationTransaction struct {
	ReservationTransactionResource
	// REQUIRED; The properties of a modern reservation transaction.
	Properties *ModernReservationTransactionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationTransaction.
func (m ModernReservationTransaction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ReservationTransactionResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// ModernReservationTransactionProperties - The properties of a modern reservation transaction.
type ModernReservationTransactionProperties struct {
	// READ-ONLY; The charge of the transaction.
	Amount *float64 `json:"amount,omitempty" azure:"ro"`

	// READ-ONLY; This is the ARM Sku name. It can be used to join with the serviceType field in additional info in usage records.
	ArmSKUName *string `json:"armSkuName,omitempty" azure:"ro"`

	// READ-ONLY; The billing frequency, which can be either one-time or recurring.
	BillingFrequency *string `json:"billingFrequency,omitempty" azure:"ro"`

	// READ-ONLY; Billing profile Id.
	BillingProfileID *string `json:"billingProfileId,omitempty" azure:"ro"`

	// READ-ONLY; Billing profile name.
	BillingProfileName *string `json:"billingProfileName,omitempty" azure:"ro"`

	// READ-ONLY; The ISO currency in which the transaction is charged, for example, USD.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; The description of the transaction.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The date of the transaction
	EventDate *time.Time `json:"eventDate,omitempty" azure:"ro"`

	// READ-ONLY; The type of the transaction (Purchase, Cancel, etc.)
	EventType *string `json:"eventType,omitempty" azure:"ro"`

	// READ-ONLY; Invoice Number
	Invoice *string `json:"invoice,omitempty" azure:"ro"`

	// READ-ONLY; Invoice Id as on the invoice where the specific transaction appears.
	InvoiceID *string `json:"invoiceId,omitempty" azure:"ro"`

	// READ-ONLY; Invoice Section Id
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty" azure:"ro"`

	// READ-ONLY; Invoice Section Name.
	InvoiceSectionName *string `json:"invoiceSectionName,omitempty" azure:"ro"`

	// READ-ONLY; The subscription guid that makes the transaction.
	PurchasingSubscriptionGUID *string `json:"purchasingSubscriptionGuid,omitempty" azure:"ro"`

	// READ-ONLY; The subscription name that makes the transaction.
	PurchasingSubscriptionName *string `json:"purchasingSubscriptionName,omitempty" azure:"ro"`

	// READ-ONLY; The quantity of the transaction.
	Quantity *float64 `json:"quantity,omitempty" azure:"ro"`

	// READ-ONLY; The region of the transaction.
	Region *string `json:"region,omitempty" azure:"ro"`

	// READ-ONLY; The reservation order ID is the identifier for a reservation purchase. Each reservation order ID represents a single purchase transaction.
	// A reservation order contains reservations. The reservation
	// order specifies the VM size and region for the reservations.
	ReservationOrderID *string `json:"reservationOrderId,omitempty" azure:"ro"`

	// READ-ONLY; The name of the reservation order.
	ReservationOrderName *string `json:"reservationOrderName,omitempty" azure:"ro"`

	// READ-ONLY; This is the term of the transaction.
	Term *string `json:"term,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationTransactionProperties.
func (m ModernReservationTransactionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "amount", m.Amount)
	populate(objectMap, "armSkuName", m.ArmSKUName)
	populate(objectMap, "billingFrequency", m.BillingFrequency)
	populate(objectMap, "billingProfileId", m.BillingProfileID)
	populate(objectMap, "billingProfileName", m.BillingProfileName)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "description", m.Description)
	populateTimeRFC3339(objectMap, "eventDate", m.EventDate)
	populate(objectMap, "eventType", m.EventType)
	populate(objectMap, "invoice", m.Invoice)
	populate(objectMap, "invoiceId", m.InvoiceID)
	populate(objectMap, "invoiceSectionId", m.InvoiceSectionID)
	populate(objectMap, "invoiceSectionName", m.InvoiceSectionName)
	populate(objectMap, "purchasingSubscriptionGuid", m.PurchasingSubscriptionGUID)
	populate(objectMap, "purchasingSubscriptionName", m.PurchasingSubscriptionName)
	populate(objectMap, "quantity", m.Quantity)
	populate(objectMap, "region", m.Region)
	populate(objectMap, "reservationOrderId", m.ReservationOrderID)
	populate(objectMap, "reservationOrderName", m.ReservationOrderName)
	populate(objectMap, "term", m.Term)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernReservationTransactionProperties.
func (m *ModernReservationTransactionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "amount":
			err = unpopulate(val, &m.Amount)
			delete(rawMsg, key)
		case "armSkuName":
			err = unpopulate(val, &m.ArmSKUName)
			delete(rawMsg, key)
		case "billingFrequency":
			err = unpopulate(val, &m.BillingFrequency)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &m.BillingProfileID)
			delete(rawMsg, key)
		case "billingProfileName":
			err = unpopulate(val, &m.BillingProfileName)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &m.Currency)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "eventDate":
			err = unpopulateTimeRFC3339(val, &m.EventDate)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, &m.EventType)
			delete(rawMsg, key)
		case "invoice":
			err = unpopulate(val, &m.Invoice)
			delete(rawMsg, key)
		case "invoiceId":
			err = unpopulate(val, &m.InvoiceID)
			delete(rawMsg, key)
		case "invoiceSectionId":
			err = unpopulate(val, &m.InvoiceSectionID)
			delete(rawMsg, key)
		case "invoiceSectionName":
			err = unpopulate(val, &m.InvoiceSectionName)
			delete(rawMsg, key)
		case "purchasingSubscriptionGuid":
			err = unpopulate(val, &m.PurchasingSubscriptionGUID)
			delete(rawMsg, key)
		case "purchasingSubscriptionName":
			err = unpopulate(val, &m.PurchasingSubscriptionName)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &m.Quantity)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &m.Region)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &m.ReservationOrderID)
			delete(rawMsg, key)
		case "reservationOrderName":
			err = unpopulate(val, &m.ReservationOrderName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &m.Term)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ModernReservationTransactionsListResult - Result of listing reservation recommendations.
type ModernReservationTransactionsListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of reservation recommendations.
	Value []*ModernReservationTransaction `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationTransactionsListResult.
func (m ModernReservationTransactionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// ModernUsageDetail - Modern usage detail.
type ModernUsageDetail struct {
	UsageDetail
	// REQUIRED; Properties for modern usage details
	Properties *ModernUsageDetailProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernUsageDetail.
func (m ModernUsageDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.UsageDetail.marshalInternal(objectMap, UsageDetailsKindModern)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernUsageDetail.
func (m *ModernUsageDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.UsageDetail.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ModernUsageDetailProperties - The properties of the usage detail.
type ModernUsageDetailProperties struct {
	// READ-ONLY; Additional details of this usage item. Use this field to get usage line item specific details such as the actual VM Size (ServiceType) or
	// the ratio in which the reservation discount is applied.
	AdditionalInfo *string `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; Unique identifier for the applicable benefit.
	BenefitID *string `json:"benefitId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the applicable benefit.
	BenefitName *string `json:"benefitName,omitempty" azure:"ro"`

	// READ-ONLY; Billing Account identifier.
	BillingAccountID *string `json:"billingAccountId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the Billing Account.
	BillingAccountName *string `json:"billingAccountName,omitempty" azure:"ro"`

	// READ-ONLY; The currency defining the billed cost.
	BillingCurrencyCode *string `json:"billingCurrencyCode,omitempty" azure:"ro"`

	// READ-ONLY; Billing Period End Date as in the invoice.
	BillingPeriodEndDate *time.Time `json:"billingPeriodEndDate,omitempty" azure:"ro"`

	// READ-ONLY; Billing Period Start Date as in the invoice.
	BillingPeriodStartDate *time.Time `json:"billingPeriodStartDate,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the billing profile that groups costs across invoices in the a singular billing currency across across the customers who have
	// onboarded the Microsoft customer agreement and the
	// customers in CSP who have made entitlement purchases like SaaS, Marketplace, RI, etc.
	BillingProfileID *string `json:"billingProfileId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the billing profile that groups costs across invoices in the a singular billing currency across across the customers who have onboarded
	// the Microsoft customer agreement and the customers in
	// CSP who have made entitlement purchases like SaaS, Marketplace, RI, etc.
	BillingProfileName *string `json:"billingProfileName,omitempty" azure:"ro"`

	// READ-ONLY; Indicates a charge represents credits, usage, a Marketplace purchase, a reservation fee, or a refund.
	ChargeType *string `json:"chargeType,omitempty" azure:"ro"`

	// READ-ONLY; Consumed service name. Name of the azure resource provider that emits the usage or was purchased. This value is not provided for marketplace
	// usage.
	ConsumedService *string `json:"consumedService,omitempty" azure:"ro"`

	// READ-ONLY; Name for Cost Allocation Rule.
	CostAllocationRuleName *string `json:"costAllocationRuleName,omitempty" azure:"ro"`

	// READ-ONLY; The cost center of this department if it is a department and a cost center is provided.
	CostCenter *string `json:"costCenter,omitempty" azure:"ro"`

	// READ-ONLY; ExtendedCost or blended cost before tax in billed currency.
	CostInBillingCurrency *float64 `json:"costInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; ExtendedCost or blended cost before tax in pricing currency to correlate with prices.
	CostInPricingCurrency *float64 `json:"costInPricingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; Estimated extendedCost or blended cost before tax in USD.
	CostInUSD *float64 `json:"costInUSD,omitempty" azure:"ro"`

	// READ-ONLY; Name of the customer's AAD tenant.
	CustomerName *string `json:"customerName,omitempty" azure:"ro"`

	// READ-ONLY; Identifier of the customer's AAD tenant.
	CustomerTenantID *string `json:"customerTenantId,omitempty" azure:"ro"`

	// READ-ONLY; Date for the usage record.
	Date *time.Time `json:"date,omitempty" azure:"ro"`

	// READ-ONLY; Effective Price that's charged for the usage.
	EffectivePrice *float64 `json:"effectivePrice,omitempty" azure:"ro"`

	// READ-ONLY; Exchange rate used in conversion from pricing currency to billing currency.
	ExchangeRate *string `json:"exchangeRate,omitempty" azure:"ro"`

	// READ-ONLY; Date on which exchange rate used in conversion from pricing currency to billing currency.
	ExchangeRateDate *time.Time `json:"exchangeRateDate,omitempty" azure:"ro"`

	// READ-ONLY; Exchange Rate from pricing currency to billing currency.
	ExchangeRatePricingToBilling *float64 `json:"exchangeRatePricingToBilling,omitempty" azure:"ro"`

	// READ-ONLY; Indicates how frequently this charge will occur. OneTime for purchases which only happen once, Monthly for fees which recur every month, and
	// UsageBased for charges based on how much a service is used.
	Frequency *string `json:"frequency,omitempty" azure:"ro"`

	// READ-ONLY; Instance Name.
	InstanceName *string `json:"instanceName,omitempty" azure:"ro"`

	// READ-ONLY; Invoice ID as on the invoice where the specific transaction appears.
	InvoiceID *string `json:"invoiceId,omitempty" azure:"ro"`

	// READ-ONLY; Identifier of the project that is being charged in the invoice. Not applicable for Microsoft Customer Agreements onboarded by partners.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the project that is being charged in the invoice. Not applicable for Microsoft Customer Agreements onboarded by partners.
	InvoiceSectionName *string `json:"invoiceSectionName,omitempty" azure:"ro"`

	// READ-ONLY; Determines if the cost is eligible to be paid for using Azure credits.
	IsAzureCreditEligible *bool `json:"isAzureCreditEligible,omitempty" azure:"ro"`

	// READ-ONLY; Market Price that's charged for the usage.
	MarketPrice *float64 `json:"marketPrice,omitempty" azure:"ro"`

	// READ-ONLY; Identifies the top-level service for the usage.
	MeterCategory *string `json:"meterCategory,omitempty" azure:"ro"`

	// READ-ONLY; The meter id (GUID). Not available for marketplace. For reserved instance this represents the primary meter for which the reservation was
	// purchased. For the actual VM Size for which the reservation is
	// purchased see productOrderName.
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; Identifies the name of the meter against which consumption is measured.
	MeterName *string `json:"meterName,omitempty" azure:"ro"`

	// READ-ONLY; Identifies the location of the datacenter for certain services that are priced based on datacenter location.
	MeterRegion *string `json:"meterRegion,omitempty" azure:"ro"`

	// READ-ONLY; Defines the type or sub-category of Azure service that can affect the rate.
	MeterSubCategory *string `json:"meterSubCategory,omitempty" azure:"ro"`

	// READ-ONLY; Flag to indicate if partner earned credit has been applied or not.
	PartnerEarnedCreditApplied *string `json:"partnerEarnedCreditApplied,omitempty" azure:"ro"`

	// READ-ONLY; Rate of discount applied if there is a partner earned credit (PEC) based on partner admin link access.
	PartnerEarnedCreditRate *float64 `json:"partnerEarnedCreditRate,omitempty" azure:"ro"`

	// READ-ONLY; Name of the partner' AAD tenant.
	PartnerName *string `json:"partnerName,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the partner's AAD tenant.
	PartnerTenantID *string `json:"partnerTenantId,omitempty" azure:"ro"`

	// READ-ONLY; Retail price for the resource.
	PayGPrice *float64 `json:"payGPrice,omitempty" azure:"ro"`

	// READ-ONLY; The amount of PayG cost before tax in billing currency.
	PaygCostInBillingCurrency *float64 `json:"paygCostInBillingCurrency,omitempty" azure:"ro"`

	// READ-ONLY; The amount of PayG cost before tax in US Dollar currency.
	PaygCostInUSD *float64 `json:"paygCostInUSD,omitempty" azure:"ro"`

	// READ-ONLY; Reference to an original invoice there is a refund (negative cost). This is populated only when there is a refund.
	PreviousInvoiceID *string `json:"previousInvoiceId,omitempty" azure:"ro"`

	// READ-ONLY; Pricing Billing Currency.
	PricingCurrencyCode *string `json:"pricingCurrencyCode,omitempty" azure:"ro"`

	// READ-ONLY; Identifier that indicates how the meter is priced
	PricingModel *PricingModelType `json:"pricingModel,omitempty" azure:"ro"`

	// READ-ONLY; Name of the product that has accrued charges by consumption or purchase as listed in the invoice. Not available for Marketplace.
	Product *string `json:"product,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the product that has accrued charges by consumption or purchase . This is the concatenated key of productId and SkuId in partner
	// center.
	ProductIdentifier *string `json:"productIdentifier,omitempty" azure:"ro"`

	// READ-ONLY; The identifier for the asset or Azure plan name that the subscription belongs to. For example: Azure Plan. For reservations this is the Reservation
	// Order ID.
	ProductOrderID *string `json:"productOrderId,omitempty" azure:"ro"`

	// READ-ONLY; Product Order Name. For reservations this is the SKU that was purchased.
	ProductOrderName *string `json:"productOrderName,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for Product Category or Line Of Business, Ex - Azure, Microsoft 365, AWS e.t.c
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Publisher Id.
	PublisherID *string `json:"publisherId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the publisher of the service including Microsoft or Third Party publishers.
	PublisherName *string `json:"publisherName,omitempty" azure:"ro"`

	// READ-ONLY; Type of publisher that identifies if the publisher is first party, third party reseller or third party agency.
	PublisherType *string `json:"publisherType,omitempty" azure:"ro"`

	// READ-ONLY; Measure the quantity purchased or consumed.The amount of the meter used during the billing period.
	Quantity *float64 `json:"quantity,omitempty" azure:"ro"`

	// READ-ONLY; MPNId for the reseller associated with the subscription.
	ResellerMpnID *string `json:"resellerMpnId,omitempty" azure:"ro"`

	// READ-ONLY; Reseller Name.
	ResellerName *string `json:"resellerName,omitempty" azure:"ro"`

	// READ-ONLY; ARM resource id of the reservation. Only applies to records relevant to reservations.
	ReservationID *string `json:"reservationId,omitempty" azure:"ro"`

	// READ-ONLY; User provided display name of the reservation. Last known name for a particular day is populated in the daily data. Only applies to records
	// relevant to reservations.
	ReservationName *string `json:"reservationName,omitempty" azure:"ro"`

	// READ-ONLY; Name of the Azure resource group used for cohesive lifecycle management of resources.
	ResourceGroup *string `json:"resourceGroup,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource location.
	ResourceLocation *string `json:"resourceLocation,omitempty" azure:"ro"`

	// READ-ONLY; Resource Location Normalized.
	ResourceLocationNormalized *string `json:"resourceLocationNormalized,omitempty" azure:"ro"`

	// READ-ONLY; List the service family for the product purchased or charged (Example: Storage ; Compute).
	ServiceFamily *string `json:"serviceFamily,omitempty" azure:"ro"`

	// READ-ONLY; Service-specific metadata.
	ServiceInfo1 *string `json:"serviceInfo1,omitempty" azure:"ro"`

	// READ-ONLY; Legacy field with optional service-specific metadata.
	ServiceInfo2 *string `json:"serviceInfo2,omitempty" azure:"ro"`

	// READ-ONLY; End date for the period when the service usage was rated for charges. The prices for Azure services are determined based on the rating period.
	ServicePeriodEndDate *time.Time `json:"servicePeriodEndDate,omitempty" azure:"ro"`

	// READ-ONLY; Start date for the rating period when the service usage was rated for charges. The prices for Azure services are determined for the rating
	// period.
	ServicePeriodStartDate *time.Time `json:"servicePeriodStartDate,omitempty" azure:"ro"`

	// READ-ONLY; Unique Microsoft generated identifier for the Azure Subscription.
	SubscriptionGUID *string `json:"subscriptionGuid,omitempty" azure:"ro"`

	// READ-ONLY; Name of the Azure Subscription.
	SubscriptionName *string `json:"subscriptionName,omitempty" azure:"ro"`

	// READ-ONLY; Term (in months). Displays the term for the validity of the offer. For example. In case of reserved instances it displays 12 months for yearly
	// term of reserved instance. For one time purchases or
	// recurring purchases, the terms displays 1 month; This is not applicable for Azure consumption.
	Term *string `json:"term,omitempty" azure:"ro"`

	// READ-ONLY; Identifies the Unit that the service is charged in. For example, GB, hours, 10,000 s.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty" azure:"ro"`

	// READ-ONLY; Unit Price is the price applicable to you. (your EA or other contract price).
	UnitPrice *float64 `json:"unitPrice,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModernUsageDetailProperties.
func (m ModernUsageDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", m.AdditionalInfo)
	populate(objectMap, "benefitId", m.BenefitID)
	populate(objectMap, "benefitName", m.BenefitName)
	populate(objectMap, "billingAccountId", m.BillingAccountID)
	populate(objectMap, "billingAccountName", m.BillingAccountName)
	populate(objectMap, "billingCurrencyCode", m.BillingCurrencyCode)
	populateTimeRFC3339(objectMap, "billingPeriodEndDate", m.BillingPeriodEndDate)
	populateTimeRFC3339(objectMap, "billingPeriodStartDate", m.BillingPeriodStartDate)
	populate(objectMap, "billingProfileId", m.BillingProfileID)
	populate(objectMap, "billingProfileName", m.BillingProfileName)
	populate(objectMap, "chargeType", m.ChargeType)
	populate(objectMap, "consumedService", m.ConsumedService)
	populate(objectMap, "costAllocationRuleName", m.CostAllocationRuleName)
	populate(objectMap, "costCenter", m.CostCenter)
	populate(objectMap, "costInBillingCurrency", m.CostInBillingCurrency)
	populate(objectMap, "costInPricingCurrency", m.CostInPricingCurrency)
	populate(objectMap, "costInUSD", m.CostInUSD)
	populate(objectMap, "customerName", m.CustomerName)
	populate(objectMap, "customerTenantId", m.CustomerTenantID)
	populateTimeRFC3339(objectMap, "date", m.Date)
	populate(objectMap, "effectivePrice", m.EffectivePrice)
	populate(objectMap, "exchangeRate", m.ExchangeRate)
	populateTimeRFC3339(objectMap, "exchangeRateDate", m.ExchangeRateDate)
	populate(objectMap, "exchangeRatePricingToBilling", m.ExchangeRatePricingToBilling)
	populate(objectMap, "frequency", m.Frequency)
	populate(objectMap, "instanceName", m.InstanceName)
	populate(objectMap, "invoiceId", m.InvoiceID)
	populate(objectMap, "invoiceSectionId", m.InvoiceSectionID)
	populate(objectMap, "invoiceSectionName", m.InvoiceSectionName)
	populate(objectMap, "isAzureCreditEligible", m.IsAzureCreditEligible)
	populate(objectMap, "marketPrice", m.MarketPrice)
	populate(objectMap, "meterCategory", m.MeterCategory)
	populate(objectMap, "meterId", m.MeterID)
	populate(objectMap, "meterName", m.MeterName)
	populate(objectMap, "meterRegion", m.MeterRegion)
	populate(objectMap, "meterSubCategory", m.MeterSubCategory)
	populate(objectMap, "partnerEarnedCreditApplied", m.PartnerEarnedCreditApplied)
	populate(objectMap, "partnerEarnedCreditRate", m.PartnerEarnedCreditRate)
	populate(objectMap, "partnerName", m.PartnerName)
	populate(objectMap, "partnerTenantId", m.PartnerTenantID)
	populate(objectMap, "payGPrice", m.PayGPrice)
	populate(objectMap, "paygCostInBillingCurrency", m.PaygCostInBillingCurrency)
	populate(objectMap, "paygCostInUSD", m.PaygCostInUSD)
	populate(objectMap, "previousInvoiceId", m.PreviousInvoiceID)
	populate(objectMap, "pricingCurrencyCode", m.PricingCurrencyCode)
	populate(objectMap, "pricingModel", m.PricingModel)
	populate(objectMap, "product", m.Product)
	populate(objectMap, "productIdentifier", m.ProductIdentifier)
	populate(objectMap, "productOrderId", m.ProductOrderID)
	populate(objectMap, "productOrderName", m.ProductOrderName)
	populate(objectMap, "provider", m.Provider)
	populate(objectMap, "publisherId", m.PublisherID)
	populate(objectMap, "publisherName", m.PublisherName)
	populate(objectMap, "publisherType", m.PublisherType)
	populate(objectMap, "quantity", m.Quantity)
	populate(objectMap, "resellerMpnId", m.ResellerMpnID)
	populate(objectMap, "resellerName", m.ResellerName)
	populate(objectMap, "reservationId", m.ReservationID)
	populate(objectMap, "reservationName", m.ReservationName)
	populate(objectMap, "resourceGroup", m.ResourceGroup)
	populate(objectMap, "resourceLocation", m.ResourceLocation)
	populate(objectMap, "resourceLocationNormalized", m.ResourceLocationNormalized)
	populate(objectMap, "serviceFamily", m.ServiceFamily)
	populate(objectMap, "serviceInfo1", m.ServiceInfo1)
	populate(objectMap, "serviceInfo2", m.ServiceInfo2)
	populateTimeRFC3339(objectMap, "servicePeriodEndDate", m.ServicePeriodEndDate)
	populateTimeRFC3339(objectMap, "servicePeriodStartDate", m.ServicePeriodStartDate)
	populate(objectMap, "subscriptionGuid", m.SubscriptionGUID)
	populate(objectMap, "subscriptionName", m.SubscriptionName)
	populate(objectMap, "term", m.Term)
	populate(objectMap, "unitOfMeasure", m.UnitOfMeasure)
	populate(objectMap, "unitPrice", m.UnitPrice)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernUsageDetailProperties.
func (m *ModernUsageDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, &m.AdditionalInfo)
			delete(rawMsg, key)
		case "benefitId":
			err = unpopulate(val, &m.BenefitID)
			delete(rawMsg, key)
		case "benefitName":
			err = unpopulate(val, &m.BenefitName)
			delete(rawMsg, key)
		case "billingAccountId":
			err = unpopulate(val, &m.BillingAccountID)
			delete(rawMsg, key)
		case "billingAccountName":
			err = unpopulate(val, &m.BillingAccountName)
			delete(rawMsg, key)
		case "billingCurrencyCode":
			err = unpopulate(val, &m.BillingCurrencyCode)
			delete(rawMsg, key)
		case "billingPeriodEndDate":
			err = unpopulateTimeRFC3339(val, &m.BillingPeriodEndDate)
			delete(rawMsg, key)
		case "billingPeriodStartDate":
			err = unpopulateTimeRFC3339(val, &m.BillingPeriodStartDate)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &m.BillingProfileID)
			delete(rawMsg, key)
		case "billingProfileName":
			err = unpopulate(val, &m.BillingProfileName)
			delete(rawMsg, key)
		case "chargeType":
			err = unpopulate(val, &m.ChargeType)
			delete(rawMsg, key)
		case "consumedService":
			err = unpopulate(val, &m.ConsumedService)
			delete(rawMsg, key)
		case "costAllocationRuleName":
			err = unpopulate(val, &m.CostAllocationRuleName)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &m.CostCenter)
			delete(rawMsg, key)
		case "costInBillingCurrency":
			err = unpopulate(val, &m.CostInBillingCurrency)
			delete(rawMsg, key)
		case "costInPricingCurrency":
			err = unpopulate(val, &m.CostInPricingCurrency)
			delete(rawMsg, key)
		case "costInUSD":
			err = unpopulate(val, &m.CostInUSD)
			delete(rawMsg, key)
		case "customerName":
			err = unpopulate(val, &m.CustomerName)
			delete(rawMsg, key)
		case "customerTenantId":
			err = unpopulate(val, &m.CustomerTenantID)
			delete(rawMsg, key)
		case "date":
			err = unpopulateTimeRFC3339(val, &m.Date)
			delete(rawMsg, key)
		case "effectivePrice":
			err = unpopulate(val, &m.EffectivePrice)
			delete(rawMsg, key)
		case "exchangeRate":
			err = unpopulate(val, &m.ExchangeRate)
			delete(rawMsg, key)
		case "exchangeRateDate":
			err = unpopulateTimeRFC3339(val, &m.ExchangeRateDate)
			delete(rawMsg, key)
		case "exchangeRatePricingToBilling":
			err = unpopulate(val, &m.ExchangeRatePricingToBilling)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &m.Frequency)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, &m.InstanceName)
			delete(rawMsg, key)
		case "invoiceId":
			err = unpopulate(val, &m.InvoiceID)
			delete(rawMsg, key)
		case "invoiceSectionId":
			err = unpopulate(val, &m.InvoiceSectionID)
			delete(rawMsg, key)
		case "invoiceSectionName":
			err = unpopulate(val, &m.InvoiceSectionName)
			delete(rawMsg, key)
		case "isAzureCreditEligible":
			err = unpopulate(val, &m.IsAzureCreditEligible)
			delete(rawMsg, key)
		case "marketPrice":
			err = unpopulate(val, &m.MarketPrice)
			delete(rawMsg, key)
		case "meterCategory":
			err = unpopulate(val, &m.MeterCategory)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &m.MeterID)
			delete(rawMsg, key)
		case "meterName":
			err = unpopulate(val, &m.MeterName)
			delete(rawMsg, key)
		case "meterRegion":
			err = unpopulate(val, &m.MeterRegion)
			delete(rawMsg, key)
		case "meterSubCategory":
			err = unpopulate(val, &m.MeterSubCategory)
			delete(rawMsg, key)
		case "partnerEarnedCreditApplied":
			err = unpopulate(val, &m.PartnerEarnedCreditApplied)
			delete(rawMsg, key)
		case "partnerEarnedCreditRate":
			err = unpopulate(val, &m.PartnerEarnedCreditRate)
			delete(rawMsg, key)
		case "partnerName":
			err = unpopulate(val, &m.PartnerName)
			delete(rawMsg, key)
		case "partnerTenantId":
			err = unpopulate(val, &m.PartnerTenantID)
			delete(rawMsg, key)
		case "payGPrice":
			err = unpopulate(val, &m.PayGPrice)
			delete(rawMsg, key)
		case "paygCostInBillingCurrency":
			err = unpopulate(val, &m.PaygCostInBillingCurrency)
			delete(rawMsg, key)
		case "paygCostInUSD":
			err = unpopulate(val, &m.PaygCostInUSD)
			delete(rawMsg, key)
		case "previousInvoiceId":
			err = unpopulate(val, &m.PreviousInvoiceID)
			delete(rawMsg, key)
		case "pricingCurrencyCode":
			err = unpopulate(val, &m.PricingCurrencyCode)
			delete(rawMsg, key)
		case "pricingModel":
			err = unpopulate(val, &m.PricingModel)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, &m.Product)
			delete(rawMsg, key)
		case "productIdentifier":
			err = unpopulate(val, &m.ProductIdentifier)
			delete(rawMsg, key)
		case "productOrderId":
			err = unpopulate(val, &m.ProductOrderID)
			delete(rawMsg, key)
		case "productOrderName":
			err = unpopulate(val, &m.ProductOrderName)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, &m.Provider)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, &m.PublisherID)
			delete(rawMsg, key)
		case "publisherName":
			err = unpopulate(val, &m.PublisherName)
			delete(rawMsg, key)
		case "publisherType":
			err = unpopulate(val, &m.PublisherType)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &m.Quantity)
			delete(rawMsg, key)
		case "resellerMpnId":
			err = unpopulate(val, &m.ResellerMpnID)
			delete(rawMsg, key)
		case "resellerName":
			err = unpopulate(val, &m.ResellerName)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &m.ReservationID)
			delete(rawMsg, key)
		case "reservationName":
			err = unpopulate(val, &m.ReservationName)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, &m.ResourceGroup)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, &m.ResourceLocation)
			delete(rawMsg, key)
		case "resourceLocationNormalized":
			err = unpopulate(val, &m.ResourceLocationNormalized)
			delete(rawMsg, key)
		case "serviceFamily":
			err = unpopulate(val, &m.ServiceFamily)
			delete(rawMsg, key)
		case "serviceInfo1":
			err = unpopulate(val, &m.ServiceInfo1)
			delete(rawMsg, key)
		case "serviceInfo2":
			err = unpopulate(val, &m.ServiceInfo2)
			delete(rawMsg, key)
		case "servicePeriodEndDate":
			err = unpopulateTimeRFC3339(val, &m.ServicePeriodEndDate)
			delete(rawMsg, key)
		case "servicePeriodStartDate":
			err = unpopulateTimeRFC3339(val, &m.ServicePeriodStartDate)
			delete(rawMsg, key)
		case "subscriptionGuid":
			err = unpopulate(val, &m.SubscriptionGUID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, &m.SubscriptionName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &m.Term)
			delete(rawMsg, key)
		case "unitOfMeasure":
			err = unpopulate(val, &m.UnitOfMeasure)
			delete(rawMsg, key)
		case "unitPrice":
			err = unpopulate(val, &m.UnitPrice)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Notification - The notification associated with a budget.
type Notification struct {
	// REQUIRED; Email addresses to send the budget notification to when the threshold is exceeded. Must have at least one contact email or contact group specified
	// at the Subscription or Resource Group scopes. All
	// other scopes must have at least one contact email specified.
	ContactEmails []*string `json:"contactEmails,omitempty"`

	// REQUIRED; The notification is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// REQUIRED; The comparison operator.
	Operator *OperatorType `json:"operator,omitempty"`

	// REQUIRED; Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to
	// be between 0 and 1000.
	Threshold *float64 `json:"threshold,omitempty"`

	// Action groups to send the budget notification to when the threshold is exceeded. Must be provided as a fully qualified Azure resource id. Only supported
	// at Subscription or Resource Group scopes.
	ContactGroups []*string `json:"contactGroups,omitempty"`

	// Contact roles to send the budget notification to when the threshold is exceeded.
	ContactRoles []*string `json:"contactRoles,omitempty"`

	// The type of threshold
	ThresholdType *ThresholdType `json:"thresholdType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Notification.
func (n Notification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contactEmails", n.ContactEmails)
	populate(objectMap, "contactGroups", n.ContactGroups)
	populate(objectMap, "contactRoles", n.ContactRoles)
	populate(objectMap, "enabled", n.Enabled)
	populate(objectMap, "operator", n.Operator)
	populate(objectMap, "threshold", n.Threshold)
	populate(objectMap, "thresholdType", n.ThresholdType)
	return json.Marshal(objectMap)
}

// Operation - A Consumption REST API operation.
type Operation struct {
	// The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Operation Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// OperationDisplay - The object that represents the operation.
type OperationDisplay struct {
	// READ-ONLY; Description of the operation.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Operation type: Read, write, delete, etc.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Service provider: Microsoft.Consumption.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource on which the operation is performed: UsageDetail, etc.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - Result of listing consumption operations. It contains a list of operations and a URL link to get the next set of results.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of consumption operations supported by the Microsoft.Consumption resource provider.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PriceSheetGetByBillingPeriodOptions contains the optional parameters for the PriceSheet.GetByBillingPeriod method.
type PriceSheetGetByBillingPeriodOptions struct {
	// May be used to expand the properties/meterDetails within a price sheet. By default, these fields are not included when returning price sheet.
	Expand *string
	// Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink
	// element will include a skiptoken parameter that specifies a starting point to use for subsequent calls.
	Skiptoken *string
	// May be used to limit the number of results to the top N results.
	Top *int32
}

// PriceSheetGetOptions contains the optional parameters for the PriceSheet.Get method.
type PriceSheetGetOptions struct {
	// May be used to expand the properties/meterDetails within a price sheet. By default, these fields are not included when returning price sheet.
	Expand *string
	// Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink
	// element will include a skiptoken parameter that specifies a starting point to use for subsequent calls.
	Skiptoken *string
	// May be used to limit the number of results to the top N results.
	Top *int32
}

// PriceSheetModel - price sheet result. It contains the pricesheet associated with billing period
type PriceSheetModel struct {
	// READ-ONLY; Pricesheet download details.
	Download *MeterDetails `json:"download,omitempty" azure:"ro"`

	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Price sheet
	Pricesheets []*PriceSheetProperties `json:"pricesheets,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PriceSheetModel.
func (p PriceSheetModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "download", p.Download)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "pricesheets", p.Pricesheets)
	return json.Marshal(objectMap)
}

// PriceSheetProperties - The properties of the price sheet.
type PriceSheetProperties struct {
	// READ-ONLY; The id of the billing period resource that the usage belongs to.
	BillingPeriodID *string `json:"billingPeriodId,omitempty" azure:"ro"`

	// READ-ONLY; Currency Code
	CurrencyCode *string `json:"currencyCode,omitempty" azure:"ro"`

	// READ-ONLY; Included quality for an offer
	IncludedQuantity *float64 `json:"includedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; The details about the meter. By default this is not populated, unless it's specified in $expand.
	MeterDetails *MeterDetails `json:"meterDetails,omitempty" azure:"ro"`

	// READ-ONLY; The meter id (GUID)
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; Offer Id
	OfferID *string `json:"offerId,omitempty" azure:"ro"`

	// READ-ONLY; Part Number
	PartNumber *string `json:"partNumber,omitempty" azure:"ro"`

	// READ-ONLY; Unit of measure
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty" azure:"ro"`

	// READ-ONLY; Unit Price
	UnitPrice *float64 `json:"unitPrice,omitempty" azure:"ro"`
}

// PriceSheetResult - An pricesheet resource.
type PriceSheetResult struct {
	Resource
	// price sheet result. It contains the pricesheet associated with billing period
	Properties *PriceSheetModel `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PriceSheetResult.
func (p PriceSheetResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PriceSheetResult.
func (p *PriceSheetResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ProxyResource - The Resource model definition.
type ProxyResource struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating the latest version or not.
	ETag *string `json:"eTag,omitempty"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// Reseller - The reseller properties.
type Reseller struct {
	// READ-ONLY; The reseller property description.
	ResellerDescription *string `json:"resellerDescription,omitempty" azure:"ro"`

	// READ-ONLY; The reseller property ID.
	ResellerID *string `json:"resellerId,omitempty" azure:"ro"`
}

// ReservationDetail - reservation detail resource.
type ReservationDetail struct {
	Resource
	// The properties of the reservation detail.
	Properties *ReservationDetailProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationDetail.
func (r ReservationDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationDetail.
func (r *ReservationDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReservationDetailProperties - The properties of the reservation detail.
type ReservationDetailProperties struct {
	// READ-ONLY; The instance Flexibility Group.
	InstanceFlexibilityGroup *string `json:"instanceFlexibilityGroup,omitempty" azure:"ro"`

	// READ-ONLY; The instance Flexibility Ratio.
	InstanceFlexibilityRatio *string `json:"instanceFlexibilityRatio,omitempty" azure:"ro"`

	// READ-ONLY; This identifier is the name of the resource or the fully qualified Resource ID.
	InstanceID *string `json:"instanceId,omitempty" azure:"ro"`

	// READ-ONLY; The reservation kind.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The reservation ID is the identifier of a reservation within a reservation order. Each reservation is the grouping for applying the benefit
	// scope and also specifies the number of instances to which
	// the reservation benefit can be applied to.
	ReservationID *string `json:"reservationId,omitempty" azure:"ro"`

	// READ-ONLY; The reservation order ID is the identifier for a reservation purchase. Each reservation order ID represents a single purchase transaction.
	// A reservation order contains reservations. The reservation
	// order specifies the VM size and region for the reservations.
	ReservationOrderID *string `json:"reservationOrderId,omitempty" azure:"ro"`

	// READ-ONLY; This is the total hours reserved for the day. E.g. if reservation for 1 instance was made on 1 PM, this will be 11 hours for that day and
	// 24 hours from subsequent days.
	ReservedHours *float64 `json:"reservedHours,omitempty" azure:"ro"`

	// READ-ONLY; This is the ARM Sku name. It can be used to join with the serviceType field in additional info in usage records.
	SKUName *string `json:"skuName,omitempty" azure:"ro"`

	// READ-ONLY; This is the total count of instances that are reserved for the reservationId.
	TotalReservedQuantity *float64 `json:"totalReservedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; The date on which consumption occurred.
	UsageDate *time.Time `json:"usageDate,omitempty" azure:"ro"`

	// READ-ONLY; This is the total hours used by the instance.
	UsedHours *float64 `json:"usedHours,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationDetailProperties.
func (r ReservationDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "instanceFlexibilityGroup", r.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", r.InstanceFlexibilityRatio)
	populate(objectMap, "instanceId", r.InstanceID)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "reservationId", r.ReservationID)
	populate(objectMap, "reservationOrderId", r.ReservationOrderID)
	populate(objectMap, "reservedHours", r.ReservedHours)
	populate(objectMap, "skuName", r.SKUName)
	populate(objectMap, "totalReservedQuantity", r.TotalReservedQuantity)
	populateTimeRFC3339(objectMap, "usageDate", r.UsageDate)
	populate(objectMap, "usedHours", r.UsedHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationDetailProperties.
func (r *ReservationDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &r.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &r.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, &r.InstanceID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &r.ReservationID)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &r.ReservationOrderID)
			delete(rawMsg, key)
		case "reservedHours":
			err = unpopulate(val, &r.ReservedHours)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &r.SKUName)
			delete(rawMsg, key)
		case "totalReservedQuantity":
			err = unpopulate(val, &r.TotalReservedQuantity)
			delete(rawMsg, key)
		case "usageDate":
			err = unpopulateTimeRFC3339(val, &r.UsageDate)
			delete(rawMsg, key)
		case "usedHours":
			err = unpopulate(val, &r.UsedHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ReservationDetailsListResult - Result of listing reservation details.
type ReservationDetailsListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of reservation details.
	Value []*ReservationDetail `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationDetailsListResult.
func (r ReservationDetailsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// ReservationRecommendationClassification provides polymorphic access to related types.
// Call the interface's GetReservationRecommendation() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *LegacyReservationRecommendation, *ModernReservationRecommendation, *ReservationRecommendation
type ReservationRecommendationClassification interface {
	// GetReservationRecommendation returns the ReservationRecommendation content of the underlying type.
	GetReservationRecommendation() *ReservationRecommendation
}

// ReservationRecommendation - A reservation recommendation resource.
type ReservationRecommendation struct {
	Resource
	ResourceAttributes
	// REQUIRED; Specifies the kind of reservation recommendation.
	Kind *ReservationRecommendationKind `json:"kind,omitempty"`
}

// GetReservationRecommendation implements the ReservationRecommendationClassification interface for type ReservationRecommendation.
func (r *ReservationRecommendation) GetReservationRecommendation() *ReservationRecommendation {
	return r
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationRecommendation.
func (r *ReservationRecommendation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r ReservationRecommendation) marshalInternal(objectMap map[string]interface{}, discValue ReservationRecommendationKind) {
	r.Resource.marshalInternal(objectMap)
	r.ResourceAttributes.marshalInternal(objectMap)
	r.Kind = &discValue
	objectMap["kind"] = r.Kind
}

func (r *ReservationRecommendation) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	if err := r.ResourceAttributes.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReservationRecommendationDetailsCalculatedSavingsProperties - Details of estimated savings.
type ReservationRecommendationDetailsCalculatedSavingsProperties struct {
	// The number of reserved units used to calculate savings. Always 1 for virtual machines.
	ReservedUnitCount *float32 `json:"reservedUnitCount,omitempty"`

	// READ-ONLY; The cost without reservation.
	OnDemandCost *float32 `json:"onDemandCost,omitempty" azure:"ro"`

	// READ-ONLY; The difference between total reservation cost and reservation cost.
	OverageCost *float32 `json:"overageCost,omitempty" azure:"ro"`

	// READ-ONLY; The quantity for calculated savings.
	Quantity *float32 `json:"quantity,omitempty" azure:"ro"`

	// READ-ONLY; The exact cost of the estimated usage using reservation.
	ReservationCost *float32 `json:"reservationCost,omitempty" azure:"ro"`

	// READ-ONLY; The amount saved by purchasing the recommended quantity of reservation.
	Savings *float32 `json:"savings,omitempty" azure:"ro"`

	// READ-ONLY; The cost of the suggested quantity.
	TotalReservationCost *float32 `json:"totalReservationCost,omitempty" azure:"ro"`
}

// ReservationRecommendationDetailsGetOptions contains the optional parameters for the ReservationRecommendationDetails.Get method.
type ReservationRecommendationDetailsGetOptions struct {
	// placeholder for future optional parameters
}

// ReservationRecommendationDetailsModel - Reservation recommendation details.
type ReservationRecommendationDetailsModel struct {
	Resource
	// Resource Location.
	Location *string `json:"location,omitempty"`

	// The properties of the reservation recommendation.
	Properties *ReservationRecommendationDetailsProperties `json:"properties,omitempty"`

	// Resource sku
	SKU *string `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsModel.
func (r ReservationRecommendationDetailsModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationRecommendationDetailsModel.
func (r *ReservationRecommendationDetailsModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &r.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &r.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReservationRecommendationDetailsProperties - The properties of the reservation recommendation.
type ReservationRecommendationDetailsProperties struct {
	// READ-ONLY; An ISO 4217 currency code identifier for the costs and savings
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; Resource specific properties.
	Resource *ReservationRecommendationDetailsResourceProperties `json:"resource,omitempty" azure:"ro"`

	// READ-ONLY; Resource Group.
	ResourceGroup *string `json:"resourceGroup,omitempty" azure:"ro"`

	// READ-ONLY; Savings information for the recommendation.
	Savings *ReservationRecommendationDetailsSavingsProperties `json:"savings,omitempty" azure:"ro"`

	// READ-ONLY; Scope of the reservation, ex: Single or Shared.
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; Historical usage details used to calculate the estimated savings.
	Usage *ReservationRecommendationDetailsUsageProperties `json:"usage,omitempty" azure:"ro"`
}

// ReservationRecommendationDetailsResourceProperties - Details of the resource.
type ReservationRecommendationDetailsResourceProperties struct {
	// READ-ONLY; List of subscriptions for which the reservation is applied.
	AppliedScopes []*string `json:"appliedScopes,omitempty" azure:"ro"`

	// READ-ONLY; On demand rate of the resource.
	OnDemandRate *float32 `json:"onDemandRate,omitempty" azure:"ro"`

	// READ-ONLY; Azure product ex: StandardE8sv3 etc.
	Product *string `json:"product,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource region ex:EastUS, WestUS etc.
	Region *string `json:"region,omitempty" azure:"ro"`

	// READ-ONLY; Reservation rate of the resource.
	ReservationRate *float32 `json:"reservationRate,omitempty" azure:"ro"`

	// READ-ONLY; The azure resource type.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsResourceProperties.
func (r ReservationRecommendationDetailsResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedScopes", r.AppliedScopes)
	populate(objectMap, "onDemandRate", r.OnDemandRate)
	populate(objectMap, "product", r.Product)
	populate(objectMap, "region", r.Region)
	populate(objectMap, "reservationRate", r.ReservationRate)
	populate(objectMap, "resourceType", r.ResourceType)
	return json.Marshal(objectMap)
}

// ReservationRecommendationDetailsSavingsProperties - Details of the estimated savings.
type ReservationRecommendationDetailsSavingsProperties struct {
	// List of calculated savings.
	CalculatedSavings []*ReservationRecommendationDetailsCalculatedSavingsProperties `json:"calculatedSavings,omitempty"`

	// READ-ONLY; Number of days of usage to look back used for computing the recommendation.
	LookBackPeriod *int32 `json:"lookBackPeriod,omitempty" azure:"ro"`

	// READ-ONLY; Number of recommended units of the resource.
	RecommendedQuantity *float32 `json:"recommendedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; Term period of the reservation, ex: P1Y or P3Y.
	ReservationOrderTerm *string `json:"reservationOrderTerm,omitempty" azure:"ro"`

	// READ-ONLY; Type of savings, ex: instance.
	SavingsType *string `json:"savingsType,omitempty" azure:"ro"`

	// READ-ONLY; Measurement unit ex: hour etc.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsSavingsProperties.
func (r ReservationRecommendationDetailsSavingsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "calculatedSavings", r.CalculatedSavings)
	populate(objectMap, "lookBackPeriod", r.LookBackPeriod)
	populate(objectMap, "recommendedQuantity", r.RecommendedQuantity)
	populate(objectMap, "reservationOrderTerm", r.ReservationOrderTerm)
	populate(objectMap, "savingsType", r.SavingsType)
	populate(objectMap, "unitOfMeasure", r.UnitOfMeasure)
	return json.Marshal(objectMap)
}

// ReservationRecommendationDetailsUsageProperties - Details about historical usage data that has been used for computing the recommendation.
type ReservationRecommendationDetailsUsageProperties struct {
	// READ-ONLY; The first usage date used for looking back for computing the recommendation.
	FirstConsumptionDate *string `json:"firstConsumptionDate,omitempty" azure:"ro"`

	// READ-ONLY; The last usage date used for looking back for computing the recommendation.
	LastConsumptionDate *string `json:"lastConsumptionDate,omitempty" azure:"ro"`

	// READ-ONLY; What the usage data values represent ex: virtual machine instance.
	LookBackUnitType *string `json:"lookBackUnitType,omitempty" azure:"ro"`

	// READ-ONLY; The breakdown of historical resource usage. The values are in the order of usage between the firstConsumptionDate and the lastConsumptionDate.
	UsageData []*float32 `json:"usageData,omitempty" azure:"ro"`

	// READ-ONLY; The grain of the values represented in the usage data ex: hourly.
	UsageGrain *string `json:"usageGrain,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsUsageProperties.
func (r ReservationRecommendationDetailsUsageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "firstConsumptionDate", r.FirstConsumptionDate)
	populate(objectMap, "lastConsumptionDate", r.LastConsumptionDate)
	populate(objectMap, "lookBackUnitType", r.LookBackUnitType)
	populate(objectMap, "usageData", r.UsageData)
	populate(objectMap, "usageGrain", r.UsageGrain)
	return json.Marshal(objectMap)
}

// ReservationRecommendationsListOptions contains the optional parameters for the ReservationRecommendations.List method.
type ReservationRecommendationsListOptions struct {
	// May be used to filter reservationRecommendations by: properties/scope with allowed values ['Single', 'Shared'] and default value 'Single'; properties/resourceType
	// with allowed values ['VirtualMachines', 'SQLDatabases', 'PostgreSQL', 'ManagedDisk', 'MySQL', 'RedHat', 'MariaDB', 'RedisCache', 'CosmosDB', 'SqlDataWarehouse',
	// 'SUSELinux', 'AppService', 'BlockBlob', 'AzureDataExplorer', 'VMwareCloudSimple'] and default value 'VirtualMachines'; and properties/lookBackPeriod
	// with allowed values ['Last7Days', 'Last30Days', 'Last60Days'] and default value 'Last7Days'.
	Filter *string
}

// ReservationRecommendationsListResult - Result of listing reservation recommendations.
type ReservationRecommendationsListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The link (url) to the previous page of results.
	PreviousLink *string `json:"previousLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of reservation recommendations.
	Value []ReservationRecommendationClassification `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationsListResult.
func (r ReservationRecommendationsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "previousLink", r.PreviousLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationRecommendationsListResult.
func (r *ReservationRecommendationsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &r.NextLink)
			delete(rawMsg, key)
		case "previousLink":
			err = unpopulate(val, &r.PreviousLink)
			delete(rawMsg, key)
		case "value":
			r.Value, err = unmarshalReservationRecommendationClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ReservationSummariesListResult - Result of listing reservation summaries.
type ReservationSummariesListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of reservation summaries.
	Value []*ReservationSummary `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationSummariesListResult.
func (r ReservationSummariesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// ReservationSummary - reservation summary resource.
type ReservationSummary struct {
	Resource
	// The properties of the reservation summary.
	Properties *ReservationSummaryProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationSummary.
func (r ReservationSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationSummary.
func (r *ReservationSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReservationSummaryProperties - The properties of the reservation summary.
type ReservationSummaryProperties struct {
	// READ-ONLY; This is average utilization for the entire time range. (day or month depending on the grain)
	AvgUtilizationPercentage *float64 `json:"avgUtilizationPercentage,omitempty" azure:"ro"`

	// READ-ONLY; The reservation kind.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; This is the maximum hourly utilization in the usage time (day or month). E.g. if usage record corresponds to 12/10/2017 and on that for hour
	// 4 and 5, utilization was 100%, this field will return 100%
	// for that day.
	MaxUtilizationPercentage *float64 `json:"maxUtilizationPercentage,omitempty" azure:"ro"`

	// READ-ONLY; This is the minimum hourly utilization in the usage time (day or month). E.g. if usage record corresponds to 12/10/2017 and on that for hour
	// 4 and 5, utilization was 10%, this field will return 10%
	// for that day
	MinUtilizationPercentage *float64 `json:"minUtilizationPercentage,omitempty" azure:"ro"`

	// READ-ONLY; This is the purchased quantity for the reservationId.
	PurchasedQuantity *float64 `json:"purchasedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; This is the remaining quantity for the reservationId.
	RemainingQuantity *float64 `json:"remainingQuantity,omitempty" azure:"ro"`

	// READ-ONLY; The reservation ID is the identifier of a reservation within a reservation order. Each reservation is the grouping for applying the benefit
	// scope and also specifies the number of instances to which
	// the reservation benefit can be applied to.
	ReservationID *string `json:"reservationId,omitempty" azure:"ro"`

	// READ-ONLY; The reservation order ID is the identifier for a reservation purchase. Each reservation order ID represents a single purchase transaction.
	// A reservation order contains reservations. The reservation
	// order specifies the VM size and region for the reservations.
	ReservationOrderID *string `json:"reservationOrderId,omitempty" azure:"ro"`

	// READ-ONLY; This is the total hours reserved. E.g. if reservation for 1 instance was made on 1 PM, this will be 11 hours for that day and 24 hours from
	// subsequent days
	ReservedHours *float64 `json:"reservedHours,omitempty" azure:"ro"`

	// READ-ONLY; This is the ARM Sku name. It can be used to join with the serviceType field in additional info in usage records.
	SKUName *string `json:"skuName,omitempty" azure:"ro"`

	// READ-ONLY; This is the total count of instances that are reserved for the reservationId.
	TotalReservedQuantity *float64 `json:"totalReservedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; Data corresponding to the utilization record. If the grain of data is monthly, it will be first day of month.
	UsageDate *time.Time `json:"usageDate,omitempty" azure:"ro"`

	// READ-ONLY; Total used hours by the reservation
	UsedHours *float64 `json:"usedHours,omitempty" azure:"ro"`

	// READ-ONLY; This is the used quantity for the reservationId.
	UsedQuantity *float64 `json:"usedQuantity,omitempty" azure:"ro"`

	// READ-ONLY; This is the utilized percentage for the reservation Id.
	UtilizedPercentage *float64 `json:"utilizedPercentage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationSummaryProperties.
func (r ReservationSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "avgUtilizationPercentage", r.AvgUtilizationPercentage)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "maxUtilizationPercentage", r.MaxUtilizationPercentage)
	populate(objectMap, "minUtilizationPercentage", r.MinUtilizationPercentage)
	populate(objectMap, "purchasedQuantity", r.PurchasedQuantity)
	populate(objectMap, "remainingQuantity", r.RemainingQuantity)
	populate(objectMap, "reservationId", r.ReservationID)
	populate(objectMap, "reservationOrderId", r.ReservationOrderID)
	populate(objectMap, "reservedHours", r.ReservedHours)
	populate(objectMap, "skuName", r.SKUName)
	populate(objectMap, "totalReservedQuantity", r.TotalReservedQuantity)
	populateTimeRFC3339(objectMap, "usageDate", r.UsageDate)
	populate(objectMap, "usedHours", r.UsedHours)
	populate(objectMap, "usedQuantity", r.UsedQuantity)
	populate(objectMap, "utilizedPercentage", r.UtilizedPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationSummaryProperties.
func (r *ReservationSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avgUtilizationPercentage":
			err = unpopulate(val, &r.AvgUtilizationPercentage)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "maxUtilizationPercentage":
			err = unpopulate(val, &r.MaxUtilizationPercentage)
			delete(rawMsg, key)
		case "minUtilizationPercentage":
			err = unpopulate(val, &r.MinUtilizationPercentage)
			delete(rawMsg, key)
		case "purchasedQuantity":
			err = unpopulate(val, &r.PurchasedQuantity)
			delete(rawMsg, key)
		case "remainingQuantity":
			err = unpopulate(val, &r.RemainingQuantity)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &r.ReservationID)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &r.ReservationOrderID)
			delete(rawMsg, key)
		case "reservedHours":
			err = unpopulate(val, &r.ReservedHours)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &r.SKUName)
			delete(rawMsg, key)
		case "totalReservedQuantity":
			err = unpopulate(val, &r.TotalReservedQuantity)
			delete(rawMsg, key)
		case "usageDate":
			err = unpopulateTimeRFC3339(val, &r.UsageDate)
			delete(rawMsg, key)
		case "usedHours":
			err = unpopulate(val, &r.UsedHours)
			delete(rawMsg, key)
		case "usedQuantity":
			err = unpopulate(val, &r.UsedQuantity)
			delete(rawMsg, key)
		case "utilizedPercentage":
			err = unpopulate(val, &r.UtilizedPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ReservationTransaction - Reservation transaction resource.
type ReservationTransaction struct {
	ReservationTransactionResource
	// The properties of a legacy reservation transaction.
	Properties *LegacyReservationTransactionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationTransaction.
func (r ReservationTransaction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r ReservationTransaction) marshalInternal(objectMap map[string]interface{}) {
	r.ReservationTransactionResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
}

// ReservationTransactionResource - The Resource model definition.
type ReservationTransactionResource struct {
	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource tags.
	Tags []*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationTransactionResource.
func (r ReservationTransactionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r ReservationTransactionResource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// ReservationTransactionsListByBillingProfileOptions contains the optional parameters for the ReservationTransactions.ListByBillingProfile method.
type ReservationTransactionsListByBillingProfileOptions struct {
	// Filter reservation transactions by date range. The properties/EventDate for start date and end date. The filter supports 'le' and 'ge'
	Filter *string
}

// ReservationTransactionsListOptions contains the optional parameters for the ReservationTransactions.List method.
type ReservationTransactionsListOptions struct {
	// Filter reservation transactions by date range. The properties/EventDate for start date and end date. The filter supports 'le' and 'ge'
	Filter *string
}

// ReservationTransactionsListResult - Result of listing reservation recommendations.
type ReservationTransactionsListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of reservation recommendations.
	Value []*ReservationTransaction `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReservationTransactionsListResult.
func (r ReservationTransactionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// ReservationsDetailsListByReservationOrderAndReservationOptions contains the optional parameters for the ReservationsDetails.ListByReservationOrderAndReservation
// method.
type ReservationsDetailsListByReservationOrderAndReservationOptions struct {
	// placeholder for future optional parameters
}

// ReservationsDetailsListByReservationOrderOptions contains the optional parameters for the ReservationsDetails.ListByReservationOrder method.
type ReservationsDetailsListByReservationOrderOptions struct {
	// placeholder for future optional parameters
}

// ReservationsDetailsListOptions contains the optional parameters for the ReservationsDetails.List method.
type ReservationsDetailsListOptions struct {
	// End date. Only applicable when querying with billing profile
	EndDate *string
	// Filter reservation details by date range. The properties/UsageDate for start date and end date. The filter supports 'le' and 'ge'. Not applicable when
	// querying with billing profile
	Filter *string
	// Reservation Id GUID. Only valid if reservationOrderId is also provided. Filter to a specific reservation
	ReservationID *string
	// Reservation Order Id GUID. Required if reservationId is provided. Filter to a specific reservation order
	ReservationOrderID *string
	// Start date. Only applicable when querying with billing profile
	StartDate *string
}

// ReservationsSummariesListByReservationOrderAndReservationOptions contains the optional parameters for the ReservationsSummaries.ListByReservationOrderAndReservation
// method.
type ReservationsSummariesListByReservationOrderAndReservationOptions struct {
	// Required only for daily grain. The properties/UsageDate for start date and end date. The filter supports 'le' and 'ge'
	Filter *string
}

// ReservationsSummariesListByReservationOrderOptions contains the optional parameters for the ReservationsSummaries.ListByReservationOrder method.
type ReservationsSummariesListByReservationOrderOptions struct {
	// Required only for daily grain. The properties/UsageDate for start date and end date. The filter supports 'le' and 'ge'
	Filter *string
}

// ReservationsSummariesListOptions contains the optional parameters for the ReservationsSummaries.List method.
type ReservationsSummariesListOptions struct {
	// End date. Only applicable when querying with billing profile
	EndDate *string
	// Required only for daily grain. The properties/UsageDate for start date and end date. The filter supports 'le' and 'ge'. Not applicable when querying
	// with billing profile
	Filter *string
	// Reservation Id GUID. Only valid if reservationOrderId is also provided. Filter to a specific reservation
	ReservationID *string
	// Reservation Order Id GUID. Required if reservationId is provided. Filter to a specific reservation order
	ReservationOrderID *string
	// Start date. Only applicable when querying with billing profile
	StartDate *string
}

// Resource - The Resource model definition.
type Resource struct {
	// READ-ONLY; The etag for the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The full qualified ARM ID of an event.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The ID that uniquely identifies an event.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource tags.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

func (r *Resource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &r.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &r.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceAttributes - The Resource model definition.
type ResourceAttributes struct {
	// READ-ONLY; Resource location
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; Resource sku
	SKU *string `json:"sku,omitempty" azure:"ro"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceAttributes.
func (r *ResourceAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r ResourceAttributes) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "location", r.Location)
	populate(objectMap, "sku", r.SKU)
}

func (r *ResourceAttributes) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &r.Location)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &r.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SKUProperty - The Sku property
type SKUProperty struct {
	// READ-ONLY; The name of sku property.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The value of sku property.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// Tag - The tag resource.
type Tag struct {
	// Tag key.
	Key *string `json:"key,omitempty"`

	// Tag values.
	Value []*string `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Tag.
func (t Tag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", t.Key)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TagProperties - The properties of the tag.
type TagProperties struct {
	// A list of Tag.
	Tags []*Tag `json:"tags,omitempty"`

	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The link (url) to the previous page of results.
	PreviousLink *string `json:"previousLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TagProperties.
func (t TagProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "previousLink", t.PreviousLink)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// TagsGetOptions contains the optional parameters for the Tags.Get method.
type TagsGetOptions struct {
	// placeholder for future optional parameters
}

// TagsResult - A resource listing all tags.
type TagsResult struct {
	ProxyResource
	// The properties of the tag.
	Properties *TagProperties `json:"properties,omitempty"`
}

// UsageDetailClassification provides polymorphic access to related types.
// Call the interface's GetUsageDetail() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *LegacyUsageDetail, *ModernUsageDetail, *UsageDetail
type UsageDetailClassification interface {
	// GetUsageDetail returns the UsageDetail content of the underlying type.
	GetUsageDetail() *UsageDetail
}

// UsageDetail - An usage detail resource.
type UsageDetail struct {
	Resource
	// REQUIRED; Specifies the kind of usage details.
	Kind *UsageDetailsKind `json:"kind,omitempty"`
}

// GetUsageDetail implements the UsageDetailClassification interface for type UsageDetail.
func (u *UsageDetail) GetUsageDetail() *UsageDetail { return u }

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageDetail.
func (u *UsageDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return u.unmarshalInternal(rawMsg)
}

func (u UsageDetail) marshalInternal(objectMap map[string]interface{}, discValue UsageDetailsKind) {
	u.Resource.marshalInternal(objectMap)
	u.Kind = &discValue
	objectMap["kind"] = u.Kind
}

func (u *UsageDetail) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &u.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UsageDetailsListOptions contains the optional parameters for the UsageDetails.List method.
type UsageDetailsListOptions struct {
	// May be used to expand the properties/additionalInfo or properties/meterDetails within a list of usage details. By default, these fields are not included
	// when listing usage details.
	Expand *string
	// May be used to filter usageDetails by properties/resourceGroup, properties/resourceName, properties/resourceId, properties/chargeType, properties/reservationId,
	// properties/publisherType or tags. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag
	// filter is a key value pair string where key and value is separated by a colon (:). PublisherType Filter accepts two values azure and marketplace and
	// it is currently supported for Web Direct Offer Type
	Filter *string
	// Allows to select different type of cost/usage records.
	Metric *Metrictype
	// Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink
	// element will include a skiptoken parameter that specifies a starting point to use for subsequent calls.
	Skiptoken *string
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// UsageDetailsListResult - Result of listing usage details. It contains a list of available usage details in reverse chronological order by billing period.
type UsageDetailsListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of usage details.
	Value []UsageDetailClassification `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UsageDetailsListResult.
func (u UsageDetailsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageDetailsListResult.
func (u *UsageDetailsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &u.NextLink)
			delete(rawMsg, key)
		case "value":
			u.Value, err = unmarshalUsageDetailClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
