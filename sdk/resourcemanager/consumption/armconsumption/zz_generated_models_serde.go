//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armconsumption

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type Balance.
func (b Balance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", b.Etag)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "tags", b.Tags)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BalanceProperties.
func (b BalanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adjustmentDetails", b.AdjustmentDetails)
	populate(objectMap, "adjustments", b.Adjustments)
	populate(objectMap, "azureMarketplaceServiceCharges", b.AzureMarketplaceServiceCharges)
	populate(objectMap, "beginningBalance", b.BeginningBalance)
	populate(objectMap, "billingFrequency", b.BillingFrequency)
	populate(objectMap, "chargesBilledSeparately", b.ChargesBilledSeparately)
	populate(objectMap, "currency", b.Currency)
	populate(objectMap, "endingBalance", b.EndingBalance)
	populate(objectMap, "newPurchases", b.NewPurchases)
	populate(objectMap, "newPurchasesDetails", b.NewPurchasesDetails)
	populate(objectMap, "priceHidden", b.PriceHidden)
	populate(objectMap, "serviceOverage", b.ServiceOverage)
	populate(objectMap, "totalOverage", b.TotalOverage)
	populate(objectMap, "totalUsage", b.TotalUsage)
	populate(objectMap, "utilized", b.Utilized)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BudgetComparisonExpression.
func (b BudgetComparisonExpression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", b.Name)
	populate(objectMap, "operator", b.Operator)
	populate(objectMap, "values", b.Values)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BudgetFilter.
func (b BudgetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "and", b.And)
	populate(objectMap, "dimensions", b.Dimensions)
	populate(objectMap, "tags", b.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BudgetProperties.
func (b BudgetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "amount", b.Amount)
	populate(objectMap, "category", b.Category)
	populate(objectMap, "currentSpend", b.CurrentSpend)
	populate(objectMap, "filter", b.Filter)
	populate(objectMap, "forecastSpend", b.ForecastSpend)
	populate(objectMap, "notifications", b.Notifications)
	populate(objectMap, "timeGrain", b.TimeGrain)
	populate(objectMap, "timePeriod", b.TimePeriod)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BudgetTimePeriod.
func (b BudgetTimePeriod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endDate", b.EndDate)
	populateTimeRFC3339(objectMap, "startDate", b.StartDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BudgetTimePeriod.
func (b *BudgetTimePeriod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDate":
			err = unpopulateTimeRFC3339(val, &b.EndDate)
			delete(rawMsg, key)
		case "startDate":
			err = unpopulateTimeRFC3339(val, &b.StartDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BudgetsListResult.
func (b BudgetsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// GetChargeSummary implements the ChargeSummaryClassification interface for type ChargeSummary.
func (c *ChargeSummary) GetChargeSummary() *ChargeSummary { return c }

// MarshalJSON implements the json.Marshaller interface for type ChargesListResult.
func (c ChargesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChargesListResult.
func (c *ChargesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			c.Value, err = unmarshalChargeSummaryClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreditSummary.
func (c CreditSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EventProperties.
func (e EventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adjustments", e.Adjustments)
	populate(objectMap, "adjustmentsInBillingCurrency", e.AdjustmentsInBillingCurrency)
	populate(objectMap, "billingCurrency", e.BillingCurrency)
	populate(objectMap, "billingProfileDisplayName", e.BillingProfileDisplayName)
	populate(objectMap, "billingProfileId", e.BillingProfileID)
	populate(objectMap, "canceledCredit", e.CanceledCredit)
	populate(objectMap, "charges", e.Charges)
	populate(objectMap, "chargesInBillingCurrency", e.ChargesInBillingCurrency)
	populate(objectMap, "closedBalance", e.ClosedBalance)
	populate(objectMap, "closedBalanceInBillingCurrency", e.ClosedBalanceInBillingCurrency)
	populate(objectMap, "creditCurrency", e.CreditCurrency)
	populate(objectMap, "creditExpired", e.CreditExpired)
	populate(objectMap, "creditExpiredInBillingCurrency", e.CreditExpiredInBillingCurrency)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "eTag", e.ETag)
	populate(objectMap, "eventType", e.EventType)
	populate(objectMap, "invoiceNumber", e.InvoiceNumber)
	populate(objectMap, "lotId", e.LotID)
	populate(objectMap, "lotSource", e.LotSource)
	populate(objectMap, "newCredit", e.NewCredit)
	populate(objectMap, "newCreditInBillingCurrency", e.NewCreditInBillingCurrency)
	populate(objectMap, "reseller", e.Reseller)
	populateTimeRFC3339(objectMap, "transactionDate", e.TransactionDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventProperties.
func (e *EventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adjustments":
			err = unpopulate(val, &e.Adjustments)
			delete(rawMsg, key)
		case "adjustmentsInBillingCurrency":
			err = unpopulate(val, &e.AdjustmentsInBillingCurrency)
			delete(rawMsg, key)
		case "billingCurrency":
			err = unpopulate(val, &e.BillingCurrency)
			delete(rawMsg, key)
		case "billingProfileDisplayName":
			err = unpopulate(val, &e.BillingProfileDisplayName)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &e.BillingProfileID)
			delete(rawMsg, key)
		case "canceledCredit":
			err = unpopulate(val, &e.CanceledCredit)
			delete(rawMsg, key)
		case "charges":
			err = unpopulate(val, &e.Charges)
			delete(rawMsg, key)
		case "chargesInBillingCurrency":
			err = unpopulate(val, &e.ChargesInBillingCurrency)
			delete(rawMsg, key)
		case "closedBalance":
			err = unpopulate(val, &e.ClosedBalance)
			delete(rawMsg, key)
		case "closedBalanceInBillingCurrency":
			err = unpopulate(val, &e.ClosedBalanceInBillingCurrency)
			delete(rawMsg, key)
		case "creditCurrency":
			err = unpopulate(val, &e.CreditCurrency)
			delete(rawMsg, key)
		case "creditExpired":
			err = unpopulate(val, &e.CreditExpired)
			delete(rawMsg, key)
		case "creditExpiredInBillingCurrency":
			err = unpopulate(val, &e.CreditExpiredInBillingCurrency)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, &e.ETag)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, &e.EventType)
			delete(rawMsg, key)
		case "invoiceNumber":
			err = unpopulate(val, &e.InvoiceNumber)
			delete(rawMsg, key)
		case "lotId":
			err = unpopulate(val, &e.LotID)
			delete(rawMsg, key)
		case "lotSource":
			err = unpopulate(val, &e.LotSource)
			delete(rawMsg, key)
		case "newCredit":
			err = unpopulate(val, &e.NewCredit)
			delete(rawMsg, key)
		case "newCreditInBillingCurrency":
			err = unpopulate(val, &e.NewCreditInBillingCurrency)
			delete(rawMsg, key)
		case "reseller":
			err = unpopulate(val, &e.Reseller)
			delete(rawMsg, key)
		case "transactionDate":
			err = unpopulateTimeRFC3339(val, &e.TransactionDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Events.
func (e Events) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// GetChargeSummary implements the ChargeSummaryClassification interface for type LegacyChargeSummary.
func (l *LegacyChargeSummary) GetChargeSummary() *ChargeSummary {
	return &ChargeSummary{
		Kind: l.Kind,
		ID:   l.ID,
		Name: l.Name,
		Type: l.Type,
		ETag: l.ETag,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LegacyChargeSummary.
func (l LegacyChargeSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", l.ETag)
	populate(objectMap, "id", l.ID)
	objectMap["kind"] = ChargeSummaryKindLegacy
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyChargeSummary.
func (l *LegacyChargeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, &l.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &l.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &l.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetReservationRecommendation implements the ReservationRecommendationClassification interface for type LegacyReservationRecommendation.
func (l *LegacyReservationRecommendation) GetReservationRecommendation() *ReservationRecommendation {
	return &ReservationRecommendation{
		Kind:     l.Kind,
		ID:       l.ID,
		Name:     l.Name,
		Type:     l.Type,
		Etag:     l.Etag,
		Tags:     l.Tags,
		Location: l.Location,
		SKU:      l.SKU,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationRecommendation.
func (l LegacyReservationRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "id", l.ID)
	objectMap["kind"] = ReservationRecommendationKindLegacy
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "sku", l.SKU)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyReservationRecommendation.
func (l *LegacyReservationRecommendation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &l.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &l.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &l.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &l.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "properties":
			l.Properties, err = unmarshalLegacyReservationRecommendationPropertiesClassification(val)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &l.SKU)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &l.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetLegacyReservationRecommendationProperties implements the LegacyReservationRecommendationPropertiesClassification interface
// for type LegacyReservationRecommendationProperties.
func (l *LegacyReservationRecommendationProperties) GetLegacyReservationRecommendationProperties() *LegacyReservationRecommendationProperties {
	return l
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationRecommendationProperties.
func (l LegacyReservationRecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costWithNoReservedInstances", l.CostWithNoReservedInstances)
	populateTimeRFC3339(objectMap, "firstUsageDate", l.FirstUsageDate)
	populate(objectMap, "instanceFlexibilityGroup", l.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", l.InstanceFlexibilityRatio)
	populate(objectMap, "lookBackPeriod", l.LookBackPeriod)
	populate(objectMap, "meterId", l.MeterID)
	populate(objectMap, "netSavings", l.NetSavings)
	populate(objectMap, "normalizedSize", l.NormalizedSize)
	populate(objectMap, "recommendedQuantity", l.RecommendedQuantity)
	populate(objectMap, "recommendedQuantityNormalized", l.RecommendedQuantityNormalized)
	populate(objectMap, "resourceType", l.ResourceType)
	populate(objectMap, "skuProperties", l.SKUProperties)
	objectMap["scope"] = l.Scope
	populate(objectMap, "term", l.Term)
	populate(objectMap, "totalCostWithReservedInstances", l.TotalCostWithReservedInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyReservationRecommendationProperties.
func (l *LegacyReservationRecommendationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costWithNoReservedInstances":
			err = unpopulate(val, &l.CostWithNoReservedInstances)
			delete(rawMsg, key)
		case "firstUsageDate":
			err = unpopulateTimeRFC3339(val, &l.FirstUsageDate)
			delete(rawMsg, key)
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &l.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &l.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "lookBackPeriod":
			err = unpopulate(val, &l.LookBackPeriod)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &l.MeterID)
			delete(rawMsg, key)
		case "netSavings":
			err = unpopulate(val, &l.NetSavings)
			delete(rawMsg, key)
		case "normalizedSize":
			err = unpopulate(val, &l.NormalizedSize)
			delete(rawMsg, key)
		case "recommendedQuantity":
			err = unpopulate(val, &l.RecommendedQuantity)
			delete(rawMsg, key)
		case "recommendedQuantityNormalized":
			err = unpopulate(val, &l.RecommendedQuantityNormalized)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, &l.ResourceType)
			delete(rawMsg, key)
		case "skuProperties":
			err = unpopulate(val, &l.SKUProperties)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &l.Scope)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		case "totalCostWithReservedInstances":
			err = unpopulate(val, &l.TotalCostWithReservedInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationTransaction.
func (l LegacyReservationTransaction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", l.ID)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LegacyReservationTransactionProperties.
func (l LegacyReservationTransactionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", l.AccountName)
	populate(objectMap, "accountOwnerEmail", l.AccountOwnerEmail)
	populate(objectMap, "amount", l.Amount)
	populate(objectMap, "armSkuName", l.ArmSKUName)
	populate(objectMap, "billingFrequency", l.BillingFrequency)
	populate(objectMap, "billingMonth", l.BillingMonth)
	populate(objectMap, "costCenter", l.CostCenter)
	populate(objectMap, "currency", l.Currency)
	populate(objectMap, "currentEnrollment", l.CurrentEnrollment)
	populate(objectMap, "departmentName", l.DepartmentName)
	populate(objectMap, "description", l.Description)
	populateTimeRFC3339(objectMap, "eventDate", l.EventDate)
	populate(objectMap, "eventType", l.EventType)
	populate(objectMap, "monetaryCommitment", l.MonetaryCommitment)
	populate(objectMap, "overage", l.Overage)
	populate(objectMap, "purchasingEnrollment", l.PurchasingEnrollment)
	populate(objectMap, "purchasingSubscriptionGuid", l.PurchasingSubscriptionGUID)
	populate(objectMap, "purchasingSubscriptionName", l.PurchasingSubscriptionName)
	populate(objectMap, "quantity", l.Quantity)
	populate(objectMap, "region", l.Region)
	populate(objectMap, "reservationOrderId", l.ReservationOrderID)
	populate(objectMap, "reservationOrderName", l.ReservationOrderName)
	populate(objectMap, "term", l.Term)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyReservationTransactionProperties.
func (l *LegacyReservationTransactionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &l.AccountName)
			delete(rawMsg, key)
		case "accountOwnerEmail":
			err = unpopulate(val, &l.AccountOwnerEmail)
			delete(rawMsg, key)
		case "amount":
			err = unpopulate(val, &l.Amount)
			delete(rawMsg, key)
		case "armSkuName":
			err = unpopulate(val, &l.ArmSKUName)
			delete(rawMsg, key)
		case "billingFrequency":
			err = unpopulate(val, &l.BillingFrequency)
			delete(rawMsg, key)
		case "billingMonth":
			err = unpopulate(val, &l.BillingMonth)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &l.CostCenter)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &l.Currency)
			delete(rawMsg, key)
		case "currentEnrollment":
			err = unpopulate(val, &l.CurrentEnrollment)
			delete(rawMsg, key)
		case "departmentName":
			err = unpopulate(val, &l.DepartmentName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "eventDate":
			err = unpopulateTimeRFC3339(val, &l.EventDate)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, &l.EventType)
			delete(rawMsg, key)
		case "monetaryCommitment":
			err = unpopulate(val, &l.MonetaryCommitment)
			delete(rawMsg, key)
		case "overage":
			err = unpopulate(val, &l.Overage)
			delete(rawMsg, key)
		case "purchasingEnrollment":
			err = unpopulate(val, &l.PurchasingEnrollment)
			delete(rawMsg, key)
		case "purchasingSubscriptionGuid":
			err = unpopulate(val, &l.PurchasingSubscriptionGUID)
			delete(rawMsg, key)
		case "purchasingSubscriptionName":
			err = unpopulate(val, &l.PurchasingSubscriptionName)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &l.Quantity)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &l.Region)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &l.ReservationOrderID)
			delete(rawMsg, key)
		case "reservationOrderName":
			err = unpopulate(val, &l.ReservationOrderName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetLegacyReservationRecommendationProperties implements the LegacyReservationRecommendationPropertiesClassification interface
// for type LegacySharedScopeReservationRecommendationProperties.
func (l *LegacySharedScopeReservationRecommendationProperties) GetLegacyReservationRecommendationProperties() *LegacyReservationRecommendationProperties {
	return &LegacyReservationRecommendationProperties{
		LookBackPeriod:                 l.LookBackPeriod,
		InstanceFlexibilityRatio:       l.InstanceFlexibilityRatio,
		InstanceFlexibilityGroup:       l.InstanceFlexibilityGroup,
		NormalizedSize:                 l.NormalizedSize,
		RecommendedQuantityNormalized:  l.RecommendedQuantityNormalized,
		MeterID:                        l.MeterID,
		ResourceType:                   l.ResourceType,
		Term:                           l.Term,
		CostWithNoReservedInstances:    l.CostWithNoReservedInstances,
		RecommendedQuantity:            l.RecommendedQuantity,
		TotalCostWithReservedInstances: l.TotalCostWithReservedInstances,
		NetSavings:                     l.NetSavings,
		FirstUsageDate:                 l.FirstUsageDate,
		Scope:                          l.Scope,
		SKUProperties:                  l.SKUProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LegacySharedScopeReservationRecommendationProperties.
func (l LegacySharedScopeReservationRecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costWithNoReservedInstances", l.CostWithNoReservedInstances)
	populateTimeRFC3339(objectMap, "firstUsageDate", l.FirstUsageDate)
	populate(objectMap, "instanceFlexibilityGroup", l.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", l.InstanceFlexibilityRatio)
	populate(objectMap, "lookBackPeriod", l.LookBackPeriod)
	populate(objectMap, "meterId", l.MeterID)
	populate(objectMap, "netSavings", l.NetSavings)
	populate(objectMap, "normalizedSize", l.NormalizedSize)
	populate(objectMap, "recommendedQuantity", l.RecommendedQuantity)
	populate(objectMap, "recommendedQuantityNormalized", l.RecommendedQuantityNormalized)
	populate(objectMap, "resourceType", l.ResourceType)
	populate(objectMap, "skuProperties", l.SKUProperties)
	objectMap["scope"] = "Shared"
	populate(objectMap, "term", l.Term)
	populate(objectMap, "totalCostWithReservedInstances", l.TotalCostWithReservedInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacySharedScopeReservationRecommendationProperties.
func (l *LegacySharedScopeReservationRecommendationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costWithNoReservedInstances":
			err = unpopulate(val, &l.CostWithNoReservedInstances)
			delete(rawMsg, key)
		case "firstUsageDate":
			err = unpopulateTimeRFC3339(val, &l.FirstUsageDate)
			delete(rawMsg, key)
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &l.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &l.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "lookBackPeriod":
			err = unpopulate(val, &l.LookBackPeriod)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &l.MeterID)
			delete(rawMsg, key)
		case "netSavings":
			err = unpopulate(val, &l.NetSavings)
			delete(rawMsg, key)
		case "normalizedSize":
			err = unpopulate(val, &l.NormalizedSize)
			delete(rawMsg, key)
		case "recommendedQuantity":
			err = unpopulate(val, &l.RecommendedQuantity)
			delete(rawMsg, key)
		case "recommendedQuantityNormalized":
			err = unpopulate(val, &l.RecommendedQuantityNormalized)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, &l.ResourceType)
			delete(rawMsg, key)
		case "skuProperties":
			err = unpopulate(val, &l.SKUProperties)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &l.Scope)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		case "totalCostWithReservedInstances":
			err = unpopulate(val, &l.TotalCostWithReservedInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetLegacyReservationRecommendationProperties implements the LegacyReservationRecommendationPropertiesClassification interface
// for type LegacySingleScopeReservationRecommendationProperties.
func (l *LegacySingleScopeReservationRecommendationProperties) GetLegacyReservationRecommendationProperties() *LegacyReservationRecommendationProperties {
	return &LegacyReservationRecommendationProperties{
		LookBackPeriod:                 l.LookBackPeriod,
		InstanceFlexibilityRatio:       l.InstanceFlexibilityRatio,
		InstanceFlexibilityGroup:       l.InstanceFlexibilityGroup,
		NormalizedSize:                 l.NormalizedSize,
		RecommendedQuantityNormalized:  l.RecommendedQuantityNormalized,
		MeterID:                        l.MeterID,
		ResourceType:                   l.ResourceType,
		Term:                           l.Term,
		CostWithNoReservedInstances:    l.CostWithNoReservedInstances,
		RecommendedQuantity:            l.RecommendedQuantity,
		TotalCostWithReservedInstances: l.TotalCostWithReservedInstances,
		NetSavings:                     l.NetSavings,
		FirstUsageDate:                 l.FirstUsageDate,
		Scope:                          l.Scope,
		SKUProperties:                  l.SKUProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LegacySingleScopeReservationRecommendationProperties.
func (l LegacySingleScopeReservationRecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costWithNoReservedInstances", l.CostWithNoReservedInstances)
	populateTimeRFC3339(objectMap, "firstUsageDate", l.FirstUsageDate)
	populate(objectMap, "instanceFlexibilityGroup", l.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", l.InstanceFlexibilityRatio)
	populate(objectMap, "lookBackPeriod", l.LookBackPeriod)
	populate(objectMap, "meterId", l.MeterID)
	populate(objectMap, "netSavings", l.NetSavings)
	populate(objectMap, "normalizedSize", l.NormalizedSize)
	populate(objectMap, "recommendedQuantity", l.RecommendedQuantity)
	populate(objectMap, "recommendedQuantityNormalized", l.RecommendedQuantityNormalized)
	populate(objectMap, "resourceType", l.ResourceType)
	populate(objectMap, "skuProperties", l.SKUProperties)
	objectMap["scope"] = "Single"
	populate(objectMap, "subscriptionId", l.SubscriptionID)
	populate(objectMap, "term", l.Term)
	populate(objectMap, "totalCostWithReservedInstances", l.TotalCostWithReservedInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacySingleScopeReservationRecommendationProperties.
func (l *LegacySingleScopeReservationRecommendationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costWithNoReservedInstances":
			err = unpopulate(val, &l.CostWithNoReservedInstances)
			delete(rawMsg, key)
		case "firstUsageDate":
			err = unpopulateTimeRFC3339(val, &l.FirstUsageDate)
			delete(rawMsg, key)
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &l.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &l.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "lookBackPeriod":
			err = unpopulate(val, &l.LookBackPeriod)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &l.MeterID)
			delete(rawMsg, key)
		case "netSavings":
			err = unpopulate(val, &l.NetSavings)
			delete(rawMsg, key)
		case "normalizedSize":
			err = unpopulate(val, &l.NormalizedSize)
			delete(rawMsg, key)
		case "recommendedQuantity":
			err = unpopulate(val, &l.RecommendedQuantity)
			delete(rawMsg, key)
		case "recommendedQuantityNormalized":
			err = unpopulate(val, &l.RecommendedQuantityNormalized)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, &l.ResourceType)
			delete(rawMsg, key)
		case "skuProperties":
			err = unpopulate(val, &l.SKUProperties)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &l.Scope)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &l.SubscriptionID)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		case "totalCostWithReservedInstances":
			err = unpopulate(val, &l.TotalCostWithReservedInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetUsageDetail implements the UsageDetailClassification interface for type LegacyUsageDetail.
func (l *LegacyUsageDetail) GetUsageDetail() *UsageDetail {
	return &UsageDetail{
		Kind: l.Kind,
		ID:   l.ID,
		Name: l.Name,
		Type: l.Type,
		Etag: l.Etag,
		Tags: l.Tags,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LegacyUsageDetail.
func (l LegacyUsageDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "id", l.ID)
	objectMap["kind"] = UsageDetailsKindLegacy
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyUsageDetail.
func (l *LegacyUsageDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &l.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &l.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &l.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &l.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LegacyUsageDetailProperties.
func (l LegacyUsageDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", l.AccountName)
	populate(objectMap, "accountOwnerId", l.AccountOwnerID)
	populate(objectMap, "additionalInfo", l.AdditionalInfo)
	populate(objectMap, "benefitId", l.BenefitID)
	populate(objectMap, "benefitName", l.BenefitName)
	populate(objectMap, "billingAccountId", l.BillingAccountID)
	populate(objectMap, "billingAccountName", l.BillingAccountName)
	populate(objectMap, "billingCurrency", l.BillingCurrency)
	populateTimeRFC3339(objectMap, "billingPeriodEndDate", l.BillingPeriodEndDate)
	populateTimeRFC3339(objectMap, "billingPeriodStartDate", l.BillingPeriodStartDate)
	populate(objectMap, "billingProfileId", l.BillingProfileID)
	populate(objectMap, "billingProfileName", l.BillingProfileName)
	populate(objectMap, "chargeType", l.ChargeType)
	populate(objectMap, "consumedService", l.ConsumedService)
	populate(objectMap, "cost", l.Cost)
	populate(objectMap, "costCenter", l.CostCenter)
	populateTimeRFC3339(objectMap, "date", l.Date)
	populate(objectMap, "effectivePrice", l.EffectivePrice)
	populate(objectMap, "frequency", l.Frequency)
	populate(objectMap, "invoiceSection", l.InvoiceSection)
	populate(objectMap, "isAzureCreditEligible", l.IsAzureCreditEligible)
	populate(objectMap, "meterDetails", l.MeterDetails)
	populate(objectMap, "meterId", l.MeterID)
	populate(objectMap, "offerId", l.OfferID)
	populate(objectMap, "partNumber", l.PartNumber)
	populate(objectMap, "payGPrice", l.PayGPrice)
	populate(objectMap, "planName", l.PlanName)
	populate(objectMap, "pricingModel", l.PricingModel)
	populate(objectMap, "product", l.Product)
	populate(objectMap, "productOrderId", l.ProductOrderID)
	populate(objectMap, "productOrderName", l.ProductOrderName)
	populate(objectMap, "publisherName", l.PublisherName)
	populate(objectMap, "publisherType", l.PublisherType)
	populate(objectMap, "quantity", l.Quantity)
	populate(objectMap, "reservationId", l.ReservationID)
	populate(objectMap, "reservationName", l.ReservationName)
	populate(objectMap, "resourceGroup", l.ResourceGroup)
	populate(objectMap, "resourceId", l.ResourceID)
	populate(objectMap, "resourceLocation", l.ResourceLocation)
	populate(objectMap, "resourceName", l.ResourceName)
	populate(objectMap, "serviceInfo1", l.ServiceInfo1)
	populate(objectMap, "serviceInfo2", l.ServiceInfo2)
	populate(objectMap, "subscriptionId", l.SubscriptionID)
	populate(objectMap, "subscriptionName", l.SubscriptionName)
	populate(objectMap, "term", l.Term)
	populate(objectMap, "unitPrice", l.UnitPrice)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LegacyUsageDetailProperties.
func (l *LegacyUsageDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &l.AccountName)
			delete(rawMsg, key)
		case "accountOwnerId":
			err = unpopulate(val, &l.AccountOwnerID)
			delete(rawMsg, key)
		case "additionalInfo":
			err = unpopulate(val, &l.AdditionalInfo)
			delete(rawMsg, key)
		case "benefitId":
			err = unpopulate(val, &l.BenefitID)
			delete(rawMsg, key)
		case "benefitName":
			err = unpopulate(val, &l.BenefitName)
			delete(rawMsg, key)
		case "billingAccountId":
			err = unpopulate(val, &l.BillingAccountID)
			delete(rawMsg, key)
		case "billingAccountName":
			err = unpopulate(val, &l.BillingAccountName)
			delete(rawMsg, key)
		case "billingCurrency":
			err = unpopulate(val, &l.BillingCurrency)
			delete(rawMsg, key)
		case "billingPeriodEndDate":
			err = unpopulateTimeRFC3339(val, &l.BillingPeriodEndDate)
			delete(rawMsg, key)
		case "billingPeriodStartDate":
			err = unpopulateTimeRFC3339(val, &l.BillingPeriodStartDate)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &l.BillingProfileID)
			delete(rawMsg, key)
		case "billingProfileName":
			err = unpopulate(val, &l.BillingProfileName)
			delete(rawMsg, key)
		case "chargeType":
			err = unpopulate(val, &l.ChargeType)
			delete(rawMsg, key)
		case "consumedService":
			err = unpopulate(val, &l.ConsumedService)
			delete(rawMsg, key)
		case "cost":
			err = unpopulate(val, &l.Cost)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &l.CostCenter)
			delete(rawMsg, key)
		case "date":
			err = unpopulateTimeRFC3339(val, &l.Date)
			delete(rawMsg, key)
		case "effectivePrice":
			err = unpopulate(val, &l.EffectivePrice)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &l.Frequency)
			delete(rawMsg, key)
		case "invoiceSection":
			err = unpopulate(val, &l.InvoiceSection)
			delete(rawMsg, key)
		case "isAzureCreditEligible":
			err = unpopulate(val, &l.IsAzureCreditEligible)
			delete(rawMsg, key)
		case "meterDetails":
			err = unpopulate(val, &l.MeterDetails)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &l.MeterID)
			delete(rawMsg, key)
		case "offerId":
			err = unpopulate(val, &l.OfferID)
			delete(rawMsg, key)
		case "partNumber":
			err = unpopulate(val, &l.PartNumber)
			delete(rawMsg, key)
		case "payGPrice":
			err = unpopulate(val, &l.PayGPrice)
			delete(rawMsg, key)
		case "planName":
			err = unpopulate(val, &l.PlanName)
			delete(rawMsg, key)
		case "pricingModel":
			err = unpopulate(val, &l.PricingModel)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, &l.Product)
			delete(rawMsg, key)
		case "productOrderId":
			err = unpopulate(val, &l.ProductOrderID)
			delete(rawMsg, key)
		case "productOrderName":
			err = unpopulate(val, &l.ProductOrderName)
			delete(rawMsg, key)
		case "publisherName":
			err = unpopulate(val, &l.PublisherName)
			delete(rawMsg, key)
		case "publisherType":
			err = unpopulate(val, &l.PublisherType)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &l.Quantity)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &l.ReservationID)
			delete(rawMsg, key)
		case "reservationName":
			err = unpopulate(val, &l.ReservationName)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, &l.ResourceGroup)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &l.ResourceID)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, &l.ResourceLocation)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, &l.ResourceName)
			delete(rawMsg, key)
		case "serviceInfo1":
			err = unpopulate(val, &l.ServiceInfo1)
			delete(rawMsg, key)
		case "serviceInfo2":
			err = unpopulate(val, &l.ServiceInfo2)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &l.SubscriptionID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, &l.SubscriptionName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &l.Term)
			delete(rawMsg, key)
		case "unitPrice":
			err = unpopulate(val, &l.UnitPrice)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LotProperties.
func (l LotProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "billingCurrency", l.BillingCurrency)
	populate(objectMap, "closedBalance", l.ClosedBalance)
	populate(objectMap, "closedBalanceInBillingCurrency", l.ClosedBalanceInBillingCurrency)
	populate(objectMap, "creditCurrency", l.CreditCurrency)
	populate(objectMap, "eTag", l.ETag)
	populateTimeRFC3339(objectMap, "expirationDate", l.ExpirationDate)
	populate(objectMap, "originalAmount", l.OriginalAmount)
	populate(objectMap, "originalAmountInBillingCurrency", l.OriginalAmountInBillingCurrency)
	populate(objectMap, "poNumber", l.PoNumber)
	populateTimeRFC3339(objectMap, "purchasedDate", l.PurchasedDate)
	populate(objectMap, "reseller", l.Reseller)
	populate(objectMap, "source", l.Source)
	populateTimeRFC3339(objectMap, "startDate", l.StartDate)
	populate(objectMap, "status", l.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LotProperties.
func (l *LotProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "billingCurrency":
			err = unpopulate(val, &l.BillingCurrency)
			delete(rawMsg, key)
		case "closedBalance":
			err = unpopulate(val, &l.ClosedBalance)
			delete(rawMsg, key)
		case "closedBalanceInBillingCurrency":
			err = unpopulate(val, &l.ClosedBalanceInBillingCurrency)
			delete(rawMsg, key)
		case "creditCurrency":
			err = unpopulate(val, &l.CreditCurrency)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, &l.ETag)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &l.ExpirationDate)
			delete(rawMsg, key)
		case "originalAmount":
			err = unpopulate(val, &l.OriginalAmount)
			delete(rawMsg, key)
		case "originalAmountInBillingCurrency":
			err = unpopulate(val, &l.OriginalAmountInBillingCurrency)
			delete(rawMsg, key)
		case "poNumber":
			err = unpopulate(val, &l.PoNumber)
			delete(rawMsg, key)
		case "purchasedDate":
			err = unpopulateTimeRFC3339(val, &l.PurchasedDate)
			delete(rawMsg, key)
		case "reseller":
			err = unpopulate(val, &l.Reseller)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &l.Source)
			delete(rawMsg, key)
		case "startDate":
			err = unpopulateTimeRFC3339(val, &l.StartDate)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &l.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Lots.
func (l Lots) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ManagementGroupAggregatedCostProperties.
func (m ManagementGroupAggregatedCostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureCharges", m.AzureCharges)
	populate(objectMap, "billingPeriodId", m.BillingPeriodID)
	populate(objectMap, "chargesBilledSeparately", m.ChargesBilledSeparately)
	populate(objectMap, "children", m.Children)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "excludedSubscriptions", m.ExcludedSubscriptions)
	populate(objectMap, "includedSubscriptions", m.IncludedSubscriptions)
	populate(objectMap, "marketplaceCharges", m.MarketplaceCharges)
	populateTimeRFC3339(objectMap, "usageEnd", m.UsageEnd)
	populateTimeRFC3339(objectMap, "usageStart", m.UsageStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementGroupAggregatedCostProperties.
func (m *ManagementGroupAggregatedCostProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureCharges":
			err = unpopulate(val, &m.AzureCharges)
			delete(rawMsg, key)
		case "billingPeriodId":
			err = unpopulate(val, &m.BillingPeriodID)
			delete(rawMsg, key)
		case "chargesBilledSeparately":
			err = unpopulate(val, &m.ChargesBilledSeparately)
			delete(rawMsg, key)
		case "children":
			err = unpopulate(val, &m.Children)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &m.Currency)
			delete(rawMsg, key)
		case "excludedSubscriptions":
			err = unpopulate(val, &m.ExcludedSubscriptions)
			delete(rawMsg, key)
		case "includedSubscriptions":
			err = unpopulate(val, &m.IncludedSubscriptions)
			delete(rawMsg, key)
		case "marketplaceCharges":
			err = unpopulate(val, &m.MarketplaceCharges)
			delete(rawMsg, key)
		case "usageEnd":
			err = unpopulateTimeRFC3339(val, &m.UsageEnd)
			delete(rawMsg, key)
		case "usageStart":
			err = unpopulateTimeRFC3339(val, &m.UsageStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementGroupAggregatedCostResult.
func (m ManagementGroupAggregatedCostResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Marketplace.
func (m Marketplace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MarketplaceProperties.
func (m MarketplaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", m.AccountName)
	populate(objectMap, "additionalInfo", m.AdditionalInfo)
	populate(objectMap, "additionalProperties", m.AdditionalProperties)
	populate(objectMap, "billingPeriodId", m.BillingPeriodID)
	populate(objectMap, "consumedQuantity", m.ConsumedQuantity)
	populate(objectMap, "consumedService", m.ConsumedService)
	populate(objectMap, "costCenter", m.CostCenter)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "departmentName", m.DepartmentName)
	populate(objectMap, "instanceId", m.InstanceID)
	populate(objectMap, "instanceName", m.InstanceName)
	populate(objectMap, "isEstimated", m.IsEstimated)
	populate(objectMap, "isRecurringCharge", m.IsRecurringCharge)
	populate(objectMap, "meterId", m.MeterID)
	populate(objectMap, "offerName", m.OfferName)
	populate(objectMap, "orderNumber", m.OrderNumber)
	populate(objectMap, "planName", m.PlanName)
	populate(objectMap, "pretaxCost", m.PretaxCost)
	populate(objectMap, "publisherName", m.PublisherName)
	populate(objectMap, "resourceGroup", m.ResourceGroup)
	populate(objectMap, "resourceRate", m.ResourceRate)
	populate(objectMap, "subscriptionGuid", m.SubscriptionGUID)
	populate(objectMap, "subscriptionName", m.SubscriptionName)
	populate(objectMap, "unitOfMeasure", m.UnitOfMeasure)
	populateTimeRFC3339(objectMap, "usageEnd", m.UsageEnd)
	populateTimeRFC3339(objectMap, "usageStart", m.UsageStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketplaceProperties.
func (m *MarketplaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &m.AccountName)
			delete(rawMsg, key)
		case "additionalInfo":
			err = unpopulate(val, &m.AdditionalInfo)
			delete(rawMsg, key)
		case "additionalProperties":
			err = unpopulate(val, &m.AdditionalProperties)
			delete(rawMsg, key)
		case "billingPeriodId":
			err = unpopulate(val, &m.BillingPeriodID)
			delete(rawMsg, key)
		case "consumedQuantity":
			err = unpopulate(val, &m.ConsumedQuantity)
			delete(rawMsg, key)
		case "consumedService":
			err = unpopulate(val, &m.ConsumedService)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &m.CostCenter)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &m.Currency)
			delete(rawMsg, key)
		case "departmentName":
			err = unpopulate(val, &m.DepartmentName)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, &m.InstanceID)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, &m.InstanceName)
			delete(rawMsg, key)
		case "isEstimated":
			err = unpopulate(val, &m.IsEstimated)
			delete(rawMsg, key)
		case "isRecurringCharge":
			err = unpopulate(val, &m.IsRecurringCharge)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &m.MeterID)
			delete(rawMsg, key)
		case "offerName":
			err = unpopulate(val, &m.OfferName)
			delete(rawMsg, key)
		case "orderNumber":
			err = unpopulate(val, &m.OrderNumber)
			delete(rawMsg, key)
		case "planName":
			err = unpopulate(val, &m.PlanName)
			delete(rawMsg, key)
		case "pretaxCost":
			err = unpopulate(val, &m.PretaxCost)
			delete(rawMsg, key)
		case "publisherName":
			err = unpopulate(val, &m.PublisherName)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, &m.ResourceGroup)
			delete(rawMsg, key)
		case "resourceRate":
			err = unpopulate(val, &m.ResourceRate)
			delete(rawMsg, key)
		case "subscriptionGuid":
			err = unpopulate(val, &m.SubscriptionGUID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, &m.SubscriptionName)
			delete(rawMsg, key)
		case "unitOfMeasure":
			err = unpopulate(val, &m.UnitOfMeasure)
			delete(rawMsg, key)
		case "usageEnd":
			err = unpopulateTimeRFC3339(val, &m.UsageEnd)
			delete(rawMsg, key)
		case "usageStart":
			err = unpopulateTimeRFC3339(val, &m.UsageStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MarketplacesListResult.
func (m MarketplacesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// GetChargeSummary implements the ChargeSummaryClassification interface for type ModernChargeSummary.
func (m *ModernChargeSummary) GetChargeSummary() *ChargeSummary {
	return &ChargeSummary{
		Kind: m.Kind,
		ID:   m.ID,
		Name: m.Name,
		Type: m.Type,
		ETag: m.ETag,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ModernChargeSummary.
func (m ModernChargeSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", m.ETag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = ChargeSummaryKindModern
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernChargeSummary.
func (m *ModernChargeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, &m.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetReservationRecommendation implements the ReservationRecommendationClassification interface for type ModernReservationRecommendation.
func (m *ModernReservationRecommendation) GetReservationRecommendation() *ReservationRecommendation {
	return &ReservationRecommendation{
		Kind:     m.Kind,
		ID:       m.ID,
		Name:     m.Name,
		Type:     m.Type,
		Etag:     m.Etag,
		Tags:     m.Tags,
		Location: m.Location,
		SKU:      m.SKU,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationRecommendation.
func (m ModernReservationRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = ReservationRecommendationKindModern
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "sku", m.SKU)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernReservationRecommendation.
func (m *ModernReservationRecommendation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &m.SKU)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationRecommendationProperties.
func (m ModernReservationRecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costWithNoReservedInstances", m.CostWithNoReservedInstances)
	populateTimeRFC3339(objectMap, "firstUsageDate", m.FirstUsageDate)
	populate(objectMap, "instanceFlexibilityGroup", m.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", m.InstanceFlexibilityRatio)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "lookBackPeriod", m.LookBackPeriod)
	populate(objectMap, "meterId", m.MeterID)
	populate(objectMap, "netSavings", m.NetSavings)
	populate(objectMap, "normalizedSize", m.NormalizedSize)
	populate(objectMap, "recommendedQuantity", m.RecommendedQuantity)
	populate(objectMap, "recommendedQuantityNormalized", m.RecommendedQuantityNormalized)
	populate(objectMap, "skuName", m.SKUName)
	populate(objectMap, "skuProperties", m.SKUProperties)
	populate(objectMap, "scope", m.Scope)
	populate(objectMap, "term", m.Term)
	populate(objectMap, "totalCostWithReservedInstances", m.TotalCostWithReservedInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernReservationRecommendationProperties.
func (m *ModernReservationRecommendationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costWithNoReservedInstances":
			err = unpopulate(val, &m.CostWithNoReservedInstances)
			delete(rawMsg, key)
		case "firstUsageDate":
			err = unpopulateTimeRFC3339(val, &m.FirstUsageDate)
			delete(rawMsg, key)
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &m.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &m.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &m.Location)
			delete(rawMsg, key)
		case "lookBackPeriod":
			err = unpopulate(val, &m.LookBackPeriod)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &m.MeterID)
			delete(rawMsg, key)
		case "netSavings":
			err = unpopulate(val, &m.NetSavings)
			delete(rawMsg, key)
		case "normalizedSize":
			err = unpopulate(val, &m.NormalizedSize)
			delete(rawMsg, key)
		case "recommendedQuantity":
			err = unpopulate(val, &m.RecommendedQuantity)
			delete(rawMsg, key)
		case "recommendedQuantityNormalized":
			err = unpopulate(val, &m.RecommendedQuantityNormalized)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &m.SKUName)
			delete(rawMsg, key)
		case "skuProperties":
			err = unpopulate(val, &m.SKUProperties)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &m.Scope)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &m.Term)
			delete(rawMsg, key)
		case "totalCostWithReservedInstances":
			err = unpopulate(val, &m.TotalCostWithReservedInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationTransaction.
func (m ModernReservationTransaction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationTransactionProperties.
func (m ModernReservationTransactionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "amount", m.Amount)
	populate(objectMap, "armSkuName", m.ArmSKUName)
	populate(objectMap, "billingFrequency", m.BillingFrequency)
	populate(objectMap, "billingProfileId", m.BillingProfileID)
	populate(objectMap, "billingProfileName", m.BillingProfileName)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "description", m.Description)
	populateTimeRFC3339(objectMap, "eventDate", m.EventDate)
	populate(objectMap, "eventType", m.EventType)
	populate(objectMap, "invoice", m.Invoice)
	populate(objectMap, "invoiceId", m.InvoiceID)
	populate(objectMap, "invoiceSectionId", m.InvoiceSectionID)
	populate(objectMap, "invoiceSectionName", m.InvoiceSectionName)
	populate(objectMap, "purchasingSubscriptionGuid", m.PurchasingSubscriptionGUID)
	populate(objectMap, "purchasingSubscriptionName", m.PurchasingSubscriptionName)
	populate(objectMap, "quantity", m.Quantity)
	populate(objectMap, "region", m.Region)
	populate(objectMap, "reservationOrderId", m.ReservationOrderID)
	populate(objectMap, "reservationOrderName", m.ReservationOrderName)
	populate(objectMap, "term", m.Term)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernReservationTransactionProperties.
func (m *ModernReservationTransactionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "amount":
			err = unpopulate(val, &m.Amount)
			delete(rawMsg, key)
		case "armSkuName":
			err = unpopulate(val, &m.ArmSKUName)
			delete(rawMsg, key)
		case "billingFrequency":
			err = unpopulate(val, &m.BillingFrequency)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &m.BillingProfileID)
			delete(rawMsg, key)
		case "billingProfileName":
			err = unpopulate(val, &m.BillingProfileName)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &m.Currency)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "eventDate":
			err = unpopulateTimeRFC3339(val, &m.EventDate)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, &m.EventType)
			delete(rawMsg, key)
		case "invoice":
			err = unpopulate(val, &m.Invoice)
			delete(rawMsg, key)
		case "invoiceId":
			err = unpopulate(val, &m.InvoiceID)
			delete(rawMsg, key)
		case "invoiceSectionId":
			err = unpopulate(val, &m.InvoiceSectionID)
			delete(rawMsg, key)
		case "invoiceSectionName":
			err = unpopulate(val, &m.InvoiceSectionName)
			delete(rawMsg, key)
		case "purchasingSubscriptionGuid":
			err = unpopulate(val, &m.PurchasingSubscriptionGUID)
			delete(rawMsg, key)
		case "purchasingSubscriptionName":
			err = unpopulate(val, &m.PurchasingSubscriptionName)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &m.Quantity)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &m.Region)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &m.ReservationOrderID)
			delete(rawMsg, key)
		case "reservationOrderName":
			err = unpopulate(val, &m.ReservationOrderName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &m.Term)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModernReservationTransactionsListResult.
func (m ModernReservationTransactionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// GetUsageDetail implements the UsageDetailClassification interface for type ModernUsageDetail.
func (m *ModernUsageDetail) GetUsageDetail() *UsageDetail {
	return &UsageDetail{
		Kind: m.Kind,
		ID:   m.ID,
		Name: m.Name,
		Type: m.Type,
		Etag: m.Etag,
		Tags: m.Tags,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ModernUsageDetail.
func (m ModernUsageDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = UsageDetailsKindModern
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernUsageDetail.
func (m *ModernUsageDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModernUsageDetailProperties.
func (m ModernUsageDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", m.AdditionalInfo)
	populate(objectMap, "benefitId", m.BenefitID)
	populate(objectMap, "benefitName", m.BenefitName)
	populate(objectMap, "billingAccountId", m.BillingAccountID)
	populate(objectMap, "billingAccountName", m.BillingAccountName)
	populate(objectMap, "billingCurrencyCode", m.BillingCurrencyCode)
	populateTimeRFC3339(objectMap, "billingPeriodEndDate", m.BillingPeriodEndDate)
	populateTimeRFC3339(objectMap, "billingPeriodStartDate", m.BillingPeriodStartDate)
	populate(objectMap, "billingProfileId", m.BillingProfileID)
	populate(objectMap, "billingProfileName", m.BillingProfileName)
	populate(objectMap, "chargeType", m.ChargeType)
	populate(objectMap, "consumedService", m.ConsumedService)
	populate(objectMap, "costAllocationRuleName", m.CostAllocationRuleName)
	populate(objectMap, "costCenter", m.CostCenter)
	populate(objectMap, "costInBillingCurrency", m.CostInBillingCurrency)
	populate(objectMap, "costInPricingCurrency", m.CostInPricingCurrency)
	populate(objectMap, "costInUSD", m.CostInUSD)
	populate(objectMap, "customerName", m.CustomerName)
	populate(objectMap, "customerTenantId", m.CustomerTenantID)
	populateTimeRFC3339(objectMap, "date", m.Date)
	populate(objectMap, "effectivePrice", m.EffectivePrice)
	populate(objectMap, "exchangeRate", m.ExchangeRate)
	populateTimeRFC3339(objectMap, "exchangeRateDate", m.ExchangeRateDate)
	populate(objectMap, "exchangeRatePricingToBilling", m.ExchangeRatePricingToBilling)
	populate(objectMap, "frequency", m.Frequency)
	populate(objectMap, "instanceName", m.InstanceName)
	populate(objectMap, "invoiceId", m.InvoiceID)
	populate(objectMap, "invoiceSectionId", m.InvoiceSectionID)
	populate(objectMap, "invoiceSectionName", m.InvoiceSectionName)
	populate(objectMap, "isAzureCreditEligible", m.IsAzureCreditEligible)
	populate(objectMap, "marketPrice", m.MarketPrice)
	populate(objectMap, "meterCategory", m.MeterCategory)
	populate(objectMap, "meterId", m.MeterID)
	populate(objectMap, "meterName", m.MeterName)
	populate(objectMap, "meterRegion", m.MeterRegion)
	populate(objectMap, "meterSubCategory", m.MeterSubCategory)
	populate(objectMap, "partnerEarnedCreditApplied", m.PartnerEarnedCreditApplied)
	populate(objectMap, "partnerEarnedCreditRate", m.PartnerEarnedCreditRate)
	populate(objectMap, "partnerName", m.PartnerName)
	populate(objectMap, "partnerTenantId", m.PartnerTenantID)
	populate(objectMap, "payGPrice", m.PayGPrice)
	populate(objectMap, "paygCostInBillingCurrency", m.PaygCostInBillingCurrency)
	populate(objectMap, "paygCostInUSD", m.PaygCostInUSD)
	populate(objectMap, "previousInvoiceId", m.PreviousInvoiceID)
	populate(objectMap, "pricingCurrencyCode", m.PricingCurrencyCode)
	populate(objectMap, "pricingModel", m.PricingModel)
	populate(objectMap, "product", m.Product)
	populate(objectMap, "productIdentifier", m.ProductIdentifier)
	populate(objectMap, "productOrderId", m.ProductOrderID)
	populate(objectMap, "productOrderName", m.ProductOrderName)
	populate(objectMap, "provider", m.Provider)
	populate(objectMap, "publisherId", m.PublisherID)
	populate(objectMap, "publisherName", m.PublisherName)
	populate(objectMap, "publisherType", m.PublisherType)
	populate(objectMap, "quantity", m.Quantity)
	populate(objectMap, "resellerMpnId", m.ResellerMpnID)
	populate(objectMap, "resellerName", m.ResellerName)
	populate(objectMap, "reservationId", m.ReservationID)
	populate(objectMap, "reservationName", m.ReservationName)
	populate(objectMap, "resourceGroup", m.ResourceGroup)
	populate(objectMap, "resourceLocation", m.ResourceLocation)
	populate(objectMap, "resourceLocationNormalized", m.ResourceLocationNormalized)
	populate(objectMap, "serviceFamily", m.ServiceFamily)
	populate(objectMap, "serviceInfo1", m.ServiceInfo1)
	populate(objectMap, "serviceInfo2", m.ServiceInfo2)
	populateTimeRFC3339(objectMap, "servicePeriodEndDate", m.ServicePeriodEndDate)
	populateTimeRFC3339(objectMap, "servicePeriodStartDate", m.ServicePeriodStartDate)
	populate(objectMap, "subscriptionGuid", m.SubscriptionGUID)
	populate(objectMap, "subscriptionName", m.SubscriptionName)
	populate(objectMap, "term", m.Term)
	populate(objectMap, "unitOfMeasure", m.UnitOfMeasure)
	populate(objectMap, "unitPrice", m.UnitPrice)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModernUsageDetailProperties.
func (m *ModernUsageDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, &m.AdditionalInfo)
			delete(rawMsg, key)
		case "benefitId":
			err = unpopulate(val, &m.BenefitID)
			delete(rawMsg, key)
		case "benefitName":
			err = unpopulate(val, &m.BenefitName)
			delete(rawMsg, key)
		case "billingAccountId":
			err = unpopulate(val, &m.BillingAccountID)
			delete(rawMsg, key)
		case "billingAccountName":
			err = unpopulate(val, &m.BillingAccountName)
			delete(rawMsg, key)
		case "billingCurrencyCode":
			err = unpopulate(val, &m.BillingCurrencyCode)
			delete(rawMsg, key)
		case "billingPeriodEndDate":
			err = unpopulateTimeRFC3339(val, &m.BillingPeriodEndDate)
			delete(rawMsg, key)
		case "billingPeriodStartDate":
			err = unpopulateTimeRFC3339(val, &m.BillingPeriodStartDate)
			delete(rawMsg, key)
		case "billingProfileId":
			err = unpopulate(val, &m.BillingProfileID)
			delete(rawMsg, key)
		case "billingProfileName":
			err = unpopulate(val, &m.BillingProfileName)
			delete(rawMsg, key)
		case "chargeType":
			err = unpopulate(val, &m.ChargeType)
			delete(rawMsg, key)
		case "consumedService":
			err = unpopulate(val, &m.ConsumedService)
			delete(rawMsg, key)
		case "costAllocationRuleName":
			err = unpopulate(val, &m.CostAllocationRuleName)
			delete(rawMsg, key)
		case "costCenter":
			err = unpopulate(val, &m.CostCenter)
			delete(rawMsg, key)
		case "costInBillingCurrency":
			err = unpopulate(val, &m.CostInBillingCurrency)
			delete(rawMsg, key)
		case "costInPricingCurrency":
			err = unpopulate(val, &m.CostInPricingCurrency)
			delete(rawMsg, key)
		case "costInUSD":
			err = unpopulate(val, &m.CostInUSD)
			delete(rawMsg, key)
		case "customerName":
			err = unpopulate(val, &m.CustomerName)
			delete(rawMsg, key)
		case "customerTenantId":
			err = unpopulate(val, &m.CustomerTenantID)
			delete(rawMsg, key)
		case "date":
			err = unpopulateTimeRFC3339(val, &m.Date)
			delete(rawMsg, key)
		case "effectivePrice":
			err = unpopulate(val, &m.EffectivePrice)
			delete(rawMsg, key)
		case "exchangeRate":
			err = unpopulate(val, &m.ExchangeRate)
			delete(rawMsg, key)
		case "exchangeRateDate":
			err = unpopulateTimeRFC3339(val, &m.ExchangeRateDate)
			delete(rawMsg, key)
		case "exchangeRatePricingToBilling":
			err = unpopulate(val, &m.ExchangeRatePricingToBilling)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &m.Frequency)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, &m.InstanceName)
			delete(rawMsg, key)
		case "invoiceId":
			err = unpopulate(val, &m.InvoiceID)
			delete(rawMsg, key)
		case "invoiceSectionId":
			err = unpopulate(val, &m.InvoiceSectionID)
			delete(rawMsg, key)
		case "invoiceSectionName":
			err = unpopulate(val, &m.InvoiceSectionName)
			delete(rawMsg, key)
		case "isAzureCreditEligible":
			err = unpopulate(val, &m.IsAzureCreditEligible)
			delete(rawMsg, key)
		case "marketPrice":
			err = unpopulate(val, &m.MarketPrice)
			delete(rawMsg, key)
		case "meterCategory":
			err = unpopulate(val, &m.MeterCategory)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, &m.MeterID)
			delete(rawMsg, key)
		case "meterName":
			err = unpopulate(val, &m.MeterName)
			delete(rawMsg, key)
		case "meterRegion":
			err = unpopulate(val, &m.MeterRegion)
			delete(rawMsg, key)
		case "meterSubCategory":
			err = unpopulate(val, &m.MeterSubCategory)
			delete(rawMsg, key)
		case "partnerEarnedCreditApplied":
			err = unpopulate(val, &m.PartnerEarnedCreditApplied)
			delete(rawMsg, key)
		case "partnerEarnedCreditRate":
			err = unpopulate(val, &m.PartnerEarnedCreditRate)
			delete(rawMsg, key)
		case "partnerName":
			err = unpopulate(val, &m.PartnerName)
			delete(rawMsg, key)
		case "partnerTenantId":
			err = unpopulate(val, &m.PartnerTenantID)
			delete(rawMsg, key)
		case "payGPrice":
			err = unpopulate(val, &m.PayGPrice)
			delete(rawMsg, key)
		case "paygCostInBillingCurrency":
			err = unpopulate(val, &m.PaygCostInBillingCurrency)
			delete(rawMsg, key)
		case "paygCostInUSD":
			err = unpopulate(val, &m.PaygCostInUSD)
			delete(rawMsg, key)
		case "previousInvoiceId":
			err = unpopulate(val, &m.PreviousInvoiceID)
			delete(rawMsg, key)
		case "pricingCurrencyCode":
			err = unpopulate(val, &m.PricingCurrencyCode)
			delete(rawMsg, key)
		case "pricingModel":
			err = unpopulate(val, &m.PricingModel)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, &m.Product)
			delete(rawMsg, key)
		case "productIdentifier":
			err = unpopulate(val, &m.ProductIdentifier)
			delete(rawMsg, key)
		case "productOrderId":
			err = unpopulate(val, &m.ProductOrderID)
			delete(rawMsg, key)
		case "productOrderName":
			err = unpopulate(val, &m.ProductOrderName)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, &m.Provider)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, &m.PublisherID)
			delete(rawMsg, key)
		case "publisherName":
			err = unpopulate(val, &m.PublisherName)
			delete(rawMsg, key)
		case "publisherType":
			err = unpopulate(val, &m.PublisherType)
			delete(rawMsg, key)
		case "quantity":
			err = unpopulate(val, &m.Quantity)
			delete(rawMsg, key)
		case "resellerMpnId":
			err = unpopulate(val, &m.ResellerMpnID)
			delete(rawMsg, key)
		case "resellerName":
			err = unpopulate(val, &m.ResellerName)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &m.ReservationID)
			delete(rawMsg, key)
		case "reservationName":
			err = unpopulate(val, &m.ReservationName)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, &m.ResourceGroup)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, &m.ResourceLocation)
			delete(rawMsg, key)
		case "resourceLocationNormalized":
			err = unpopulate(val, &m.ResourceLocationNormalized)
			delete(rawMsg, key)
		case "serviceFamily":
			err = unpopulate(val, &m.ServiceFamily)
			delete(rawMsg, key)
		case "serviceInfo1":
			err = unpopulate(val, &m.ServiceInfo1)
			delete(rawMsg, key)
		case "serviceInfo2":
			err = unpopulate(val, &m.ServiceInfo2)
			delete(rawMsg, key)
		case "servicePeriodEndDate":
			err = unpopulateTimeRFC3339(val, &m.ServicePeriodEndDate)
			delete(rawMsg, key)
		case "servicePeriodStartDate":
			err = unpopulateTimeRFC3339(val, &m.ServicePeriodStartDate)
			delete(rawMsg, key)
		case "subscriptionGuid":
			err = unpopulate(val, &m.SubscriptionGUID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, &m.SubscriptionName)
			delete(rawMsg, key)
		case "term":
			err = unpopulate(val, &m.Term)
			delete(rawMsg, key)
		case "unitOfMeasure":
			err = unpopulate(val, &m.UnitOfMeasure)
			delete(rawMsg, key)
		case "unitPrice":
			err = unpopulate(val, &m.UnitPrice)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Notification.
func (n Notification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contactEmails", n.ContactEmails)
	populate(objectMap, "contactGroups", n.ContactGroups)
	populate(objectMap, "contactRoles", n.ContactRoles)
	populate(objectMap, "enabled", n.Enabled)
	populate(objectMap, "locale", n.Locale)
	populate(objectMap, "operator", n.Operator)
	populate(objectMap, "threshold", n.Threshold)
	populate(objectMap, "thresholdType", n.ThresholdType)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PriceSheetModel.
func (p PriceSheetModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "download", p.Download)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "pricesheets", p.Pricesheets)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PriceSheetResult.
func (p PriceSheetResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationDetail.
func (r ReservationDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationDetailProperties.
func (r ReservationDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "instanceFlexibilityGroup", r.InstanceFlexibilityGroup)
	populate(objectMap, "instanceFlexibilityRatio", r.InstanceFlexibilityRatio)
	populate(objectMap, "instanceId", r.InstanceID)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "reservationId", r.ReservationID)
	populate(objectMap, "reservationOrderId", r.ReservationOrderID)
	populate(objectMap, "reservedHours", r.ReservedHours)
	populate(objectMap, "skuName", r.SKUName)
	populate(objectMap, "totalReservedQuantity", r.TotalReservedQuantity)
	populateTimeRFC3339(objectMap, "usageDate", r.UsageDate)
	populate(objectMap, "usedHours", r.UsedHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationDetailProperties.
func (r *ReservationDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceFlexibilityGroup":
			err = unpopulate(val, &r.InstanceFlexibilityGroup)
			delete(rawMsg, key)
		case "instanceFlexibilityRatio":
			err = unpopulate(val, &r.InstanceFlexibilityRatio)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, &r.InstanceID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &r.ReservationID)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &r.ReservationOrderID)
			delete(rawMsg, key)
		case "reservedHours":
			err = unpopulate(val, &r.ReservedHours)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &r.SKUName)
			delete(rawMsg, key)
		case "totalReservedQuantity":
			err = unpopulate(val, &r.TotalReservedQuantity)
			delete(rawMsg, key)
		case "usageDate":
			err = unpopulateTimeRFC3339(val, &r.UsageDate)
			delete(rawMsg, key)
		case "usedHours":
			err = unpopulate(val, &r.UsedHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReservationDetailsListResult.
func (r ReservationDetailsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// GetReservationRecommendation implements the ReservationRecommendationClassification interface for type ReservationRecommendation.
func (r *ReservationRecommendation) GetReservationRecommendation() *ReservationRecommendation {
	return r
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendation.
func (r ReservationRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	objectMap["kind"] = r.Kind
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsModel.
func (r ReservationRecommendationDetailsModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsResourceProperties.
func (r ReservationRecommendationDetailsResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedScopes", r.AppliedScopes)
	populate(objectMap, "onDemandRate", r.OnDemandRate)
	populate(objectMap, "product", r.Product)
	populate(objectMap, "region", r.Region)
	populate(objectMap, "reservationRate", r.ReservationRate)
	populate(objectMap, "resourceType", r.ResourceType)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsSavingsProperties.
func (r ReservationRecommendationDetailsSavingsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "calculatedSavings", r.CalculatedSavings)
	populate(objectMap, "lookBackPeriod", r.LookBackPeriod)
	populate(objectMap, "recommendedQuantity", r.RecommendedQuantity)
	populate(objectMap, "reservationOrderTerm", r.ReservationOrderTerm)
	populate(objectMap, "savingsType", r.SavingsType)
	populate(objectMap, "unitOfMeasure", r.UnitOfMeasure)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationDetailsUsageProperties.
func (r ReservationRecommendationDetailsUsageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "firstConsumptionDate", r.FirstConsumptionDate)
	populate(objectMap, "lastConsumptionDate", r.LastConsumptionDate)
	populate(objectMap, "lookBackUnitType", r.LookBackUnitType)
	populate(objectMap, "usageData", r.UsageData)
	populate(objectMap, "usageGrain", r.UsageGrain)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationRecommendationsListResult.
func (r ReservationRecommendationsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "previousLink", r.PreviousLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationRecommendationsListResult.
func (r *ReservationRecommendationsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &r.NextLink)
			delete(rawMsg, key)
		case "previousLink":
			err = unpopulate(val, &r.PreviousLink)
			delete(rawMsg, key)
		case "value":
			r.Value, err = unmarshalReservationRecommendationClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReservationSummariesListResult.
func (r ReservationSummariesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationSummary.
func (r ReservationSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationSummaryProperties.
func (r ReservationSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "avgUtilizationPercentage", r.AvgUtilizationPercentage)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "maxUtilizationPercentage", r.MaxUtilizationPercentage)
	populate(objectMap, "minUtilizationPercentage", r.MinUtilizationPercentage)
	populate(objectMap, "purchasedQuantity", r.PurchasedQuantity)
	populate(objectMap, "remainingQuantity", r.RemainingQuantity)
	populate(objectMap, "reservationId", r.ReservationID)
	populate(objectMap, "reservationOrderId", r.ReservationOrderID)
	populate(objectMap, "reservedHours", r.ReservedHours)
	populate(objectMap, "skuName", r.SKUName)
	populate(objectMap, "totalReservedQuantity", r.TotalReservedQuantity)
	populateTimeRFC3339(objectMap, "usageDate", r.UsageDate)
	populate(objectMap, "usedHours", r.UsedHours)
	populate(objectMap, "usedQuantity", r.UsedQuantity)
	populate(objectMap, "utilizedPercentage", r.UtilizedPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReservationSummaryProperties.
func (r *ReservationSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avgUtilizationPercentage":
			err = unpopulate(val, &r.AvgUtilizationPercentage)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "maxUtilizationPercentage":
			err = unpopulate(val, &r.MaxUtilizationPercentage)
			delete(rawMsg, key)
		case "minUtilizationPercentage":
			err = unpopulate(val, &r.MinUtilizationPercentage)
			delete(rawMsg, key)
		case "purchasedQuantity":
			err = unpopulate(val, &r.PurchasedQuantity)
			delete(rawMsg, key)
		case "remainingQuantity":
			err = unpopulate(val, &r.RemainingQuantity)
			delete(rawMsg, key)
		case "reservationId":
			err = unpopulate(val, &r.ReservationID)
			delete(rawMsg, key)
		case "reservationOrderId":
			err = unpopulate(val, &r.ReservationOrderID)
			delete(rawMsg, key)
		case "reservedHours":
			err = unpopulate(val, &r.ReservedHours)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &r.SKUName)
			delete(rawMsg, key)
		case "totalReservedQuantity":
			err = unpopulate(val, &r.TotalReservedQuantity)
			delete(rawMsg, key)
		case "usageDate":
			err = unpopulateTimeRFC3339(val, &r.UsageDate)
			delete(rawMsg, key)
		case "usedHours":
			err = unpopulate(val, &r.UsedHours)
			delete(rawMsg, key)
		case "usedQuantity":
			err = unpopulate(val, &r.UsedQuantity)
			delete(rawMsg, key)
		case "utilizedPercentage":
			err = unpopulate(val, &r.UtilizedPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReservationTransaction.
func (r ReservationTransaction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationTransactionResource.
func (r ReservationTransactionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReservationTransactionsListResult.
func (r ReservationTransactionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Tag.
func (t Tag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", t.Key)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TagProperties.
func (t TagProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "previousLink", t.PreviousLink)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// GetUsageDetail implements the UsageDetailClassification interface for type UsageDetail.
func (u *UsageDetail) GetUsageDetail() *UsageDetail { return u }

// MarshalJSON implements the json.Marshaller interface for type UsageDetail.
func (u UsageDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", u.Etag)
	populate(objectMap, "id", u.ID)
	objectMap["kind"] = u.Kind
	populate(objectMap, "name", u.Name)
	populate(objectMap, "tags", u.Tags)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type UsageDetailsListResult.
func (u UsageDetailsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageDetailsListResult.
func (u *UsageDetailsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &u.NextLink)
			delete(rawMsg, key)
		case "value":
			u.Value, err = unmarshalUsageDetailClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
