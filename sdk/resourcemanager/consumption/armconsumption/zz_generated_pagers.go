//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armconsumption

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// BudgetsListPager provides operations for iterating over paged responses.
type BudgetsListPager struct {
	client    *BudgetsClient
	current   BudgetsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BudgetsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BudgetsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BudgetsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BudgetsListResult.NextLink == nil || len(*p.current.BudgetsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BudgetsListResponse page.
func (p *BudgetsListPager) PageResponse() BudgetsListResponse {
	return p.current
}

// EventsListByBillingAccountPager provides operations for iterating over paged responses.
type EventsListByBillingAccountPager struct {
	client    *EventsClient
	current   EventsListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventsListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EventsListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EventsListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.Events.NextLink == nil || len(*p.current.Events.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByBillingAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EventsListByBillingAccountResponse page.
func (p *EventsListByBillingAccountPager) PageResponse() EventsListByBillingAccountResponse {
	return p.current
}

// EventsListByBillingProfilePager provides operations for iterating over paged responses.
type EventsListByBillingProfilePager struct {
	client    *EventsClient
	current   EventsListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventsListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EventsListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EventsListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.Events.NextLink == nil || len(*p.current.Events.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByBillingProfileHandleError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EventsListByBillingProfileResponse page.
func (p *EventsListByBillingProfilePager) PageResponse() EventsListByBillingProfileResponse {
	return p.current
}

// LotsListByBillingAccountPager provides operations for iterating over paged responses.
type LotsListByBillingAccountPager struct {
	client    *LotsClient
	current   LotsListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LotsListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LotsListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LotsListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.Lots.NextLink == nil || len(*p.current.Lots.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByBillingAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LotsListByBillingAccountResponse page.
func (p *LotsListByBillingAccountPager) PageResponse() LotsListByBillingAccountResponse {
	return p.current
}

// LotsListByBillingProfilePager provides operations for iterating over paged responses.
type LotsListByBillingProfilePager struct {
	client    *LotsClient
	current   LotsListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LotsListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LotsListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LotsListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.Lots.NextLink == nil || len(*p.current.Lots.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByBillingProfileHandleError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LotsListByBillingProfileResponse page.
func (p *LotsListByBillingProfilePager) PageResponse() LotsListByBillingProfileResponse {
	return p.current
}

// MarketplacesListPager provides operations for iterating over paged responses.
type MarketplacesListPager struct {
	client    *MarketplacesClient
	current   MarketplacesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, MarketplacesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *MarketplacesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *MarketplacesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.MarketplacesListResult.NextLink == nil || len(*p.current.MarketplacesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current MarketplacesListResponse page.
func (p *MarketplacesListPager) PageResponse() MarketplacesListResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// ReservationRecommendationsListPager provides operations for iterating over paged responses.
type ReservationRecommendationsListPager struct {
	client    *ReservationRecommendationsClient
	current   ReservationRecommendationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationRecommendationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationRecommendationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationRecommendationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationRecommendationsListResult.NextLink == nil || len(*p.current.ReservationRecommendationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationRecommendationsListResponse page.
func (p *ReservationRecommendationsListPager) PageResponse() ReservationRecommendationsListResponse {
	return p.current
}

// ReservationTransactionsListByBillingProfilePager provides operations for iterating over paged responses.
type ReservationTransactionsListByBillingProfilePager struct {
	client    *ReservationTransactionsClient
	current   ReservationTransactionsListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationTransactionsListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationTransactionsListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationTransactionsListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ModernReservationTransactionsListResult.NextLink == nil || len(*p.current.ModernReservationTransactionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByBillingProfileHandleError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationTransactionsListByBillingProfileResponse page.
func (p *ReservationTransactionsListByBillingProfilePager) PageResponse() ReservationTransactionsListByBillingProfileResponse {
	return p.current
}

// ReservationTransactionsListPager provides operations for iterating over paged responses.
type ReservationTransactionsListPager struct {
	client    *ReservationTransactionsClient
	current   ReservationTransactionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationTransactionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationTransactionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationTransactionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationTransactionsListResult.NextLink == nil || len(*p.current.ReservationTransactionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationTransactionsListResponse page.
func (p *ReservationTransactionsListPager) PageResponse() ReservationTransactionsListResponse {
	return p.current
}

// ReservationsDetailsListByReservationOrderAndReservationPager provides operations for iterating over paged responses.
type ReservationsDetailsListByReservationOrderAndReservationPager struct {
	client    *ReservationsDetailsClient
	current   ReservationsDetailsListByReservationOrderAndReservationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsDetailsListByReservationOrderAndReservationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsDetailsListByReservationOrderAndReservationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsDetailsListByReservationOrderAndReservationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationDetailsListResult.NextLink == nil || len(*p.current.ReservationDetailsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByReservationOrderAndReservationHandleError(resp)
		return false
	}
	result, err := p.client.listByReservationOrderAndReservationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsDetailsListByReservationOrderAndReservationResponse page.
func (p *ReservationsDetailsListByReservationOrderAndReservationPager) PageResponse() ReservationsDetailsListByReservationOrderAndReservationResponse {
	return p.current
}

// ReservationsDetailsListByReservationOrderPager provides operations for iterating over paged responses.
type ReservationsDetailsListByReservationOrderPager struct {
	client    *ReservationsDetailsClient
	current   ReservationsDetailsListByReservationOrderResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsDetailsListByReservationOrderResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsDetailsListByReservationOrderPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsDetailsListByReservationOrderPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationDetailsListResult.NextLink == nil || len(*p.current.ReservationDetailsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByReservationOrderHandleError(resp)
		return false
	}
	result, err := p.client.listByReservationOrderHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsDetailsListByReservationOrderResponse page.
func (p *ReservationsDetailsListByReservationOrderPager) PageResponse() ReservationsDetailsListByReservationOrderResponse {
	return p.current
}

// ReservationsDetailsListPager provides operations for iterating over paged responses.
type ReservationsDetailsListPager struct {
	client    *ReservationsDetailsClient
	current   ReservationsDetailsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsDetailsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsDetailsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsDetailsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationDetailsListResult.NextLink == nil || len(*p.current.ReservationDetailsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsDetailsListResponse page.
func (p *ReservationsDetailsListPager) PageResponse() ReservationsDetailsListResponse {
	return p.current
}

// ReservationsSummariesListByReservationOrderAndReservationPager provides operations for iterating over paged responses.
type ReservationsSummariesListByReservationOrderAndReservationPager struct {
	client    *ReservationsSummariesClient
	current   ReservationsSummariesListByReservationOrderAndReservationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsSummariesListByReservationOrderAndReservationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsSummariesListByReservationOrderAndReservationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsSummariesListByReservationOrderAndReservationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationSummariesListResult.NextLink == nil || len(*p.current.ReservationSummariesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByReservationOrderAndReservationHandleError(resp)
		return false
	}
	result, err := p.client.listByReservationOrderAndReservationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsSummariesListByReservationOrderAndReservationResponse page.
func (p *ReservationsSummariesListByReservationOrderAndReservationPager) PageResponse() ReservationsSummariesListByReservationOrderAndReservationResponse {
	return p.current
}

// ReservationsSummariesListByReservationOrderPager provides operations for iterating over paged responses.
type ReservationsSummariesListByReservationOrderPager struct {
	client    *ReservationsSummariesClient
	current   ReservationsSummariesListByReservationOrderResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsSummariesListByReservationOrderResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsSummariesListByReservationOrderPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsSummariesListByReservationOrderPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationSummariesListResult.NextLink == nil || len(*p.current.ReservationSummariesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByReservationOrderHandleError(resp)
		return false
	}
	result, err := p.client.listByReservationOrderHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsSummariesListByReservationOrderResponse page.
func (p *ReservationsSummariesListByReservationOrderPager) PageResponse() ReservationsSummariesListByReservationOrderResponse {
	return p.current
}

// ReservationsSummariesListPager provides operations for iterating over paged responses.
type ReservationsSummariesListPager struct {
	client    *ReservationsSummariesClient
	current   ReservationsSummariesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsSummariesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsSummariesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsSummariesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationSummariesListResult.NextLink == nil || len(*p.current.ReservationSummariesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsSummariesListResponse page.
func (p *ReservationsSummariesListPager) PageResponse() ReservationsSummariesListResponse {
	return p.current
}

// UsageDetailsListPager provides operations for iterating over paged responses.
type UsageDetailsListPager struct {
	client    *UsageDetailsClient
	current   UsageDetailsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsageDetailsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsageDetailsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsageDetailsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageDetailsListResult.NextLink == nil || len(*p.current.UsageDetailsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsageDetailsListResponse page.
func (p *UsageDetailsListPager) PageResponse() UsageDetailsListResponse {
	return p.current
}
