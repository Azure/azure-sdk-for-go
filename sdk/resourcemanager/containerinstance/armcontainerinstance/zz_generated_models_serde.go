//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerinstance

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ContainerExec.
func (c ContainerExec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "command", c.Command)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerGroup.
func (c ContainerGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerGroupIdentity.
func (c ContainerGroupIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", c.PrincipalID)
	populate(objectMap, "tenantId", c.TenantID)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "userAssignedIdentities", c.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerGroupProperties.
func (c ContainerGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containers", c.Containers)
	populate(objectMap, "dnsConfig", c.DNSConfig)
	populate(objectMap, "diagnostics", c.Diagnostics)
	populate(objectMap, "encryptionProperties", c.EncryptionProperties)
	populate(objectMap, "ipAddress", c.IPAddress)
	populate(objectMap, "imageRegistryCredentials", c.ImageRegistryCredentials)
	populate(objectMap, "initContainers", c.InitContainers)
	populate(objectMap, "instanceView", c.InstanceView)
	populate(objectMap, "osType", c.OSType)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "restartPolicy", c.RestartPolicy)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "subnetIds", c.SubnetIDs)
	populate(objectMap, "volumes", c.Volumes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerGroupPropertiesInstanceView.
func (c ContainerGroupPropertiesInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "events", c.Events)
	populate(objectMap, "state", c.State)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerHTTPGet.
func (c ContainerHTTPGet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "httpHeaders", c.HTTPHeaders)
	populate(objectMap, "path", c.Path)
	populate(objectMap, "port", c.Port)
	populate(objectMap, "scheme", c.Scheme)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "command", c.Command)
	populate(objectMap, "environmentVariables", c.EnvironmentVariables)
	populate(objectMap, "image", c.Image)
	populate(objectMap, "instanceView", c.InstanceView)
	populate(objectMap, "livenessProbe", c.LivenessProbe)
	populate(objectMap, "ports", c.Ports)
	populate(objectMap, "readinessProbe", c.ReadinessProbe)
	populate(objectMap, "resources", c.Resources)
	populate(objectMap, "volumeMounts", c.VolumeMounts)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerPropertiesInstanceView.
func (c ContainerPropertiesInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currentState", c.CurrentState)
	populate(objectMap, "events", c.Events)
	populate(objectMap, "previousState", c.PreviousState)
	populate(objectMap, "restartCount", c.RestartCount)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerState.
func (c ContainerState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "detailStatus", c.DetailStatus)
	populate(objectMap, "exitCode", c.ExitCode)
	populateTimeRFC3339(objectMap, "finishTime", c.FinishTime)
	populateTimeRFC3339(objectMap, "startTime", c.StartTime)
	populate(objectMap, "state", c.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerState.
func (c *ContainerState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detailStatus":
			err = unpopulate(val, "DetailStatus", &c.DetailStatus)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &c.ExitCode)
			delete(rawMsg, key)
		case "finishTime":
			err = unpopulateTimeRFC3339(val, "FinishTime", &c.FinishTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &c.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &c.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSConfiguration.
func (d DNSConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nameServers", d.NameServers)
	populate(objectMap, "options", d.Options)
	populate(objectMap, "searchDomains", d.SearchDomains)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Event.
func (e Event) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "count", e.Count)
	populateTimeRFC3339(objectMap, "firstTimestamp", e.FirstTimestamp)
	populateTimeRFC3339(objectMap, "lastTimestamp", e.LastTimestamp)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Event.
func (e *Event) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &e.Count)
			delete(rawMsg, key)
		case "firstTimestamp":
			err = unpopulateTimeRFC3339(val, "FirstTimestamp", &e.FirstTimestamp)
			delete(rawMsg, key)
		case "lastTimestamp":
			err = unpopulateTimeRFC3339(val, "LastTimestamp", &e.LastTimestamp)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPAddress.
func (i IPAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsNameLabel", i.DNSNameLabel)
	populate(objectMap, "dnsNameLabelReusePolicy", i.DNSNameLabelReusePolicy)
	populate(objectMap, "fqdn", i.Fqdn)
	populate(objectMap, "ip", i.IP)
	populate(objectMap, "ports", i.Ports)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InitContainerPropertiesDefinition.
func (i InitContainerPropertiesDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "command", i.Command)
	populate(objectMap, "environmentVariables", i.EnvironmentVariables)
	populate(objectMap, "image", i.Image)
	populate(objectMap, "instanceView", i.InstanceView)
	populate(objectMap, "volumeMounts", i.VolumeMounts)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InitContainerPropertiesDefinitionInstanceView.
func (i InitContainerPropertiesDefinitionInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currentState", i.CurrentState)
	populate(objectMap, "events", i.Events)
	populate(objectMap, "previousState", i.PreviousState)
	populate(objectMap, "restartCount", i.RestartCount)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogAnalytics.
func (l LogAnalytics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logType", l.LogType)
	populate(objectMap, "metadata", l.Metadata)
	populate(objectMap, "workspaceId", l.WorkspaceID)
	populate(objectMap, "workspaceKey", l.WorkspaceKey)
	populate(objectMap, "workspaceResourceId", l.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "zones", r.Zones)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Volume.
func (v Volume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureFile", v.AzureFile)
	populate(objectMap, "emptyDir", &v.EmptyDir)
	populate(objectMap, "gitRepo", v.GitRepo)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "secret", v.Secret)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
