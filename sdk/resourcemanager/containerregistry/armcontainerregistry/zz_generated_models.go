//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerregistry

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// ActivationProperties - The activation properties of the connected registry.
type ActivationProperties struct {
	// READ-ONLY; The activation status of the connected registry.
	Status *ActivationStatus `json:"status,omitempty" azure:"ro"`
}

// ActiveDirectoryObject - The Active Directory Object that will be used for authenticating the token of a container registry.
type ActiveDirectoryObject struct {
	// The user/group/application object ID for Active Directory Object that will be used for authenticating the token of a container registry.
	ObjectID *string `json:"objectId,omitempty"`

	// The tenant ID of user/group/application object Active Directory Object that will be used for authenticating the token of a container registry.
	TenantID *string `json:"tenantId,omitempty"`
}

// Actor - The agent that initiated the event. For most situations, this could be from the authorization context of the request.
type Actor struct {
	// The subject or username associated with the request context that generated the event.
	Name *string `json:"name,omitempty"`
}

// AgentPool - The agentpool that has the ARM resource and properties. The agentpool will have all information to create an agent pool.
type AgentPool struct {
	Resource
	// The properties associated with the agent pool
	Properties *AgentPoolProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AgentPool.
func (a AgentPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AgentPoolListResult - The collection of agent pools.
type AgentPoolListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value []*AgentPool `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolListResult.
func (a AgentPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AgentPoolProperties - The properties of agent pool.
type AgentPoolProperties struct {
	// The count of agent machine
	Count *int32 `json:"count,omitempty"`

	// The OS of agent machine
	OS *OS `json:"os,omitempty"`

	// The Tier of agent machine
	Tier *string `json:"tier,omitempty"`

	// The Virtual Network Subnet Resource Id of the agent machine
	VirtualNetworkSubnetResourceID *string `json:"virtualNetworkSubnetResourceId,omitempty"`

	// READ-ONLY; The provisioning state of this agent pool
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

type AgentPoolPropertiesUpdateParameters struct {
	// The count of agent machine
	Count *int32 `json:"count,omitempty"`
}

// AgentPoolQueueStatus - The QueueStatus of Agent Pool
type AgentPoolQueueStatus struct {
	// The number of pending runs in the queue
	Count *int32 `json:"count,omitempty"`
}

// AgentPoolUpdateParameters - The parameters for updating an agent pool.
type AgentPoolUpdateParameters struct {
	// The properties associated with the agent pool
	Properties *AgentPoolPropertiesUpdateParameters `json:"properties,omitempty"`

	// The ARM resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolUpdateParameters.
func (a AgentPoolUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// AgentPoolsBeginCreateOptions contains the optional parameters for the AgentPools.BeginCreate method.
type AgentPoolsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AgentPoolsBeginDeleteOptions contains the optional parameters for the AgentPools.BeginDelete method.
type AgentPoolsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AgentPoolsBeginUpdateOptions contains the optional parameters for the AgentPools.BeginUpdate method.
type AgentPoolsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AgentPoolsGetOptions contains the optional parameters for the AgentPools.Get method.
type AgentPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// AgentPoolsGetQueueStatusOptions contains the optional parameters for the AgentPools.GetQueueStatus method.
type AgentPoolsGetQueueStatusOptions struct {
	// placeholder for future optional parameters
}

// AgentPoolsListOptions contains the optional parameters for the AgentPools.List method.
type AgentPoolsListOptions struct {
	// placeholder for future optional parameters
}

// AgentProperties - The properties that determine the run agent configuration.
type AgentProperties struct {
	// The CPU configuration in terms of number of cores required for the run.
	CPU *int32 `json:"cpu,omitempty"`
}

// Argument - The properties of a run argument.
type Argument struct {
	// REQUIRED; The name of the argument.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The value of the argument.
	Value *string `json:"value,omitempty"`

	// Flag to indicate whether the argument represents a secret and want to be removed from build logs.
	IsSecret *bool `json:"isSecret,omitempty"`
}

// AuthInfo - The authorization properties for accessing the source code repository.
type AuthInfo struct {
	// REQUIRED; The access token used to access the source control provider.
	Token *string `json:"token,omitempty"`

	// REQUIRED; The type of Auth token.
	TokenType *TokenType `json:"tokenType,omitempty"`

	// Time in seconds that the token remains valid
	ExpiresIn *int32 `json:"expiresIn,omitempty"`

	// The refresh token used to refresh the access token.
	RefreshToken *string `json:"refreshToken,omitempty"`

	// The scope of the access token.
	Scope *string `json:"scope,omitempty"`
}

// AuthInfoUpdateParameters - The authorization properties for accessing the source code repository.
type AuthInfoUpdateParameters struct {
	// Time in seconds that the token remains valid
	ExpiresIn *int32 `json:"expiresIn,omitempty"`

	// The refresh token used to refresh the access token.
	RefreshToken *string `json:"refreshToken,omitempty"`

	// The scope of the access token.
	Scope *string `json:"scope,omitempty"`

	// The access token used to access the source control provider.
	Token *string `json:"token,omitempty"`

	// The type of Auth token.
	TokenType *TokenType `json:"tokenType,omitempty"`
}

// BaseImageDependency - Properties that describe a base image dependency.
type BaseImageDependency struct {
	// The sha256-based digest of the image manifest.
	Digest *string `json:"digest,omitempty"`

	// The registry login server.
	Registry *string `json:"registry,omitempty"`

	// The repository name.
	Repository *string `json:"repository,omitempty"`

	// The tag name.
	Tag *string `json:"tag,omitempty"`

	// The type of the base image dependency.
	Type *BaseImageDependencyType `json:"type,omitempty"`
}

// BaseImageTrigger - The trigger based on base image dependency.
type BaseImageTrigger struct {
	// REQUIRED; The type of the auto trigger for base image dependency updates.
	BaseImageTriggerType *BaseImageTriggerType `json:"baseImageTriggerType,omitempty"`

	// REQUIRED; The name of the trigger.
	Name *string `json:"name,omitempty"`

	// The current status of trigger.
	Status *TriggerStatus `json:"status,omitempty"`

	// The endpoint URL for receiving update triggers.
	UpdateTriggerEndpoint *string `json:"updateTriggerEndpoint,omitempty"`

	// Type of Payload body for Base image update triggers.
	UpdateTriggerPayloadType *UpdateTriggerPayloadType `json:"updateTriggerPayloadType,omitempty"`
}

// BaseImageTriggerUpdateParameters - The properties for updating base image dependency trigger.
type BaseImageTriggerUpdateParameters struct {
	// REQUIRED; The name of the trigger.
	Name *string `json:"name,omitempty"`

	// The type of the auto trigger for base image dependency updates.
	BaseImageTriggerType *BaseImageTriggerType `json:"baseImageTriggerType,omitempty"`

	// The current status of trigger.
	Status *TriggerStatus `json:"status,omitempty"`

	// The endpoint URL for receiving update triggers.
	UpdateTriggerEndpoint *string `json:"updateTriggerEndpoint,omitempty"`

	// Type of Payload body for Base image update triggers.
	UpdateTriggerPayloadType *UpdateTriggerPayloadType `json:"updateTriggerPayloadType,omitempty"`
}

// CallbackConfig - The configuration of service URI and custom headers for the webhook.
type CallbackConfig struct {
	// REQUIRED; The service URI for the webhook to post notifications.
	ServiceURI *string `json:"serviceUri,omitempty"`

	// Custom headers that will be added to the webhook notifications.
	CustomHeaders map[string]*string `json:"customHeaders,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CallbackConfig.
func (c CallbackConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customHeaders", c.CustomHeaders)
	populate(objectMap, "serviceUri", c.ServiceURI)
	return json.Marshal(objectMap)
}

// ConnectedRegistriesBeginCreateOptions contains the optional parameters for the ConnectedRegistries.BeginCreate method.
type ConnectedRegistriesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// ConnectedRegistriesBeginDeactivateOptions contains the optional parameters for the ConnectedRegistries.BeginDeactivate method.
type ConnectedRegistriesBeginDeactivateOptions struct {
	// placeholder for future optional parameters
}

// ConnectedRegistriesBeginDeleteOptions contains the optional parameters for the ConnectedRegistries.BeginDelete method.
type ConnectedRegistriesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ConnectedRegistriesBeginUpdateOptions contains the optional parameters for the ConnectedRegistries.BeginUpdate method.
type ConnectedRegistriesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ConnectedRegistriesGetOptions contains the optional parameters for the ConnectedRegistries.Get method.
type ConnectedRegistriesGetOptions struct {
	// placeholder for future optional parameters
}

// ConnectedRegistriesListOptions contains the optional parameters for the ConnectedRegistries.List method.
type ConnectedRegistriesListOptions struct {
	// An OData filter expression that describes a subset of connectedRegistries to return. The parameters that can be filtered are parent.id (the resource
	// id of the connectedRegistry parent), mode, and connectionState. The supported operator is eq.
	Filter *string
}

// ConnectedRegistry - An object that represents a connected registry for a container registry.
type ConnectedRegistry struct {
	ProxyResource
	// The properties of the connected registry.
	Properties *ConnectedRegistryProperties `json:"properties,omitempty"`
}

// ConnectedRegistryListResult - The result of a request to list connected registries for a container registry.
type ConnectedRegistryListResult struct {
	// The URI that can be used to request the next list of connected registries.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of connected registries. Since this list may be incomplete, the nextLink field should be used to request the next list of connected registries.
	Value []*ConnectedRegistry `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryListResult.
func (c ConnectedRegistryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ConnectedRegistryProperties - The properties of a connected registry.
type ConnectedRegistryProperties struct {
	// REQUIRED; The mode of the connected registry resource that indicates the permissions of the registry.
	Mode *ConnectedRegistryMode `json:"mode,omitempty"`

	// REQUIRED; The parent of the connected registry.
	Parent *ParentProperties `json:"parent,omitempty"`

	// The list of the ACR token resource IDs used to authenticate clients to the connected registry.
	ClientTokenIDs []*string `json:"clientTokenIds,omitempty"`

	// The logging properties of the connected registry.
	Logging *LoggingProperties `json:"logging,omitempty"`

	// The login server properties of the connected registry.
	LoginServer *LoginServerProperties `json:"loginServer,omitempty"`

	// READ-ONLY; The activation properties of the connected registry.
	Activation *ActivationProperties `json:"activation,omitempty" azure:"ro"`

	// READ-ONLY; The current connection state of the connected registry.
	ConnectionState *ConnectionState `json:"connectionState,omitempty" azure:"ro"`

	// READ-ONLY; The last activity time of the connected registry.
	LastActivityTime *time.Time `json:"lastActivityTime,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The list of current statuses of the connected registry.
	StatusDetails []*StatusDetailProperties `json:"statusDetails,omitempty" azure:"ro"`

	// READ-ONLY; The current version of ACR runtime on the connected registry.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryProperties.
func (c ConnectedRegistryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activation", c.Activation)
	populate(objectMap, "clientTokenIds", c.ClientTokenIDs)
	populate(objectMap, "connectionState", c.ConnectionState)
	populate(objectMap, "lastActivityTime", (*timeRFC3339)(c.LastActivityTime))
	populate(objectMap, "logging", c.Logging)
	populate(objectMap, "loginServer", c.LoginServer)
	populate(objectMap, "mode", c.Mode)
	populate(objectMap, "parent", c.Parent)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "statusDetails", c.StatusDetails)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectedRegistryProperties.
func (c *ConnectedRegistryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activation":
			err = unpopulate(val, &c.Activation)
			delete(rawMsg, key)
		case "clientTokenIds":
			err = unpopulate(val, &c.ClientTokenIDs)
			delete(rawMsg, key)
		case "connectionState":
			err = unpopulate(val, &c.ConnectionState)
			delete(rawMsg, key)
		case "lastActivityTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.LastActivityTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "logging":
			err = unpopulate(val, &c.Logging)
			delete(rawMsg, key)
		case "loginServer":
			err = unpopulate(val, &c.LoginServer)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &c.Mode)
			delete(rawMsg, key)
		case "parent":
			err = unpopulate(val, &c.Parent)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &c.StatusDetails)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &c.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectedRegistryUpdateParameters - The parameters for updating a connected registry.
type ConnectedRegistryUpdateParameters struct {
	// The properties of the connected registry update parameters.
	Properties *ConnectedRegistryUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryUpdateParameters.
func (c ConnectedRegistryUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// ConnectedRegistryUpdateProperties - The parameters for updating token properties.
type ConnectedRegistryUpdateProperties struct {
	// The list of the ACR token resource IDs used to authenticate clients to the connected registry.
	ClientTokenIDs []*string `json:"clientTokenIds,omitempty"`

	// The logging properties of the connected registry.
	Logging *LoggingProperties `json:"logging,omitempty"`

	// The sync properties of the connected registry with its parent.
	SyncProperties *SyncUpdateProperties `json:"syncProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryUpdateProperties.
func (c ConnectedRegistryUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientTokenIds", c.ClientTokenIDs)
	populate(objectMap, "logging", c.Logging)
	populate(objectMap, "syncProperties", c.SyncProperties)
	return json.Marshal(objectMap)
}

// Credentials - The parameters that describes a set of credentials that will be used when a run is invoked.
type Credentials struct {
	// Describes the credential parameters for accessing other custom registries. The key for the dictionary item will be the registry login server (myregistry.azurecr.io)
	// and the value of the item will be
	// the registry credentials for accessing the registry.
	CustomRegistries map[string]*CustomRegistryCredentials `json:"customRegistries,omitempty"`

	// Describes the credential parameters for accessing the source registry.
	SourceRegistry *SourceRegistryCredentials `json:"sourceRegistry,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Credentials.
func (c Credentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customRegistries", c.CustomRegistries)
	populate(objectMap, "sourceRegistry", c.SourceRegistry)
	return json.Marshal(objectMap)
}

// CustomRegistryCredentials - Describes the credentials that will be used to access a custom registry during a run.
type CustomRegistryCredentials struct {
	// Indicates the managed identity assigned to the custom credential. If a user-assigned identity this value is the Client ID. If a system-assigned identity,
	// the value will be system. In the case of a
	// system-assigned identity, the Client ID will be determined by the runner. This identity may be used to authenticate to key vault to retrieve credentials
	// or it may be the only source of authentication
	// used for accessing the registry.
	Identity *string `json:"identity,omitempty"`

	// The password for logging into the custom registry. The password is a secret object that allows multiple ways of providing the value for it.
	Password *SecretObject `json:"password,omitempty"`

	// The username for logging into the custom registry.
	UserName *SecretObject `json:"userName,omitempty"`
}

// DockerBuildRequest - The parameters for a docker quick build.
type DockerBuildRequest struct {
	RunRequest
	// REQUIRED; The Docker file path relative to the source location.
	DockerFilePath *string `json:"dockerFilePath,omitempty"`

	// REQUIRED; The platform properties against which the run has to happen.
	Platform *PlatformProperties `json:"platform,omitempty"`

	// The machine configuration of the run agent.
	AgentConfiguration *AgentProperties `json:"agentConfiguration,omitempty"`

	// The collection of override arguments to be used when executing the run.
	Arguments []*Argument `json:"arguments,omitempty"`

	// The properties that describes a set of credentials that will be used when this run is invoked.
	Credentials *Credentials `json:"credentials,omitempty"`

	// The fully qualified image names including the repository and tag.
	ImageNames []*string `json:"imageNames,omitempty"`

	// The value of this property indicates whether the image built should be pushed to the registry or not.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// The value of this property indicates whether the image cache is enabled or not.
	NoCache *bool `json:"noCache,omitempty"`

	// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository. If it is relative URL, the relative path should be
	// obtained from calling listBuildSourceUploadUrl API.
	SourceLocation *string `json:"sourceLocation,omitempty"`

	// The name of the target build stage for the docker build.
	Target *string `json:"target,omitempty"`

	// Run timeout in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildRequest.
func (d DockerBuildRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.RunRequest.marshalInternal(objectMap, "DockerBuildRequest")
	populate(objectMap, "agentConfiguration", d.AgentConfiguration)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "credentials", d.Credentials)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "platform", d.Platform)
	populate(objectMap, "sourceLocation", d.SourceLocation)
	populate(objectMap, "target", d.Target)
	populate(objectMap, "timeout", d.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildRequest.
func (d *DockerBuildRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &d.AgentConfiguration)
			delete(rawMsg, key)
		case "arguments":
			err = unpopulate(val, &d.Arguments)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &d.Credentials)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, &d.NoCache)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &d.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, &d.SourceLocation)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &d.Target)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &d.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.RunRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DockerBuildStep - The Docker build step.
type DockerBuildStep struct {
	TaskStepProperties
	// REQUIRED; The Docker file path relative to the source context.
	DockerFilePath *string `json:"dockerFilePath,omitempty"`

	// The collection of override arguments to be used when executing this build step.
	Arguments []*Argument `json:"arguments,omitempty"`

	// The fully qualified image names including the repository and tag.
	ImageNames []*string `json:"imageNames,omitempty"`

	// The value of this property indicates whether the image built should be pushed to the registry or not.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// The value of this property indicates whether the image cache is enabled or not.
	NoCache *bool `json:"noCache,omitempty"`

	// The name of the target build stage for the docker build.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildStep.
func (d DockerBuildStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.TaskStepProperties.marshalInternal(objectMap, StepTypeDocker)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "target", d.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildStep.
func (d *DockerBuildStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, &d.Arguments)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, &d.NoCache)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &d.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.TaskStepProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DockerBuildStepUpdateParameters - The properties for updating a docker build step.
type DockerBuildStepUpdateParameters struct {
	TaskStepUpdateParameters
	// The collection of override arguments to be used when executing this build step.
	Arguments []*Argument `json:"arguments,omitempty"`

	// The Docker file path relative to the source context.
	DockerFilePath *string `json:"dockerFilePath,omitempty"`

	// The fully qualified image names including the repository and tag.
	ImageNames []*string `json:"imageNames,omitempty"`

	// The value of this property indicates whether the image built should be pushed to the registry or not.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// The value of this property indicates whether the image cache is enabled or not.
	NoCache *bool `json:"noCache,omitempty"`

	// The name of the target build stage for the docker build.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildStepUpdateParameters.
func (d DockerBuildStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.TaskStepUpdateParameters.marshalInternal(objectMap, StepTypeDocker)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "target", d.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildStepUpdateParameters.
func (d *DockerBuildStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, &d.Arguments)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, &d.NoCache)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &d.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.TaskStepUpdateParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EncodedTaskRunRequest - The parameters for a quick task run request.
type EncodedTaskRunRequest struct {
	RunRequest
	// REQUIRED; Base64 encoded value of the template/definition file content.
	EncodedTaskContent *string `json:"encodedTaskContent,omitempty"`

	// REQUIRED; The platform properties against which the run has to happen.
	Platform *PlatformProperties `json:"platform,omitempty"`

	// The machine configuration of the run agent.
	AgentConfiguration *AgentProperties `json:"agentConfiguration,omitempty"`

	// The properties that describes a set of credentials that will be used when this run is invoked.
	Credentials *Credentials `json:"credentials,omitempty"`

	// Base64 encoded value of the parameters/values file content.
	EncodedValuesContent *string `json:"encodedValuesContent,omitempty"`

	// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository. If it is relative URL, the relative path should be
	// obtained from calling listBuildSourceUploadUrl API.
	SourceLocation *string `json:"sourceLocation,omitempty"`

	// Run timeout in seconds.
	Timeout *int32 `json:"timeout,omitempty"`

	// The collection of overridable values that can be passed when running a task.
	Values []*SetValue `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskRunRequest.
func (e EncodedTaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.RunRequest.marshalInternal(objectMap, "EncodedTaskRunRequest")
	populate(objectMap, "agentConfiguration", e.AgentConfiguration)
	populate(objectMap, "credentials", e.Credentials)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	populate(objectMap, "platform", e.Platform)
	populate(objectMap, "sourceLocation", e.SourceLocation)
	populate(objectMap, "timeout", e.Timeout)
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskRunRequest.
func (e *EncodedTaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &e.AgentConfiguration)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &e.Credentials)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &e.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, &e.SourceLocation)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &e.Timeout)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.RunRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EncodedTaskStep - The properties of a encoded task step.
type EncodedTaskStep struct {
	TaskStepProperties
	// REQUIRED; Base64 encoded value of the template/definition file content.
	EncodedTaskContent *string `json:"encodedTaskContent,omitempty"`

	// Base64 encoded value of the parameters/values file content.
	EncodedValuesContent *string `json:"encodedValuesContent,omitempty"`

	// The collection of overridable values that can be passed when running a task.
	Values []*SetValue `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskStep.
func (e EncodedTaskStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.TaskStepProperties.marshalInternal(objectMap, StepTypeEncodedTask)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskStep.
func (e *EncodedTaskStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encodedTaskContent":
			err = unpopulate(val, &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.TaskStepProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EncodedTaskStepUpdateParameters - The properties for updating encoded task step.
type EncodedTaskStepUpdateParameters struct {
	TaskStepUpdateParameters
	// Base64 encoded value of the template/definition file content.
	EncodedTaskContent *string `json:"encodedTaskContent,omitempty"`

	// Base64 encoded value of the parameters/values file content.
	EncodedValuesContent *string `json:"encodedValuesContent,omitempty"`

	// The collection of overridable values that can be passed when running a task.
	Values []*SetValue `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskStepUpdateParameters.
func (e EncodedTaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.TaskStepUpdateParameters.marshalInternal(objectMap, StepTypeEncodedTask)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskStepUpdateParameters.
func (e *EncodedTaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encodedTaskContent":
			err = unpopulate(val, &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.TaskStepUpdateParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type EncryptionProperty struct {
	// Key vault properties.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// Indicates whether or not the encryption is enabled for container registry.
	Status *EncryptionStatus `json:"status,omitempty"`
}

// ErrorResponse - An error response from the Azure Container Registry service.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// Azure container registry build API error body.
	InnerError *ErrorResponseBody `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// ErrorResponseBody - An error response from the Azure Container Registry service.
type ErrorResponseBody struct {
	// REQUIRED; error code.
	Code *string `json:"code,omitempty"`

	// REQUIRED; error message.
	Message *string `json:"message,omitempty"`

	// an array of additional nested error response info objects, as described by this contract.
	Details *InnerErrorDescription `json:"details,omitempty"`

	// target of the particular error.
	Target *string `json:"target,omitempty"`
}

// Event - The event for a webhook.
type Event struct {
	EventInfo
	// The event request message sent to the service URI.
	EventRequestMessage *EventRequestMessage `json:"eventRequestMessage,omitempty"`

	// The event response message received from the service URI.
	EventResponseMessage *EventResponseMessage `json:"eventResponseMessage,omitempty"`
}

// EventContent - The content of the event request message.
type EventContent struct {
	// The action that encompasses the provided event.
	Action *string `json:"action,omitempty"`

	// The agent that initiated the event. For most situations, this could be from the authorization context of the request.
	Actor *Actor `json:"actor,omitempty"`

	// The event ID.
	ID *string `json:"id,omitempty"`

	// The request that generated the event.
	Request *Request `json:"request,omitempty"`

	// The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it.
	Source *Source `json:"source,omitempty"`

	// The target of the event.
	Target *Target `json:"target,omitempty"`

	// The time at which the event occurred.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventContent.
func (e EventContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", e.Action)
	populate(objectMap, "actor", e.Actor)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "request", e.Request)
	populate(objectMap, "source", e.Source)
	populate(objectMap, "target", e.Target)
	populate(objectMap, "timestamp", (*timeRFC3339)(e.Timestamp))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventContent.
func (e *EventContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, &e.Action)
			delete(rawMsg, key)
		case "actor":
			err = unpopulate(val, &e.Actor)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &e.ID)
			delete(rawMsg, key)
		case "request":
			err = unpopulate(val, &e.Request)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &e.Source)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &e.Target)
			delete(rawMsg, key)
		case "timestamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			e.Timestamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventInfo - The basic information of an event.
type EventInfo struct {
	// The event ID.
	ID *string `json:"id,omitempty"`
}

// EventListResult - The result of a request to list events for a webhook.
type EventListResult struct {
	// The URI that can be used to request the next list of events.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of events. Since this list may be incomplete, the nextLink field should be used to request the next list of events.
	Value []*Event `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventListResult.
func (e EventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EventRequestMessage - The event request message sent to the service URI.
type EventRequestMessage struct {
	// The content of the event request message.
	Content *EventContent `json:"content,omitempty"`

	// The headers of the event request message.
	Headers map[string]*string `json:"headers,omitempty"`

	// The HTTP method used to send the event request message.
	Method *string `json:"method,omitempty"`

	// The URI used to send the event request message.
	RequestURI *string `json:"requestUri,omitempty"`

	// The HTTP message version.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventRequestMessage.
func (e EventRequestMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", e.Content)
	populate(objectMap, "headers", e.Headers)
	populate(objectMap, "method", e.Method)
	populate(objectMap, "requestUri", e.RequestURI)
	populate(objectMap, "version", e.Version)
	return json.Marshal(objectMap)
}

// EventResponseMessage - The event response message received from the service URI.
type EventResponseMessage struct {
	// The content of the event response message.
	Content *string `json:"content,omitempty"`

	// The headers of the event response message.
	Headers map[string]*string `json:"headers,omitempty"`

	// The reason phrase of the event response message.
	ReasonPhrase *string `json:"reasonPhrase,omitempty"`

	// The status code of the event response message.
	StatusCode *string `json:"statusCode,omitempty"`

	// The HTTP message version.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventResponseMessage.
func (e EventResponseMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", e.Content)
	populate(objectMap, "headers", e.Headers)
	populate(objectMap, "reasonPhrase", e.ReasonPhrase)
	populate(objectMap, "statusCode", e.StatusCode)
	populate(objectMap, "version", e.Version)
	return json.Marshal(objectMap)
}

// ExportPipeline - An object that represents an export pipeline for a container registry.
type ExportPipeline struct {
	ProxyResource
	// The identity of the export pipeline.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The location of the export pipeline.
	Location *string `json:"location,omitempty"`

	// The properties of the export pipeline.
	Properties *ExportPipelineProperties `json:"properties,omitempty"`
}

// ExportPipelineListResult - The result of a request to list export pipelines for a container registry.
type ExportPipelineListResult struct {
	// The URI that can be used to request the next list of pipeline runs.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of export pipelines. Since this list may be incomplete, the nextLink field should be used to request the next list of export pipelines.
	Value []*ExportPipeline `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportPipelineListResult.
func (e ExportPipelineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExportPipelineProperties - The properties of an export pipeline.
type ExportPipelineProperties struct {
	// REQUIRED; The target properties of the export pipeline.
	Target *ExportPipelineTargetProperties `json:"target,omitempty"`

	// The list of all options configured for the pipeline.
	Options []*PipelineOptions `json:"options,omitempty"`

	// READ-ONLY; The provisioning state of the pipeline at the time the operation was called.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportPipelineProperties.
func (e ExportPipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "options", e.Options)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ExportPipelineTargetProperties - The properties of the export pipeline target.
type ExportPipelineTargetProperties struct {
	// REQUIRED; They key vault secret uri to obtain the target storage SAS token.
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`

	// The type of target for the export pipeline.
	Type *string `json:"type,omitempty"`

	// The target uri of the export pipeline. When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName" When 'AzureStorageBlobContainer':
	// "https://accountName.blob.core.windows.net/containerName"
	URI *string `json:"uri,omitempty"`
}

// ExportPipelinesBeginCreateOptions contains the optional parameters for the ExportPipelines.BeginCreate method.
type ExportPipelinesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// ExportPipelinesBeginDeleteOptions contains the optional parameters for the ExportPipelines.BeginDelete method.
type ExportPipelinesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ExportPipelinesGetOptions contains the optional parameters for the ExportPipelines.Get method.
type ExportPipelinesGetOptions struct {
	// placeholder for future optional parameters
}

// ExportPipelinesListOptions contains the optional parameters for the ExportPipelines.List method.
type ExportPipelinesListOptions struct {
	// placeholder for future optional parameters
}

// ExportPolicy - The export policy for a container registry.
type ExportPolicy struct {
	// The value that indicates whether the policy is enabled or not.
	Status *ExportPolicyStatus `json:"status,omitempty"`
}

// FileTaskRunRequest - The request parameters for a scheduling run against a task file.
type FileTaskRunRequest struct {
	RunRequest
	// REQUIRED; The platform properties against which the run has to happen.
	Platform *PlatformProperties `json:"platform,omitempty"`

	// REQUIRED; The template/definition file path relative to the source.
	TaskFilePath *string `json:"taskFilePath,omitempty"`

	// The machine configuration of the run agent.
	AgentConfiguration *AgentProperties `json:"agentConfiguration,omitempty"`

	// The properties that describes a set of credentials that will be used when this run is invoked.
	Credentials *Credentials `json:"credentials,omitempty"`

	// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository. If it is relative URL, the relative path should be
	// obtained from calling listBuildSourceUploadUrl API.
	SourceLocation *string `json:"sourceLocation,omitempty"`

	// Run timeout in seconds.
	Timeout *int32 `json:"timeout,omitempty"`

	// The collection of overridable values that can be passed when running a task.
	Values []*SetValue `json:"values,omitempty"`

	// The values/parameters file path relative to the source.
	ValuesFilePath *string `json:"valuesFilePath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskRunRequest.
func (f FileTaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.RunRequest.marshalInternal(objectMap, "FileTaskRunRequest")
	populate(objectMap, "agentConfiguration", f.AgentConfiguration)
	populate(objectMap, "credentials", f.Credentials)
	populate(objectMap, "platform", f.Platform)
	populate(objectMap, "sourceLocation", f.SourceLocation)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	populate(objectMap, "timeout", f.Timeout)
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskRunRequest.
func (f *FileTaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &f.AgentConfiguration)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &f.Credentials)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &f.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, &f.SourceLocation)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, &f.TaskFilePath)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &f.Timeout)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := f.RunRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// FileTaskStep - The properties of a task step.
type FileTaskStep struct {
	TaskStepProperties
	// REQUIRED; The task template/definition file path relative to the source context.
	TaskFilePath *string `json:"taskFilePath,omitempty"`

	// The collection of overridable values that can be passed when running a task.
	Values []*SetValue `json:"values,omitempty"`

	// The task values/parameters file path relative to the source context.
	ValuesFilePath *string `json:"valuesFilePath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskStep.
func (f FileTaskStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.TaskStepProperties.marshalInternal(objectMap, StepTypeFileTask)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskStep.
func (f *FileTaskStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "taskFilePath":
			err = unpopulate(val, &f.TaskFilePath)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := f.TaskStepProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// FileTaskStepUpdateParameters - The properties of updating a task step.
type FileTaskStepUpdateParameters struct {
	TaskStepUpdateParameters
	// The task template/definition file path relative to the source context.
	TaskFilePath *string `json:"taskFilePath,omitempty"`

	// The collection of overridable values that can be passed when running a task.
	Values []*SetValue `json:"values,omitempty"`

	// The values/parameters file path relative to the source context.
	ValuesFilePath *string `json:"valuesFilePath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskStepUpdateParameters.
func (f FileTaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.TaskStepUpdateParameters.marshalInternal(objectMap, StepTypeFileTask)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskStepUpdateParameters.
func (f *FileTaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "taskFilePath":
			err = unpopulate(val, &f.TaskFilePath)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := f.TaskStepUpdateParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GenerateCredentialsParameters - The parameters used to generate credentials for a specified token or user of a container registry.
type GenerateCredentialsParameters struct {
	// The expiry date of the generated credentials after which the credentials become invalid.
	Expiry *time.Time `json:"expiry,omitempty"`

	// Specifies name of the password which should be regenerated if any -- password1 or password2.
	Name *TokenPasswordName `json:"name,omitempty"`

	// The resource ID of the token for which credentials have to be generated.
	TokenID *string `json:"tokenId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GenerateCredentialsParameters.
func (g GenerateCredentialsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expiry", (*timeRFC3339)(g.Expiry))
	populate(objectMap, "name", g.Name)
	populate(objectMap, "tokenId", g.TokenID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenerateCredentialsParameters.
func (g *GenerateCredentialsParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiry":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			g.Expiry = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &g.Name)
			delete(rawMsg, key)
		case "tokenId":
			err = unpopulate(val, &g.TokenID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GenerateCredentialsResult - The response from the GenerateCredentials operation.
type GenerateCredentialsResult struct {
	// The list of passwords for a container registry.
	Passwords []*TokenPassword `json:"passwords,omitempty"`

	// The username for a container registry.
	Username *string `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GenerateCredentialsResult.
func (g GenerateCredentialsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "passwords", g.Passwords)
	populate(objectMap, "username", g.Username)
	return json.Marshal(objectMap)
}

// IPRule - IP rule with specific IP or IP range in CIDR format.
type IPRule struct {
	// REQUIRED; Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
	IPAddressOrRange *string `json:"value,omitempty"`

	// The action of IP ACL rule.
	Action *Action `json:"action,omitempty"`
}

// IdentityProperties - Managed identity for the resource.
type IdentityProperties struct {
	// The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`

	// The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`

	// The identity type.
	Type *ResourceIdentityType `json:"type,omitempty"`

	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/ providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*UserIdentityProperties `json:"userAssignedIdentities,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IdentityProperties.
func (i IdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// ImageDescriptor - Properties for a registry image.
type ImageDescriptor struct {
	// The sha256-based digest of the image manifest.
	Digest *string `json:"digest,omitempty"`

	// The registry login server.
	Registry *string `json:"registry,omitempty"`

	// The repository name.
	Repository *string `json:"repository,omitempty"`

	// The tag name.
	Tag *string `json:"tag,omitempty"`
}

// ImageUpdateTrigger - The image update trigger that caused a build.
type ImageUpdateTrigger struct {
	// The unique ID of the trigger.
	ID *string `json:"id,omitempty"`

	// The list of image updates that caused the build.
	Images []*ImageDescriptor `json:"images,omitempty"`

	// The timestamp when the image update happened.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImageUpdateTrigger.
func (i ImageUpdateTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "images", i.Images)
	populate(objectMap, "timestamp", (*timeRFC3339)(i.Timestamp))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageUpdateTrigger.
func (i *ImageUpdateTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "images":
			err = unpopulate(val, &i.Images)
			delete(rawMsg, key)
		case "timestamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			i.Timestamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type ImportImageParameters struct {
	// REQUIRED; The source of the image.
	Source *ImportSource `json:"source,omitempty"`

	// When Force, any existing target tags will be overwritten. When NoForce, any existing target tags will fail the operation before any copying begins.
	Mode *ImportMode `json:"mode,omitempty"`

	// List of strings of the form repo[:tag]. When tag is omitted the source will be used (or 'latest' if source tag is also omitted).
	TargetTags []*string `json:"targetTags,omitempty"`

	// List of strings of repository names to do a manifest only copy. No tag will be created.
	UntaggedTargetRepositories []*string `json:"untaggedTargetRepositories,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImportImageParameters.
func (i ImportImageParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "mode", i.Mode)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "targetTags", i.TargetTags)
	populate(objectMap, "untaggedTargetRepositories", i.UntaggedTargetRepositories)
	return json.Marshal(objectMap)
}

// ImportPipeline - An object that represents an import pipeline for a container registry.
type ImportPipeline struct {
	ProxyResource
	// The identity of the import pipeline.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The location of the import pipeline.
	Location *string `json:"location,omitempty"`

	// The properties of the import pipeline.
	Properties *ImportPipelineProperties `json:"properties,omitempty"`
}

// ImportPipelineListResult - The result of a request to list import pipelines for a container registry.
type ImportPipelineListResult struct {
	// The URI that can be used to request the next list of pipeline runs.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of import pipelines. Since this list may be incomplete, the nextLink field should be used to request the next list of import pipelines.
	Value []*ImportPipeline `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImportPipelineListResult.
func (i ImportPipelineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// ImportPipelineProperties - The properties of an import pipeline.
type ImportPipelineProperties struct {
	// REQUIRED; The source properties of the import pipeline.
	Source *ImportPipelineSourceProperties `json:"source,omitempty"`

	// The list of all options configured for the pipeline.
	Options []*PipelineOptions `json:"options,omitempty"`

	// The properties that describe the trigger of the import pipeline.
	Trigger *PipelineTriggerProperties `json:"trigger,omitempty"`

	// READ-ONLY; The provisioning state of the pipeline at the time the operation was called.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ImportPipelineProperties.
func (i ImportPipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "options", i.Options)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "trigger", i.Trigger)
	return json.Marshal(objectMap)
}

// ImportPipelineSourceProperties - The properties of the import pipeline source.
type ImportPipelineSourceProperties struct {
	// REQUIRED; They key vault secret uri to obtain the source storage SAS token.
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`

	// The type of source for the import pipeline.
	Type *PipelineSourceType `json:"type,omitempty"`

	// The source uri of the import pipeline. When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName" When 'AzureStorageBlobContainer':
	// "https://accountName.blob.core.windows.net/containerName"
	URI *string `json:"uri,omitempty"`
}

// ImportPipelinesBeginCreateOptions contains the optional parameters for the ImportPipelines.BeginCreate method.
type ImportPipelinesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// ImportPipelinesBeginDeleteOptions contains the optional parameters for the ImportPipelines.BeginDelete method.
type ImportPipelinesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ImportPipelinesGetOptions contains the optional parameters for the ImportPipelines.Get method.
type ImportPipelinesGetOptions struct {
	// placeholder for future optional parameters
}

// ImportPipelinesListOptions contains the optional parameters for the ImportPipelines.List method.
type ImportPipelinesListOptions struct {
	// placeholder for future optional parameters
}

type ImportSource struct {
	// REQUIRED; Repository name of the source image. Specify an image by repository ('hello-world'). This will use the 'latest' tag. Specify an image by tag
	// ('hello-world:latest'). Specify an image by sha256-based
	// manifest digest ('hello-world@sha256:abc123').
	SourceImage *string `json:"sourceImage,omitempty"`

	// Credentials used when importing from a registry uri.
	Credentials *ImportSourceCredentials `json:"credentials,omitempty"`

	// The address of the source registry (e.g. 'mcr.microsoft.com').
	RegistryURI *string `json:"registryUri,omitempty"`

	// The resource identifier of the source Azure Container Registry.
	ResourceID *string `json:"resourceId,omitempty"`
}

type ImportSourceCredentials struct {
	// REQUIRED; The password used to authenticate with the source registry.
	Password *string `json:"password,omitempty"`

	// The username to authenticate with the source registry.
	Username *string `json:"username,omitempty"`
}

// InnerErrorDescription - inner error.
type InnerErrorDescription struct {
	// REQUIRED; error code.
	Code *string `json:"code,omitempty"`

	// REQUIRED; error message.
	Message *string `json:"message,omitempty"`

	// target of the particular error.
	Target *string `json:"target,omitempty"`
}

type KeyVaultProperties struct {
	// The client id of the identity which will be used to access key vault.
	Identity *string `json:"identity,omitempty"`

	// Key vault uri to access the encryption key.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// READ-ONLY; Auto key rotation status for a CMK enabled registry.
	KeyRotationEnabled *bool `json:"keyRotationEnabled,omitempty" azure:"ro"`

	// READ-ONLY; Timestamp of the last successful key rotation.
	LastKeyRotationTimestamp *time.Time `json:"lastKeyRotationTimestamp,omitempty" azure:"ro"`

	// READ-ONLY; The fully qualified key identifier that includes the version of the key that is actually used for encryption.
	VersionedKeyIdentifier *string `json:"versionedKeyIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyVaultProperties.
func (k KeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", k.Identity)
	populate(objectMap, "keyIdentifier", k.KeyIdentifier)
	populate(objectMap, "keyRotationEnabled", k.KeyRotationEnabled)
	populate(objectMap, "lastKeyRotationTimestamp", (*timeRFC3339)(k.LastKeyRotationTimestamp))
	populate(objectMap, "versionedKeyIdentifier", k.VersionedKeyIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyVaultProperties.
func (k *KeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &k.Identity)
			delete(rawMsg, key)
		case "keyIdentifier":
			err = unpopulate(val, &k.KeyIdentifier)
			delete(rawMsg, key)
		case "keyRotationEnabled":
			err = unpopulate(val, &k.KeyRotationEnabled)
			delete(rawMsg, key)
		case "lastKeyRotationTimestamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			k.LastKeyRotationTimestamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "versionedKeyIdentifier":
			err = unpopulate(val, &k.VersionedKeyIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LoggingProperties - The logging properties of the connected registry.
type LoggingProperties struct {
	// Indicates whether audit logs are enabled on the connected registry.
	AuditLogStatus *AuditLogStatus `json:"auditLogStatus,omitempty"`

	// The verbosity of logs persisted on the connected registry.
	LogLevel *LogLevel `json:"logLevel,omitempty"`
}

// LoginServerProperties - The login server properties of the connected registry.
type LoginServerProperties struct {
	// READ-ONLY; The host of the connected registry. Can be FQDN or IP.
	Host *string `json:"host,omitempty" azure:"ro"`

	// READ-ONLY; The TLS properties of the connected registry login server.
	TLS *TLSProperties `json:"tls,omitempty" azure:"ro"`
}

// NetworkRuleSet - The network rule set for a container registry.
type NetworkRuleSet struct {
	// REQUIRED; The default action of allow or deny when no other rules match.
	DefaultAction *DefaultAction `json:"defaultAction,omitempty"`

	// The IP ACL rules.
	IPRules []*IPRule `json:"ipRules,omitempty"`

	// The virtual network rules.
	VirtualNetworkRules []*VirtualNetworkRule `json:"virtualNetworkRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSet.
func (n NetworkRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", n.DefaultAction)
	populate(objectMap, "ipRules", n.IPRules)
	populate(objectMap, "virtualNetworkRules", n.VirtualNetworkRules)
	return json.Marshal(objectMap)
}

// OperationDefinition - The definition of a container registry operation.
type OperationDefinition struct {
	// The display information for the container registry operation.
	Display *OperationDisplayDefinition `json:"display,omitempty"`

	// This property indicates if the operation is an action or a data action ref: https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#management-and-data-operations
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`

	// The origin information of the container registry operation.
	Origin *string `json:"origin,omitempty"`

	// The properties information for the container registry operation.
	Properties *OperationPropertiesDefinition `json:"properties,omitempty"`
}

// OperationDisplayDefinition - The display information for a container registry operation.
type OperationDisplayDefinition struct {
	// The description for the operation.
	Description *string `json:"description,omitempty"`

	// The operation that users can perform.
	Operation *string `json:"operation,omitempty"`

	// The resource provider name: Microsoft.ContainerRegistry.
	Provider *string `json:"provider,omitempty"`

	// The resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationListResult - The result of a request to list container registry operations.
type OperationListResult struct {
	// The URI that can be used to request the next list of container registry operations.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of container registry operations. Since this list may be incomplete, the nextLink field should be used to request the next list of operations.
	Value []*OperationDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationLogSpecificationDefinition - The definition of Azure Monitoring log.
type OperationLogSpecificationDefinition struct {
	// Log blob duration.
	BlobDuration *string `json:"blobDuration,omitempty"`

	// Log display name.
	DisplayName *string `json:"displayName,omitempty"`

	// Log name.
	Name *string `json:"name,omitempty"`
}

// OperationMetricSpecificationDefinition - The definition of Azure Monitoring metric.
type OperationMetricSpecificationDefinition struct {
	// Metric aggregation type.
	AggregationType *string `json:"aggregationType,omitempty"`

	// Metric description.
	DisplayDescription *string `json:"displayDescription,omitempty"`

	// Metric display name.
	DisplayName *string `json:"displayName,omitempty"`

	// Internal metric name.
	InternalMetricName *string `json:"internalMetricName,omitempty"`

	// Metric name.
	Name *string `json:"name,omitempty"`

	// Metric unit.
	Unit *string `json:"unit,omitempty"`
}

// OperationPropertiesDefinition - The definition of Azure Monitoring properties.
type OperationPropertiesDefinition struct {
	// The definition of Azure Monitoring service.
	ServiceSpecification *OperationServiceSpecificationDefinition `json:"serviceSpecification,omitempty"`
}

// OperationServiceSpecificationDefinition - The definition of Azure Monitoring list.
type OperationServiceSpecificationDefinition struct {
	// A list of Azure Monitoring log definitions.
	LogSpecifications []*OperationLogSpecificationDefinition `json:"logSpecifications,omitempty"`

	// A list of Azure Monitoring metrics definition.
	MetricSpecifications []*OperationMetricSpecificationDefinition `json:"metricSpecifications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationServiceSpecificationDefinition.
func (o OperationServiceSpecificationDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", o.LogSpecifications)
	populate(objectMap, "metricSpecifications", o.MetricSpecifications)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

type OverrideTaskStepProperties struct {
	// Gets or sets the collection of override arguments to be used when executing a build step.
	Arguments []*Argument `json:"arguments,omitempty"`

	// The source context against which run has to be queued.
	ContextPath *string `json:"contextPath,omitempty"`

	// The file against which run has to be queued.
	File *string `json:"file,omitempty"`

	// The name of the target build stage for the docker build.
	Target *string `json:"target,omitempty"`

	// Base64 encoded update trigger token that will be attached with the base image trigger webhook.
	UpdateTriggerToken *string `json:"updateTriggerToken,omitempty"`

	// The collection of overridable values that can be passed when running a Task.
	Values []*SetValue `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OverrideTaskStepProperties.
func (o OverrideTaskStepProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", o.Arguments)
	populate(objectMap, "contextPath", o.ContextPath)
	populate(objectMap, "file", o.File)
	populate(objectMap, "target", o.Target)
	populate(objectMap, "updateTriggerToken", o.UpdateTriggerToken)
	populate(objectMap, "values", o.Values)
	return json.Marshal(objectMap)
}

// ParentProperties - The properties of the connected registry parent.
type ParentProperties struct {
	// REQUIRED; The sync properties of the connected registry with its parent.
	SyncProperties *SyncProperties `json:"syncProperties,omitempty"`

	// The resource ID of the parent to which the connected registry will be associated.
	ID *string `json:"id,omitempty"`
}

// PipelineRun - An object that represents a pipeline run for a container registry.
type PipelineRun struct {
	ProxyResource
	// The properties of a pipeline run.
	Properties *PipelineRunProperties `json:"properties,omitempty"`
}

// PipelineRunListResult - The result of a request to list pipeline runs for a container registry.
type PipelineRunListResult struct {
	// The URI that can be used to request the next list of pipeline runs.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of pipeline runs. Since this list may be incomplete, the nextLink field should be used to request the next list of pipeline runs.
	Value []*PipelineRun `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunListResult.
func (p PipelineRunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PipelineRunProperties - The properties of a pipeline run.
type PipelineRunProperties struct {
	// How the pipeline run should be forced to recreate even if the pipeline run configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// The request parameters for a pipeline run.
	Request *PipelineRunRequest `json:"request,omitempty"`

	// READ-ONLY; The provisioning state of a pipeline run.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The response of a pipeline run.
	Response *PipelineRunResponse `json:"response,omitempty" azure:"ro"`
}

// PipelineRunRequest - The request properties provided for a pipeline run.
type PipelineRunRequest struct {
	// List of source artifacts to be transferred by the pipeline. Specify an image by repository ('hello-world'). This will use the 'latest' tag. Specify an
	// image by tag ('hello-world:latest'). Specify an
	// image by sha256-based manifest digest ('hello-world@sha256:abc123').
	Artifacts []*string `json:"artifacts,omitempty"`

	// The digest of the tar used to transfer the artifacts.
	CatalogDigest *string `json:"catalogDigest,omitempty"`

	// The resource ID of the pipeline to run.
	PipelineResourceID *string `json:"pipelineResourceId,omitempty"`

	// The source properties of the pipeline run.
	Source *PipelineRunSourceProperties `json:"source,omitempty"`

	// The target properties of the pipeline run.
	Target *PipelineRunTargetProperties `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunRequest.
func (p PipelineRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "artifacts", p.Artifacts)
	populate(objectMap, "catalogDigest", p.CatalogDigest)
	populate(objectMap, "pipelineResourceId", p.PipelineResourceID)
	populate(objectMap, "source", p.Source)
	populate(objectMap, "target", p.Target)
	return json.Marshal(objectMap)
}

// PipelineRunResponse - The response properties returned for a pipeline run.
type PipelineRunResponse struct {
	// The digest of the tar used to transfer the artifacts.
	CatalogDigest *string `json:"catalogDigest,omitempty"`

	// The time the pipeline run finished.
	FinishTime *time.Time `json:"finishTime,omitempty"`

	// The artifacts imported in the pipeline run.
	ImportedArtifacts []*string `json:"importedArtifacts,omitempty"`

	// The detailed error message for the pipeline run in the case of failure.
	PipelineRunErrorMessage *string `json:"pipelineRunErrorMessage,omitempty"`

	// The current progress of the copy operation.
	Progress *ProgressProperties `json:"progress,omitempty"`

	// The source of the pipeline run.
	Source *ImportPipelineSourceProperties `json:"source,omitempty"`

	// The time the pipeline run started.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The current status of the pipeline run.
	Status *string `json:"status,omitempty"`

	// The target of the pipeline run.
	Target *ExportPipelineTargetProperties `json:"target,omitempty"`

	// The trigger that caused the pipeline run.
	Trigger *PipelineTriggerDescriptor `json:"trigger,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunResponse.
func (p PipelineRunResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "catalogDigest", p.CatalogDigest)
	populate(objectMap, "finishTime", (*timeRFC3339)(p.FinishTime))
	populate(objectMap, "importedArtifacts", p.ImportedArtifacts)
	populate(objectMap, "pipelineRunErrorMessage", p.PipelineRunErrorMessage)
	populate(objectMap, "progress", p.Progress)
	populate(objectMap, "source", p.Source)
	populate(objectMap, "startTime", (*timeRFC3339)(p.StartTime))
	populate(objectMap, "status", p.Status)
	populate(objectMap, "target", p.Target)
	populate(objectMap, "trigger", p.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRunResponse.
func (p *PipelineRunResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogDigest":
			err = unpopulate(val, &p.CatalogDigest)
			delete(rawMsg, key)
		case "finishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			p.FinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "importedArtifacts":
			err = unpopulate(val, &p.ImportedArtifacts)
			delete(rawMsg, key)
		case "pipelineRunErrorMessage":
			err = unpopulate(val, &p.PipelineRunErrorMessage)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &p.Progress)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &p.Source)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			p.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &p.Status)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &p.Target)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &p.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type PipelineRunSourceProperties struct {
	// The name of the source.
	Name *string `json:"name,omitempty"`

	// The type of the source.
	Type *PipelineRunSourceType `json:"type,omitempty"`
}

type PipelineRunTargetProperties struct {
	// The name of the target.
	Name *string `json:"name,omitempty"`

	// The type of the target.
	Type *PipelineRunTargetType `json:"type,omitempty"`
}

// PipelineRunsBeginCreateOptions contains the optional parameters for the PipelineRuns.BeginCreate method.
type PipelineRunsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunsBeginDeleteOptions contains the optional parameters for the PipelineRuns.BeginDelete method.
type PipelineRunsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunsGetOptions contains the optional parameters for the PipelineRuns.Get method.
type PipelineRunsGetOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunsListOptions contains the optional parameters for the PipelineRuns.List method.
type PipelineRunsListOptions struct {
	// placeholder for future optional parameters
}

type PipelineSourceTriggerDescriptor struct {
	// The timestamp when the source update happened.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineSourceTriggerDescriptor.
func (p PipelineSourceTriggerDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "timestamp", (*timeRFC3339)(p.Timestamp))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineSourceTriggerDescriptor.
func (p *PipelineSourceTriggerDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			p.Timestamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type PipelineSourceTriggerProperties struct {
	// REQUIRED; The current status of the source trigger.
	Status *TriggerStatus `json:"status,omitempty"`
}

type PipelineTriggerDescriptor struct {
	// The source trigger that caused the pipeline run.
	SourceTrigger *PipelineSourceTriggerDescriptor `json:"sourceTrigger,omitempty"`
}

type PipelineTriggerProperties struct {
	// The source trigger properties of the pipeline.
	SourceTrigger *PipelineSourceTriggerProperties `json:"sourceTrigger,omitempty"`
}

// PlatformProperties - The platform properties against which the run has to happen.
type PlatformProperties struct {
	// REQUIRED; The operating system type required for the run.
	OS *OS `json:"os,omitempty"`

	// The OS architecture.
	Architecture *Architecture `json:"architecture,omitempty"`

	// Variant of the CPU.
	Variant *Variant `json:"variant,omitempty"`
}

// PlatformUpdateParameters - The properties for updating the platform configuration.
type PlatformUpdateParameters struct {
	// The OS architecture.
	Architecture *Architecture `json:"architecture,omitempty"`

	// The operating system type required for the run.
	OS *OS `json:"os,omitempty"`

	// Variant of the CPU.
	Variant *Variant `json:"variant,omitempty"`
}

// Policies - The policies for a container registry.
type Policies struct {
	// The export policy for a container registry.
	ExportPolicy *ExportPolicy `json:"exportPolicy,omitempty"`

	// The quarantine policy for a container registry.
	QuarantinePolicy *QuarantinePolicy `json:"quarantinePolicy,omitempty"`

	// The retention policy for a container registry.
	RetentionPolicy *RetentionPolicy `json:"retentionPolicy,omitempty"`

	// The content trust policy for a container registry.
	TrustPolicy *TrustPolicy `json:"trustPolicy,omitempty"`
}

// PrivateEndpoint - The Private Endpoint resource.
type PrivateEndpoint struct {
	// This is private endpoint resource created with Microsoft.Network resource provider.
	ID *string `json:"id,omitempty"`
}

// PrivateEndpointConnection - An object that represents a private endpoint connection for a container registry.
type PrivateEndpointConnection struct {
	ProxyResource
	// The properties of a private endpoint connection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// PrivateEndpointConnectionListResult - The result of a request to list private endpoint connections for a container registry.
type PrivateEndpointConnectionListResult struct {
	// The URI that can be used to request the next list of private endpoint connections.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of private endpoint connections. Since this list may be incomplete, the nextLink field should be used to request the next list of private endpoint
	// connections.
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - The properties of a private endpoint connection.
type PrivateEndpointConnectionProperties struct {
	// The resource of private endpoint.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// READ-ONLY; The provisioning state of private endpoint connection resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionsBeginCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnections.BeginCreateOrUpdate method.
type PrivateEndpointConnectionsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsBeginDeleteOptions contains the optional parameters for the PrivateEndpointConnections.BeginDelete method.
type PrivateEndpointConnectionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListOptions contains the optional parameters for the PrivateEndpointConnections.List method.
type PrivateEndpointConnectionsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - A resource that supports private link capabilities.
type PrivateLinkResource struct {
	// The resource ID.
	ID *string `json:"id,omitempty"`

	// The name of the resource.
	Name *string `json:"name,omitempty"`

	// A resource that supports private link capabilities.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// READ-ONLY; The resource type is private link resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkResourceListResult - The result of a request to list private link resources for a container registry.
type PrivateLinkResourceListResult struct {
	// The URI that can be used to request the next list of private link resources.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of private link resources. Since this list may be incomplete, the nextLink field should be used to request the next list of private link resources.
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - The properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// The private link resource group id.
	GroupID *string `json:"groupId,omitempty"`

	// The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty"`

	// The private link resource Private link DNS zone name.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkServiceConnectionState - The state of a private link service connection.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *ActionsRequired `json:"actionsRequired,omitempty"`

	// The description for connection status. For example if connection is rejected it can indicate reason for rejection.
	Description *string `json:"description,omitempty"`

	// The private link service connection status.
	Status *ConnectionStatus `json:"status,omitempty"`
}

type ProgressProperties struct {
	// The percentage complete of the copy operation.
	Percentage *string `json:"percentage,omitempty"`
}

// ProxyResource - The resource model definition for a ARM proxy resource. It will have everything other than required location and tags.
type ProxyResource struct {
	// READ-ONLY; The resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// QuarantinePolicy - The quarantine policy for a container registry.
type QuarantinePolicy struct {
	// The value that indicates whether the policy is enabled or not.
	Status *PolicyStatus `json:"status,omitempty"`
}

// RegenerateCredentialParameters - The parameters used to regenerate the login credential.
type RegenerateCredentialParameters struct {
	// REQUIRED; Specifies name of the password which should be regenerated -- password or password2.
	Name *PasswordName `json:"name,omitempty"`
}

// RegistriesBeginCreateOptions contains the optional parameters for the Registries.BeginCreate method.
type RegistriesBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// RegistriesBeginDeleteOptions contains the optional parameters for the Registries.BeginDelete method.
type RegistriesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RegistriesBeginGenerateCredentialsOptions contains the optional parameters for the Registries.BeginGenerateCredentials method.
type RegistriesBeginGenerateCredentialsOptions struct {
	// placeholder for future optional parameters
}

// RegistriesBeginImportImageOptions contains the optional parameters for the Registries.BeginImportImage method.
type RegistriesBeginImportImageOptions struct {
	// placeholder for future optional parameters
}

// RegistriesBeginScheduleRunOptions contains the optional parameters for the Registries.BeginScheduleRun method.
type RegistriesBeginScheduleRunOptions struct {
	// placeholder for future optional parameters
}

// RegistriesBeginUpdateOptions contains the optional parameters for the Registries.BeginUpdate method.
type RegistriesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// RegistriesCheckNameAvailabilityOptions contains the optional parameters for the Registries.CheckNameAvailability method.
type RegistriesCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// RegistriesGetBuildSourceUploadURLOptions contains the optional parameters for the Registries.GetBuildSourceUploadURL method.
type RegistriesGetBuildSourceUploadURLOptions struct {
	// placeholder for future optional parameters
}

// RegistriesGetOptions contains the optional parameters for the Registries.Get method.
type RegistriesGetOptions struct {
	// placeholder for future optional parameters
}

// RegistriesListByResourceGroupOptions contains the optional parameters for the Registries.ListByResourceGroup method.
type RegistriesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// RegistriesListCredentialsOptions contains the optional parameters for the Registries.ListCredentials method.
type RegistriesListCredentialsOptions struct {
	// placeholder for future optional parameters
}

// RegistriesListOptions contains the optional parameters for the Registries.List method.
type RegistriesListOptions struct {
	// placeholder for future optional parameters
}

// RegistriesListPrivateLinkResourcesOptions contains the optional parameters for the Registries.ListPrivateLinkResources method.
type RegistriesListPrivateLinkResourcesOptions struct {
	// placeholder for future optional parameters
}

// RegistriesListUsagesOptions contains the optional parameters for the Registries.ListUsages method.
type RegistriesListUsagesOptions struct {
	// placeholder for future optional parameters
}

// RegistriesRegenerateCredentialOptions contains the optional parameters for the Registries.RegenerateCredential method.
type RegistriesRegenerateCredentialOptions struct {
	// placeholder for future optional parameters
}

// Registry - An object that represents a container registry.
type Registry struct {
	Resource
	// REQUIRED; The SKU of the container registry.
	SKU *SKU `json:"sku,omitempty"`

	// The identity of the container registry.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The properties of the container registry.
	Properties *RegistryProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Registry.
func (r Registry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	return json.Marshal(objectMap)
}

// RegistryListCredentialsResult - The response from the ListCredentials operation.
type RegistryListCredentialsResult struct {
	// The list of passwords for a container registry.
	Passwords []*RegistryPassword `json:"passwords,omitempty"`

	// The username for a container registry.
	Username *string `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistryListCredentialsResult.
func (r RegistryListCredentialsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "passwords", r.Passwords)
	populate(objectMap, "username", r.Username)
	return json.Marshal(objectMap)
}

// RegistryListResult - The result of a request to list container registries.
type RegistryListResult struct {
	// The URI that can be used to request the next list of container registries.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of container registries. Since this list may be incomplete, the nextLink field should be used to request the next list of container registries.
	Value []*Registry `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistryListResult.
func (r RegistryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RegistryNameCheckRequest - A request to check whether a container registry name is available.
type RegistryNameCheckRequest struct {
	// REQUIRED; The name of the container registry.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The resource type of the container registry. This field must be set to 'Microsoft.ContainerRegistry/registries'.
	Type *string `json:"type,omitempty"`
}

// RegistryNameStatus - The result of a request to check the availability of a container registry name.
type RegistryNameStatus struct {
	// If any, the error message that provides more detail for the reason that the name is not available.
	Message *string `json:"message,omitempty"`

	// The value that indicates whether the name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// If any, the reason that the name is not available.
	Reason *string `json:"reason,omitempty"`
}

// RegistryPassword - The login password for the container registry.
type RegistryPassword struct {
	// The password name.
	Name *PasswordName `json:"name,omitempty"`

	// The password value.
	Value *string `json:"value,omitempty"`
}

// RegistryProperties - The properties of a container registry.
type RegistryProperties struct {
	// The value that indicates whether the admin user is enabled.
	AdminUserEnabled *bool `json:"adminUserEnabled,omitempty"`

	// Enables registry-wide pull from unauthenticated clients.
	AnonymousPullEnabled *bool `json:"anonymousPullEnabled,omitempty"`

	// Enable a single data endpoint per region for serving data.
	DataEndpointEnabled *bool `json:"dataEndpointEnabled,omitempty"`

	// The encryption settings of container registry.
	Encryption *EncryptionProperty `json:"encryption,omitempty"`

	// Whether to allow trusted Azure services to access a network restricted registry.
	NetworkRuleBypassOptions *NetworkRuleBypassOptions `json:"networkRuleBypassOptions,omitempty"`

	// The network rule set for a container registry.
	NetworkRuleSet *NetworkRuleSet `json:"networkRuleSet,omitempty"`

	// The policies for a container registry.
	Policies *Policies `json:"policies,omitempty"`

	// Whether or not public network access is allowed for the container registry.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Whether or not zone redundancy is enabled for this container registry
	ZoneRedundancy *ZoneRedundancy `json:"zoneRedundancy,omitempty"`

	// READ-ONLY; The creation date of the container registry in ISO8601 format.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; List of host names that will serve data when dataEndpointEnabled is true.
	DataEndpointHostNames []*string `json:"dataEndpointHostNames,omitempty" azure:"ro"`

	// READ-ONLY; The URL that can be used to log into the container registry.
	LoginServer *string `json:"loginServer,omitempty" azure:"ro"`

	// READ-ONLY; List of private endpoint connections for a container registry.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the container registry at the time the operation was called.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The status of the container registry at the time the operation was called.
	Status *Status `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistryProperties.
func (r RegistryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adminUserEnabled", r.AdminUserEnabled)
	populate(objectMap, "anonymousPullEnabled", r.AnonymousPullEnabled)
	populate(objectMap, "creationDate", (*timeRFC3339)(r.CreationDate))
	populate(objectMap, "dataEndpointEnabled", r.DataEndpointEnabled)
	populate(objectMap, "dataEndpointHostNames", r.DataEndpointHostNames)
	populate(objectMap, "encryption", r.Encryption)
	populate(objectMap, "loginServer", r.LoginServer)
	populate(objectMap, "networkRuleBypassOptions", r.NetworkRuleBypassOptions)
	populate(objectMap, "networkRuleSet", r.NetworkRuleSet)
	populate(objectMap, "policies", r.Policies)
	populate(objectMap, "privateEndpointConnections", r.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", r.PublicNetworkAccess)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "zoneRedundancy", r.ZoneRedundancy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistryProperties.
func (r *RegistryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminUserEnabled":
			err = unpopulate(val, &r.AdminUserEnabled)
			delete(rawMsg, key)
		case "anonymousPullEnabled":
			err = unpopulate(val, &r.AnonymousPullEnabled)
			delete(rawMsg, key)
		case "creationDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.CreationDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "dataEndpointEnabled":
			err = unpopulate(val, &r.DataEndpointEnabled)
			delete(rawMsg, key)
		case "dataEndpointHostNames":
			err = unpopulate(val, &r.DataEndpointHostNames)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &r.Encryption)
			delete(rawMsg, key)
		case "loginServer":
			err = unpopulate(val, &r.LoginServer)
			delete(rawMsg, key)
		case "networkRuleBypassOptions":
			err = unpopulate(val, &r.NetworkRuleBypassOptions)
			delete(rawMsg, key)
		case "networkRuleSet":
			err = unpopulate(val, &r.NetworkRuleSet)
			delete(rawMsg, key)
		case "policies":
			err = unpopulate(val, &r.Policies)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &r.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &r.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &r.PublicNetworkAccess)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "zoneRedundancy":
			err = unpopulate(val, &r.ZoneRedundancy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RegistryPropertiesUpdateParameters - The parameters for updating the properties of a container registry.
type RegistryPropertiesUpdateParameters struct {
	// The value that indicates whether the admin user is enabled.
	AdminUserEnabled *bool `json:"adminUserEnabled,omitempty"`

	// Enables registry-wide pull from unauthenticated clients.
	AnonymousPullEnabled *bool `json:"anonymousPullEnabled,omitempty"`

	// Enable a single data endpoint per region for serving data.
	DataEndpointEnabled *bool `json:"dataEndpointEnabled,omitempty"`

	// The encryption settings of container registry.
	Encryption *EncryptionProperty `json:"encryption,omitempty"`

	// Whether to allow trusted Azure services to access a network restricted registry.
	NetworkRuleBypassOptions *NetworkRuleBypassOptions `json:"networkRuleBypassOptions,omitempty"`

	// The network rule set for a container registry.
	NetworkRuleSet *NetworkRuleSet `json:"networkRuleSet,omitempty"`

	// The policies for a container registry.
	Policies *Policies `json:"policies,omitempty"`

	// Whether or not public network access is allowed for the container registry.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// RegistryUpdateParameters - The parameters for updating a container registry.
type RegistryUpdateParameters struct {
	// The identity of the container registry.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The properties that the container registry will be updated with.
	Properties *RegistryPropertiesUpdateParameters `json:"properties,omitempty"`

	// The SKU of the container registry.
	SKU *SKU `json:"sku,omitempty"`

	// The tags for the container registry.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistryUpdateParameters.
func (r RegistryUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// RegistryUsage - The quota usage for a container registry.
type RegistryUsage struct {
	// The current value of the usage.
	CurrentValue *int64 `json:"currentValue,omitempty"`

	// The limit of the usage.
	Limit *int64 `json:"limit,omitempty"`

	// The name of the usage.
	Name *string `json:"name,omitempty"`

	// The unit of measurement.
	Unit *RegistryUsageUnit `json:"unit,omitempty"`
}

// RegistryUsageListResult - The result of a request to get container registry quota usages.
type RegistryUsageListResult struct {
	// The list of container registry quota usages.
	Value []*RegistryUsage `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistryUsageListResult.
func (r RegistryUsageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// Replication - An object that represents a replication for a container registry.
type Replication struct {
	Resource
	// The properties of the replication.
	Properties *ReplicationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Replication.
func (r Replication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// ReplicationListResult - The result of a request to list replications for a container registry.
type ReplicationListResult struct {
	// The URI that can be used to request the next list of replications.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of replications. Since this list may be incomplete, the nextLink field should be used to request the next list of replications.
	Value []*Replication `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationListResult.
func (r ReplicationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// ReplicationProperties - The properties of a replication.
type ReplicationProperties struct {
	// Specifies whether the replication's regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however
	// its data will continue to be synced with
	// other replications.
	RegionEndpointEnabled *bool `json:"regionEndpointEnabled,omitempty"`

	// Whether or not zone redundancy is enabled for this container registry replication
	ZoneRedundancy *ZoneRedundancy `json:"zoneRedundancy,omitempty"`

	// READ-ONLY; The provisioning state of the replication at the time the operation was called.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The status of the replication at the time the operation was called.
	Status *Status `json:"status,omitempty" azure:"ro"`
}

// ReplicationUpdateParameters - The parameters for updating a replication.
type ReplicationUpdateParameters struct {
	// The parameters for updating a replication's properties
	Properties *ReplicationUpdateParametersProperties `json:"properties,omitempty"`

	// The tags for the replication.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationUpdateParameters.
func (r ReplicationUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

type ReplicationUpdateParametersProperties struct {
	// Specifies whether the replication's regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however
	// its data will continue to be synced with
	// other replications.
	RegionEndpointEnabled *bool `json:"regionEndpointEnabled,omitempty"`
}

// ReplicationsBeginCreateOptions contains the optional parameters for the Replications.BeginCreate method.
type ReplicationsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// ReplicationsBeginDeleteOptions contains the optional parameters for the Replications.BeginDelete method.
type ReplicationsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ReplicationsBeginUpdateOptions contains the optional parameters for the Replications.BeginUpdate method.
type ReplicationsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ReplicationsGetOptions contains the optional parameters for the Replications.Get method.
type ReplicationsGetOptions struct {
	// placeholder for future optional parameters
}

// ReplicationsListOptions contains the optional parameters for the Replications.List method.
type ReplicationsListOptions struct {
	// placeholder for future optional parameters
}

// Request - The request that generated the event.
type Request struct {
	// The IP or hostname and possibly port of the client connection that initiated the event. This is the RemoteAddr from the standard http request.
	Addr *string `json:"addr,omitempty"`

	// The externally accessible hostname of the registry instance, as specified by the http host header on incoming requests.
	Host *string `json:"host,omitempty"`

	// The ID of the request that initiated the event.
	ID *string `json:"id,omitempty"`

	// The request method that generated the event.
	Method *string `json:"method,omitempty"`

	// The user agent header of the request.
	Useragent *string `json:"useragent,omitempty"`
}

// Resource - An Azure resource.
type Resource struct {
	// REQUIRED; The location of the resource. This cannot be changed after the resource is created.
	Location *string `json:"location,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// RetentionPolicy - The retention policy for a container registry.
type RetentionPolicy struct {
	// The number of days to retain an untagged manifest after which it gets purged.
	Days *int32 `json:"days,omitempty"`

	// The value that indicates whether the policy is enabled or not.
	Status *PolicyStatus `json:"status,omitempty"`

	// READ-ONLY; The timestamp when the policy was last updated.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RetentionPolicy.
func (r RetentionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "days", r.Days)
	populate(objectMap, "lastUpdatedTime", (*timeRFC3339)(r.LastUpdatedTime))
	populate(objectMap, "status", r.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RetentionPolicy.
func (r *RetentionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "days":
			err = unpopulate(val, &r.Days)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.LastUpdatedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Run resource properties
type Run struct {
	ProxyResource
	// The properties of a run.
	Properties *RunProperties `json:"properties,omitempty"`
}

// RunFilter - Properties that are enabled for Odata querying on runs.
type RunFilter struct {
	// The name of the agent pool that the run corresponds to.
	AgentPoolName *string `json:"agentPoolName,omitempty"`

	// The create time for a run.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// The time the run finished.
	FinishTime *time.Time `json:"finishTime,omitempty"`

	// The value that indicates whether archiving is enabled or not.
	IsArchiveEnabled *bool `json:"isArchiveEnabled,omitempty"`

	// The list of comma-separated image manifests that were generated from the run. This is applicable if the run is of build type.
	OutputImageManifests *string `json:"outputImageManifests,omitempty"`

	// The unique identifier for the run.
	RunID *string `json:"runId,omitempty"`

	// The type of run.
	RunType *RunType `json:"runType,omitempty"`

	// The current status of the run.
	Status *RunStatus `json:"status,omitempty"`

	// The name of the task that the run corresponds to.
	TaskName *string `json:"taskName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunFilter.
func (r RunFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populate(objectMap, "createTime", (*timeRFC3339)(r.CreateTime))
	populate(objectMap, "finishTime", (*timeRFC3339)(r.FinishTime))
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populate(objectMap, "outputImageManifests", r.OutputImageManifests)
	populate(objectMap, "runId", r.RunID)
	populate(objectMap, "runType", r.RunType)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "taskName", r.TaskName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunFilter.
func (r *RunFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentPoolName":
			err = unpopulate(val, &r.AgentPoolName)
			delete(rawMsg, key)
		case "createTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.CreateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "finishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.FinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "outputImageManifests":
			err = unpopulate(val, &r.OutputImageManifests)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, &r.RunID)
			delete(rawMsg, key)
		case "runType":
			err = unpopulate(val, &r.RunType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "taskName":
			err = unpopulate(val, &r.TaskName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RunGetLogResult - The result of get log link operation.
type RunGetLogResult struct {
	// The link to logs in registry for a run on a azure container registry.
	LogArtifactLink *string `json:"logArtifactLink,omitempty"`

	// The link to logs for a run on a azure container registry.
	LogLink *string `json:"logLink,omitempty"`
}

// RunListResult - Collection of runs.
type RunListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value []*Run `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunListResult.
func (r RunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RunProperties - The properties for a run.
type RunProperties struct {
	// The machine configuration of the run agent.
	AgentConfiguration *AgentProperties `json:"agentConfiguration,omitempty"`

	// The dedicated agent pool for the run.
	AgentPoolName *string `json:"agentPoolName,omitempty"`

	// The time the run was scheduled.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// The list of custom registries that were logged in during this run.
	CustomRegistries []*string `json:"customRegistries,omitempty"`

	// The time the run finished.
	FinishTime *time.Time `json:"finishTime,omitempty"`

	// The image update trigger that caused the run. This is applicable if the task has base image trigger configured.
	ImageUpdateTrigger *ImageUpdateTrigger `json:"imageUpdateTrigger,omitempty"`

	// The value that indicates whether archiving is enabled or not.
	IsArchiveEnabled *bool `json:"isArchiveEnabled,omitempty"`

	// The last updated time for the run.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// The list of all images that were generated from the run. This is applicable if the run generates base image dependencies.
	OutputImages []*ImageDescriptor `json:"outputImages,omitempty"`

	// The platform properties against which the run will happen.
	Platform *PlatformProperties `json:"platform,omitempty"`

	// The provisioning state of a run.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`

	// The unique identifier for the run.
	RunID *string `json:"runId,omitempty"`

	// The type of run.
	RunType *RunType `json:"runType,omitempty"`

	// The scope of the credentials that were used to login to the source registry during this run.
	SourceRegistryAuth *string `json:"sourceRegistryAuth,omitempty"`

	// The source trigger that caused the run.
	SourceTrigger *SourceTriggerDescriptor `json:"sourceTrigger,omitempty"`

	// The time the run started.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The current status of the run.
	Status *RunStatus `json:"status,omitempty"`

	// The task against which run was scheduled.
	Task *string `json:"task,omitempty"`

	// The timer trigger that caused the run.
	TimerTrigger *TimerTriggerDescriptor `json:"timerTrigger,omitempty"`

	// The update trigger token passed for the Run.
	UpdateTriggerToken *string `json:"updateTriggerToken,omitempty"`

	// READ-ONLY; The image description for the log artifact.
	LogArtifact *ImageDescriptor `json:"logArtifact,omitempty" azure:"ro"`

	// READ-ONLY; The error message received from backend systems after the run is scheduled.
	RunErrorMessage *string `json:"runErrorMessage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RunProperties.
func (r RunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", r.AgentConfiguration)
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populate(objectMap, "createTime", (*timeRFC3339)(r.CreateTime))
	populate(objectMap, "customRegistries", r.CustomRegistries)
	populate(objectMap, "finishTime", (*timeRFC3339)(r.FinishTime))
	populate(objectMap, "imageUpdateTrigger", r.ImageUpdateTrigger)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populate(objectMap, "lastUpdatedTime", (*timeRFC3339)(r.LastUpdatedTime))
	populate(objectMap, "logArtifact", r.LogArtifact)
	populate(objectMap, "outputImages", r.OutputImages)
	populate(objectMap, "platform", r.Platform)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "runErrorMessage", r.RunErrorMessage)
	populate(objectMap, "runId", r.RunID)
	populate(objectMap, "runType", r.RunType)
	populate(objectMap, "sourceRegistryAuth", r.SourceRegistryAuth)
	populate(objectMap, "sourceTrigger", r.SourceTrigger)
	populate(objectMap, "startTime", (*timeRFC3339)(r.StartTime))
	populate(objectMap, "status", r.Status)
	populate(objectMap, "task", r.Task)
	populate(objectMap, "timerTrigger", r.TimerTrigger)
	populate(objectMap, "updateTriggerToken", r.UpdateTriggerToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunProperties.
func (r *RunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &r.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &r.AgentPoolName)
			delete(rawMsg, key)
		case "createTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.CreateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "customRegistries":
			err = unpopulate(val, &r.CustomRegistries)
			delete(rawMsg, key)
		case "finishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.FinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "imageUpdateTrigger":
			err = unpopulate(val, &r.ImageUpdateTrigger)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.LastUpdatedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "logArtifact":
			err = unpopulate(val, &r.LogArtifact)
			delete(rawMsg, key)
		case "outputImages":
			err = unpopulate(val, &r.OutputImages)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &r.Platform)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &r.ProvisioningState)
			delete(rawMsg, key)
		case "runErrorMessage":
			err = unpopulate(val, &r.RunErrorMessage)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, &r.RunID)
			delete(rawMsg, key)
		case "runType":
			err = unpopulate(val, &r.RunType)
			delete(rawMsg, key)
		case "sourceRegistryAuth":
			err = unpopulate(val, &r.SourceRegistryAuth)
			delete(rawMsg, key)
		case "sourceTrigger":
			err = unpopulate(val, &r.SourceTrigger)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			r.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "task":
			err = unpopulate(val, &r.Task)
			delete(rawMsg, key)
		case "timerTrigger":
			err = unpopulate(val, &r.TimerTrigger)
			delete(rawMsg, key)
		case "updateTriggerToken":
			err = unpopulate(val, &r.UpdateTriggerToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RunRequestClassification provides polymorphic access to related types.
// Call the interface's GetRunRequest() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DockerBuildRequest, *EncodedTaskRunRequest, *FileTaskRunRequest, *RunRequest, *TaskRunRequest
type RunRequestClassification interface {
	// GetRunRequest returns the RunRequest content of the underlying type.
	GetRunRequest() *RunRequest
}

// RunRequest - The request parameters for scheduling a run.
type RunRequest struct {
	// REQUIRED; The type of the run request.
	Type *string `json:"type,omitempty"`

	// The dedicated agent pool for the run.
	AgentPoolName *string `json:"agentPoolName,omitempty"`

	// The value that indicates whether archiving is enabled for the run or not.
	IsArchiveEnabled *bool `json:"isArchiveEnabled,omitempty"`

	// The template that describes the repository and tag information for run log artifact.
	LogTemplate *string `json:"logTemplate,omitempty"`
}

// GetRunRequest implements the RunRequestClassification interface for type RunRequest.
func (r *RunRequest) GetRunRequest() *RunRequest { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type RunRequest.
func (r *RunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RunRequest) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populate(objectMap, "logTemplate", r.LogTemplate)
	r.Type = &discValue
	objectMap["type"] = r.Type
}

func (r *RunRequest) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentPoolName":
			err = unpopulate(val, &r.AgentPoolName)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &r.LogTemplate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RunUpdateParameters - The set of run properties that can be updated.
type RunUpdateParameters struct {
	// The value that indicates whether archiving is enabled or not.
	IsArchiveEnabled *bool `json:"isArchiveEnabled,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunUpdateParameters.
func (r RunUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	return json.Marshal(objectMap)
}

// RunsBeginCancelOptions contains the optional parameters for the Runs.BeginCancel method.
type RunsBeginCancelOptions struct {
	// placeholder for future optional parameters
}

// RunsBeginUpdateOptions contains the optional parameters for the Runs.BeginUpdate method.
type RunsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// RunsGetLogSasURLOptions contains the optional parameters for the Runs.GetLogSasURL method.
type RunsGetLogSasURLOptions struct {
	// placeholder for future optional parameters
}

// RunsGetOptions contains the optional parameters for the Runs.Get method.
type RunsGetOptions struct {
	// placeholder for future optional parameters
}

// RunsListOptions contains the optional parameters for the Runs.List method.
type RunsListOptions struct {
	// The runs filter to apply on the operation. Arithmetic operators are not supported. The allowed string function is 'contains'. All logical operators except
	// 'Not', 'Has', 'All' are allowed.
	Filter *string
	// $top is supported for get list of runs, which limits the maximum number of runs to return.
	Top *int32
}

// SKU - The SKU of a container registry.
type SKU struct {
	// REQUIRED; The SKU name of the container registry. Required for registry creation.
	Name *SKUName `json:"name,omitempty"`

	// READ-ONLY; The SKU tier based on the SKU name.
	Tier *SKUTier `json:"tier,omitempty" azure:"ro"`
}

// ScopeMap - An object that represents a scope map for a container registry.
type ScopeMap struct {
	ProxyResource
	// The properties of the scope map.
	Properties *ScopeMapProperties `json:"properties,omitempty"`
}

// ScopeMapListResult - The result of a request to list scope maps for a container registry.
type ScopeMapListResult struct {
	// The URI that can be used to request the next list of scope maps.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of scope maps. Since this list may be incomplete, the nextLink field should be used to request the next list of scope maps.
	Value []*ScopeMap `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapListResult.
func (s ScopeMapListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ScopeMapProperties - The properties of a scope map.
type ScopeMapProperties struct {
	// REQUIRED; The list of scoped permissions for registry artifacts. E.g. repositories/repository-name/content/read, repositories/repository-name/metadata/write
	Actions []*string `json:"actions,omitempty"`

	// The user friendly description of the scope map.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; The creation date of scope map.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The type of the scope map. E.g. BuildIn scope map.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapProperties.
func (s ScopeMapProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", s.Actions)
	populate(objectMap, "creationDate", (*timeRFC3339)(s.CreationDate))
	populate(objectMap, "description", s.Description)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScopeMapProperties.
func (s *ScopeMapProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			err = unpopulate(val, &s.Actions)
			delete(rawMsg, key)
		case "creationDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreationDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ScopeMapPropertiesUpdateParameters - The update parameters for scope map properties.
type ScopeMapPropertiesUpdateParameters struct {
	// The list of scope permissions for registry artifacts. E.g. repositories/repository-name/pull, repositories/repository-name/delete
	Actions []*string `json:"actions,omitempty"`

	// The user friendly description of the scope map.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapPropertiesUpdateParameters.
func (s ScopeMapPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", s.Actions)
	populate(objectMap, "description", s.Description)
	return json.Marshal(objectMap)
}

// ScopeMapUpdateParameters - The properties for updating the scope map.
type ScopeMapUpdateParameters struct {
	// The update parameters for scope map properties.
	Properties *ScopeMapPropertiesUpdateParameters `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapUpdateParameters.
func (s ScopeMapUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// ScopeMapsBeginCreateOptions contains the optional parameters for the ScopeMaps.BeginCreate method.
type ScopeMapsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// ScopeMapsBeginDeleteOptions contains the optional parameters for the ScopeMaps.BeginDelete method.
type ScopeMapsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ScopeMapsBeginUpdateOptions contains the optional parameters for the ScopeMaps.BeginUpdate method.
type ScopeMapsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ScopeMapsGetOptions contains the optional parameters for the ScopeMaps.Get method.
type ScopeMapsGetOptions struct {
	// placeholder for future optional parameters
}

// ScopeMapsListOptions contains the optional parameters for the ScopeMaps.List method.
type ScopeMapsListOptions struct {
	// placeholder for future optional parameters
}

// SecretObject - Describes the properties of a secret object value.
type SecretObject struct {
	// The type of the secret object which determines how the value of the secret object has to be interpreted.
	Type *SecretObjectType `json:"type,omitempty"`

	// The value of the secret. The format of this value will be determined based on the type of the secret object. If the type is Opaque, the value will be
	// used as is without any modification.
	Value *string `json:"value,omitempty"`
}

// SetValue - The properties of a overridable value that can be passed to a task template.
type SetValue struct {
	// REQUIRED; The name of the overridable value.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The overridable value.
	Value *string `json:"value,omitempty"`

	// Flag to indicate whether the value represents a secret or not.
	IsSecret *bool `json:"isSecret,omitempty"`
}

// Source - The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it.
type Source struct {
	// The IP or hostname and the port of the registry node that generated the event. Generally, this will be resolved by os.Hostname() along with the running
	// port.
	Addr *string `json:"addr,omitempty"`

	// The running instance of an application. Changes after each restart.
	InstanceID *string `json:"instanceID,omitempty"`
}

// SourceProperties - The properties of the source code repository.
type SourceProperties struct {
	// REQUIRED; The full URL to the source code repository
	RepositoryURL *string `json:"repositoryUrl,omitempty"`

	// REQUIRED; The type of source control service.
	SourceControlType *SourceControlType `json:"sourceControlType,omitempty"`

	// The branch name of the source code.
	Branch *string `json:"branch,omitempty"`

	// The authorization properties for accessing the source code repository and to set up webhooks for notifications.
	SourceControlAuthProperties *AuthInfo `json:"sourceControlAuthProperties,omitempty"`
}

// SourceRegistryCredentials - Describes the credential parameters for accessing the source registry.
type SourceRegistryCredentials struct {
	// The authentication mode which determines the source registry login scope. The credentials for the source registry will be generated using the given scope.
	// These credentials will be used to login to
	// the source registry during the run.
	LoginMode *SourceRegistryLoginMode `json:"loginMode,omitempty"`
}

// SourceTrigger - The properties of a source based trigger.
type SourceTrigger struct {
	// REQUIRED; The name of the trigger.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The properties that describes the source(code) for the task.
	SourceRepository *SourceProperties `json:"sourceRepository,omitempty"`

	// REQUIRED; The source event corresponding to the trigger.
	SourceTriggerEvents []*SourceTriggerEvent `json:"sourceTriggerEvents,omitempty"`

	// The current status of trigger.
	Status *TriggerStatus `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SourceTrigger.
func (s SourceTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sourceRepository", s.SourceRepository)
	populate(objectMap, "sourceTriggerEvents", s.SourceTriggerEvents)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// SourceTriggerDescriptor - The source trigger that caused a run.
type SourceTriggerDescriptor struct {
	// The branch name in the repository.
	BranchName *string `json:"branchName,omitempty"`

	// The unique ID that identifies a commit.
	CommitID *string `json:"commitId,omitempty"`

	// The event type of the trigger.
	EventType *string `json:"eventType,omitempty"`

	// The unique ID of the trigger.
	ID *string `json:"id,omitempty"`

	// The source control provider type.
	ProviderType *string `json:"providerType,omitempty"`

	// The unique ID that identifies pull request.
	PullRequestID *string `json:"pullRequestId,omitempty"`

	// The repository URL.
	RepositoryURL *string `json:"repositoryUrl,omitempty"`
}

// SourceTriggerUpdateParameters - The properties for updating a source based trigger.
type SourceTriggerUpdateParameters struct {
	// REQUIRED; The name of the trigger.
	Name *string `json:"name,omitempty"`

	// The properties that describes the source(code) for the task.
	SourceRepository *SourceUpdateParameters `json:"sourceRepository,omitempty"`

	// The source event corresponding to the trigger.
	SourceTriggerEvents []*SourceTriggerEvent `json:"sourceTriggerEvents,omitempty"`

	// The current status of trigger.
	Status *TriggerStatus `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SourceTriggerUpdateParameters.
func (s SourceTriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sourceRepository", s.SourceRepository)
	populate(objectMap, "sourceTriggerEvents", s.SourceTriggerEvents)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// SourceUpdateParameters - The properties for updating the source code repository.
type SourceUpdateParameters struct {
	// The branch name of the source code.
	Branch *string `json:"branch,omitempty"`

	// The full URL to the source code repository
	RepositoryURL *string `json:"repositoryUrl,omitempty"`

	// The authorization properties for accessing the source code repository and to set up webhooks for notifications.
	SourceControlAuthProperties *AuthInfoUpdateParameters `json:"sourceControlAuthProperties,omitempty"`

	// The type of source control service.
	SourceControlType *SourceControlType `json:"sourceControlType,omitempty"`
}

// SourceUploadDefinition - The properties of a response to source upload request.
type SourceUploadDefinition struct {
	// The relative path to the source. This is used to submit the subsequent queue build request.
	RelativePath *string `json:"relativePath,omitempty"`

	// The URL where the client can upload the source.
	UploadURL *string `json:"uploadUrl,omitempty"`
}

// Status - The status of an Azure resource at the time the operation was called.
type Status struct {
	// READ-ONLY; The short label for the status.
	DisplayStatus *string `json:"displayStatus,omitempty" azure:"ro"`

	// READ-ONLY; The detailed message for the status, including alerts and error messages.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp when the status was changed to the current value.
	Timestamp *time.Time `json:"timestamp,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Status.
func (s Status) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayStatus", s.DisplayStatus)
	populate(objectMap, "message", s.Message)
	populate(objectMap, "timestamp", (*timeRFC3339)(s.Timestamp))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Status.
func (s *Status) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayStatus":
			err = unpopulate(val, &s.DisplayStatus)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &s.Message)
			delete(rawMsg, key)
		case "timestamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.Timestamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StatusDetailProperties - The status detail properties of the connected registry.
type StatusDetailProperties struct {
	// READ-ONLY; The code of the status.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The correlation ID of the status.
	CorrelationID *string `json:"correlationId,omitempty" azure:"ro"`

	// READ-ONLY; The description of the status.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of the status.
	Timestamp *time.Time `json:"timestamp,omitempty" azure:"ro"`

	// READ-ONLY; The component of the connected registry corresponding to the status.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StatusDetailProperties.
func (s StatusDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", s.Code)
	populate(objectMap, "correlationId", s.CorrelationID)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "timestamp", (*timeRFC3339)(s.Timestamp))
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatusDetailProperties.
func (s *StatusDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, &s.Code)
			delete(rawMsg, key)
		case "correlationId":
			err = unpopulate(val, &s.CorrelationID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "timestamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.Timestamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SyncProperties - The sync properties of the connected registry with its parent.
type SyncProperties struct {
	// REQUIRED; The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S
	// as per ISO8601.
	MessageTTL *string `json:"messageTtl,omitempty"`

	// REQUIRED; The resource ID of the ACR token used to authenticate the connected registry to its parent during sync.
	TokenID *string `json:"tokenId,omitempty"`

	// The cron expression indicating the schedule that the connected registry will sync with its parent.
	Schedule *string `json:"schedule,omitempty"`

	// The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
	SyncWindow *string `json:"syncWindow,omitempty"`

	// READ-ONLY; The gateway endpoint used by the connected registry to communicate with its parent.
	GatewayEndpoint *string `json:"gatewayEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; The last time a sync occurred between the connected registry and its parent.
	LastSyncTime *time.Time `json:"lastSyncTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SyncProperties.
func (s SyncProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "gatewayEndpoint", s.GatewayEndpoint)
	populate(objectMap, "lastSyncTime", (*timeRFC3339)(s.LastSyncTime))
	populate(objectMap, "messageTtl", s.MessageTTL)
	populate(objectMap, "schedule", s.Schedule)
	populate(objectMap, "syncWindow", s.SyncWindow)
	populate(objectMap, "tokenId", s.TokenID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SyncProperties.
func (s *SyncProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gatewayEndpoint":
			err = unpopulate(val, &s.GatewayEndpoint)
			delete(rawMsg, key)
		case "lastSyncTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.LastSyncTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "messageTtl":
			err = unpopulate(val, &s.MessageTTL)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, &s.Schedule)
			delete(rawMsg, key)
		case "syncWindow":
			err = unpopulate(val, &s.SyncWindow)
			delete(rawMsg, key)
		case "tokenId":
			err = unpopulate(val, &s.TokenID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SyncUpdateProperties - The parameters for updating the sync properties of the connected registry with its parent.
type SyncUpdateProperties struct {
	// The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
	// per ISO8601.
	MessageTTL *string `json:"messageTtl,omitempty"`

	// The cron expression indicating the schedule that the connected registry will sync with its parent.
	Schedule *string `json:"schedule,omitempty"`

	// The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
	SyncWindow *string `json:"syncWindow,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource modification (UTC).
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *LastModifiedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populate(objectMap, "lastModifiedAt", (*timeRFC3339)(s.LastModifiedAt))
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.LastModifiedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TLSCertificateProperties - The TLS certificate properties of the connected registry login server.
type TLSCertificateProperties struct {
	// READ-ONLY; Indicates the location of the certificates.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The type of certificate location.
	Type *CertificateType `json:"type,omitempty" azure:"ro"`
}

// TLSProperties - The TLS properties of the connected registry login server.
type TLSProperties struct {
	// READ-ONLY; The certificate used to configure HTTPS for the login server.
	Certificate *TLSCertificateProperties `json:"certificate,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether HTTPS is enabled for the login server.
	Status *TLSStatus `json:"status,omitempty" azure:"ro"`
}

// Target - The target of the event.
type Target struct {
	// The digest of the content, as defined by the Registry V2 HTTP API Specification.
	Digest *string `json:"digest,omitempty"`

	// The number of bytes of the content. Same as Size field.
	Length *int64 `json:"length,omitempty"`

	// The MIME type of the referenced object.
	MediaType *string `json:"mediaType,omitempty"`

	// The name of the artifact.
	Name *string `json:"name,omitempty"`

	// The repository name.
	Repository *string `json:"repository,omitempty"`

	// The number of bytes of the content. Same as Length field.
	Size *int64 `json:"size,omitempty"`

	// The tag name.
	Tag *string `json:"tag,omitempty"`

	// The direct URL to the content.
	URL *string `json:"url,omitempty"`

	// The version of the artifact.
	Version *string `json:"version,omitempty"`
}

// Task - The task that has the ARM resource and task properties. The task will have all information to schedule a run against it.
type Task struct {
	Resource
	// Identity for the resource.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The properties of a task.
	Properties *TaskProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Task.
func (t Task) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// TaskListResult - The collection of tasks.
type TaskListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value []*Task `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskListResult.
func (t TaskListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TaskProperties - The properties of a task.
type TaskProperties struct {
	// The machine configuration of the run agent.
	AgentConfiguration *AgentProperties `json:"agentConfiguration,omitempty"`

	// The dedicated agent pool for the task.
	AgentPoolName *string `json:"agentPoolName,omitempty"`

	// The properties that describes a set of credentials that will be used when this run is invoked.
	Credentials *Credentials `json:"credentials,omitempty"`

	// The value of this property indicates whether the task resource is system task or not.
	IsSystemTask *bool `json:"isSystemTask,omitempty"`

	// The template that describes the repository and tag information for run log artifact.
	LogTemplate *string `json:"logTemplate,omitempty"`

	// The platform properties against which the run has to happen.
	Platform *PlatformProperties `json:"platform,omitempty"`

	// The current status of task.
	Status *TaskStatus `json:"status,omitempty"`

	// The properties of a task step.
	Step TaskStepPropertiesClassification `json:"step,omitempty"`

	// Run timeout in seconds.
	Timeout *int32 `json:"timeout,omitempty"`

	// The properties that describe all triggers for the task.
	Trigger *TriggerProperties `json:"trigger,omitempty"`

	// READ-ONLY; The creation date of task.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the task.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskProperties.
func (t TaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", t.AgentConfiguration)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populate(objectMap, "creationDate", (*timeRFC3339)(t.CreationDate))
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "isSystemTask", t.IsSystemTask)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "platform", t.Platform)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "step", t.Step)
	populate(objectMap, "timeout", t.Timeout)
	populate(objectMap, "trigger", t.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskProperties.
func (t *TaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &t.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &t.AgentPoolName)
			delete(rawMsg, key)
		case "creationDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.CreationDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &t.Credentials)
			delete(rawMsg, key)
		case "isSystemTask":
			err = unpopulate(val, &t.IsSystemTask)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &t.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &t.Platform)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "step":
			t.Step, err = unmarshalTaskStepPropertiesClassification(val)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &t.Timeout)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &t.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskPropertiesUpdateParameters - The properties for updating a task.
type TaskPropertiesUpdateParameters struct {
	// The machine configuration of the run agent.
	AgentConfiguration *AgentProperties `json:"agentConfiguration,omitempty"`

	// The dedicated agent pool for the task.
	AgentPoolName *string `json:"agentPoolName,omitempty"`

	// The parameters that describes a set of credentials that will be used when this run is invoked.
	Credentials *Credentials `json:"credentials,omitempty"`

	// The template that describes the repository and tag information for run log artifact.
	LogTemplate *string `json:"logTemplate,omitempty"`

	// The platform properties against which the run has to happen.
	Platform *PlatformUpdateParameters `json:"platform,omitempty"`

	// The current status of task.
	Status *TaskStatus `json:"status,omitempty"`

	// The properties for updating a task step.
	Step TaskStepUpdateParametersClassification `json:"step,omitempty"`

	// Run timeout in seconds.
	Timeout *int32 `json:"timeout,omitempty"`

	// The properties for updating trigger properties.
	Trigger *TriggerUpdateParameters `json:"trigger,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskPropertiesUpdateParameters.
func (t TaskPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", t.AgentConfiguration)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "platform", t.Platform)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "step", t.Step)
	populate(objectMap, "timeout", t.Timeout)
	populate(objectMap, "trigger", t.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskPropertiesUpdateParameters.
func (t *TaskPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &t.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &t.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &t.Credentials)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &t.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &t.Platform)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "step":
			t.Step, err = unmarshalTaskStepUpdateParametersClassification(val)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &t.Timeout)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &t.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskRun - The task run that has the ARM resource and properties. The task run will have the information of request and result of a run.
type TaskRun struct {
	ProxyResource
	// Identity for the resource.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The location of the resource
	Location *string `json:"location,omitempty"`

	// The properties associated with the task run, i.e., request and result of the run
	Properties *TaskRunProperties `json:"properties,omitempty"`
}

// TaskRunListResult - The collection of task runs.
type TaskRunListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value []*TaskRun `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunListResult.
func (t TaskRunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TaskRunProperties - The properties of task run.
type TaskRunProperties struct {
	// How the run should be forced to rerun even if the run request configuration has not changed
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// The request (parameters) for the run
	RunRequest RunRequestClassification `json:"runRequest,omitempty"`

	// READ-ONLY; The provisioning state of this task run
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The result of this task run
	RunResult *Run `json:"runResult,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunProperties.
func (t TaskRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "forceUpdateTag", t.ForceUpdateTag)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "runRequest", t.RunRequest)
	populate(objectMap, "runResult", t.RunResult)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunProperties.
func (t *TaskRunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceUpdateTag":
			err = unpopulate(val, &t.ForceUpdateTag)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "runRequest":
			t.RunRequest, err = unmarshalRunRequestClassification(val)
			delete(rawMsg, key)
		case "runResult":
			err = unpopulate(val, &t.RunResult)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskRunPropertiesUpdateParameters - The properties of a task run update parameters.
type TaskRunPropertiesUpdateParameters struct {
	// How the run should be forced to rerun even if the run request configuration has not changed
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// The request (parameters) for the new run
	RunRequest RunRequestClassification `json:"runRequest,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunPropertiesUpdateParameters.
func (t TaskRunPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "forceUpdateTag", t.ForceUpdateTag)
	populate(objectMap, "runRequest", t.RunRequest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunPropertiesUpdateParameters.
func (t *TaskRunPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceUpdateTag":
			err = unpopulate(val, &t.ForceUpdateTag)
			delete(rawMsg, key)
		case "runRequest":
			t.RunRequest, err = unmarshalRunRequestClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskRunRequest - The parameters for a task run request.
type TaskRunRequest struct {
	RunRequest
	// REQUIRED; The resource ID of task against which run has to be queued.
	TaskID *string `json:"taskId,omitempty"`

	// Set of overridable parameters that can be passed when running a Task.
	OverrideTaskStepProperties *OverrideTaskStepProperties `json:"overrideTaskStepProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunRequest.
func (t TaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.RunRequest.marshalInternal(objectMap, "TaskRunRequest")
	populate(objectMap, "overrideTaskStepProperties", t.OverrideTaskStepProperties)
	populate(objectMap, "taskId", t.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunRequest.
func (t *TaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "overrideTaskStepProperties":
			err = unpopulate(val, &t.OverrideTaskStepProperties)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &t.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.RunRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TaskRunUpdateParameters - The parameters for updating a task run.
type TaskRunUpdateParameters struct {
	// Identity for the resource.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The location of the resource
	Location *string `json:"location,omitempty"`

	// The properties for updating a task run.
	Properties *TaskRunPropertiesUpdateParameters `json:"properties,omitempty"`

	// The ARM resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunUpdateParameters.
func (t TaskRunUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// TaskRunsBeginCreateOptions contains the optional parameters for the TaskRuns.BeginCreate method.
type TaskRunsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// TaskRunsBeginDeleteOptions contains the optional parameters for the TaskRuns.BeginDelete method.
type TaskRunsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// TaskRunsBeginUpdateOptions contains the optional parameters for the TaskRuns.BeginUpdate method.
type TaskRunsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// TaskRunsGetDetailsOptions contains the optional parameters for the TaskRuns.GetDetails method.
type TaskRunsGetDetailsOptions struct {
	// placeholder for future optional parameters
}

// TaskRunsGetOptions contains the optional parameters for the TaskRuns.Get method.
type TaskRunsGetOptions struct {
	// placeholder for future optional parameters
}

// TaskRunsListOptions contains the optional parameters for the TaskRuns.List method.
type TaskRunsListOptions struct {
	// placeholder for future optional parameters
}

// TaskStepPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetTaskStepProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DockerBuildStep, *EncodedTaskStep, *FileTaskStep, *TaskStepProperties
type TaskStepPropertiesClassification interface {
	// GetTaskStepProperties returns the TaskStepProperties content of the underlying type.
	GetTaskStepProperties() *TaskStepProperties
}

// TaskStepProperties - Base properties for any task step.
type TaskStepProperties struct {
	// REQUIRED; The type of the step.
	Type *StepType `json:"type,omitempty"`

	// The token (git PAT or SAS token of storage account blob) associated with the context for a step.
	ContextAccessToken *string `json:"contextAccessToken,omitempty"`

	// The URL(absolute or relative) of the source context for the task step.
	ContextPath *string `json:"contextPath,omitempty"`

	// READ-ONLY; List of base image dependencies for a step.
	BaseImageDependencies []*BaseImageDependency `json:"baseImageDependencies,omitempty" azure:"ro"`
}

// GetTaskStepProperties implements the TaskStepPropertiesClassification interface for type TaskStepProperties.
func (t *TaskStepProperties) GetTaskStepProperties() *TaskStepProperties { return t }

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskStepProperties.
func (t *TaskStepProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TaskStepProperties) marshalInternal(objectMap map[string]interface{}, discValue StepType) {
	populate(objectMap, "baseImageDependencies", t.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", t.ContextAccessToken)
	populate(objectMap, "contextPath", t.ContextPath)
	t.Type = &discValue
	objectMap["type"] = t.Type
}

func (t *TaskStepProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageDependencies":
			err = unpopulate(val, &t.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, &t.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &t.ContextPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskStepUpdateParametersClassification provides polymorphic access to related types.
// Call the interface's GetTaskStepUpdateParameters() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DockerBuildStepUpdateParameters, *EncodedTaskStepUpdateParameters, *FileTaskStepUpdateParameters, *TaskStepUpdateParameters
type TaskStepUpdateParametersClassification interface {
	// GetTaskStepUpdateParameters returns the TaskStepUpdateParameters content of the underlying type.
	GetTaskStepUpdateParameters() *TaskStepUpdateParameters
}

// TaskStepUpdateParameters - Base properties for updating any task step.
type TaskStepUpdateParameters struct {
	// REQUIRED; The type of the step.
	Type *StepType `json:"type,omitempty"`

	// The token (git PAT or SAS token of storage account blob) associated with the context for a step.
	ContextAccessToken *string `json:"contextAccessToken,omitempty"`

	// The URL(absolute or relative) of the source context for the task step.
	ContextPath *string `json:"contextPath,omitempty"`
}

// GetTaskStepUpdateParameters implements the TaskStepUpdateParametersClassification interface for type TaskStepUpdateParameters.
func (t *TaskStepUpdateParameters) GetTaskStepUpdateParameters() *TaskStepUpdateParameters { return t }

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskStepUpdateParameters.
func (t *TaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TaskStepUpdateParameters) marshalInternal(objectMap map[string]interface{}, discValue StepType) {
	populate(objectMap, "contextAccessToken", t.ContextAccessToken)
	populate(objectMap, "contextPath", t.ContextPath)
	t.Type = &discValue
	objectMap["type"] = t.Type
}

func (t *TaskStepUpdateParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextAccessToken":
			err = unpopulate(val, &t.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &t.ContextPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskUpdateParameters - The parameters for updating a task.
type TaskUpdateParameters struct {
	// Identity for the resource.
	Identity *IdentityProperties `json:"identity,omitempty"`

	// The properties for updating a task.
	Properties *TaskPropertiesUpdateParameters `json:"properties,omitempty"`

	// The ARM resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskUpdateParameters.
func (t TaskUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// TasksBeginCreateOptions contains the optional parameters for the Tasks.BeginCreate method.
type TasksBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// TasksBeginDeleteOptions contains the optional parameters for the Tasks.BeginDelete method.
type TasksBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// TasksBeginUpdateOptions contains the optional parameters for the Tasks.BeginUpdate method.
type TasksBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// TasksGetDetailsOptions contains the optional parameters for the Tasks.GetDetails method.
type TasksGetDetailsOptions struct {
	// placeholder for future optional parameters
}

// TasksGetOptions contains the optional parameters for the Tasks.Get method.
type TasksGetOptions struct {
	// placeholder for future optional parameters
}

// TasksListOptions contains the optional parameters for the Tasks.List method.
type TasksListOptions struct {
	// placeholder for future optional parameters
}

// TimerTrigger - The properties of a timer trigger.
type TimerTrigger struct {
	// REQUIRED; The name of the trigger.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The CRON expression for the task schedule
	Schedule *string `json:"schedule,omitempty"`

	// The current status of trigger.
	Status *TriggerStatus `json:"status,omitempty"`
}

type TimerTriggerDescriptor struct {
	// The occurrence that triggered the run.
	ScheduleOccurrence *string `json:"scheduleOccurrence,omitempty"`

	// The timer trigger name that caused the run.
	TimerTriggerName *string `json:"timerTriggerName,omitempty"`
}

// TimerTriggerUpdateParameters - The properties for updating a timer trigger.
type TimerTriggerUpdateParameters struct {
	// REQUIRED; The name of the trigger.
	Name *string `json:"name,omitempty"`

	// The CRON expression for the task schedule
	Schedule *string `json:"schedule,omitempty"`

	// The current status of trigger.
	Status *TriggerStatus `json:"status,omitempty"`
}

// Token - An object that represents a token for a container registry.
type Token struct {
	ProxyResource
	// The properties of the token.
	Properties *TokenProperties `json:"properties,omitempty"`
}

// TokenCertificate - The properties of a certificate used for authenticating a token.
type TokenCertificate struct {
	// Base 64 encoded string of the public certificate1 in PEM format that will be used for authenticating the token.
	EncodedPemCertificate *string `json:"encodedPemCertificate,omitempty"`

	// The expiry datetime of the certificate.
	Expiry *time.Time            `json:"expiry,omitempty"`
	Name   *TokenCertificateName `json:"name,omitempty"`

	// The thumbprint of the certificate.
	Thumbprint *string `json:"thumbprint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TokenCertificate.
func (t TokenCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encodedPemCertificate", t.EncodedPemCertificate)
	populate(objectMap, "expiry", (*timeRFC3339)(t.Expiry))
	populate(objectMap, "name", t.Name)
	populate(objectMap, "thumbprint", t.Thumbprint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenCertificate.
func (t *TokenCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encodedPemCertificate":
			err = unpopulate(val, &t.EncodedPemCertificate)
			delete(rawMsg, key)
		case "expiry":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.Expiry = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, &t.Thumbprint)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TokenCredentialsProperties - The properties of the credentials that can be used for authenticating the token.
type TokenCredentialsProperties struct {
	Certificates []*TokenCertificate `json:"certificates,omitempty"`
	Passwords    []*TokenPassword    `json:"passwords,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TokenCredentialsProperties.
func (t TokenCredentialsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "certificates", t.Certificates)
	populate(objectMap, "passwords", t.Passwords)
	return json.Marshal(objectMap)
}

// TokenListResult - The result of a request to list tokens for a container registry.
type TokenListResult struct {
	// The URI that can be used to request the next list of tokens.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of tokens. Since this list may be incomplete, the nextLink field should be used to request the next list of tokens.
	Value []*Token `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TokenListResult.
func (t TokenListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TokenPassword - The password that will be used for authenticating the token of a container registry.
type TokenPassword struct {
	// The creation datetime of the password.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// The expiry datetime of the password.
	Expiry *time.Time `json:"expiry,omitempty"`

	// The password name "password1" or "password2"
	Name *TokenPasswordName `json:"name,omitempty"`

	// READ-ONLY; The password value.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TokenPassword.
func (t TokenPassword) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "creationTime", (*timeRFC3339)(t.CreationTime))
	populate(objectMap, "expiry", (*timeRFC3339)(t.Expiry))
	populate(objectMap, "name", t.Name)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenPassword.
func (t *TokenPassword) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.CreationTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "expiry":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.Expiry = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TokenProperties - The properties of a token.
type TokenProperties struct {
	// The credentials that can be used for authenticating the token.
	Credentials *TokenCredentialsProperties `json:"credentials,omitempty"`

	// The resource ID of the scope map to which the token will be associated with.
	ScopeMapID *string `json:"scopeMapId,omitempty"`

	// The status of the token example enabled or disabled.
	Status *TokenStatus `json:"status,omitempty"`

	// READ-ONLY; The creation date of scope map.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TokenProperties.
func (t TokenProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "creationDate", (*timeRFC3339)(t.CreationDate))
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "scopeMapId", t.ScopeMapID)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenProperties.
func (t *TokenProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.CreationDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &t.Credentials)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "scopeMapId":
			err = unpopulate(val, &t.ScopeMapID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TokenUpdateParameters - The parameters for updating a token.
type TokenUpdateParameters struct {
	// The properties of the token update parameters.
	Properties *TokenUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TokenUpdateParameters.
func (t TokenUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// TokenUpdateProperties - The parameters for updating token properties.
type TokenUpdateProperties struct {
	// The credentials that can be used for authenticating the token.
	Credentials *TokenCredentialsProperties `json:"credentials,omitempty"`

	// The resource ID of the scope map to which the token will be associated with.
	ScopeMapID *string `json:"scopeMapId,omitempty"`

	// The status of the token example enabled or disabled.
	Status *TokenStatus `json:"status,omitempty"`
}

// TokensBeginCreateOptions contains the optional parameters for the Tokens.BeginCreate method.
type TokensBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// TokensBeginDeleteOptions contains the optional parameters for the Tokens.BeginDelete method.
type TokensBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// TokensBeginUpdateOptions contains the optional parameters for the Tokens.BeginUpdate method.
type TokensBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// TokensGetOptions contains the optional parameters for the Tokens.Get method.
type TokensGetOptions struct {
	// placeholder for future optional parameters
}

// TokensListOptions contains the optional parameters for the Tokens.List method.
type TokensListOptions struct {
	// placeholder for future optional parameters
}

// TriggerProperties - The properties of a trigger.
type TriggerProperties struct {
	// The trigger based on base image dependencies.
	BaseImageTrigger *BaseImageTrigger `json:"baseImageTrigger,omitempty"`

	// The collection of triggers based on source code repository.
	SourceTriggers []*SourceTrigger `json:"sourceTriggers,omitempty"`

	// The collection of timer triggers.
	TimerTriggers []*TimerTrigger `json:"timerTriggers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerProperties.
func (t TriggerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageTrigger", t.BaseImageTrigger)
	populate(objectMap, "sourceTriggers", t.SourceTriggers)
	populate(objectMap, "timerTriggers", t.TimerTriggers)
	return json.Marshal(objectMap)
}

// TriggerUpdateParameters - The properties for updating triggers.
type TriggerUpdateParameters struct {
	// The trigger based on base image dependencies.
	BaseImageTrigger *BaseImageTriggerUpdateParameters `json:"baseImageTrigger,omitempty"`

	// The collection of triggers based on source code repository.
	SourceTriggers []*SourceTriggerUpdateParameters `json:"sourceTriggers,omitempty"`

	// The collection of timer triggers.
	TimerTriggers []*TimerTriggerUpdateParameters `json:"timerTriggers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerUpdateParameters.
func (t TriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageTrigger", t.BaseImageTrigger)
	populate(objectMap, "sourceTriggers", t.SourceTriggers)
	populate(objectMap, "timerTriggers", t.TimerTriggers)
	return json.Marshal(objectMap)
}

// TrustPolicy - The content trust policy for a container registry.
type TrustPolicy struct {
	// The value that indicates whether the policy is enabled or not.
	Status *PolicyStatus `json:"status,omitempty"`

	// The type of trust policy.
	Type *TrustPolicyType `json:"type,omitempty"`
}

type UserIdentityProperties struct {
	// The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty"`

	// The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty"`
}

// VirtualNetworkRule - Virtual network rule.
type VirtualNetworkRule struct {
	// REQUIRED; Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
	VirtualNetworkResourceID *string `json:"id,omitempty"`

	// The action of virtual network rule.
	Action *Action `json:"action,omitempty"`
}

// Webhook - An object that represents a webhook for a container registry.
type Webhook struct {
	Resource
	// The properties of the webhook.
	Properties *WebhookProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Webhook.
func (w Webhook) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// WebhookCreateParameters - The parameters for creating a webhook.
type WebhookCreateParameters struct {
	// REQUIRED; The location of the webhook. This cannot be changed after the resource is created.
	Location *string `json:"location,omitempty"`

	// The properties that the webhook will be created with.
	Properties *WebhookPropertiesCreateParameters `json:"properties,omitempty"`

	// The tags for the webhook.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebhookCreateParameters.
func (w WebhookCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", w.Location)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// WebhookListResult - The result of a request to list webhooks for a container registry.
type WebhookListResult struct {
	// The URI that can be used to request the next list of webhooks.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of webhooks. Since this list may be incomplete, the nextLink field should be used to request the next list of webhooks.
	Value []*Webhook `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebhookListResult.
func (w WebhookListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WebhookProperties - The properties of a webhook.
type WebhookProperties struct {
	// REQUIRED; The list of actions that trigger the webhook to post notifications.
	Actions []*WebhookAction `json:"actions,omitempty"`

	// The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events
	// for 'foo:bar' only. 'foo' is equivalent to
	// 'foo:latest'. Empty means all events.
	Scope *string `json:"scope,omitempty"`

	// The status of the webhook at the time the operation was called.
	Status *WebhookStatus `json:"status,omitempty"`

	// READ-ONLY; The provisioning state of the webhook at the time the operation was called.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WebhookProperties.
func (w WebhookProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", w.Actions)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "scope", w.Scope)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// WebhookPropertiesCreateParameters - The parameters for creating the properties of a webhook.
type WebhookPropertiesCreateParameters struct {
	// REQUIRED; The list of actions that trigger the webhook to post notifications.
	Actions []*WebhookAction `json:"actions,omitempty"`

	// REQUIRED; The service URI for the webhook to post notifications.
	ServiceURI *string `json:"serviceUri,omitempty"`

	// Custom headers that will be added to the webhook notifications.
	CustomHeaders map[string]*string `json:"customHeaders,omitempty"`

	// The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events
	// for 'foo:bar' only. 'foo' is equivalent to
	// 'foo:latest'. Empty means all events.
	Scope *string `json:"scope,omitempty"`

	// The status of the webhook at the time the operation was called.
	Status *WebhookStatus `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebhookPropertiesCreateParameters.
func (w WebhookPropertiesCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", w.Actions)
	populate(objectMap, "customHeaders", w.CustomHeaders)
	populate(objectMap, "scope", w.Scope)
	populate(objectMap, "serviceUri", w.ServiceURI)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// WebhookPropertiesUpdateParameters - The parameters for updating the properties of a webhook.
type WebhookPropertiesUpdateParameters struct {
	// The list of actions that trigger the webhook to post notifications.
	Actions []*WebhookAction `json:"actions,omitempty"`

	// Custom headers that will be added to the webhook notifications.
	CustomHeaders map[string]*string `json:"customHeaders,omitempty"`

	// The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events
	// for 'foo:bar' only. 'foo' is equivalent to
	// 'foo:latest'. Empty means all events.
	Scope *string `json:"scope,omitempty"`

	// The service URI for the webhook to post notifications.
	ServiceURI *string `json:"serviceUri,omitempty"`

	// The status of the webhook at the time the operation was called.
	Status *WebhookStatus `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebhookPropertiesUpdateParameters.
func (w WebhookPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", w.Actions)
	populate(objectMap, "customHeaders", w.CustomHeaders)
	populate(objectMap, "scope", w.Scope)
	populate(objectMap, "serviceUri", w.ServiceURI)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// WebhookUpdateParameters - The parameters for updating a webhook.
type WebhookUpdateParameters struct {
	// The properties that the webhook will be updated with.
	Properties *WebhookPropertiesUpdateParameters `json:"properties,omitempty"`

	// The tags for the webhook.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebhookUpdateParameters.
func (w WebhookUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// WebhooksBeginCreateOptions contains the optional parameters for the Webhooks.BeginCreate method.
type WebhooksBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// WebhooksBeginDeleteOptions contains the optional parameters for the Webhooks.BeginDelete method.
type WebhooksBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// WebhooksBeginUpdateOptions contains the optional parameters for the Webhooks.BeginUpdate method.
type WebhooksBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// WebhooksGetCallbackConfigOptions contains the optional parameters for the Webhooks.GetCallbackConfig method.
type WebhooksGetCallbackConfigOptions struct {
	// placeholder for future optional parameters
}

// WebhooksGetOptions contains the optional parameters for the Webhooks.Get method.
type WebhooksGetOptions struct {
	// placeholder for future optional parameters
}

// WebhooksListEventsOptions contains the optional parameters for the Webhooks.ListEvents method.
type WebhooksListEventsOptions struct {
	// placeholder for future optional parameters
}

// WebhooksListOptions contains the optional parameters for the Webhooks.List method.
type WebhooksListOptions struct {
	// placeholder for future optional parameters
}

// WebhooksPingOptions contains the optional parameters for the Webhooks.Ping method.
type WebhooksPingOptions struct {
	// placeholder for future optional parameters
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
