//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerregistry

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AgentPool.
func (a AgentPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolListResult.
func (a AgentPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolUpdateParameters.
func (a AgentPoolUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CallbackConfig.
func (c CallbackConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customHeaders", c.CustomHeaders)
	populate(objectMap, "serviceUri", c.ServiceURI)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryListResult.
func (c ConnectedRegistryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryProperties.
func (c ConnectedRegistryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activation", c.Activation)
	populate(objectMap, "clientTokenIds", c.ClientTokenIDs)
	populate(objectMap, "connectionState", c.ConnectionState)
	populateTimeRFC3339(objectMap, "lastActivityTime", c.LastActivityTime)
	populate(objectMap, "logging", c.Logging)
	populate(objectMap, "loginServer", c.LoginServer)
	populate(objectMap, "mode", c.Mode)
	populate(objectMap, "notificationsList", c.NotificationsList)
	populate(objectMap, "parent", c.Parent)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "statusDetails", c.StatusDetails)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectedRegistryProperties.
func (c *ConnectedRegistryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activation":
			err = unpopulate(val, &c.Activation)
			delete(rawMsg, key)
		case "clientTokenIds":
			err = unpopulate(val, &c.ClientTokenIDs)
			delete(rawMsg, key)
		case "connectionState":
			err = unpopulate(val, &c.ConnectionState)
			delete(rawMsg, key)
		case "lastActivityTime":
			err = unpopulateTimeRFC3339(val, &c.LastActivityTime)
			delete(rawMsg, key)
		case "logging":
			err = unpopulate(val, &c.Logging)
			delete(rawMsg, key)
		case "loginServer":
			err = unpopulate(val, &c.LoginServer)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &c.Mode)
			delete(rawMsg, key)
		case "notificationsList":
			err = unpopulate(val, &c.NotificationsList)
			delete(rawMsg, key)
		case "parent":
			err = unpopulate(val, &c.Parent)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &c.StatusDetails)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &c.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryUpdateParameters.
func (c ConnectedRegistryUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedRegistryUpdateProperties.
func (c ConnectedRegistryUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientTokenIds", c.ClientTokenIDs)
	populate(objectMap, "logging", c.Logging)
	populate(objectMap, "notificationsList", c.NotificationsList)
	populate(objectMap, "syncProperties", c.SyncProperties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Credentials.
func (c Credentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customRegistries", c.CustomRegistries)
	populate(objectMap, "sourceRegistry", c.SourceRegistry)
	return json.Marshal(objectMap)
}

// GetRunRequest implements the RunRequestClassification interface for type DockerBuildRequest.
func (d *DockerBuildRequest) GetRunRequest() *RunRequest {
	return &RunRequest{
		Type:             d.Type,
		IsArchiveEnabled: d.IsArchiveEnabled,
		AgentPoolName:    d.AgentPoolName,
		LogTemplate:      d.LogTemplate,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildRequest.
func (d DockerBuildRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", d.AgentConfiguration)
	populate(objectMap, "agentPoolName", d.AgentPoolName)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "credentials", d.Credentials)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isArchiveEnabled", d.IsArchiveEnabled)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "logTemplate", d.LogTemplate)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "platform", d.Platform)
	populate(objectMap, "sourceLocation", d.SourceLocation)
	populate(objectMap, "target", d.Target)
	populate(objectMap, "timeout", d.Timeout)
	objectMap["type"] = "DockerBuildRequest"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildRequest.
func (d *DockerBuildRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &d.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &d.AgentPoolName)
			delete(rawMsg, key)
		case "arguments":
			err = unpopulate(val, &d.Arguments)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &d.Credentials)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, &d.ImageNames)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &d.IsArchiveEnabled)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, &d.IsPushEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &d.LogTemplate)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, &d.NoCache)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &d.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, &d.SourceLocation)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &d.Target)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &d.Timeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTaskStepProperties implements the TaskStepPropertiesClassification interface for type DockerBuildStep.
func (d *DockerBuildStep) GetTaskStepProperties() *TaskStepProperties {
	return &TaskStepProperties{
		Type:                  d.Type,
		BaseImageDependencies: d.BaseImageDependencies,
		ContextPath:           d.ContextPath,
		ContextAccessToken:    d.ContextAccessToken,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildStep.
func (d DockerBuildStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "baseImageDependencies", d.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", d.ContextAccessToken)
	populate(objectMap, "contextPath", d.ContextPath)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "target", d.Target)
	objectMap["type"] = StepTypeDocker
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildStep.
func (d *DockerBuildStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, &d.Arguments)
			delete(rawMsg, key)
		case "baseImageDependencies":
			err = unpopulate(val, &d.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, &d.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &d.ContextPath)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, &d.NoCache)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &d.Target)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTaskStepUpdateParameters implements the TaskStepUpdateParametersClassification interface for type DockerBuildStepUpdateParameters.
func (d *DockerBuildStepUpdateParameters) GetTaskStepUpdateParameters() *TaskStepUpdateParameters {
	return &TaskStepUpdateParameters{
		Type:               d.Type,
		ContextPath:        d.ContextPath,
		ContextAccessToken: d.ContextAccessToken,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildStepUpdateParameters.
func (d DockerBuildStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "contextAccessToken", d.ContextAccessToken)
	populate(objectMap, "contextPath", d.ContextPath)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "target", d.Target)
	objectMap["type"] = StepTypeDocker
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildStepUpdateParameters.
func (d *DockerBuildStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, &d.Arguments)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, &d.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &d.ContextPath)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, &d.NoCache)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &d.Target)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRunRequest implements the RunRequestClassification interface for type EncodedTaskRunRequest.
func (e *EncodedTaskRunRequest) GetRunRequest() *RunRequest {
	return &RunRequest{
		Type:             e.Type,
		IsArchiveEnabled: e.IsArchiveEnabled,
		AgentPoolName:    e.AgentPoolName,
		LogTemplate:      e.LogTemplate,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskRunRequest.
func (e EncodedTaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", e.AgentConfiguration)
	populate(objectMap, "agentPoolName", e.AgentPoolName)
	populate(objectMap, "credentials", e.Credentials)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	populate(objectMap, "isArchiveEnabled", e.IsArchiveEnabled)
	populate(objectMap, "logTemplate", e.LogTemplate)
	populate(objectMap, "platform", e.Platform)
	populate(objectMap, "sourceLocation", e.SourceLocation)
	populate(objectMap, "timeout", e.Timeout)
	objectMap["type"] = "EncodedTaskRunRequest"
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskRunRequest.
func (e *EncodedTaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &e.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &e.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &e.Credentials)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &e.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &e.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &e.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, &e.SourceLocation)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &e.Timeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTaskStepProperties implements the TaskStepPropertiesClassification interface for type EncodedTaskStep.
func (e *EncodedTaskStep) GetTaskStepProperties() *TaskStepProperties {
	return &TaskStepProperties{
		Type:                  e.Type,
		BaseImageDependencies: e.BaseImageDependencies,
		ContextPath:           e.ContextPath,
		ContextAccessToken:    e.ContextAccessToken,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskStep.
func (e EncodedTaskStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageDependencies", e.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", e.ContextAccessToken)
	populate(objectMap, "contextPath", e.ContextPath)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	objectMap["type"] = StepTypeEncodedTask
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskStep.
func (e *EncodedTaskStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageDependencies":
			err = unpopulate(val, &e.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, &e.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &e.ContextPath)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTaskStepUpdateParameters implements the TaskStepUpdateParametersClassification interface for type EncodedTaskStepUpdateParameters.
func (e *EncodedTaskStepUpdateParameters) GetTaskStepUpdateParameters() *TaskStepUpdateParameters {
	return &TaskStepUpdateParameters{
		Type:               e.Type,
		ContextPath:        e.ContextPath,
		ContextAccessToken: e.ContextAccessToken,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskStepUpdateParameters.
func (e EncodedTaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contextAccessToken", e.ContextAccessToken)
	populate(objectMap, "contextPath", e.ContextPath)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	objectMap["type"] = StepTypeEncodedTask
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskStepUpdateParameters.
func (e *EncodedTaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextAccessToken":
			err = unpopulate(val, &e.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &e.ContextPath)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseBody.
func (e ErrorResponseBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EventContent.
func (e EventContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", e.Action)
	populate(objectMap, "actor", e.Actor)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "request", e.Request)
	populate(objectMap, "source", e.Source)
	populate(objectMap, "target", e.Target)
	populateTimeRFC3339(objectMap, "timestamp", e.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventContent.
func (e *EventContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, &e.Action)
			delete(rawMsg, key)
		case "actor":
			err = unpopulate(val, &e.Actor)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &e.ID)
			delete(rawMsg, key)
		case "request":
			err = unpopulate(val, &e.Request)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &e.Source)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &e.Target)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &e.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventListResult.
func (e EventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EventRequestMessage.
func (e EventRequestMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", e.Content)
	populate(objectMap, "headers", e.Headers)
	populate(objectMap, "method", e.Method)
	populate(objectMap, "requestUri", e.RequestURI)
	populate(objectMap, "version", e.Version)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EventResponseMessage.
func (e EventResponseMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", e.Content)
	populate(objectMap, "headers", e.Headers)
	populate(objectMap, "reasonPhrase", e.ReasonPhrase)
	populate(objectMap, "statusCode", e.StatusCode)
	populate(objectMap, "version", e.Version)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ExportPipelineListResult.
func (e ExportPipelineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ExportPipelineProperties.
func (e ExportPipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "options", e.Options)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// GetRunRequest implements the RunRequestClassification interface for type FileTaskRunRequest.
func (f *FileTaskRunRequest) GetRunRequest() *RunRequest {
	return &RunRequest{
		Type:             f.Type,
		IsArchiveEnabled: f.IsArchiveEnabled,
		AgentPoolName:    f.AgentPoolName,
		LogTemplate:      f.LogTemplate,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskRunRequest.
func (f FileTaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", f.AgentConfiguration)
	populate(objectMap, "agentPoolName", f.AgentPoolName)
	populate(objectMap, "credentials", f.Credentials)
	populate(objectMap, "isArchiveEnabled", f.IsArchiveEnabled)
	populate(objectMap, "logTemplate", f.LogTemplate)
	populate(objectMap, "platform", f.Platform)
	populate(objectMap, "sourceLocation", f.SourceLocation)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	populate(objectMap, "timeout", f.Timeout)
	objectMap["type"] = "FileTaskRunRequest"
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskRunRequest.
func (f *FileTaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &f.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &f.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &f.Credentials)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &f.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &f.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &f.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, &f.SourceLocation)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, &f.TaskFilePath)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &f.Timeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTaskStepProperties implements the TaskStepPropertiesClassification interface for type FileTaskStep.
func (f *FileTaskStep) GetTaskStepProperties() *TaskStepProperties {
	return &TaskStepProperties{
		Type:                  f.Type,
		BaseImageDependencies: f.BaseImageDependencies,
		ContextPath:           f.ContextPath,
		ContextAccessToken:    f.ContextAccessToken,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskStep.
func (f FileTaskStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageDependencies", f.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", f.ContextAccessToken)
	populate(objectMap, "contextPath", f.ContextPath)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	objectMap["type"] = StepTypeFileTask
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskStep.
func (f *FileTaskStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageDependencies":
			err = unpopulate(val, &f.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, &f.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &f.ContextPath)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, &f.TaskFilePath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTaskStepUpdateParameters implements the TaskStepUpdateParametersClassification interface for type FileTaskStepUpdateParameters.
func (f *FileTaskStepUpdateParameters) GetTaskStepUpdateParameters() *TaskStepUpdateParameters {
	return &TaskStepUpdateParameters{
		Type:               f.Type,
		ContextPath:        f.ContextPath,
		ContextAccessToken: f.ContextAccessToken,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskStepUpdateParameters.
func (f FileTaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contextAccessToken", f.ContextAccessToken)
	populate(objectMap, "contextPath", f.ContextPath)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	objectMap["type"] = StepTypeFileTask
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskStepUpdateParameters.
func (f *FileTaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextAccessToken":
			err = unpopulate(val, &f.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, &f.ContextPath)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, &f.TaskFilePath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenerateCredentialsParameters.
func (g GenerateCredentialsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expiry", g.Expiry)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "tokenId", g.TokenID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenerateCredentialsParameters.
func (g *GenerateCredentialsParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiry":
			err = unpopulateTimeRFC3339(val, &g.Expiry)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &g.Name)
			delete(rawMsg, key)
		case "tokenId":
			err = unpopulate(val, &g.TokenID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenerateCredentialsResult.
func (g GenerateCredentialsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "passwords", g.Passwords)
	populate(objectMap, "username", g.Username)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IdentityProperties.
func (i IdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ImageUpdateTrigger.
func (i ImageUpdateTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "images", i.Images)
	populateTimeRFC3339(objectMap, "timestamp", i.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageUpdateTrigger.
func (i *ImageUpdateTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "images":
			err = unpopulate(val, &i.Images)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &i.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImportImageParameters.
func (i ImportImageParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "mode", i.Mode)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "targetTags", i.TargetTags)
	populate(objectMap, "untaggedTargetRepositories", i.UntaggedTargetRepositories)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ImportPipelineListResult.
func (i ImportPipelineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ImportPipelineProperties.
func (i ImportPipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "options", i.Options)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "trigger", i.Trigger)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type KeyVaultProperties.
func (k KeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", k.Identity)
	populate(objectMap, "keyIdentifier", k.KeyIdentifier)
	populate(objectMap, "keyRotationEnabled", k.KeyRotationEnabled)
	populateTimeRFC3339(objectMap, "lastKeyRotationTimestamp", k.LastKeyRotationTimestamp)
	populate(objectMap, "versionedKeyIdentifier", k.VersionedKeyIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyVaultProperties.
func (k *KeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &k.Identity)
			delete(rawMsg, key)
		case "keyIdentifier":
			err = unpopulate(val, &k.KeyIdentifier)
			delete(rawMsg, key)
		case "keyRotationEnabled":
			err = unpopulate(val, &k.KeyRotationEnabled)
			delete(rawMsg, key)
		case "lastKeyRotationTimestamp":
			err = unpopulateTimeRFC3339(val, &k.LastKeyRotationTimestamp)
			delete(rawMsg, key)
		case "versionedKeyIdentifier":
			err = unpopulate(val, &k.VersionedKeyIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSet.
func (n NetworkRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", n.DefaultAction)
	populate(objectMap, "ipRules", n.IPRules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationServiceSpecificationDefinition.
func (o OperationServiceSpecificationDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", o.LogSpecifications)
	populate(objectMap, "metricSpecifications", o.MetricSpecifications)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OverrideTaskStepProperties.
func (o OverrideTaskStepProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", o.Arguments)
	populate(objectMap, "contextPath", o.ContextPath)
	populate(objectMap, "file", o.File)
	populate(objectMap, "target", o.Target)
	populate(objectMap, "updateTriggerToken", o.UpdateTriggerToken)
	populate(objectMap, "values", o.Values)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunListResult.
func (p PipelineRunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunRequest.
func (p PipelineRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "artifacts", p.Artifacts)
	populate(objectMap, "catalogDigest", p.CatalogDigest)
	populate(objectMap, "pipelineResourceId", p.PipelineResourceID)
	populate(objectMap, "source", p.Source)
	populate(objectMap, "target", p.Target)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunResponse.
func (p PipelineRunResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "catalogDigest", p.CatalogDigest)
	populateTimeRFC3339(objectMap, "finishTime", p.FinishTime)
	populate(objectMap, "importedArtifacts", p.ImportedArtifacts)
	populate(objectMap, "pipelineRunErrorMessage", p.PipelineRunErrorMessage)
	populate(objectMap, "progress", p.Progress)
	populate(objectMap, "source", p.Source)
	populateTimeRFC3339(objectMap, "startTime", p.StartTime)
	populate(objectMap, "status", p.Status)
	populate(objectMap, "target", p.Target)
	populate(objectMap, "trigger", p.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRunResponse.
func (p *PipelineRunResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogDigest":
			err = unpopulate(val, &p.CatalogDigest)
			delete(rawMsg, key)
		case "finishTime":
			err = unpopulateTimeRFC3339(val, &p.FinishTime)
			delete(rawMsg, key)
		case "importedArtifacts":
			err = unpopulate(val, &p.ImportedArtifacts)
			delete(rawMsg, key)
		case "pipelineRunErrorMessage":
			err = unpopulate(val, &p.PipelineRunErrorMessage)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &p.Progress)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &p.Source)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &p.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &p.Status)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &p.Target)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &p.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineSourceTriggerDescriptor.
func (p PipelineSourceTriggerDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "timestamp", p.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineSourceTriggerDescriptor.
func (p *PipelineSourceTriggerDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &p.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Registry.
func (r Registry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RegistryListCredentialsResult.
func (r RegistryListCredentialsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "passwords", r.Passwords)
	populate(objectMap, "username", r.Username)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RegistryListResult.
func (r RegistryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RegistryProperties.
func (r RegistryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adminUserEnabled", r.AdminUserEnabled)
	populate(objectMap, "anonymousPullEnabled", r.AnonymousPullEnabled)
	populateTimeRFC3339(objectMap, "creationDate", r.CreationDate)
	populate(objectMap, "dataEndpointEnabled", r.DataEndpointEnabled)
	populate(objectMap, "dataEndpointHostNames", r.DataEndpointHostNames)
	populate(objectMap, "encryption", r.Encryption)
	populate(objectMap, "loginServer", r.LoginServer)
	populate(objectMap, "networkRuleBypassOptions", r.NetworkRuleBypassOptions)
	populate(objectMap, "networkRuleSet", r.NetworkRuleSet)
	populate(objectMap, "policies", r.Policies)
	populate(objectMap, "privateEndpointConnections", r.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", r.PublicNetworkAccess)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "zoneRedundancy", r.ZoneRedundancy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistryProperties.
func (r *RegistryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminUserEnabled":
			err = unpopulate(val, &r.AdminUserEnabled)
			delete(rawMsg, key)
		case "anonymousPullEnabled":
			err = unpopulate(val, &r.AnonymousPullEnabled)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &r.CreationDate)
			delete(rawMsg, key)
		case "dataEndpointEnabled":
			err = unpopulate(val, &r.DataEndpointEnabled)
			delete(rawMsg, key)
		case "dataEndpointHostNames":
			err = unpopulate(val, &r.DataEndpointHostNames)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &r.Encryption)
			delete(rawMsg, key)
		case "loginServer":
			err = unpopulate(val, &r.LoginServer)
			delete(rawMsg, key)
		case "networkRuleBypassOptions":
			err = unpopulate(val, &r.NetworkRuleBypassOptions)
			delete(rawMsg, key)
		case "networkRuleSet":
			err = unpopulate(val, &r.NetworkRuleSet)
			delete(rawMsg, key)
		case "policies":
			err = unpopulate(val, &r.Policies)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &r.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &r.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &r.PublicNetworkAccess)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "zoneRedundancy":
			err = unpopulate(val, &r.ZoneRedundancy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegistryUpdateParameters.
func (r RegistryUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RegistryUsageListResult.
func (r RegistryUsageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Replication.
func (r Replication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationListResult.
func (r ReplicationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationUpdateParameters.
func (r ReplicationUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RetentionPolicy.
func (r RetentionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "days", r.Days)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", r.LastUpdatedTime)
	populate(objectMap, "status", r.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RetentionPolicy.
func (r *RetentionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "days":
			err = unpopulate(val, &r.Days)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &r.LastUpdatedTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunFilter.
func (r RunFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populateTimeRFC3339(objectMap, "createTime", r.CreateTime)
	populateTimeRFC3339(objectMap, "finishTime", r.FinishTime)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populate(objectMap, "outputImageManifests", r.OutputImageManifests)
	populate(objectMap, "runId", r.RunID)
	populate(objectMap, "runType", r.RunType)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "taskName", r.TaskName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunFilter.
func (r *RunFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentPoolName":
			err = unpopulate(val, &r.AgentPoolName)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateTimeRFC3339(val, &r.CreateTime)
			delete(rawMsg, key)
		case "finishTime":
			err = unpopulateTimeRFC3339(val, &r.FinishTime)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "outputImageManifests":
			err = unpopulate(val, &r.OutputImageManifests)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, &r.RunID)
			delete(rawMsg, key)
		case "runType":
			err = unpopulate(val, &r.RunType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "taskName":
			err = unpopulate(val, &r.TaskName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunListResult.
func (r RunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RunProperties.
func (r RunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", r.AgentConfiguration)
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populateTimeRFC3339(objectMap, "createTime", r.CreateTime)
	populate(objectMap, "customRegistries", r.CustomRegistries)
	populateTimeRFC3339(objectMap, "finishTime", r.FinishTime)
	populate(objectMap, "imageUpdateTrigger", r.ImageUpdateTrigger)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", r.LastUpdatedTime)
	populate(objectMap, "logArtifact", r.LogArtifact)
	populate(objectMap, "outputImages", r.OutputImages)
	populate(objectMap, "platform", r.Platform)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "runErrorMessage", r.RunErrorMessage)
	populate(objectMap, "runId", r.RunID)
	populate(objectMap, "runType", r.RunType)
	populate(objectMap, "sourceRegistryAuth", r.SourceRegistryAuth)
	populate(objectMap, "sourceTrigger", r.SourceTrigger)
	populateTimeRFC3339(objectMap, "startTime", r.StartTime)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "task", r.Task)
	populate(objectMap, "timerTrigger", r.TimerTrigger)
	populate(objectMap, "updateTriggerToken", r.UpdateTriggerToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunProperties.
func (r *RunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &r.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &r.AgentPoolName)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateTimeRFC3339(val, &r.CreateTime)
			delete(rawMsg, key)
		case "customRegistries":
			err = unpopulate(val, &r.CustomRegistries)
			delete(rawMsg, key)
		case "finishTime":
			err = unpopulateTimeRFC3339(val, &r.FinishTime)
			delete(rawMsg, key)
		case "imageUpdateTrigger":
			err = unpopulate(val, &r.ImageUpdateTrigger)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &r.LastUpdatedTime)
			delete(rawMsg, key)
		case "logArtifact":
			err = unpopulate(val, &r.LogArtifact)
			delete(rawMsg, key)
		case "outputImages":
			err = unpopulate(val, &r.OutputImages)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &r.Platform)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &r.ProvisioningState)
			delete(rawMsg, key)
		case "runErrorMessage":
			err = unpopulate(val, &r.RunErrorMessage)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, &r.RunID)
			delete(rawMsg, key)
		case "runType":
			err = unpopulate(val, &r.RunType)
			delete(rawMsg, key)
		case "sourceRegistryAuth":
			err = unpopulate(val, &r.SourceRegistryAuth)
			delete(rawMsg, key)
		case "sourceTrigger":
			err = unpopulate(val, &r.SourceTrigger)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &r.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "task":
			err = unpopulate(val, &r.Task)
			delete(rawMsg, key)
		case "timerTrigger":
			err = unpopulate(val, &r.TimerTrigger)
			delete(rawMsg, key)
		case "updateTriggerToken":
			err = unpopulate(val, &r.UpdateTriggerToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRunRequest implements the RunRequestClassification interface for type RunRequest.
func (r *RunRequest) GetRunRequest() *RunRequest { return r }

// MarshalJSON implements the json.Marshaller interface for type RunUpdateParameters.
func (r RunUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapListResult.
func (s ScopeMapListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapProperties.
func (s ScopeMapProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", s.Actions)
	populateTimeRFC3339(objectMap, "creationDate", s.CreationDate)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScopeMapProperties.
func (s *ScopeMapProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			err = unpopulate(val, &s.Actions)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &s.CreationDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapPropertiesUpdateParameters.
func (s ScopeMapPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", s.Actions)
	populate(objectMap, "description", s.Description)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScopeMapUpdateParameters.
func (s ScopeMapUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SoftDeletePolicy.
func (s SoftDeletePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "lastUpdatedTime", s.LastUpdatedTime)
	populate(objectMap, "retentionDays", s.RetentionDays)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SoftDeletePolicy.
func (s *SoftDeletePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &s.LastUpdatedTime)
			delete(rawMsg, key)
		case "retentionDays":
			err = unpopulate(val, &s.RetentionDays)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceTrigger.
func (s SourceTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sourceRepository", s.SourceRepository)
	populate(objectMap, "sourceTriggerEvents", s.SourceTriggerEvents)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SourceTriggerUpdateParameters.
func (s SourceTriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sourceRepository", s.SourceRepository)
	populate(objectMap, "sourceTriggerEvents", s.SourceTriggerEvents)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Status.
func (s Status) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayStatus", s.DisplayStatus)
	populate(objectMap, "message", s.Message)
	populateTimeRFC3339(objectMap, "timestamp", s.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Status.
func (s *Status) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayStatus":
			err = unpopulate(val, &s.DisplayStatus)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &s.Message)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &s.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StatusDetailProperties.
func (s StatusDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", s.Code)
	populate(objectMap, "correlationId", s.CorrelationID)
	populate(objectMap, "description", s.Description)
	populateTimeRFC3339(objectMap, "timestamp", s.Timestamp)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatusDetailProperties.
func (s *StatusDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, &s.Code)
			delete(rawMsg, key)
		case "correlationId":
			err = unpopulate(val, &s.CorrelationID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &s.Timestamp)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SyncProperties.
func (s SyncProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "gatewayEndpoint", s.GatewayEndpoint)
	populateTimeRFC3339(objectMap, "lastSyncTime", s.LastSyncTime)
	populate(objectMap, "messageTtl", s.MessageTTL)
	populate(objectMap, "schedule", s.Schedule)
	populate(objectMap, "syncWindow", s.SyncWindow)
	populate(objectMap, "tokenId", s.TokenID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SyncProperties.
func (s *SyncProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gatewayEndpoint":
			err = unpopulate(val, &s.GatewayEndpoint)
			delete(rawMsg, key)
		case "lastSyncTime":
			err = unpopulateTimeRFC3339(val, &s.LastSyncTime)
			delete(rawMsg, key)
		case "messageTtl":
			err = unpopulate(val, &s.MessageTTL)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, &s.Schedule)
			delete(rawMsg, key)
		case "syncWindow":
			err = unpopulate(val, &s.SyncWindow)
			delete(rawMsg, key)
		case "tokenId":
			err = unpopulate(val, &s.TokenID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Task.
func (t Task) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TaskListResult.
func (t TaskListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TaskProperties.
func (t TaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", t.AgentConfiguration)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populateTimeRFC3339(objectMap, "creationDate", t.CreationDate)
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "isSystemTask", t.IsSystemTask)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "platform", t.Platform)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "step", t.Step)
	populate(objectMap, "timeout", t.Timeout)
	populate(objectMap, "trigger", t.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskProperties.
func (t *TaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &t.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &t.AgentPoolName)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &t.CreationDate)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &t.Credentials)
			delete(rawMsg, key)
		case "isSystemTask":
			err = unpopulate(val, &t.IsSystemTask)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &t.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &t.Platform)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "step":
			t.Step, err = unmarshalTaskStepPropertiesClassification(val)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &t.Timeout)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &t.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskPropertiesUpdateParameters.
func (t TaskPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", t.AgentConfiguration)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "platform", t.Platform)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "step", t.Step)
	populate(objectMap, "timeout", t.Timeout)
	populate(objectMap, "trigger", t.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskPropertiesUpdateParameters.
func (t *TaskPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, &t.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, &t.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &t.Credentials)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &t.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &t.Platform)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "step":
			t.Step, err = unmarshalTaskStepUpdateParametersClassification(val)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &t.Timeout)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &t.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunListResult.
func (t TaskRunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunProperties.
func (t TaskRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "forceUpdateTag", t.ForceUpdateTag)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "runRequest", t.RunRequest)
	populate(objectMap, "runResult", t.RunResult)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunProperties.
func (t *TaskRunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceUpdateTag":
			err = unpopulate(val, &t.ForceUpdateTag)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "runRequest":
			t.RunRequest, err = unmarshalRunRequestClassification(val)
			delete(rawMsg, key)
		case "runResult":
			err = unpopulate(val, &t.RunResult)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunPropertiesUpdateParameters.
func (t TaskRunPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "forceUpdateTag", t.ForceUpdateTag)
	populate(objectMap, "runRequest", t.RunRequest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunPropertiesUpdateParameters.
func (t *TaskRunPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceUpdateTag":
			err = unpopulate(val, &t.ForceUpdateTag)
			delete(rawMsg, key)
		case "runRequest":
			t.RunRequest, err = unmarshalRunRequestClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRunRequest implements the RunRequestClassification interface for type TaskRunRequest.
func (t *TaskRunRequest) GetRunRequest() *RunRequest {
	return &RunRequest{
		Type:             t.Type,
		IsArchiveEnabled: t.IsArchiveEnabled,
		AgentPoolName:    t.AgentPoolName,
		LogTemplate:      t.LogTemplate,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunRequest.
func (t TaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populate(objectMap, "isArchiveEnabled", t.IsArchiveEnabled)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "overrideTaskStepProperties", t.OverrideTaskStepProperties)
	populate(objectMap, "taskId", t.TaskID)
	objectMap["type"] = "TaskRunRequest"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunRequest.
func (t *TaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentPoolName":
			err = unpopulate(val, &t.AgentPoolName)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, &t.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, &t.LogTemplate)
			delete(rawMsg, key)
		case "overrideTaskStepProperties":
			err = unpopulate(val, &t.OverrideTaskStepProperties)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &t.TaskID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunUpdateParameters.
func (t TaskRunUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// GetTaskStepProperties implements the TaskStepPropertiesClassification interface for type TaskStepProperties.
func (t *TaskStepProperties) GetTaskStepProperties() *TaskStepProperties { return t }

// MarshalJSON implements the json.Marshaller interface for type TaskStepProperties.
func (t TaskStepProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageDependencies", t.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", t.ContextAccessToken)
	populate(objectMap, "contextPath", t.ContextPath)
	objectMap["type"] = t.Type
	return json.Marshal(objectMap)
}

// GetTaskStepUpdateParameters implements the TaskStepUpdateParametersClassification interface for type TaskStepUpdateParameters.
func (t *TaskStepUpdateParameters) GetTaskStepUpdateParameters() *TaskStepUpdateParameters { return t }

// MarshalJSON implements the json.Marshaller interface for type TaskUpdateParameters.
func (t TaskUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TokenCertificate.
func (t TokenCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encodedPemCertificate", t.EncodedPemCertificate)
	populateTimeRFC3339(objectMap, "expiry", t.Expiry)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "thumbprint", t.Thumbprint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenCertificate.
func (t *TokenCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encodedPemCertificate":
			err = unpopulate(val, &t.EncodedPemCertificate)
			delete(rawMsg, key)
		case "expiry":
			err = unpopulateTimeRFC3339(val, &t.Expiry)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, &t.Thumbprint)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenCredentialsProperties.
func (t TokenCredentialsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "certificates", t.Certificates)
	populate(objectMap, "passwords", t.Passwords)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TokenListResult.
func (t TokenListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TokenPassword.
func (t TokenPassword) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationTime", t.CreationTime)
	populateTimeRFC3339(objectMap, "expiry", t.Expiry)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenPassword.
func (t *TokenPassword) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, &t.CreationTime)
			delete(rawMsg, key)
		case "expiry":
			err = unpopulateTimeRFC3339(val, &t.Expiry)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenProperties.
func (t TokenProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationDate", t.CreationDate)
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "scopeMapId", t.ScopeMapID)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenProperties.
func (t *TokenProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &t.CreationDate)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, &t.Credentials)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "scopeMapId":
			err = unpopulate(val, &t.ScopeMapID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenUpdateParameters.
func (t TokenUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TriggerProperties.
func (t TriggerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageTrigger", t.BaseImageTrigger)
	populate(objectMap, "sourceTriggers", t.SourceTriggers)
	populate(objectMap, "timerTriggers", t.TimerTriggers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TriggerUpdateParameters.
func (t TriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseImageTrigger", t.BaseImageTrigger)
	populate(objectMap, "sourceTriggers", t.SourceTriggers)
	populate(objectMap, "timerTriggers", t.TimerTriggers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Webhook.
func (w Webhook) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "location", w.Location)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "tags", w.Tags)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookCreateParameters.
func (w WebhookCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", w.Location)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookListResult.
func (w WebhookListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookProperties.
func (w WebhookProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", w.Actions)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "scope", w.Scope)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookPropertiesCreateParameters.
func (w WebhookPropertiesCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", w.Actions)
	populate(objectMap, "customHeaders", w.CustomHeaders)
	populate(objectMap, "scope", w.Scope)
	populate(objectMap, "serviceUri", w.ServiceURI)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookPropertiesUpdateParameters.
func (w WebhookPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", w.Actions)
	populate(objectMap, "customHeaders", w.CustomHeaders)
	populate(objectMap, "scope", w.Scope)
	populate(objectMap, "serviceUri", w.ServiceURI)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookUpdateParameters.
func (w WebhookUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
