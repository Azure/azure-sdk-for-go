//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerregistry

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// AgentPoolsListPager provides operations for iterating over paged responses.
type AgentPoolsListPager struct {
	client    *AgentPoolsClient
	current   AgentPoolsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AgentPoolsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AgentPoolsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AgentPoolsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AgentPoolListResult.NextLink == nil || len(*p.current.AgentPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AgentPoolsListResponse page.
func (p *AgentPoolsListPager) PageResponse() AgentPoolsListResponse {
	return p.current
}

// ConnectedRegistriesListPager provides operations for iterating over paged responses.
type ConnectedRegistriesListPager struct {
	client    *ConnectedRegistriesClient
	current   ConnectedRegistriesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectedRegistriesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectedRegistriesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectedRegistriesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectedRegistryListResult.NextLink == nil || len(*p.current.ConnectedRegistryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectedRegistriesListResponse page.
func (p *ConnectedRegistriesListPager) PageResponse() ConnectedRegistriesListResponse {
	return p.current
}

// ExportPipelinesListPager provides operations for iterating over paged responses.
type ExportPipelinesListPager struct {
	client    *ExportPipelinesClient
	current   ExportPipelinesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExportPipelinesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExportPipelinesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExportPipelinesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExportPipelineListResult.NextLink == nil || len(*p.current.ExportPipelineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExportPipelinesListResponse page.
func (p *ExportPipelinesListPager) PageResponse() ExportPipelinesListResponse {
	return p.current
}

// ImportPipelinesListPager provides operations for iterating over paged responses.
type ImportPipelinesListPager struct {
	client    *ImportPipelinesClient
	current   ImportPipelinesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImportPipelinesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ImportPipelinesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ImportPipelinesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImportPipelineListResult.NextLink == nil || len(*p.current.ImportPipelineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ImportPipelinesListResponse page.
func (p *ImportPipelinesListPager) PageResponse() ImportPipelinesListResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// PipelineRunsListPager provides operations for iterating over paged responses.
type PipelineRunsListPager struct {
	client    *PipelineRunsClient
	current   PipelineRunsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PipelineRunsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PipelineRunsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PipelineRunsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PipelineRunListResult.NextLink == nil || len(*p.current.PipelineRunListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PipelineRunsListResponse page.
func (p *PipelineRunsListPager) PageResponse() PipelineRunsListResponse {
	return p.current
}

// PrivateEndpointConnectionsListPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsListPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsListResponse page.
func (p *PrivateEndpointConnectionsListPager) PageResponse() PrivateEndpointConnectionsListResponse {
	return p.current
}

// RegistriesListByResourceGroupPager provides operations for iterating over paged responses.
type RegistriesListByResourceGroupPager struct {
	client    *RegistriesClient
	current   RegistriesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegistriesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegistriesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegistriesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegistryListResult.NextLink == nil || len(*p.current.RegistryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegistriesListByResourceGroupResponse page.
func (p *RegistriesListByResourceGroupPager) PageResponse() RegistriesListByResourceGroupResponse {
	return p.current
}

// RegistriesListPager provides operations for iterating over paged responses.
type RegistriesListPager struct {
	client    *RegistriesClient
	current   RegistriesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegistriesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegistriesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegistriesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegistryListResult.NextLink == nil || len(*p.current.RegistryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegistriesListResponse page.
func (p *RegistriesListPager) PageResponse() RegistriesListResponse {
	return p.current
}

// RegistriesListPrivateLinkResourcesPager provides operations for iterating over paged responses.
type RegistriesListPrivateLinkResourcesPager struct {
	client    *RegistriesClient
	current   RegistriesListPrivateLinkResourcesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegistriesListPrivateLinkResourcesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegistriesListPrivateLinkResourcesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegistriesListPrivateLinkResourcesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listPrivateLinkResourcesHandleError(resp)
		return false
	}
	result, err := p.client.listPrivateLinkResourcesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegistriesListPrivateLinkResourcesResponse page.
func (p *RegistriesListPrivateLinkResourcesPager) PageResponse() RegistriesListPrivateLinkResourcesResponse {
	return p.current
}

// ReplicationsListPager provides operations for iterating over paged responses.
type ReplicationsListPager struct {
	client    *ReplicationsClient
	current   ReplicationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReplicationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReplicationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReplicationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationListResult.NextLink == nil || len(*p.current.ReplicationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReplicationsListResponse page.
func (p *ReplicationsListPager) PageResponse() ReplicationsListResponse {
	return p.current
}

// RunsListPager provides operations for iterating over paged responses.
type RunsListPager struct {
	client    *RunsClient
	current   RunsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RunsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RunsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RunsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunListResult.NextLink == nil || len(*p.current.RunListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RunsListResponse page.
func (p *RunsListPager) PageResponse() RunsListResponse {
	return p.current
}

// ScopeMapsListPager provides operations for iterating over paged responses.
type ScopeMapsListPager struct {
	client    *ScopeMapsClient
	current   ScopeMapsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ScopeMapsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ScopeMapsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ScopeMapsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScopeMapListResult.NextLink == nil || len(*p.current.ScopeMapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ScopeMapsListResponse page.
func (p *ScopeMapsListPager) PageResponse() ScopeMapsListResponse {
	return p.current
}

// TaskRunsListPager provides operations for iterating over paged responses.
type TaskRunsListPager struct {
	client    *TaskRunsClient
	current   TaskRunsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TaskRunsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TaskRunsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TaskRunsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskRunListResult.NextLink == nil || len(*p.current.TaskRunListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TaskRunsListResponse page.
func (p *TaskRunsListPager) PageResponse() TaskRunsListResponse {
	return p.current
}

// TasksListPager provides operations for iterating over paged responses.
type TasksListPager struct {
	client    *TasksClient
	current   TasksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskListResult.NextLink == nil || len(*p.current.TaskListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksListResponse page.
func (p *TasksListPager) PageResponse() TasksListResponse {
	return p.current
}

// TokensListPager provides operations for iterating over paged responses.
type TokensListPager struct {
	client    *TokensClient
	current   TokensListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TokensListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TokensListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TokensListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TokenListResult.NextLink == nil || len(*p.current.TokenListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TokensListResponse page.
func (p *TokensListPager) PageResponse() TokensListResponse {
	return p.current
}

// WebhooksListEventsPager provides operations for iterating over paged responses.
type WebhooksListEventsPager struct {
	client    *WebhooksClient
	current   WebhooksListEventsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebhooksListEventsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebhooksListEventsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebhooksListEventsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventListResult.NextLink == nil || len(*p.current.EventListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listEventsHandleError(resp)
		return false
	}
	result, err := p.client.listEventsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebhooksListEventsResponse page.
func (p *WebhooksListEventsPager) PageResponse() WebhooksListEventsResponse {
	return p.current
}

// WebhooksListPager provides operations for iterating over paged responses.
type WebhooksListPager struct {
	client    *WebhooksClient
	current   WebhooksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebhooksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebhooksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebhooksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebhookListResult.NextLink == nil || len(*p.current.WebhookListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebhooksListResponse page.
func (p *WebhooksListPager) PageResponse() WebhooksListResponse {
	return p.current
}
