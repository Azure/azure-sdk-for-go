// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armcontainerregistrytasks

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AgentPool.
func (a AgentPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentPool.
func (a *AgentPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolListResult.
func (a AgentPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentPoolListResult.
func (a *AgentPoolListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolProperties.
func (a AgentPoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", a.Count)
	populate(objectMap, "os", a.OS)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "tier", a.Tier)
	populate(objectMap, "virtualNetworkSubnetResourceId", a.VirtualNetworkSubnetResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentPoolProperties.
func (a *AgentPoolProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &a.Count)
			delete(rawMsg, key)
		case "os":
			err = unpopulate(val, "OS", &a.OS)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "tier":
			err = unpopulate(val, "Tier", &a.Tier)
			delete(rawMsg, key)
		case "virtualNetworkSubnetResourceId":
			err = unpopulate(val, "VirtualNetworkSubnetResourceID", &a.VirtualNetworkSubnetResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolPropertiesUpdateParameters.
func (a AgentPoolPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", a.Count)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentPoolPropertiesUpdateParameters.
func (a *AgentPoolPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &a.Count)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolQueueStatus.
func (a AgentPoolQueueStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", a.Count)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentPoolQueueStatus.
func (a *AgentPoolQueueStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &a.Count)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AgentPoolUpdateParameters.
func (a AgentPoolUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentPoolUpdateParameters.
func (a *AgentPoolUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AgentProperties.
func (a AgentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpu", a.CPU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentProperties.
func (a *AgentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpu":
			err = unpopulate(val, "CPU", &a.CPU)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Argument.
func (a Argument) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isSecret", a.IsSecret)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Argument.
func (a *Argument) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isSecret":
			err = unpopulate(val, "IsSecret", &a.IsSecret)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthInfo.
func (a AuthInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expiresIn", a.ExpiresIn)
	populate(objectMap, "refreshToken", a.RefreshToken)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "token", a.Token)
	populate(objectMap, "tokenType", a.TokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthInfo.
func (a *AuthInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiresIn":
			err = unpopulate(val, "ExpiresIn", &a.ExpiresIn)
			delete(rawMsg, key)
		case "refreshToken":
			err = unpopulate(val, "RefreshToken", &a.RefreshToken)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &a.Scope)
			delete(rawMsg, key)
		case "token":
			err = unpopulate(val, "Token", &a.Token)
			delete(rawMsg, key)
		case "tokenType":
			err = unpopulate(val, "TokenType", &a.TokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthInfoUpdateParameters.
func (a AuthInfoUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expiresIn", a.ExpiresIn)
	populate(objectMap, "refreshToken", a.RefreshToken)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "token", a.Token)
	populate(objectMap, "tokenType", a.TokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthInfoUpdateParameters.
func (a *AuthInfoUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiresIn":
			err = unpopulate(val, "ExpiresIn", &a.ExpiresIn)
			delete(rawMsg, key)
		case "refreshToken":
			err = unpopulate(val, "RefreshToken", &a.RefreshToken)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &a.Scope)
			delete(rawMsg, key)
		case "token":
			err = unpopulate(val, "Token", &a.Token)
			delete(rawMsg, key)
		case "tokenType":
			err = unpopulate(val, "TokenType", &a.TokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseImageDependency.
func (b BaseImageDependency) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "digest", b.Digest)
	populate(objectMap, "registry", b.Registry)
	populate(objectMap, "repository", b.Repository)
	populate(objectMap, "tag", b.Tag)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseImageDependency.
func (b *BaseImageDependency) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "digest":
			err = unpopulate(val, "Digest", &b.Digest)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "Registry", &b.Registry)
			delete(rawMsg, key)
		case "repository":
			err = unpopulate(val, "Repository", &b.Repository)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &b.Tag)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseImageTrigger.
func (b BaseImageTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageTriggerType", b.BaseImageTriggerType)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "status", b.Status)
	populate(objectMap, "updateTriggerEndpoint", b.UpdateTriggerEndpoint)
	populate(objectMap, "updateTriggerPayloadType", b.UpdateTriggerPayloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseImageTrigger.
func (b *BaseImageTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageTriggerType":
			err = unpopulate(val, "BaseImageTriggerType", &b.BaseImageTriggerType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &b.Status)
			delete(rawMsg, key)
		case "updateTriggerEndpoint":
			err = unpopulate(val, "UpdateTriggerEndpoint", &b.UpdateTriggerEndpoint)
			delete(rawMsg, key)
		case "updateTriggerPayloadType":
			err = unpopulate(val, "UpdateTriggerPayloadType", &b.UpdateTriggerPayloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseImageTriggerUpdateParameters.
func (b BaseImageTriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageTriggerType", b.BaseImageTriggerType)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "status", b.Status)
	populate(objectMap, "updateTriggerEndpoint", b.UpdateTriggerEndpoint)
	populate(objectMap, "updateTriggerPayloadType", b.UpdateTriggerPayloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseImageTriggerUpdateParameters.
func (b *BaseImageTriggerUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageTriggerType":
			err = unpopulate(val, "BaseImageTriggerType", &b.BaseImageTriggerType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &b.Status)
			delete(rawMsg, key)
		case "updateTriggerEndpoint":
			err = unpopulate(val, "UpdateTriggerEndpoint", &b.UpdateTriggerEndpoint)
			delete(rawMsg, key)
		case "updateTriggerPayloadType":
			err = unpopulate(val, "UpdateTriggerPayloadType", &b.UpdateTriggerPayloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Credentials.
func (c Credentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customRegistries", c.CustomRegistries)
	populate(objectMap, "sourceRegistry", c.SourceRegistry)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Credentials.
func (c *Credentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customRegistries":
			err = unpopulate(val, "CustomRegistries", &c.CustomRegistries)
			delete(rawMsg, key)
		case "sourceRegistry":
			err = unpopulate(val, "SourceRegistry", &c.SourceRegistry)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomRegistryCredentials.
func (c CustomRegistryCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "userName", c.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomRegistryCredentials.
func (c *CustomRegistryCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &c.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildRequest.
func (d DockerBuildRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentConfiguration", d.AgentConfiguration)
	populate(objectMap, "agentPoolName", d.AgentPoolName)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "credentials", d.Credentials)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isArchiveEnabled", d.IsArchiveEnabled)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "logTemplate", d.LogTemplate)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "platform", d.Platform)
	populate(objectMap, "sourceLocation", d.SourceLocation)
	populate(objectMap, "target", d.Target)
	populate(objectMap, "timeout", d.Timeout)
	objectMap["type"] = "DockerBuildRequest"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildRequest.
func (d *DockerBuildRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, "AgentConfiguration", &d.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &d.AgentPoolName)
			delete(rawMsg, key)
		case "arguments":
			err = unpopulate(val, "Arguments", &d.Arguments)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &d.Credentials)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, "DockerFilePath", &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, "ImageNames", &d.ImageNames)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &d.IsArchiveEnabled)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, "IsPushEnabled", &d.IsPushEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &d.LogTemplate)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, "NoCache", &d.NoCache)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &d.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, "SourceLocation", &d.SourceLocation)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &d.Target)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &d.Timeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildStep.
func (d DockerBuildStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "baseImageDependencies", d.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", d.ContextAccessToken)
	populate(objectMap, "contextPath", d.ContextPath)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "target", d.Target)
	objectMap["type"] = StepTypeDocker
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildStep.
func (d *DockerBuildStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &d.Arguments)
			delete(rawMsg, key)
		case "baseImageDependencies":
			err = unpopulate(val, "BaseImageDependencies", &d.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &d.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &d.ContextPath)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, "DockerFilePath", &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, "ImageNames", &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, "IsPushEnabled", &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, "NoCache", &d.NoCache)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &d.Target)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DockerBuildStepUpdateParameters.
func (d DockerBuildStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", d.Arguments)
	populate(objectMap, "contextAccessToken", d.ContextAccessToken)
	populate(objectMap, "contextPath", d.ContextPath)
	populate(objectMap, "dockerFilePath", d.DockerFilePath)
	populate(objectMap, "imageNames", d.ImageNames)
	populate(objectMap, "isPushEnabled", d.IsPushEnabled)
	populate(objectMap, "noCache", d.NoCache)
	populate(objectMap, "target", d.Target)
	objectMap["type"] = StepTypeDocker
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DockerBuildStepUpdateParameters.
func (d *DockerBuildStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &d.Arguments)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &d.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &d.ContextPath)
			delete(rawMsg, key)
		case "dockerFilePath":
			err = unpopulate(val, "DockerFilePath", &d.DockerFilePath)
			delete(rawMsg, key)
		case "imageNames":
			err = unpopulate(val, "ImageNames", &d.ImageNames)
			delete(rawMsg, key)
		case "isPushEnabled":
			err = unpopulate(val, "IsPushEnabled", &d.IsPushEnabled)
			delete(rawMsg, key)
		case "noCache":
			err = unpopulate(val, "NoCache", &d.NoCache)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &d.Target)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskRunRequest.
func (e EncodedTaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentConfiguration", e.AgentConfiguration)
	populate(objectMap, "agentPoolName", e.AgentPoolName)
	populate(objectMap, "credentials", e.Credentials)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	populate(objectMap, "isArchiveEnabled", e.IsArchiveEnabled)
	populate(objectMap, "logTemplate", e.LogTemplate)
	populate(objectMap, "platform", e.Platform)
	populate(objectMap, "sourceLocation", e.SourceLocation)
	populate(objectMap, "timeout", e.Timeout)
	objectMap["type"] = "EncodedTaskRunRequest"
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskRunRequest.
func (e *EncodedTaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, "AgentConfiguration", &e.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &e.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &e.Credentials)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, "EncodedTaskContent", &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, "EncodedValuesContent", &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &e.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &e.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &e.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, "SourceLocation", &e.SourceLocation)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &e.Timeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskStep.
func (e EncodedTaskStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageDependencies", e.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", e.ContextAccessToken)
	populate(objectMap, "contextPath", e.ContextPath)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	objectMap["type"] = StepTypeEncodedTask
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskStep.
func (e *EncodedTaskStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageDependencies":
			err = unpopulate(val, "BaseImageDependencies", &e.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &e.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &e.ContextPath)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, "EncodedTaskContent", &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, "EncodedValuesContent", &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncodedTaskStepUpdateParameters.
func (e EncodedTaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contextAccessToken", e.ContextAccessToken)
	populate(objectMap, "contextPath", e.ContextPath)
	populate(objectMap, "encodedTaskContent", e.EncodedTaskContent)
	populate(objectMap, "encodedValuesContent", e.EncodedValuesContent)
	objectMap["type"] = StepTypeEncodedTask
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncodedTaskStepUpdateParameters.
func (e *EncodedTaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &e.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &e.ContextPath)
			delete(rawMsg, key)
		case "encodedTaskContent":
			err = unpopulate(val, "EncodedTaskContent", &e.EncodedTaskContent)
			delete(rawMsg, key)
		case "encodedValuesContent":
			err = unpopulate(val, "EncodedValuesContent", &e.EncodedValuesContent)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskRunRequest.
func (f FileTaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentConfiguration", f.AgentConfiguration)
	populate(objectMap, "agentPoolName", f.AgentPoolName)
	populate(objectMap, "credentials", f.Credentials)
	populate(objectMap, "isArchiveEnabled", f.IsArchiveEnabled)
	populate(objectMap, "logTemplate", f.LogTemplate)
	populate(objectMap, "platform", f.Platform)
	populate(objectMap, "sourceLocation", f.SourceLocation)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	populate(objectMap, "timeout", f.Timeout)
	objectMap["type"] = "FileTaskRunRequest"
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskRunRequest.
func (f *FileTaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, "AgentConfiguration", &f.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &f.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &f.Credentials)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &f.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &f.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &f.Platform)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, "SourceLocation", &f.SourceLocation)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, "TaskFilePath", &f.TaskFilePath)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &f.Timeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, "ValuesFilePath", &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskStep.
func (f FileTaskStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageDependencies", f.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", f.ContextAccessToken)
	populate(objectMap, "contextPath", f.ContextPath)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	objectMap["type"] = StepTypeFileTask
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskStep.
func (f *FileTaskStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageDependencies":
			err = unpopulate(val, "BaseImageDependencies", &f.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &f.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &f.ContextPath)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, "TaskFilePath", &f.TaskFilePath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, "ValuesFilePath", &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileTaskStepUpdateParameters.
func (f FileTaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contextAccessToken", f.ContextAccessToken)
	populate(objectMap, "contextPath", f.ContextPath)
	populate(objectMap, "taskFilePath", f.TaskFilePath)
	objectMap["type"] = StepTypeFileTask
	populate(objectMap, "values", f.Values)
	populate(objectMap, "valuesFilePath", f.ValuesFilePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileTaskStepUpdateParameters.
func (f *FileTaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &f.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &f.ContextPath)
			delete(rawMsg, key)
		case "taskFilePath":
			err = unpopulate(val, "TaskFilePath", &f.TaskFilePath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &f.Values)
			delete(rawMsg, key)
		case "valuesFilePath":
			err = unpopulate(val, "ValuesFilePath", &f.ValuesFilePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityProperties.
func (i IdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityProperties.
func (i *IdentityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &i.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &i.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &i.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageDescriptor.
func (i ImageDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "digest", i.Digest)
	populate(objectMap, "registry", i.Registry)
	populate(objectMap, "repository", i.Repository)
	populate(objectMap, "tag", i.Tag)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageDescriptor.
func (i *ImageDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "digest":
			err = unpopulate(val, "Digest", &i.Digest)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "Registry", &i.Registry)
			delete(rawMsg, key)
		case "repository":
			err = unpopulate(val, "Repository", &i.Repository)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &i.Tag)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageUpdateTrigger.
func (i ImageUpdateTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "images", i.Images)
	populateDateTimeRFC3339(objectMap, "timestamp", i.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageUpdateTrigger.
func (i *ImageUpdateTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "images":
			err = unpopulate(val, "Images", &i.Images)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateDateTimeRFC3339(val, "Timestamp", &i.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OverrideTaskStepProperties.
func (o OverrideTaskStepProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", o.Arguments)
	populate(objectMap, "contextPath", o.ContextPath)
	populate(objectMap, "file", o.File)
	populate(objectMap, "target", o.Target)
	populate(objectMap, "updateTriggerToken", o.UpdateTriggerToken)
	populate(objectMap, "values", o.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OverrideTaskStepProperties.
func (o *OverrideTaskStepProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &o.Arguments)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &o.ContextPath)
			delete(rawMsg, key)
		case "file":
			err = unpopulate(val, "File", &o.File)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &o.Target)
			delete(rawMsg, key)
		case "updateTriggerToken":
			err = unpopulate(val, "UpdateTriggerToken", &o.UpdateTriggerToken)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &o.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformProperties.
func (p PlatformProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", p.Architecture)
	populate(objectMap, "os", p.OS)
	populate(objectMap, "variant", p.Variant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformProperties.
func (p *PlatformProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &p.Architecture)
			delete(rawMsg, key)
		case "os":
			err = unpopulate(val, "OS", &p.OS)
			delete(rawMsg, key)
		case "variant":
			err = unpopulate(val, "Variant", &p.Variant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformUpdateParameters.
func (p PlatformUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", p.Architecture)
	populate(objectMap, "os", p.OS)
	populate(objectMap, "variant", p.Variant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformUpdateParameters.
func (p *PlatformUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &p.Architecture)
			delete(rawMsg, key)
		case "os":
			err = unpopulate(val, "OS", &p.OS)
			delete(rawMsg, key)
		case "variant":
			err = unpopulate(val, "Variant", &p.Variant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Run.
func (r Run) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Run.
func (r *Run) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunGetLogResult.
func (r RunGetLogResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logArtifactLink", r.LogArtifactLink)
	populate(objectMap, "logLink", r.LogLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunGetLogResult.
func (r *RunGetLogResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logArtifactLink":
			err = unpopulate(val, "LogArtifactLink", &r.LogArtifactLink)
			delete(rawMsg, key)
		case "logLink":
			err = unpopulate(val, "LogLink", &r.LogLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunListResult.
func (r RunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunListResult.
func (r *RunListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunProperties.
func (r RunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentConfiguration", r.AgentConfiguration)
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populateDateTimeRFC3339(objectMap, "createTime", r.CreateTime)
	populate(objectMap, "customRegistries", r.CustomRegistries)
	populateDateTimeRFC3339(objectMap, "finishTime", r.FinishTime)
	populate(objectMap, "imageUpdateTrigger", r.ImageUpdateTrigger)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", r.LastUpdatedTime)
	populate(objectMap, "logArtifact", r.LogArtifact)
	populate(objectMap, "outputImages", r.OutputImages)
	populate(objectMap, "platform", r.Platform)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "runErrorMessage", r.RunErrorMessage)
	populate(objectMap, "runId", r.RunID)
	populate(objectMap, "runType", r.RunType)
	populate(objectMap, "sourceRegistryAuth", r.SourceRegistryAuth)
	populate(objectMap, "sourceTrigger", r.SourceTrigger)
	populateDateTimeRFC3339(objectMap, "startTime", r.StartTime)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "task", r.Task)
	populate(objectMap, "timerTrigger", r.TimerTrigger)
	populate(objectMap, "updateTriggerToken", r.UpdateTriggerToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunProperties.
func (r *RunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, "AgentConfiguration", &r.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &r.AgentPoolName)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateDateTimeRFC3339(val, "CreateTime", &r.CreateTime)
			delete(rawMsg, key)
		case "customRegistries":
			err = unpopulate(val, "CustomRegistries", &r.CustomRegistries)
			delete(rawMsg, key)
		case "finishTime":
			err = unpopulateDateTimeRFC3339(val, "FinishTime", &r.FinishTime)
			delete(rawMsg, key)
		case "imageUpdateTrigger":
			err = unpopulate(val, "ImageUpdateTrigger", &r.ImageUpdateTrigger)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &r.LastUpdatedTime)
			delete(rawMsg, key)
		case "logArtifact":
			err = unpopulate(val, "LogArtifact", &r.LogArtifact)
			delete(rawMsg, key)
		case "outputImages":
			err = unpopulate(val, "OutputImages", &r.OutputImages)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &r.Platform)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &r.ProvisioningState)
			delete(rawMsg, key)
		case "runErrorMessage":
			err = unpopulate(val, "RunErrorMessage", &r.RunErrorMessage)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, "RunID", &r.RunID)
			delete(rawMsg, key)
		case "runType":
			err = unpopulate(val, "RunType", &r.RunType)
			delete(rawMsg, key)
		case "sourceRegistryAuth":
			err = unpopulate(val, "SourceRegistryAuth", &r.SourceRegistryAuth)
			delete(rawMsg, key)
		case "sourceTrigger":
			err = unpopulate(val, "SourceTrigger", &r.SourceTrigger)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &r.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &r.Status)
			delete(rawMsg, key)
		case "task":
			err = unpopulate(val, "Task", &r.Task)
			delete(rawMsg, key)
		case "timerTrigger":
			err = unpopulate(val, "TimerTrigger", &r.TimerTrigger)
			delete(rawMsg, key)
		case "updateTriggerToken":
			err = unpopulate(val, "UpdateTriggerToken", &r.UpdateTriggerToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunRequest.
func (r RunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentPoolName", r.AgentPoolName)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	populate(objectMap, "logTemplate", r.LogTemplate)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunRequest.
func (r *RunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &r.AgentPoolName)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &r.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &r.LogTemplate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunUpdateParameters.
func (r RunUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isArchiveEnabled", r.IsArchiveEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunUpdateParameters.
func (r *RunUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &r.IsArchiveEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretObject.
func (s SecretObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretObject.
func (s *SecretObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SetValue.
func (s SetValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isSecret", s.IsSecret)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SetValue.
func (s *SetValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isSecret":
			err = unpopulate(val, "IsSecret", &s.IsSecret)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceProperties.
func (s SourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "branch", s.Branch)
	populate(objectMap, "repositoryUrl", s.RepositoryURL)
	populate(objectMap, "sourceControlAuthProperties", s.SourceControlAuthProperties)
	populate(objectMap, "sourceControlType", s.SourceControlType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceProperties.
func (s *SourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "branch":
			err = unpopulate(val, "Branch", &s.Branch)
			delete(rawMsg, key)
		case "repositoryUrl":
			err = unpopulate(val, "RepositoryURL", &s.RepositoryURL)
			delete(rawMsg, key)
		case "sourceControlAuthProperties":
			err = unpopulate(val, "SourceControlAuthProperties", &s.SourceControlAuthProperties)
			delete(rawMsg, key)
		case "sourceControlType":
			err = unpopulate(val, "SourceControlType", &s.SourceControlType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceRegistryCredentials.
func (s SourceRegistryCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "loginMode", s.LoginMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceRegistryCredentials.
func (s *SourceRegistryCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &s.Identity)
			delete(rawMsg, key)
		case "loginMode":
			err = unpopulate(val, "LoginMode", &s.LoginMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceTrigger.
func (s SourceTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sourceRepository", s.SourceRepository)
	populate(objectMap, "sourceTriggerEvents", s.SourceTriggerEvents)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceTrigger.
func (s *SourceTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "sourceRepository":
			err = unpopulate(val, "SourceRepository", &s.SourceRepository)
			delete(rawMsg, key)
		case "sourceTriggerEvents":
			err = unpopulate(val, "SourceTriggerEvents", &s.SourceTriggerEvents)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceTriggerDescriptor.
func (s SourceTriggerDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "branchName", s.BranchName)
	populate(objectMap, "commitId", s.CommitID)
	populate(objectMap, "eventType", s.EventType)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "providerType", s.ProviderType)
	populate(objectMap, "pullRequestId", s.PullRequestID)
	populate(objectMap, "repositoryUrl", s.RepositoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceTriggerDescriptor.
func (s *SourceTriggerDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "branchName":
			err = unpopulate(val, "BranchName", &s.BranchName)
			delete(rawMsg, key)
		case "commitId":
			err = unpopulate(val, "CommitID", &s.CommitID)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, "EventType", &s.EventType)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "providerType":
			err = unpopulate(val, "ProviderType", &s.ProviderType)
			delete(rawMsg, key)
		case "pullRequestId":
			err = unpopulate(val, "PullRequestID", &s.PullRequestID)
			delete(rawMsg, key)
		case "repositoryUrl":
			err = unpopulate(val, "RepositoryURL", &s.RepositoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceTriggerUpdateParameters.
func (s SourceTriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sourceRepository", s.SourceRepository)
	populate(objectMap, "sourceTriggerEvents", s.SourceTriggerEvents)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceTriggerUpdateParameters.
func (s *SourceTriggerUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "sourceRepository":
			err = unpopulate(val, "SourceRepository", &s.SourceRepository)
			delete(rawMsg, key)
		case "sourceTriggerEvents":
			err = unpopulate(val, "SourceTriggerEvents", &s.SourceTriggerEvents)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceUpdateParameters.
func (s SourceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "branch", s.Branch)
	populate(objectMap, "repositoryUrl", s.RepositoryURL)
	populate(objectMap, "sourceControlAuthProperties", s.SourceControlAuthProperties)
	populate(objectMap, "sourceControlType", s.SourceControlType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceUpdateParameters.
func (s *SourceUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "branch":
			err = unpopulate(val, "Branch", &s.Branch)
			delete(rawMsg, key)
		case "repositoryUrl":
			err = unpopulate(val, "RepositoryURL", &s.RepositoryURL)
			delete(rawMsg, key)
		case "sourceControlAuthProperties":
			err = unpopulate(val, "SourceControlAuthProperties", &s.SourceControlAuthProperties)
			delete(rawMsg, key)
		case "sourceControlType":
			err = unpopulate(val, "SourceControlType", &s.SourceControlType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SourceUploadDefinition.
func (s SourceUploadDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "relativePath", s.RelativePath)
	populate(objectMap, "uploadUrl", s.UploadURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SourceUploadDefinition.
func (s *SourceUploadDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "relativePath":
			err = unpopulate(val, "RelativePath", &s.RelativePath)
			delete(rawMsg, key)
		case "uploadUrl":
			err = unpopulate(val, "UploadURL", &s.UploadURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Task.
func (t Task) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Task.
func (t *Task) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &t.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskListResult.
func (t TaskListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskListResult.
func (t *TaskListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskProperties.
func (t TaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentConfiguration", t.AgentConfiguration)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populateDateTimeRFC3339(objectMap, "creationDate", t.CreationDate)
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "isSystemTask", t.IsSystemTask)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "platform", t.Platform)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "step", t.Step)
	populate(objectMap, "timeout", t.Timeout)
	populate(objectMap, "trigger", t.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskProperties.
func (t *TaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, "AgentConfiguration", &t.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &t.AgentPoolName)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateDateTimeRFC3339(val, "CreationDate", &t.CreationDate)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &t.Credentials)
			delete(rawMsg, key)
		case "isSystemTask":
			err = unpopulate(val, "IsSystemTask", &t.IsSystemTask)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &t.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &t.Platform)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &t.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		case "step":
			t.Step, err = unmarshalTaskStepPropertiesClassification(val)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &t.Timeout)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, "Trigger", &t.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskPropertiesUpdateParameters.
func (t TaskPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentConfiguration", t.AgentConfiguration)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populate(objectMap, "credentials", t.Credentials)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "platform", t.Platform)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "step", t.Step)
	populate(objectMap, "timeout", t.Timeout)
	populate(objectMap, "trigger", t.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskPropertiesUpdateParameters.
func (t *TaskPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentConfiguration":
			err = unpopulate(val, "AgentConfiguration", &t.AgentConfiguration)
			delete(rawMsg, key)
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &t.AgentPoolName)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &t.Credentials)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &t.LogTemplate)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &t.Platform)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		case "step":
			t.Step, err = unmarshalTaskStepUpdateParametersClassification(val)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &t.Timeout)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, "Trigger", &t.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRun.
func (t TaskRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRun.
func (t *TaskRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &t.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunListResult.
func (t TaskRunListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunListResult.
func (t *TaskRunListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunProperties.
func (t TaskRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "forceUpdateTag", t.ForceUpdateTag)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "runRequest", t.RunRequest)
	populate(objectMap, "runResult", t.RunResult)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunProperties.
func (t *TaskRunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceUpdateTag":
			err = unpopulate(val, "ForceUpdateTag", &t.ForceUpdateTag)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &t.ProvisioningState)
			delete(rawMsg, key)
		case "runRequest":
			t.RunRequest, err = unmarshalRunRequestClassification(val)
			delete(rawMsg, key)
		case "runResult":
			err = unpopulate(val, "RunResult", &t.RunResult)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunPropertiesUpdateParameters.
func (t TaskRunPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "forceUpdateTag", t.ForceUpdateTag)
	populate(objectMap, "runRequest", t.RunRequest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunPropertiesUpdateParameters.
func (t *TaskRunPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceUpdateTag":
			err = unpopulate(val, "ForceUpdateTag", &t.ForceUpdateTag)
			delete(rawMsg, key)
		case "runRequest":
			t.RunRequest, err = unmarshalRunRequestClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunRequest.
func (t TaskRunRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentPoolName", t.AgentPoolName)
	populate(objectMap, "isArchiveEnabled", t.IsArchiveEnabled)
	populate(objectMap, "logTemplate", t.LogTemplate)
	populate(objectMap, "overrideTaskStepProperties", t.OverrideTaskStepProperties)
	populate(objectMap, "taskId", t.TaskID)
	objectMap["type"] = "TaskRunRequest"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunRequest.
func (t *TaskRunRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentPoolName":
			err = unpopulate(val, "AgentPoolName", &t.AgentPoolName)
			delete(rawMsg, key)
		case "isArchiveEnabled":
			err = unpopulate(val, "IsArchiveEnabled", &t.IsArchiveEnabled)
			delete(rawMsg, key)
		case "logTemplate":
			err = unpopulate(val, "LogTemplate", &t.LogTemplate)
			delete(rawMsg, key)
		case "overrideTaskStepProperties":
			err = unpopulate(val, "OverrideTaskStepProperties", &t.OverrideTaskStepProperties)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &t.TaskID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskRunUpdateParameters.
func (t TaskRunUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskRunUpdateParameters.
func (t *TaskRunUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &t.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskStepProperties.
func (t TaskStepProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageDependencies", t.BaseImageDependencies)
	populate(objectMap, "contextAccessToken", t.ContextAccessToken)
	populate(objectMap, "contextPath", t.ContextPath)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskStepProperties.
func (t *TaskStepProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageDependencies":
			err = unpopulate(val, "BaseImageDependencies", &t.BaseImageDependencies)
			delete(rawMsg, key)
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &t.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &t.ContextPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskStepUpdateParameters.
func (t TaskStepUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contextAccessToken", t.ContextAccessToken)
	populate(objectMap, "contextPath", t.ContextPath)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskStepUpdateParameters.
func (t *TaskStepUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextAccessToken":
			err = unpopulate(val, "ContextAccessToken", &t.ContextAccessToken)
			delete(rawMsg, key)
		case "contextPath":
			err = unpopulate(val, "ContextPath", &t.ContextPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskUpdateParameters.
func (t TaskUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskUpdateParameters.
func (t *TaskUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &t.Identity)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimerTrigger.
func (t TimerTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "schedule", t.Schedule)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimerTrigger.
func (t *TimerTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, "Schedule", &t.Schedule)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimerTriggerDescriptor.
func (t TimerTriggerDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scheduleOccurrence", t.ScheduleOccurrence)
	populate(objectMap, "timerTriggerName", t.TimerTriggerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimerTriggerDescriptor.
func (t *TimerTriggerDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scheduleOccurrence":
			err = unpopulate(val, "ScheduleOccurrence", &t.ScheduleOccurrence)
			delete(rawMsg, key)
		case "timerTriggerName":
			err = unpopulate(val, "TimerTriggerName", &t.TimerTriggerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimerTriggerUpdateParameters.
func (t TimerTriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "schedule", t.Schedule)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimerTriggerUpdateParameters.
func (t *TimerTriggerUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, "Schedule", &t.Schedule)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerProperties.
func (t TriggerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageTrigger", t.BaseImageTrigger)
	populate(objectMap, "sourceTriggers", t.SourceTriggers)
	populate(objectMap, "timerTriggers", t.TimerTriggers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerProperties.
func (t *TriggerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageTrigger":
			err = unpopulate(val, "BaseImageTrigger", &t.BaseImageTrigger)
			delete(rawMsg, key)
		case "sourceTriggers":
			err = unpopulate(val, "SourceTriggers", &t.SourceTriggers)
			delete(rawMsg, key)
		case "timerTriggers":
			err = unpopulate(val, "TimerTriggers", &t.TimerTriggers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerUpdateParameters.
func (t TriggerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseImageTrigger", t.BaseImageTrigger)
	populate(objectMap, "sourceTriggers", t.SourceTriggers)
	populate(objectMap, "timerTriggers", t.TimerTriggers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerUpdateParameters.
func (t *TriggerUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseImageTrigger":
			err = unpopulate(val, "BaseImageTrigger", &t.BaseImageTrigger)
			delete(rawMsg, key)
		case "sourceTriggers":
			err = unpopulate(val, "SourceTriggers", &t.SourceTriggers)
			delete(rawMsg, key)
		case "timerTriggers":
			err = unpopulate(val, "TimerTriggers", &t.TimerTriggers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserIdentityProperties.
func (u UserIdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserIdentityProperties.
func (u *UserIdentityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
