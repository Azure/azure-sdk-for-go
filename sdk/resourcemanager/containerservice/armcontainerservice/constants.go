// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerservice

// AccelerationMode - Enable advanced network acceleration options. This allows users to configure acceleration using BPF
// host routing. This can be enabled only with Cilium dataplane. If not specified, the default value is
// None (no acceleration). The acceleration mode can be changed on a pre-existing cluster. See https://aka.ms/acnsperformance
// for a detailed explanation
type AccelerationMode string

const (
	// AccelerationModeBpfVeth - Enable eBPF host routing with veth device mode.
	AccelerationModeBpfVeth AccelerationMode = "BpfVeth"
	// AccelerationModeNone - Disable acceleration options.
	AccelerationModeNone AccelerationMode = "None"
)

// PossibleAccelerationModeValues returns the possible values for the AccelerationMode const type.
func PossibleAccelerationModeValues() []AccelerationMode {
	return []AccelerationMode{
		AccelerationModeBpfVeth,
		AccelerationModeNone,
	}
}

// AddonAutoscaling - Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.
type AddonAutoscaling string

const (
	// AddonAutoscalingDisabled - Feature to autoscale AKS-managed add-ons is disabled.
	AddonAutoscalingDisabled AddonAutoscaling = "Disabled"
	// AddonAutoscalingEnabled - Feature to autoscale AKS-managed add-ons is enabled. The default VPA update mode is Initial mode.
	AddonAutoscalingEnabled AddonAutoscaling = "Enabled"
)

// PossibleAddonAutoscalingValues returns the possible values for the AddonAutoscaling const type.
func PossibleAddonAutoscalingValues() []AddonAutoscaling {
	return []AddonAutoscaling{
		AddonAutoscalingDisabled,
		AddonAutoscalingEnabled,
	}
}

// AdoptionPolicy - Action if Kubernetes namespace with same name already exists.
type AdoptionPolicy string

const (
	// AdoptionPolicyAlways - Always take over the existing namespace to be managed by ARM, some fields might be overwritten.
	AdoptionPolicyAlways AdoptionPolicy = "Always"
	// AdoptionPolicyIfIdentical - Take over the existing namespace to be managed by ARM, if there is no difference.
	AdoptionPolicyIfIdentical AdoptionPolicy = "IfIdentical"
	// AdoptionPolicyNever - If the namespace already exists in Kubernetes, attempts to create that same namespace in ARM will
	// fail.
	AdoptionPolicyNever AdoptionPolicy = "Never"
)

// PossibleAdoptionPolicyValues returns the possible values for the AdoptionPolicy const type.
func PossibleAdoptionPolicyValues() []AdoptionPolicy {
	return []AdoptionPolicy{
		AdoptionPolicyAlways,
		AdoptionPolicyIfIdentical,
		AdoptionPolicyNever,
	}
}

// AdvancedNetworkPolicies - Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN,
// HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see
// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
// specified, the default value is FQDN if security.enabled is set to true.
type AdvancedNetworkPolicies string

const (
	// AdvancedNetworkPoliciesFQDN - Enable FQDN based network policies
	AdvancedNetworkPoliciesFQDN AdvancedNetworkPolicies = "FQDN"
	// AdvancedNetworkPoliciesL7 - Enable Layer7 network policies (FQDN, HTTP/S, Kafka). This option is a superset of the FQDN
	// option.
	AdvancedNetworkPoliciesL7 AdvancedNetworkPolicies = "L7"
	// AdvancedNetworkPoliciesNone - Disable Layer 7 network policies (FQDN, HTTP/S, Kafka)
	AdvancedNetworkPoliciesNone AdvancedNetworkPolicies = "None"
)

// PossibleAdvancedNetworkPoliciesValues returns the possible values for the AdvancedNetworkPolicies const type.
func PossibleAdvancedNetworkPoliciesValues() []AdvancedNetworkPolicies {
	return []AdvancedNetworkPolicies{
		AdvancedNetworkPoliciesFQDN,
		AdvancedNetworkPoliciesL7,
		AdvancedNetworkPoliciesNone,
	}
}

// AgentPoolMode - The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional
// information on agent pool restrictions and best practices, see:
// https://docs.microsoft.com/azure/aks/use-system-pools
type AgentPoolMode string

const (
	// AgentPoolModeGateway - Gateway agent pools are dedicated to providing static egress IPs to pods. For more details, see
	// https://aka.ms/aks/static-egress-gateway.
	AgentPoolModeGateway AgentPoolMode = "Gateway"
	// AgentPoolModeMachines - Machines agent pools are dedicated to hosting machines. Only limited operations, such as creation
	// and deletion, are allowed at the pool level. Please use the machine APIs to manage the full machine lifecycle.
	AgentPoolModeMachines AgentPoolMode = "Machines"
	// AgentPoolModeManagedSystem - ManagedSystem is a system pool managed by AKS. The pool scales dynamically according to cluster
	// usage, and has additional automated monitoring and healing capabilities. There can only be one ManagedSystem pool, and
	// it is recommended to delete all other system pools for the best experience.
	AgentPoolModeManagedSystem AgentPoolMode = "ManagedSystem"
	// AgentPoolModeSystem - System agent pools are primarily for hosting critical system pods such as CoreDNS and metrics-server.
	// System agent pools osType must be Linux. System agent pools VM SKU must have at least 2vCPUs and 4GB of memory.
	AgentPoolModeSystem AgentPoolMode = "System"
	// AgentPoolModeUser - User agent pools are primarily for hosting your application pods.
	AgentPoolModeUser AgentPoolMode = "User"
)

// PossibleAgentPoolModeValues returns the possible values for the AgentPoolMode const type.
func PossibleAgentPoolModeValues() []AgentPoolMode {
	return []AgentPoolMode{
		AgentPoolModeGateway,
		AgentPoolModeMachines,
		AgentPoolModeManagedSystem,
		AgentPoolModeSystem,
		AgentPoolModeUser,
	}
}

// AgentPoolSSHAccess - SSH access method of an agent pool.
type AgentPoolSSHAccess string

const (
	// AgentPoolSSHAccessDisabled - SSH service will be turned off on the node. More information can be found under https://aka.ms/aks/ssh/disable
	AgentPoolSSHAccessDisabled AgentPoolSSHAccess = "Disabled"
	// AgentPoolSSHAccessEntraID - SSH to node with EntraId integration. More information can be found under https://aka.ms/aks/ssh/aad
	AgentPoolSSHAccessEntraID AgentPoolSSHAccess = "EntraId"
	// AgentPoolSSHAccessLocalUser - Can SSH onto the node as a local user using private key.
	AgentPoolSSHAccessLocalUser AgentPoolSSHAccess = "LocalUser"
)

// PossibleAgentPoolSSHAccessValues returns the possible values for the AgentPoolSSHAccess const type.
func PossibleAgentPoolSSHAccessValues() []AgentPoolSSHAccess {
	return []AgentPoolSSHAccess{
		AgentPoolSSHAccessDisabled,
		AgentPoolSSHAccessEntraID,
		AgentPoolSSHAccessLocalUser,
	}
}

// AgentPoolType - The type of Agent Pool.
type AgentPoolType string

const (
	// AgentPoolTypeAvailabilitySet - Use of this is strongly discouraged.
	AgentPoolTypeAvailabilitySet AgentPoolType = "AvailabilitySet"
	// AgentPoolTypeVirtualMachineScaleSets - Create an Agent Pool backed by a Virtual Machine Scale Set.
	AgentPoolTypeVirtualMachineScaleSets AgentPoolType = "VirtualMachineScaleSets"
	// AgentPoolTypeVirtualMachines - Create an Agent Pool backed by a Single Instance VM orchestration mode.
	AgentPoolTypeVirtualMachines AgentPoolType = "VirtualMachines"
)

// PossibleAgentPoolTypeValues returns the possible values for the AgentPoolType const type.
func PossibleAgentPoolTypeValues() []AgentPoolType {
	return []AgentPoolType{
		AgentPoolTypeAvailabilitySet,
		AgentPoolTypeVirtualMachineScaleSets,
		AgentPoolTypeVirtualMachines,
	}
}

// ArtifactSource - The artifact source. The source where the artifacts are downloaded from.
type ArtifactSource string

const (
	// ArtifactSourceCache - pull images from Azure Container Registry with cache
	ArtifactSourceCache ArtifactSource = "Cache"
	// ArtifactSourceDirect - pull images from Microsoft Artifact Registry
	ArtifactSourceDirect ArtifactSource = "Direct"
)

// PossibleArtifactSourceValues returns the possible values for the ArtifactSource const type.
func PossibleArtifactSourceValues() []ArtifactSource {
	return []ArtifactSource{
		ArtifactSourceCache,
		ArtifactSourceDirect,
	}
}

// BackendPoolType - The type of the managed inbound Load Balancer BackendPool.
type BackendPoolType string

const (
	// BackendPoolTypeNodeIP - The type of the managed inbound Load Balancer BackendPool. https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#configure-load-balancer-backend.
	BackendPoolTypeNodeIP BackendPoolType = "NodeIP"
	// BackendPoolTypeNodeIPConfiguration - The type of the managed inbound Load Balancer BackendPool. https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#configure-load-balancer-backend.
	BackendPoolTypeNodeIPConfiguration BackendPoolType = "NodeIPConfiguration"
)

// PossibleBackendPoolTypeValues returns the possible values for the BackendPoolType const type.
func PossibleBackendPoolTypeValues() []BackendPoolType {
	return []BackendPoolType{
		BackendPoolTypeNodeIP,
		BackendPoolTypeNodeIPConfiguration,
	}
}

// ClusterServiceLoadBalancerHealthProbeMode - The health probing behavior for External Traffic Policy Cluster services.
type ClusterServiceLoadBalancerHealthProbeMode string

const (
	// ClusterServiceLoadBalancerHealthProbeModeServiceNodePort - Each External Traffic Policy Cluster service will have its own
	// health probe targeting service nodePort.
	ClusterServiceLoadBalancerHealthProbeModeServiceNodePort ClusterServiceLoadBalancerHealthProbeMode = "ServiceNodePort"
	// ClusterServiceLoadBalancerHealthProbeModeShared - All External Traffic Policy Cluster services in a Standard Load Balancer
	// will have a dedicated health probe targeting the backend nodes' kube-proxy health check port 10256.
	ClusterServiceLoadBalancerHealthProbeModeShared ClusterServiceLoadBalancerHealthProbeMode = "Shared"
)

// PossibleClusterServiceLoadBalancerHealthProbeModeValues returns the possible values for the ClusterServiceLoadBalancerHealthProbeMode const type.
func PossibleClusterServiceLoadBalancerHealthProbeModeValues() []ClusterServiceLoadBalancerHealthProbeMode {
	return []ClusterServiceLoadBalancerHealthProbeMode{
		ClusterServiceLoadBalancerHealthProbeModeServiceNodePort,
		ClusterServiceLoadBalancerHealthProbeModeShared,
	}
}

// Code - Tells whether the cluster is Running or Stopped
type Code string

const (
	// CodeRunning - The cluster is running.
	CodeRunning Code = "Running"
	// CodeStopped - The cluster is stopped.
	CodeStopped Code = "Stopped"
)

// PossibleCodeValues returns the possible values for the Code const type.
func PossibleCodeValues() []Code {
	return []Code{
		CodeRunning,
		CodeStopped,
	}
}

// ConnectionStatus - The private link service connection status.
type ConnectionStatus string

const (
	ConnectionStatusApproved     ConnectionStatus = "Approved"
	ConnectionStatusDisconnected ConnectionStatus = "Disconnected"
	ConnectionStatusPending      ConnectionStatus = "Pending"
	ConnectionStatusRejected     ConnectionStatus = "Rejected"
)

// PossibleConnectionStatusValues returns the possible values for the ConnectionStatus const type.
func PossibleConnectionStatusValues() []ConnectionStatus {
	return []ConnectionStatus{
		ConnectionStatusApproved,
		ConnectionStatusDisconnected,
		ConnectionStatusPending,
		ConnectionStatusRejected,
	}
}

// CreatedByType - The type of identity that created the resource.
type CreatedByType string

const (
	CreatedByTypeApplication     CreatedByType = "Application"
	CreatedByTypeKey             CreatedByType = "Key"
	CreatedByTypeManagedIdentity CreatedByType = "ManagedIdentity"
	CreatedByTypeUser            CreatedByType = "User"
)

// PossibleCreatedByTypeValues returns the possible values for the CreatedByType const type.
func PossibleCreatedByTypeValues() []CreatedByType {
	return []CreatedByType{
		CreatedByTypeApplication,
		CreatedByTypeKey,
		CreatedByTypeManagedIdentity,
		CreatedByTypeUser,
	}
}

// DeletePolicy - Delete options of a namespace.
type DeletePolicy string

const (
	// DeletePolicyDelete - Delete both the ARM resource and the Kubernetes namespace together.
	DeletePolicyDelete DeletePolicy = "Delete"
	// DeletePolicyKeep - Only delete the ARM resource, keep the Kubernetes namespace. Also delete the ManagedByARM label.
	DeletePolicyKeep DeletePolicy = "Keep"
)

// PossibleDeletePolicyValues returns the possible values for the DeletePolicy const type.
func PossibleDeletePolicyValues() []DeletePolicy {
	return []DeletePolicy{
		DeletePolicyDelete,
		DeletePolicyKeep,
	}
}

// DriftAction - The drift action of the machine. Indicates whether a machine has deviated from its expected state due to
// changes in managed cluster properties, requiring corrective action.
type DriftAction string

const (
	// DriftActionRecreate - The machine has drifted and needs to be deleted and recreated.
	DriftActionRecreate DriftAction = "Recreate"
	// DriftActionSynced - The machine is up to date.
	DriftActionSynced DriftAction = "Synced"
)

// PossibleDriftActionValues returns the possible values for the DriftAction const type.
func PossibleDriftActionValues() []DriftAction {
	return []DriftAction{
		DriftActionRecreate,
		DriftActionSynced,
	}
}

// DriverType - Specify the type of GPU driver to install when creating Windows agent pools. If not provided, AKS selects
// the driver based on system compatibility. This cannot be changed once the AgentPool has been
// created. This cannot be set on Linux AgentPools. For Linux AgentPools, the driver is selected based on system compatibility.
type DriverType string

const (
	// DriverTypeCUDA - Install the CUDA driver for the GPU, optimized for computational tasks in scientific computing and data-intensive
	// applications.
	DriverTypeCUDA DriverType = "CUDA"
	// DriverTypeGRID - Install the GRID driver for the GPU, suitable for applications requiring virtualization support.
	DriverTypeGRID DriverType = "GRID"
)

// PossibleDriverTypeValues returns the possible values for the DriverType const type.
func PossibleDriverTypeValues() []DriverType {
	return []DriverType{
		DriverTypeCUDA,
		DriverTypeGRID,
	}
}

// Expander - The expander to use when scaling up. If not specified, the default is 'random'. See expanders [https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders]
// for
// more information.
type Expander string

const (
	// ExpanderLeastWaste - Selects the node group that will have the least idle CPU (if tied, unused memory) after scale-up.
	// This is useful when you have different classes of nodes, for example, high CPU or high memory nodes, and only want to expand
	// those when there are pending pods that need a lot of those resources.
	ExpanderLeastWaste Expander = "least-waste"
	// ExpanderMostPods - Selects the node group that would be able to schedule the most pods when scaling up. This is useful
	// when you are using nodeSelector to make sure certain pods land on certain nodes. Note that this won't cause the autoscaler
	// to select bigger nodes vs. smaller, as it can add multiple smaller nodes at once.
	ExpanderMostPods Expander = "most-pods"
	// ExpanderPriority - Selects the node group that has the highest priority assigned by the user. It's configuration is described
	// in more details [here](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md).
	ExpanderPriority Expander = "priority"
	// ExpanderRandom - Used when you don't have a particular need for the node groups to scale differently.
	ExpanderRandom Expander = "random"
)

// PossibleExpanderValues returns the possible values for the Expander const type.
func PossibleExpanderValues() []Expander {
	return []Expander{
		ExpanderLeastWaste,
		ExpanderMostPods,
		ExpanderPriority,
		ExpanderRandom,
	}
}

// ExtendedLocationTypes - The type of extendedLocation.
type ExtendedLocationTypes string

const (
	ExtendedLocationTypesEdgeZone ExtendedLocationTypes = "EdgeZone"
)

// PossibleExtendedLocationTypesValues returns the possible values for the ExtendedLocationTypes const type.
func PossibleExtendedLocationTypesValues() []ExtendedLocationTypes {
	return []ExtendedLocationTypes{
		ExtendedLocationTypesEdgeZone,
	}
}

type Format string

const (
	// FormatAzure - Return azure auth-provider kubeconfig. This format is deprecated in v1.22 and will be fully removed in v1.26.
	// See: https://aka.ms/k8s/changes-1-26.
	FormatAzure Format = "azure"
	// FormatExec - Return exec format kubeconfig. This format requires kubelogin binary in the path.
	FormatExec Format = "exec"
)

// PossibleFormatValues returns the possible values for the Format const type.
func PossibleFormatValues() []Format {
	return []Format{
		FormatAzure,
		FormatExec,
	}
}

// GPUDriver - Whether to install GPU drivers. When it's not specified, default is Install.
type GPUDriver string

const (
	// GPUDriverInstall - Install driver.
	GPUDriverInstall GPUDriver = "Install"
	// GPUDriverNone - Skip driver install.
	GPUDriverNone GPUDriver = "None"
)

// PossibleGPUDriverValues returns the possible values for the GPUDriver const type.
func PossibleGPUDriverValues() []GPUDriver {
	return []GPUDriver{
		GPUDriverInstall,
		GPUDriverNone,
	}
}

// GPUInstanceProfile - GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
type GPUInstanceProfile string

const (
	GPUInstanceProfileMIG1G GPUInstanceProfile = "MIG1g"
	GPUInstanceProfileMIG2G GPUInstanceProfile = "MIG2g"
	GPUInstanceProfileMIG3G GPUInstanceProfile = "MIG3g"
	GPUInstanceProfileMIG4G GPUInstanceProfile = "MIG4g"
	GPUInstanceProfileMIG7G GPUInstanceProfile = "MIG7g"
)

// PossibleGPUInstanceProfileValues returns the possible values for the GPUInstanceProfile const type.
func PossibleGPUInstanceProfileValues() []GPUInstanceProfile {
	return []GPUInstanceProfile{
		GPUInstanceProfileMIG1G,
		GPUInstanceProfileMIG2G,
		GPUInstanceProfileMIG3G,
		GPUInstanceProfileMIG4G,
		GPUInstanceProfileMIG7G,
	}
}

// GuardrailsSupport - Whether the version is preview or stable.
type GuardrailsSupport string

const (
	// GuardrailsSupportPreview - The version is preview. It is not recommended to use preview versions on critical production
	// clusters. The preview version may not support all use-cases.
	GuardrailsSupportPreview GuardrailsSupport = "Preview"
	// GuardrailsSupportStable - The version is stable and can be used on critical production clusters.
	GuardrailsSupportStable GuardrailsSupport = "Stable"
)

// PossibleGuardrailsSupportValues returns the possible values for the GuardrailsSupport const type.
func PossibleGuardrailsSupportValues() []GuardrailsSupport {
	return []GuardrailsSupport{
		GuardrailsSupportPreview,
		GuardrailsSupportStable,
	}
}

// IPFamily - To determine if address belongs IPv4 or IPv6 family
type IPFamily string

const (
	// IPFamilyIPv4 - IPv4 family
	IPFamilyIPv4 IPFamily = "IPv4"
	// IPFamilyIPv6 - IPv6 family
	IPFamilyIPv6 IPFamily = "IPv6"
)

// PossibleIPFamilyValues returns the possible values for the IPFamily const type.
func PossibleIPFamilyValues() []IPFamily {
	return []IPFamily{
		IPFamilyIPv4,
		IPFamilyIPv6,
	}
}

// IdentityBindingProvisioningState - The provisioning state of the last accepted operation.
type IdentityBindingProvisioningState string

const (
	// IdentityBindingProvisioningStateCanceled - Resource creation was canceled.
	IdentityBindingProvisioningStateCanceled IdentityBindingProvisioningState = "Canceled"
	// IdentityBindingProvisioningStateCreating - The identity binding is being created.
	IdentityBindingProvisioningStateCreating IdentityBindingProvisioningState = "Creating"
	// IdentityBindingProvisioningStateDeleting - The identity binding is being deleted.
	IdentityBindingProvisioningStateDeleting IdentityBindingProvisioningState = "Deleting"
	// IdentityBindingProvisioningStateFailed - Resource creation failed.
	IdentityBindingProvisioningStateFailed IdentityBindingProvisioningState = "Failed"
	// IdentityBindingProvisioningStateSucceeded - Resource has been created.
	IdentityBindingProvisioningStateSucceeded IdentityBindingProvisioningState = "Succeeded"
	// IdentityBindingProvisioningStateUpdating - The identity binding is being updated.
	IdentityBindingProvisioningStateUpdating IdentityBindingProvisioningState = "Updating"
)

// PossibleIdentityBindingProvisioningStateValues returns the possible values for the IdentityBindingProvisioningState const type.
func PossibleIdentityBindingProvisioningStateValues() []IdentityBindingProvisioningState {
	return []IdentityBindingProvisioningState{
		IdentityBindingProvisioningStateCanceled,
		IdentityBindingProvisioningStateCreating,
		IdentityBindingProvisioningStateDeleting,
		IdentityBindingProvisioningStateFailed,
		IdentityBindingProvisioningStateSucceeded,
		IdentityBindingProvisioningStateUpdating,
	}
}

// InfrastructureEncryption - Whether to enable encryption at rest of Kubernetes resource objects using service-managed keys.
// More information on this can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption.
type InfrastructureEncryption string

const (
	// InfrastructureEncryptionDisabled - Encryption at rest of Kubernetes resource objects using service-managed keys is disabled.
	// More information on this can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption.
	InfrastructureEncryptionDisabled InfrastructureEncryption = "Disabled"
	// InfrastructureEncryptionEnabled - Encryption at rest of Kubernetes resource objects using service-managed keys is enabled.
	// More information on this can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption.
	InfrastructureEncryptionEnabled InfrastructureEncryption = "Enabled"
)

// PossibleInfrastructureEncryptionValues returns the possible values for the InfrastructureEncryption const type.
func PossibleInfrastructureEncryptionValues() []InfrastructureEncryption {
	return []InfrastructureEncryption{
		InfrastructureEncryptionDisabled,
		InfrastructureEncryptionEnabled,
	}
}

// IpvsScheduler - IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
type IpvsScheduler string

const (
	// IpvsSchedulerLeastConnection - Least Connection
	IpvsSchedulerLeastConnection IpvsScheduler = "LeastConnection"
	// IpvsSchedulerRoundRobin - Round Robin
	IpvsSchedulerRoundRobin IpvsScheduler = "RoundRobin"
)

// PossibleIpvsSchedulerValues returns the possible values for the IpvsScheduler const type.
func PossibleIpvsSchedulerValues() []IpvsScheduler {
	return []IpvsScheduler{
		IpvsSchedulerLeastConnection,
		IpvsSchedulerRoundRobin,
	}
}

// IstioIngressGatewayMode - Mode of an ingress gateway.
type IstioIngressGatewayMode string

const (
	// IstioIngressGatewayModeExternal - The ingress gateway is assigned a public IP address and is publicly accessible.
	IstioIngressGatewayModeExternal IstioIngressGatewayMode = "External"
	// IstioIngressGatewayModeInternal - The ingress gateway is assigned an internal IP address and cannot is accessed publicly.
	IstioIngressGatewayModeInternal IstioIngressGatewayMode = "Internal"
)

// PossibleIstioIngressGatewayModeValues returns the possible values for the IstioIngressGatewayMode const type.
func PossibleIstioIngressGatewayModeValues() []IstioIngressGatewayMode {
	return []IstioIngressGatewayMode{
		IstioIngressGatewayModeExternal,
		IstioIngressGatewayModeInternal,
	}
}

// JWTAuthenticatorProvisioningState - The provisioning state of the last accepted operation.
type JWTAuthenticatorProvisioningState string

const (
	// JWTAuthenticatorProvisioningStateCanceled - Resource creation was canceled.
	JWTAuthenticatorProvisioningStateCanceled JWTAuthenticatorProvisioningState = "Canceled"
	// JWTAuthenticatorProvisioningStateCreating - The JWT authenticator is being created.
	JWTAuthenticatorProvisioningStateCreating JWTAuthenticatorProvisioningState = "Creating"
	// JWTAuthenticatorProvisioningStateDeleting - The JWT authenticator is being deleted.
	JWTAuthenticatorProvisioningStateDeleting JWTAuthenticatorProvisioningState = "Deleting"
	// JWTAuthenticatorProvisioningStateFailed - Resource creation failed.
	JWTAuthenticatorProvisioningStateFailed JWTAuthenticatorProvisioningState = "Failed"
	// JWTAuthenticatorProvisioningStateSucceeded - Resource has been created.
	JWTAuthenticatorProvisioningStateSucceeded JWTAuthenticatorProvisioningState = "Succeeded"
	// JWTAuthenticatorProvisioningStateUpdating - The JWT authenticator is being updated.
	JWTAuthenticatorProvisioningStateUpdating JWTAuthenticatorProvisioningState = "Updating"
)

// PossibleJWTAuthenticatorProvisioningStateValues returns the possible values for the JWTAuthenticatorProvisioningState const type.
func PossibleJWTAuthenticatorProvisioningStateValues() []JWTAuthenticatorProvisioningState {
	return []JWTAuthenticatorProvisioningState{
		JWTAuthenticatorProvisioningStateCanceled,
		JWTAuthenticatorProvisioningStateCreating,
		JWTAuthenticatorProvisioningStateDeleting,
		JWTAuthenticatorProvisioningStateFailed,
		JWTAuthenticatorProvisioningStateSucceeded,
		JWTAuthenticatorProvisioningStateUpdating,
	}
}

// KeyVaultNetworkAccessTypes - Network access of the key vault. Network access of key vault. The possible values are Public
// and Private. Public means the key vault allows public access from all networks. Private means the key vault
// disables public access and enables private link. The default value is Public.
type KeyVaultNetworkAccessTypes string

const (
	KeyVaultNetworkAccessTypesPrivate KeyVaultNetworkAccessTypes = "Private"
	KeyVaultNetworkAccessTypesPublic  KeyVaultNetworkAccessTypes = "Public"
)

// PossibleKeyVaultNetworkAccessTypesValues returns the possible values for the KeyVaultNetworkAccessTypes const type.
func PossibleKeyVaultNetworkAccessTypesValues() []KeyVaultNetworkAccessTypes {
	return []KeyVaultNetworkAccessTypes{
		KeyVaultNetworkAccessTypesPrivate,
		KeyVaultNetworkAccessTypesPublic,
	}
}

// KubeletDiskType - Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
type KubeletDiskType string

const (
	// KubeletDiskTypeOS - Kubelet will use the OS disk for its data.
	KubeletDiskTypeOS KubeletDiskType = "OS"
	// KubeletDiskTypeTemporary - Kubelet will use the temporary disk for its data.
	KubeletDiskTypeTemporary KubeletDiskType = "Temporary"
)

// PossibleKubeletDiskTypeValues returns the possible values for the KubeletDiskType const type.
func PossibleKubeletDiskTypeValues() []KubeletDiskType {
	return []KubeletDiskType{
		KubeletDiskTypeOS,
		KubeletDiskTypeTemporary,
	}
}

// KubernetesSupportPlan - Different support tiers for AKS managed clusters
type KubernetesSupportPlan string

const (
	// KubernetesSupportPlanAKSLongTermSupport - Support for the version extended past the KubernetesOfficial support of 1 year.
	// AKS continues to patch CVEs for another 1 year, for a total of 2 years of support.
	KubernetesSupportPlanAKSLongTermSupport KubernetesSupportPlan = "AKSLongTermSupport"
	// KubernetesSupportPlanKubernetesOfficial - Support for the version is the same as for the open source Kubernetes offering.
	// Official Kubernetes open source community support versions for 1 year after release.
	KubernetesSupportPlanKubernetesOfficial KubernetesSupportPlan = "KubernetesOfficial"
)

// PossibleKubernetesSupportPlanValues returns the possible values for the KubernetesSupportPlan const type.
func PossibleKubernetesSupportPlanValues() []KubernetesSupportPlan {
	return []KubernetesSupportPlan{
		KubernetesSupportPlanAKSLongTermSupport,
		KubernetesSupportPlanKubernetesOfficial,
	}
}

// LicenseType - The license type to use for Windows VMs. See Azure Hybrid User Benefits [https://azure.microsoft.com/pricing/hybrid-benefit/faq/]
// for more details.
type LicenseType string

const (
	// LicenseTypeNone - No additional licensing is applied.
	LicenseTypeNone LicenseType = "None"
	// LicenseTypeWindowsServer - Enables Azure Hybrid User Benefits for Windows VMs.
	LicenseTypeWindowsServer LicenseType = "Windows_Server"
)

// PossibleLicenseTypeValues returns the possible values for the LicenseType const type.
func PossibleLicenseTypeValues() []LicenseType {
	return []LicenseType{
		LicenseTypeNone,
		LicenseTypeWindowsServer,
	}
}

// LoadBalancerSKU - The load balancer sku for the managed cluster. The default is 'standard'. See Azure Load Balancer SKUs
// [https://docs.microsoft.com/azure/load-balancer/skus] for more information about the differences
// between load balancer SKUs.
type LoadBalancerSKU string

const (
	// LoadBalancerSKUBasic - Use a basic Load Balancer with limited functionality.
	LoadBalancerSKUBasic LoadBalancerSKU = "basic"
	// LoadBalancerSKUStandard - Use a a standard Load Balancer. This is the recommended Load Balancer SKU. For more information
	// about on working with the load balancer in the managed cluster, see the [standard Load Balancer](https://docs.microsoft.com/azure/aks/load-balancer-standard)
	// article.
	LoadBalancerSKUStandard LoadBalancerSKU = "standard"
)

// PossibleLoadBalancerSKUValues returns the possible values for the LoadBalancerSKU const type.
func PossibleLoadBalancerSKUValues() []LoadBalancerSKU {
	return []LoadBalancerSKU{
		LoadBalancerSKUBasic,
		LoadBalancerSKUStandard,
	}
}

// LocalDNSForwardDestination - Destination server for DNS queries to be forwarded from localDNS.
type LocalDNSForwardDestination string

const (
	// LocalDNSForwardDestinationClusterCoreDNS - Forward DNS queries from localDNS to cluster CoreDNS.
	LocalDNSForwardDestinationClusterCoreDNS LocalDNSForwardDestination = "ClusterCoreDNS"
	// LocalDNSForwardDestinationVnetDNS - Forward DNS queries from localDNS to DNS server configured in the VNET. A VNET can
	// have multiple DNS servers configured.
	LocalDNSForwardDestinationVnetDNS LocalDNSForwardDestination = "VnetDNS"
)

// PossibleLocalDNSForwardDestinationValues returns the possible values for the LocalDNSForwardDestination const type.
func PossibleLocalDNSForwardDestinationValues() []LocalDNSForwardDestination {
	return []LocalDNSForwardDestination{
		LocalDNSForwardDestinationClusterCoreDNS,
		LocalDNSForwardDestinationVnetDNS,
	}
}

// LocalDNSForwardPolicy - Forward policy for selecting upstream DNS server. See forward plugin [https://coredns.io/plugins/forward]
// for more information.
type LocalDNSForwardPolicy string

const (
	// LocalDNSForwardPolicyRandom - Implements random upstream DNS server selection. See [forward plugin](https://coredns.io/plugins/forward)
	// for more information.
	LocalDNSForwardPolicyRandom LocalDNSForwardPolicy = "Random"
	// LocalDNSForwardPolicyRoundRobin - Implements round robin upstream DNS server selection. See [forward plugin](https://coredns.io/plugins/forward)
	// for more information.
	LocalDNSForwardPolicyRoundRobin LocalDNSForwardPolicy = "RoundRobin"
	// LocalDNSForwardPolicySequential - Implements sequential upstream DNS server selection. See [forward plugin](https://coredns.io/plugins/forward)
	// for more information.
	LocalDNSForwardPolicySequential LocalDNSForwardPolicy = "Sequential"
)

// PossibleLocalDNSForwardPolicyValues returns the possible values for the LocalDNSForwardPolicy const type.
func PossibleLocalDNSForwardPolicyValues() []LocalDNSForwardPolicy {
	return []LocalDNSForwardPolicy{
		LocalDNSForwardPolicyRandom,
		LocalDNSForwardPolicyRoundRobin,
		LocalDNSForwardPolicySequential,
	}
}

// LocalDNSMode - Mode of enablement for localDNS.
type LocalDNSMode string

const (
	// LocalDNSModeDisabled - Disable localDNS.
	LocalDNSModeDisabled LocalDNSMode = "Disabled"
	// LocalDNSModePreferred - If the current orchestrator version supports this feature, prefer enabling localDNS.
	LocalDNSModePreferred LocalDNSMode = "Preferred"
	// LocalDNSModeRequired - Enable localDNS.
	LocalDNSModeRequired LocalDNSMode = "Required"
)

// PossibleLocalDNSModeValues returns the possible values for the LocalDNSMode const type.
func PossibleLocalDNSModeValues() []LocalDNSMode {
	return []LocalDNSMode{
		LocalDNSModeDisabled,
		LocalDNSModePreferred,
		LocalDNSModeRequired,
	}
}

// LocalDNSProtocol - Enforce TCP or prefer UDP protocol for connections from localDNS to upstream DNS server.
type LocalDNSProtocol string

const (
	// LocalDNSProtocolForceTCP - Enforce TCP protocol for connections from localDNS to upstream DNS server.
	LocalDNSProtocolForceTCP LocalDNSProtocol = "ForceTCP"
	// LocalDNSProtocolPreferUDP - Prefer UDP protocol for connections from localDNS to upstream DNS server.
	LocalDNSProtocolPreferUDP LocalDNSProtocol = "PreferUDP"
)

// PossibleLocalDNSProtocolValues returns the possible values for the LocalDNSProtocol const type.
func PossibleLocalDNSProtocolValues() []LocalDNSProtocol {
	return []LocalDNSProtocol{
		LocalDNSProtocolForceTCP,
		LocalDNSProtocolPreferUDP,
	}
}

// LocalDNSQueryLogging - Log level for DNS queries in localDNS.
type LocalDNSQueryLogging string

const (
	// LocalDNSQueryLoggingError - Enables error logging in localDNS. See [errors plugin](https://coredns.io/plugins/errors) for
	// more information.
	LocalDNSQueryLoggingError LocalDNSQueryLogging = "Error"
	// LocalDNSQueryLoggingLog - Enables query logging in localDNS. See [log plugin](https://coredns.io/plugins/log) for more
	// information.
	LocalDNSQueryLoggingLog LocalDNSQueryLogging = "Log"
)

// PossibleLocalDNSQueryLoggingValues returns the possible values for the LocalDNSQueryLogging const type.
func PossibleLocalDNSQueryLoggingValues() []LocalDNSQueryLogging {
	return []LocalDNSQueryLogging{
		LocalDNSQueryLoggingError,
		LocalDNSQueryLoggingLog,
	}
}

// LocalDNSServeStale - Policy for serving stale data. See cache plugin [https://coredns.io/plugins/cache] for more information.
type LocalDNSServeStale string

const (
	// LocalDNSServeStaleDisable - Disable serving stale data.
	LocalDNSServeStaleDisable LocalDNSServeStale = "Disable"
	// LocalDNSServeStaleImmediate - Serve stale data immediately. Send the expired entry to the client before checking to see
	// if the entry is available from the source. See [cache plugin](https://coredns.io/plugins/cache) for more information.
	LocalDNSServeStaleImmediate LocalDNSServeStale = "Immediate"
	// LocalDNSServeStaleVerify - Serve stale data with verification. First verify that an entry is still unavailable from the
	// source before sending the expired entry to the client. See [cache plugin](https://coredns.io/plugins/cache) for more information.
	LocalDNSServeStaleVerify LocalDNSServeStale = "Verify"
)

// PossibleLocalDNSServeStaleValues returns the possible values for the LocalDNSServeStale const type.
func PossibleLocalDNSServeStaleValues() []LocalDNSServeStale {
	return []LocalDNSServeStale{
		LocalDNSServeStaleDisable,
		LocalDNSServeStaleImmediate,
		LocalDNSServeStaleVerify,
	}
}

// LocalDNSState - System-generated state of localDNS.
type LocalDNSState string

const (
	// LocalDNSStateDisabled - localDNS is disabled.
	LocalDNSStateDisabled LocalDNSState = "Disabled"
	// LocalDNSStateEnabled - localDNS is enabled.
	LocalDNSStateEnabled LocalDNSState = "Enabled"
)

// PossibleLocalDNSStateValues returns the possible values for the LocalDNSState const type.
func PossibleLocalDNSStateValues() []LocalDNSState {
	return []LocalDNSState{
		LocalDNSStateDisabled,
		LocalDNSStateEnabled,
	}
}

// ManagedClusterPodIdentityProvisioningState - The current provisioning state of the pod identity.
type ManagedClusterPodIdentityProvisioningState string

const (
	ManagedClusterPodIdentityProvisioningStateAssigned  ManagedClusterPodIdentityProvisioningState = "Assigned"
	ManagedClusterPodIdentityProvisioningStateCanceled  ManagedClusterPodIdentityProvisioningState = "Canceled"
	ManagedClusterPodIdentityProvisioningStateDeleting  ManagedClusterPodIdentityProvisioningState = "Deleting"
	ManagedClusterPodIdentityProvisioningStateFailed    ManagedClusterPodIdentityProvisioningState = "Failed"
	ManagedClusterPodIdentityProvisioningStateSucceeded ManagedClusterPodIdentityProvisioningState = "Succeeded"
	ManagedClusterPodIdentityProvisioningStateUpdating  ManagedClusterPodIdentityProvisioningState = "Updating"
)

// PossibleManagedClusterPodIdentityProvisioningStateValues returns the possible values for the ManagedClusterPodIdentityProvisioningState const type.
func PossibleManagedClusterPodIdentityProvisioningStateValues() []ManagedClusterPodIdentityProvisioningState {
	return []ManagedClusterPodIdentityProvisioningState{
		ManagedClusterPodIdentityProvisioningStateAssigned,
		ManagedClusterPodIdentityProvisioningStateCanceled,
		ManagedClusterPodIdentityProvisioningStateDeleting,
		ManagedClusterPodIdentityProvisioningStateFailed,
		ManagedClusterPodIdentityProvisioningStateSucceeded,
		ManagedClusterPodIdentityProvisioningStateUpdating,
	}
}

// ManagedClusterSKUName - The name of a managed cluster SKU.
type ManagedClusterSKUName string

const (
	// ManagedClusterSKUNameAutomatic - Automatic clusters are optimized to run most production workloads with configuration that
	// follows AKS best practices and recommendations for cluster and workload setup, scalability, and security. For more details
	// about Automatic clusters see aka.ms/aks/automatic.
	ManagedClusterSKUNameAutomatic ManagedClusterSKUName = "Automatic"
	// ManagedClusterSKUNameBase - Base option for the AKS control plane.
	ManagedClusterSKUNameBase ManagedClusterSKUName = "Base"
)

// PossibleManagedClusterSKUNameValues returns the possible values for the ManagedClusterSKUName const type.
func PossibleManagedClusterSKUNameValues() []ManagedClusterSKUName {
	return []ManagedClusterSKUName{
		ManagedClusterSKUNameAutomatic,
		ManagedClusterSKUNameBase,
	}
}

// ManagedClusterSKUTier - The tier of a managed cluster SKU. If not specified, the default is 'Free'. See AKS Pricing Tier
// [https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers] for more details.
type ManagedClusterSKUTier string

const (
	// ManagedClusterSKUTierFree - The cluster management is free, but charged for VM, storage, and networking usage. Best for
	// experimenting, learning, simple testing, or workloads with fewer than 10 nodes. Not recommended for production use cases.
	ManagedClusterSKUTierFree ManagedClusterSKUTier = "Free"
	// ManagedClusterSKUTierPremium - Cluster has premium capabilities in addition to all of the capabilities included in 'Standard'.
	// Premium enables selection of LongTermSupport (aka.ms/aks/lts) for certain Kubernetes versions.
	ManagedClusterSKUTierPremium ManagedClusterSKUTier = "Premium"
	// ManagedClusterSKUTierStandard - Recommended for mission-critical and production workloads. Includes Kubernetes control
	// plane autoscaling, workload-intensive testing, and up to 5,000 nodes per cluster. Guarantees 99.95% availability of the
	// Kubernetes API server endpoint for clusters that use Availability Zones and 99.9% of availability for clusters that don't
	// use Availability Zones.
	ManagedClusterSKUTierStandard ManagedClusterSKUTier = "Standard"
)

// PossibleManagedClusterSKUTierValues returns the possible values for the ManagedClusterSKUTier const type.
func PossibleManagedClusterSKUTierValues() []ManagedClusterSKUTier {
	return []ManagedClusterSKUTier{
		ManagedClusterSKUTierFree,
		ManagedClusterSKUTierPremium,
		ManagedClusterSKUTierStandard,
	}
}

// ManagedGatewayType - Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'.
// See https://aka.ms/k8s-gateway-api for more details.
type ManagedGatewayType string

const (
	// ManagedGatewayTypeDisabled - Gateway API CRDs will not be reconciled on your cluster.
	ManagedGatewayTypeDisabled ManagedGatewayType = "Disabled"
	// ManagedGatewayTypeStandard - The latest Gateway CRD bundle from the standard channel that is compatible with your Kubernetes
	// version will be reconciled onto your cluster. See https://gateway-api.sigs.k8s.io/concepts/versioning/ for more details.
	ManagedGatewayTypeStandard ManagedGatewayType = "Standard"
)

// PossibleManagedGatewayTypeValues returns the possible values for the ManagedGatewayType const type.
func PossibleManagedGatewayTypeValues() []ManagedGatewayType {
	return []ManagedGatewayType{
		ManagedGatewayTypeDisabled,
		ManagedGatewayTypeStandard,
	}
}

// MeshMembershipProvisioningState - The provisioning state of the last accepted operation.
type MeshMembershipProvisioningState string

const (
	// MeshMembershipProvisioningStateCanceled - Resource creation was canceled.
	MeshMembershipProvisioningStateCanceled MeshMembershipProvisioningState = "Canceled"
	// MeshMembershipProvisioningStateCreating - The Mesh Membership is being created.
	MeshMembershipProvisioningStateCreating MeshMembershipProvisioningState = "Creating"
	// MeshMembershipProvisioningStateDeleting - The Mesh Membership is being deleted.
	MeshMembershipProvisioningStateDeleting MeshMembershipProvisioningState = "Deleting"
	// MeshMembershipProvisioningStateFailed - Resource creation failed.
	MeshMembershipProvisioningStateFailed MeshMembershipProvisioningState = "Failed"
	// MeshMembershipProvisioningStateSucceeded - Resource has been created.
	MeshMembershipProvisioningStateSucceeded MeshMembershipProvisioningState = "Succeeded"
	// MeshMembershipProvisioningStateUpdating - The Mesh Membership is being updated.
	MeshMembershipProvisioningStateUpdating MeshMembershipProvisioningState = "Updating"
)

// PossibleMeshMembershipProvisioningStateValues returns the possible values for the MeshMembershipProvisioningState const type.
func PossibleMeshMembershipProvisioningStateValues() []MeshMembershipProvisioningState {
	return []MeshMembershipProvisioningState{
		MeshMembershipProvisioningStateCanceled,
		MeshMembershipProvisioningStateCreating,
		MeshMembershipProvisioningStateDeleting,
		MeshMembershipProvisioningStateFailed,
		MeshMembershipProvisioningStateSucceeded,
		MeshMembershipProvisioningStateUpdating,
	}
}

// Mode - Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
type Mode string

const (
	// ModeIPTABLES - IPTables proxy mode
	ModeIPTABLES Mode = "IPTABLES"
	// ModeIPVS - IPVS proxy mode. Must be using Kubernetes version >= 1.22.
	ModeIPVS Mode = "IPVS"
	// ModeNFTABLES - NFTables proxy mode. Must be using Kubernetes version >= 1.33.
	ModeNFTABLES Mode = "NFTABLES"
)

// PossibleModeValues returns the possible values for the Mode const type.
func PossibleModeValues() []Mode {
	return []Mode{
		ModeIPTABLES,
		ModeIPVS,
		ModeNFTABLES,
	}
}

// NamespaceProvisioningState - The current provisioning state of the namespace.
type NamespaceProvisioningState string

const (
	NamespaceProvisioningStateCanceled  NamespaceProvisioningState = "Canceled"
	NamespaceProvisioningStateCreating  NamespaceProvisioningState = "Creating"
	NamespaceProvisioningStateDeleting  NamespaceProvisioningState = "Deleting"
	NamespaceProvisioningStateFailed    NamespaceProvisioningState = "Failed"
	NamespaceProvisioningStateSucceeded NamespaceProvisioningState = "Succeeded"
	NamespaceProvisioningStateUpdating  NamespaceProvisioningState = "Updating"
)

// PossibleNamespaceProvisioningStateValues returns the possible values for the NamespaceProvisioningState const type.
func PossibleNamespaceProvisioningStateValues() []NamespaceProvisioningState {
	return []NamespaceProvisioningState{
		NamespaceProvisioningStateCanceled,
		NamespaceProvisioningStateCreating,
		NamespaceProvisioningStateDeleting,
		NamespaceProvisioningStateFailed,
		NamespaceProvisioningStateSucceeded,
		NamespaceProvisioningStateUpdating,
	}
}

// NetworkDataplane - Network dataplane used in the Kubernetes cluster.
type NetworkDataplane string

const (
	// NetworkDataplaneAzure - Use Azure network dataplane.
	NetworkDataplaneAzure NetworkDataplane = "azure"
	// NetworkDataplaneCilium - Use Cilium network dataplane. See [Azure CNI Powered by Cilium](https://learn.microsoft.com/azure/aks/azure-cni-powered-by-cilium)
	// for more information.
	NetworkDataplaneCilium NetworkDataplane = "cilium"
)

// PossibleNetworkDataplaneValues returns the possible values for the NetworkDataplane const type.
func PossibleNetworkDataplaneValues() []NetworkDataplane {
	return []NetworkDataplane{
		NetworkDataplaneAzure,
		NetworkDataplaneCilium,
	}
}

// NetworkMode - The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other
// than 'azure'.
type NetworkMode string

const (
	// NetworkModeBridge - This is no longer supported
	NetworkModeBridge NetworkMode = "bridge"
	// NetworkModeTransparent - No bridge is created. Intra-VM Pod to Pod communication is through IP routes created by Azure
	// CNI. See [Transparent Mode](https://docs.microsoft.com/azure/aks/faq#transparent-mode) for more information.
	NetworkModeTransparent NetworkMode = "transparent"
)

// PossibleNetworkModeValues returns the possible values for the NetworkMode const type.
func PossibleNetworkModeValues() []NetworkMode {
	return []NetworkMode{
		NetworkModeBridge,
		NetworkModeTransparent,
	}
}

// NetworkPlugin - Network plugin used for building the Kubernetes network.
type NetworkPlugin string

const (
	// NetworkPluginAzure - Use the Azure CNI network plugin. See [Azure CNI (advanced) networking](https://docs.microsoft.com/azure/aks/concepts-network#azure-cni-advanced-networking)
	// for more information.
	NetworkPluginAzure NetworkPlugin = "azure"
	// NetworkPluginKubenet - Use the Kubenet network plugin. See [Kubenet (basic) networking](https://docs.microsoft.com/azure/aks/concepts-network#kubenet-basic-networking)
	// for more information.
	NetworkPluginKubenet NetworkPlugin = "kubenet"
	// NetworkPluginNone - Do not use a network plugin. A custom CNI will need to be installed after cluster creation for networking
	// functionality.
	NetworkPluginNone NetworkPlugin = "none"
)

// PossibleNetworkPluginValues returns the possible values for the NetworkPlugin const type.
func PossibleNetworkPluginValues() []NetworkPlugin {
	return []NetworkPlugin{
		NetworkPluginAzure,
		NetworkPluginKubenet,
		NetworkPluginNone,
	}
}

// NetworkPluginMode - The mode the network plugin should use.
type NetworkPluginMode string

const (
	// NetworkPluginModeOverlay - Pods are given IPs from the PodCIDR address space but use Azure Routing Domains rather than
	// Kubenet reference plugins host-local and bridge.
	NetworkPluginModeOverlay NetworkPluginMode = "overlay"
)

// PossibleNetworkPluginModeValues returns the possible values for the NetworkPluginMode const type.
func PossibleNetworkPluginModeValues() []NetworkPluginMode {
	return []NetworkPluginMode{
		NetworkPluginModeOverlay,
	}
}

// NetworkPolicy - Network policy used for building the Kubernetes network.
type NetworkPolicy string

const (
	// NetworkPolicyAzure - Use Azure network policies. See [differences between Azure and Calico policies](https://docs.microsoft.com/azure/aks/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities)
	// for more information.
	NetworkPolicyAzure NetworkPolicy = "azure"
	// NetworkPolicyCalico - Use Calico network policies. See [differences between Azure and Calico policies](https://docs.microsoft.com/azure/aks/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities)
	// for more information.
	NetworkPolicyCalico NetworkPolicy = "calico"
	// NetworkPolicyCilium - Use Cilium to enforce network policies. This requires networkDataplane to be 'cilium'.
	NetworkPolicyCilium NetworkPolicy = "cilium"
	// NetworkPolicyNone - Network policies will not be enforced. This is the default value when NetworkPolicy is not specified.
	NetworkPolicyNone NetworkPolicy = "none"
)

// PossibleNetworkPolicyValues returns the possible values for the NetworkPolicy const type.
func PossibleNetworkPolicyValues() []NetworkPolicy {
	return []NetworkPolicy{
		NetworkPolicyAzure,
		NetworkPolicyCalico,
		NetworkPolicyCilium,
		NetworkPolicyNone,
	}
}

// NginxIngressControllerType - Ingress type for the default NginxIngressController custom resource
type NginxIngressControllerType string

const (
	// NginxIngressControllerTypeAnnotationControlled - The default NginxIngressController will be created. Users can edit the
	// default NginxIngressController Custom Resource to configure load balancer annotations.
	NginxIngressControllerTypeAnnotationControlled NginxIngressControllerType = "AnnotationControlled"
	// NginxIngressControllerTypeExternal - The default NginxIngressController will be created and the operator will provision
	// an external loadbalancer with it. Any annotation to make the default loadbalancer internal will be overwritten.
	NginxIngressControllerTypeExternal NginxIngressControllerType = "External"
	// NginxIngressControllerTypeInternal - The default NginxIngressController will be created and the operator will provision
	// an internal loadbalancer with it. Any annotation to make the default loadbalancer external will be overwritten.
	NginxIngressControllerTypeInternal NginxIngressControllerType = "Internal"
	// NginxIngressControllerTypeNone - The default Ingress Controller will not be created. It will not be deleted by the system
	// if it exists. Users should delete the default NginxIngressController Custom Resource manually if desired.
	NginxIngressControllerTypeNone NginxIngressControllerType = "None"
)

// PossibleNginxIngressControllerTypeValues returns the possible values for the NginxIngressControllerType const type.
func PossibleNginxIngressControllerTypeValues() []NginxIngressControllerType {
	return []NginxIngressControllerType{
		NginxIngressControllerTypeAnnotationControlled,
		NginxIngressControllerTypeExternal,
		NginxIngressControllerTypeInternal,
		NginxIngressControllerTypeNone,
	}
}

// NodeOSUpgradeChannel - Manner in which the OS on your nodes is updated. The default is Unmanaged, but may change to either
// NodeImage or SecurityPatch at GA.
type NodeOSUpgradeChannel string

const (
	// NodeOSUpgradeChannelNodeImage - AKS will update the nodes with a newly patched VHD containing security fixes and bugfixes
	// on a weekly cadence. With the VHD update machines will be rolling reimaged to that VHD following maintenance windows and
	// surge settings. No extra VHD cost is incurred when choosing this option as AKS hosts the images.
	NodeOSUpgradeChannelNodeImage NodeOSUpgradeChannel = "NodeImage"
	// NodeOSUpgradeChannelNone - No attempt to update your machines OS will be made either by OS or by rolling VHDs. This means
	// you are responsible for your security updates
	NodeOSUpgradeChannelNone NodeOSUpgradeChannel = "None"
	// NodeOSUpgradeChannelSecurityPatch - AKS downloads and updates the nodes with tested security updates. These updates honor
	// the maintenance window settings and produce a new VHD that is used on new nodes. On some occasions it's not possible to
	// apply the updates in place, in such cases the existing nodes will also be re-imaged to the newly produced VHD in order
	// to apply the changes. This option incurs an extra cost of hosting the new Security Patch VHDs in your resource group for
	// just in time consumption.
	NodeOSUpgradeChannelSecurityPatch NodeOSUpgradeChannel = "SecurityPatch"
	// NodeOSUpgradeChannelUnmanaged - OS updates will be applied automatically through the OS built-in patching infrastructure.
	// Newly scaled in machines will be unpatched initially, and will be patched at some later time by the OS's infrastructure.
	// Behavior of this option depends on the OS in question. Ubuntu and Mariner apply security patches through unattended upgrade
	// roughly once a day around 06:00 UTC. Windows does not apply security patches automatically and so for them this option
	// is equivalent to None till further notice
	NodeOSUpgradeChannelUnmanaged NodeOSUpgradeChannel = "Unmanaged"
)

// PossibleNodeOSUpgradeChannelValues returns the possible values for the NodeOSUpgradeChannel const type.
func PossibleNodeOSUpgradeChannelValues() []NodeOSUpgradeChannel {
	return []NodeOSUpgradeChannel{
		NodeOSUpgradeChannelNodeImage,
		NodeOSUpgradeChannelNone,
		NodeOSUpgradeChannelSecurityPatch,
		NodeOSUpgradeChannelUnmanaged,
	}
}

// NodeProvisioningDefaultNodePools - The set of default Karpenter NodePools (CRDs) configured for node provisioning. This
// field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will
// cause the default Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools.
// It is strongly recommended to not do this unless there are idle nodes ready to
// take the pods evicted by that action. If not specified, the default is Auto. For more information see aka.ms/aks/nap#node-pools.
type NodeProvisioningDefaultNodePools string

const (
	// NodeProvisioningDefaultNodePoolsAuto - A standard set of Karpenter NodePools are provisioned
	NodeProvisioningDefaultNodePoolsAuto NodeProvisioningDefaultNodePools = "Auto"
	// NodeProvisioningDefaultNodePoolsNone - No Karpenter NodePools are provisioned automatically. Automatic scaling will not
	// happen unless the user creates one or more NodePool CRD instances.
	NodeProvisioningDefaultNodePoolsNone NodeProvisioningDefaultNodePools = "None"
)

// PossibleNodeProvisioningDefaultNodePoolsValues returns the possible values for the NodeProvisioningDefaultNodePools const type.
func PossibleNodeProvisioningDefaultNodePoolsValues() []NodeProvisioningDefaultNodePools {
	return []NodeProvisioningDefaultNodePools{
		NodeProvisioningDefaultNodePoolsAuto,
		NodeProvisioningDefaultNodePoolsNone,
	}
}

// NodeProvisioningMode - The node provisioning mode. If not specified, the default is Manual.
type NodeProvisioningMode string

const (
	// NodeProvisioningModeAuto - Nodes are provisioned automatically by AKS using Karpenter (See aka.ms/aks/nap for more details).
	// Fixed size Node Pools can still be created, but autoscaling Node Pools cannot be. (See aka.ms/aks/nap for more details).
	NodeProvisioningModeAuto NodeProvisioningMode = "Auto"
	// NodeProvisioningModeManual - Nodes are provisioned manually by the user
	NodeProvisioningModeManual NodeProvisioningMode = "Manual"
)

// PossibleNodeProvisioningModeValues returns the possible values for the NodeProvisioningMode const type.
func PossibleNodeProvisioningModeValues() []NodeProvisioningMode {
	return []NodeProvisioningMode{
		NodeProvisioningModeAuto,
		NodeProvisioningModeManual,
	}
}

// OSDiskType - The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports
// it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to
// 'Managed'. May not be changed after creation. For more information see Ephemeral OS [https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os].
type OSDiskType string

const (
	// OSDiskTypeEphemeral - Ephemeral OS disks are stored only on the host machine, just like a temporary disk. This provides
	// lower read/write latency, along with faster node scaling and cluster upgrades.
	OSDiskTypeEphemeral OSDiskType = "Ephemeral"
	// OSDiskTypeManaged - Azure replicates the operating system disk for a virtual machine to Azure storage to avoid data loss
	// should the VM need to be relocated to another host. Since containers aren't designed to have local state persisted, this
	// behavior offers limited value while providing some drawbacks, including slower node provisioning and higher read/write
	// latency.
	OSDiskTypeManaged OSDiskType = "Managed"
)

// PossibleOSDiskTypeValues returns the possible values for the OSDiskType const type.
func PossibleOSDiskTypeValues() []OSDiskType {
	return []OSDiskType{
		OSDiskTypeEphemeral,
		OSDiskTypeManaged,
	}
}

// OSSKU - Specifies the OS SKU used by the agent pool. If not specified, the default is Ubuntu if OSType=Linux or Windows2019
// if OSType=Windows. And the default Windows OSSKU will be changed to Windows2022
// after Windows2019 is deprecated.
type OSSKU string

const (
	// OSSKUAzureLinux - Use AzureLinux as the OS for node images. Azure Linux is a container-optimized Linux distro built by
	// Microsoft, visit https://aka.ms/azurelinux for more information.
	OSSKUAzureLinux OSSKU = "AzureLinux"
	// OSSKUAzureLinux3 - Use AzureLinux3 as the OS for node images. Azure Linux is a container-optimized Linux distro built by
	// Microsoft, visit https://aka.ms/azurelinux for more information. For limitations, visit https://aka.ms/aks/node-images.
	// For OS migration guidance, see https://aka.ms/aks/upgrade-os-version.
	OSSKUAzureLinux3 OSSKU = "AzureLinux3"
	// OSSKUCBLMariner - Deprecated OSSKU. Microsoft recommends that new deployments choose 'AzureLinux' instead.
	OSSKUCBLMariner OSSKU = "CBLMariner"
	// OSSKUFlatcar - Use Flatcar Container Linux as the OS for node images. Flatcar is a container-optimized, security-focused
	// Linux OS, with an immutable filesystem and part of the Cloud Native Computing Foundation (CNCF). For more information about
	// Flatcar Container Linux for AKS, see aka.ms/aks/flatcar-container-linux-for-aks
	OSSKUFlatcar OSSKU = "Flatcar"
	// OSSKUMariner - Deprecated OSSKU. Microsoft recommends that new deployments choose 'AzureLinux' instead.
	OSSKUMariner OSSKU = "Mariner"
	// OSSKUUbuntu - Use Ubuntu as the OS for node images.
	OSSKUUbuntu OSSKU = "Ubuntu"
	// OSSKUUbuntu2204 - Use Ubuntu2204 as the OS for node images, however, Ubuntu 22.04 may not be supported for all nodepools.
	// For limitations and supported kubernetes versions, see see https://aka.ms/aks/supported-ubuntu-versions
	OSSKUUbuntu2204 OSSKU = "Ubuntu2204"
	// OSSKUUbuntu2404 - Use Ubuntu2404 as the OS for node images, however, Ubuntu 24.04 may not be supported for all nodepools.
	// For limitations and supported kubernetes versions, see see https://aka.ms/aks/supported-ubuntu-versions
	OSSKUUbuntu2404 OSSKU = "Ubuntu2404"
	// OSSKUWindows2019 - Use Windows2019 as the OS for node images. Unsupported for system node pools. Windows2019 only supports
	// Windows2019 containers; it cannot run Windows2022 containers and vice versa.
	OSSKUWindows2019 OSSKU = "Windows2019"
	// OSSKUWindows2022 - Use Windows2022 as the OS for node images. Unsupported for system node pools. Windows2022 only supports
	// Windows2022 containers; it cannot run Windows2019 containers and vice versa.
	OSSKUWindows2022 OSSKU = "Windows2022"
	// OSSKUWindows2025 - Use Windows2025 as the OS for node images. Unsupported for system node pools. Windows2025 supports Windows2022
	// and Windows 2025 containers; it cannot run Windows2019 containers and vice versa.
	OSSKUWindows2025 OSSKU = "Windows2025"
	// OSSKUWindowsAnnual - Use Windows Annual Channel version as the OS for node images. Unsupported for system node pools. Details
	// about supported container images and kubernetes versions under different AKS Annual Channel versions could be seen in https://aka.ms/aks/windows-annual-channel-details.
	OSSKUWindowsAnnual OSSKU = "WindowsAnnual"
)

// PossibleOSSKUValues returns the possible values for the OSSKU const type.
func PossibleOSSKUValues() []OSSKU {
	return []OSSKU{
		OSSKUAzureLinux,
		OSSKUAzureLinux3,
		OSSKUCBLMariner,
		OSSKUFlatcar,
		OSSKUMariner,
		OSSKUUbuntu,
		OSSKUUbuntu2204,
		OSSKUUbuntu2404,
		OSSKUWindows2019,
		OSSKUWindows2022,
		OSSKUWindows2025,
		OSSKUWindowsAnnual,
	}
}

// OSType - The operating system type. The default is Linux.
type OSType string

const (
	// OSTypeLinux - Use Linux.
	OSTypeLinux OSType = "Linux"
	// OSTypeWindows - Use Windows.
	OSTypeWindows OSType = "Windows"
)

// PossibleOSTypeValues returns the possible values for the OSType const type.
func PossibleOSTypeValues() []OSType {
	return []OSType{
		OSTypeLinux,
		OSTypeWindows,
	}
}

// Operator - operator represents a key's relationship to a set of values. Valid operators are In and NotIn
type Operator string

const (
	// OperatorDoesNotExist - The value of the key should not exist.
	OperatorDoesNotExist Operator = "DoesNotExist"
	// OperatorExists - The value of the key should exist.
	OperatorExists Operator = "Exists"
	// OperatorIn - The value of the key should be in the given list.
	OperatorIn Operator = "In"
	// OperatorNotIn - The value of the key should not be in the given list.
	OperatorNotIn Operator = "NotIn"
)

// PossibleOperatorValues returns the possible values for the Operator const type.
func PossibleOperatorValues() []Operator {
	return []Operator{
		OperatorDoesNotExist,
		OperatorExists,
		OperatorIn,
		OperatorNotIn,
	}
}

// OutboundType - The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed
// later. For more information see egress outbound type
// [https://docs.microsoft.com/azure/aks/egress-outboundtype].
type OutboundType string

const (
	// OutboundTypeLoadBalancer - The load balancer is used for egress through an AKS assigned public IP. This supports Kubernetes
	// services of type 'loadBalancer'. For more information see [outbound type loadbalancer](https://docs.microsoft.com/azure/aks/egress-outboundtype#outbound-type-of-loadbalancer).
	OutboundTypeLoadBalancer OutboundType = "loadBalancer"
	// OutboundTypeManagedNATGateway - The AKS-managed NAT gateway is used for egress.
	OutboundTypeManagedNATGateway OutboundType = "managedNATGateway"
	// OutboundTypeNone - The AKS cluster is not set with any outbound-type. All AKS nodes follows Azure VM default outbound behavior.
	// Please refer to https://azure.microsoft.com/en-us/updates/default-outbound-access-for-vms-in-azure-will-be-retired-transition-to-a-new-method-of-internet-access/
	OutboundTypeNone OutboundType = "none"
	// OutboundTypeUserAssignedNATGateway - The user-assigned NAT gateway associated to the cluster subnet is used for egress.
	// This is an advanced scenario and requires proper network configuration.
	OutboundTypeUserAssignedNATGateway OutboundType = "userAssignedNATGateway"
	// OutboundTypeUserDefinedRouting - Egress paths must be defined by the user. This is an advanced scenario and requires proper
	// network configuration. For more information see [outbound type userDefinedRouting](https://docs.microsoft.com/azure/aks/egress-outboundtype#outbound-type-of-userdefinedrouting).
	OutboundTypeUserDefinedRouting OutboundType = "userDefinedRouting"
)

// PossibleOutboundTypeValues returns the possible values for the OutboundType const type.
func PossibleOutboundTypeValues() []OutboundType {
	return []OutboundType{
		OutboundTypeLoadBalancer,
		OutboundTypeManagedNATGateway,
		OutboundTypeNone,
		OutboundTypeUserAssignedNATGateway,
		OutboundTypeUserDefinedRouting,
	}
}

// PodIPAllocationMode - Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with podSubnetId.
// The default is 'DynamicIndividual'.
type PodIPAllocationMode string

const (
	// PodIPAllocationModeDynamicIndividual - Each node gets allocated with a non-contiguous list of IP addresses assignable to
	// pods. This is better for maximizing a small to medium subnet of size /16 or smaller. The Azure CNI cluster with dynamic
	// IP allocation defaults to this mode if the customer does not explicitly specify a podIPAllocationMode
	PodIPAllocationModeDynamicIndividual PodIPAllocationMode = "DynamicIndividual"
	// PodIPAllocationModeStaticBlock - Each node is statically allocated CIDR block(s) of size /28 = 16 IPs per block to satisfy
	// the maxPods per node. Number of CIDR blocks >= (maxPods / 16). The block, rather than a single IP, counts against the Azure
	// Vnet Private IP limit of 65K. Therefore block mode is suitable for running larger workloads with more than the current
	// limit of 65K pods in a cluster. This mode is better suited to scale with larger subnets of /15 or bigger
	PodIPAllocationModeStaticBlock PodIPAllocationMode = "StaticBlock"
)

// PossiblePodIPAllocationModeValues returns the possible values for the PodIPAllocationMode const type.
func PossiblePodIPAllocationModeValues() []PodIPAllocationMode {
	return []PodIPAllocationMode{
		PodIPAllocationModeDynamicIndividual,
		PodIPAllocationModeStaticBlock,
	}
}

// PodLinkLocalAccess - Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods
// with hostNetwork=false. If not specified, the default is 'IMDS'.
type PodLinkLocalAccess string

const (
	// PodLinkLocalAccessIMDS - Pods with hostNetwork=false can access Azure Instance Metadata Service (IMDS) without restriction.
	PodLinkLocalAccessIMDS PodLinkLocalAccess = "IMDS"
	// PodLinkLocalAccessNone - Pods with hostNetwork=false cannot access Azure Instance Metadata Service (IMDS).
	PodLinkLocalAccessNone PodLinkLocalAccess = "None"
)

// PossiblePodLinkLocalAccessValues returns the possible values for the PodLinkLocalAccess const type.
func PossiblePodLinkLocalAccessValues() []PodLinkLocalAccess {
	return []PodLinkLocalAccess{
		PodLinkLocalAccessIMDS,
		PodLinkLocalAccessNone,
	}
}

// PolicyRule - Enum representing different network policy rules.
type PolicyRule string

const (
	// PolicyRuleAllowAll - Allow all network traffic.
	PolicyRuleAllowAll PolicyRule = "AllowAll"
	// PolicyRuleAllowSameNamespace - Allow traffic within the same namespace.
	PolicyRuleAllowSameNamespace PolicyRule = "AllowSameNamespace"
	// PolicyRuleDenyAll - Deny all network traffic.
	PolicyRuleDenyAll PolicyRule = "DenyAll"
)

// PossiblePolicyRuleValues returns the possible values for the PolicyRule const type.
func PossiblePolicyRuleValues() []PolicyRule {
	return []PolicyRule{
		PolicyRuleAllowAll,
		PolicyRuleAllowSameNamespace,
		PolicyRuleDenyAll,
	}
}

// PrivateEndpointConnectionProvisioningState - The current provisioning state.
type PrivateEndpointConnectionProvisioningState string

const (
	PrivateEndpointConnectionProvisioningStateCanceled  PrivateEndpointConnectionProvisioningState = "Canceled"
	PrivateEndpointConnectionProvisioningStateCreating  PrivateEndpointConnectionProvisioningState = "Creating"
	PrivateEndpointConnectionProvisioningStateDeleting  PrivateEndpointConnectionProvisioningState = "Deleting"
	PrivateEndpointConnectionProvisioningStateFailed    PrivateEndpointConnectionProvisioningState = "Failed"
	PrivateEndpointConnectionProvisioningStateSucceeded PrivateEndpointConnectionProvisioningState = "Succeeded"
)

// PossiblePrivateEndpointConnectionProvisioningStateValues returns the possible values for the PrivateEndpointConnectionProvisioningState const type.
func PossiblePrivateEndpointConnectionProvisioningStateValues() []PrivateEndpointConnectionProvisioningState {
	return []PrivateEndpointConnectionProvisioningState{
		PrivateEndpointConnectionProvisioningStateCanceled,
		PrivateEndpointConnectionProvisioningStateCreating,
		PrivateEndpointConnectionProvisioningStateDeleting,
		PrivateEndpointConnectionProvisioningStateFailed,
		PrivateEndpointConnectionProvisioningStateSucceeded,
	}
}

// Protocol - The network protocol of the port.
type Protocol string

const (
	// ProtocolTCP - TCP protocol.
	ProtocolTCP Protocol = "TCP"
	// ProtocolUDP - UDP protocol.
	ProtocolUDP Protocol = "UDP"
)

// PossibleProtocolValues returns the possible values for the Protocol const type.
func PossibleProtocolValues() []Protocol {
	return []Protocol{
		ProtocolTCP,
		ProtocolUDP,
	}
}

// ProxyRedirectionMechanism - Mode of traffic redirection.
type ProxyRedirectionMechanism string

const (
	// ProxyRedirectionMechanismCNIChaining - Istio will install a chained CNI plugin to redirect traffic (recommended).
	ProxyRedirectionMechanismCNIChaining ProxyRedirectionMechanism = "CNIChaining"
	// ProxyRedirectionMechanismInitContainers - Istio will inject an init container into each pod to redirect traffic (requires
	// NET_ADMIN and NET_RAW).
	ProxyRedirectionMechanismInitContainers ProxyRedirectionMechanism = "InitContainers"
)

// PossibleProxyRedirectionMechanismValues returns the possible values for the ProxyRedirectionMechanism const type.
func PossibleProxyRedirectionMechanismValues() []ProxyRedirectionMechanism {
	return []ProxyRedirectionMechanism{
		ProxyRedirectionMechanismCNIChaining,
		ProxyRedirectionMechanismInitContainers,
	}
}

// PublicNetworkAccess - PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
type PublicNetworkAccess string

const (
	// PublicNetworkAccessDisabled - Inbound traffic to managedCluster is disabled, traffic from managedCluster is allowed.
	PublicNetworkAccessDisabled PublicNetworkAccess = "Disabled"
	// PublicNetworkAccessEnabled - Inbound/Outbound to the managedCluster is allowed.
	PublicNetworkAccessEnabled PublicNetworkAccess = "Enabled"
	// PublicNetworkAccessSecuredByPerimeter - Inbound/Outbound traffic is managed by Microsoft.Network/NetworkSecurityPerimeters.
	PublicNetworkAccessSecuredByPerimeter PublicNetworkAccess = "SecuredByPerimeter"
)

// PossiblePublicNetworkAccessValues returns the possible values for the PublicNetworkAccess const type.
func PossiblePublicNetworkAccessValues() []PublicNetworkAccess {
	return []PublicNetworkAccess{
		PublicNetworkAccessDisabled,
		PublicNetworkAccessEnabled,
		PublicNetworkAccessSecuredByPerimeter,
	}
}

// ResourceIdentityType - The type of identity used for the managed cluster. For more information see use managed identities
// in AKS [https://docs.microsoft.com/azure/aks/use-managed-identity].
type ResourceIdentityType string

const (
	// ResourceIdentityTypeNone - Do not use a managed identity for the Managed Cluster, service principal will be used instead.
	ResourceIdentityTypeNone ResourceIdentityType = "None"
	// ResourceIdentityTypeSystemAssigned - Use an implicitly created system assigned managed identity to manage cluster resources.
	// Master components in the control plane such as kube-controller-manager will use the system assigned managed identity to
	// manipulate Azure resources.
	ResourceIdentityTypeSystemAssigned ResourceIdentityType = "SystemAssigned"
	// ResourceIdentityTypeUserAssigned - Use a user-specified identity to manage cluster resources. Master components in the
	// control plane such as kube-controller-manager will use the specified user assigned managed identity to manipulate Azure
	// resources.
	ResourceIdentityTypeUserAssigned ResourceIdentityType = "UserAssigned"
)

// PossibleResourceIdentityTypeValues returns the possible values for the ResourceIdentityType const type.
func PossibleResourceIdentityTypeValues() []ResourceIdentityType {
	return []ResourceIdentityType{
		ResourceIdentityTypeNone,
		ResourceIdentityTypeSystemAssigned,
		ResourceIdentityTypeUserAssigned,
	}
}

// RestrictionLevel - The restriction level applied to the cluster's node resource group
type RestrictionLevel string

const (
	// RestrictionLevelReadOnly - Only */read RBAC permissions allowed on the managed node resource group
	RestrictionLevelReadOnly RestrictionLevel = "ReadOnly"
	// RestrictionLevelUnrestricted - All RBAC permissions are allowed on the managed node resource group
	RestrictionLevelUnrestricted RestrictionLevel = "Unrestricted"
)

// PossibleRestrictionLevelValues returns the possible values for the RestrictionLevel const type.
func PossibleRestrictionLevelValues() []RestrictionLevel {
	return []RestrictionLevel{
		RestrictionLevelReadOnly,
		RestrictionLevelUnrestricted,
	}
}

// SafeguardsSupport - Whether the version is preview or stable.
type SafeguardsSupport string

const (
	// SafeguardsSupportPreview - The version is preview. It is not recommended to use preview versions on critical production
	// clusters. The preview version may not support all use-cases.
	SafeguardsSupportPreview SafeguardsSupport = "Preview"
	// SafeguardsSupportStable - The version is stable and can be used on critical production clusters.
	SafeguardsSupportStable SafeguardsSupport = "Stable"
)

// PossibleSafeguardsSupportValues returns the possible values for the SafeguardsSupport const type.
func PossibleSafeguardsSupportValues() []SafeguardsSupport {
	return []SafeguardsSupport{
		SafeguardsSupportPreview,
		SafeguardsSupportStable,
	}
}

// ScaleDownMode - Describes how VMs are added to or removed from Agent Pools. See billing states [https://docs.microsoft.com/azure/virtual-machines/states-billing].
type ScaleDownMode string

const (
	// ScaleDownModeDeallocate - Attempt to start deallocated instances (if they exist) during scale up and deallocate instances
	// during scale down.
	ScaleDownModeDeallocate ScaleDownMode = "Deallocate"
	// ScaleDownModeDelete - Create new instances during scale up and remove instances during scale down.
	ScaleDownModeDelete ScaleDownMode = "Delete"
)

// PossibleScaleDownModeValues returns the possible values for the ScaleDownMode const type.
func PossibleScaleDownModeValues() []ScaleDownMode {
	return []ScaleDownMode{
		ScaleDownModeDeallocate,
		ScaleDownModeDelete,
	}
}

// ScaleSetEvictionPolicy - The Virtual Machine Scale Set eviction policy. The eviction policy specifies what to do with the
// VM when it is evicted. The default is Delete. For more information about eviction see spot VMs
// [https://docs.microsoft.com/azure/virtual-machines/spot-vms]
type ScaleSetEvictionPolicy string

const (
	// ScaleSetEvictionPolicyDeallocate - Nodes in the underlying Scale Set of the node pool are set to the stopped-deallocated
	// state upon eviction. Nodes in the stopped-deallocated state count against your compute quota and can cause issues with
	// cluster scaling or upgrading.
	ScaleSetEvictionPolicyDeallocate ScaleSetEvictionPolicy = "Deallocate"
	// ScaleSetEvictionPolicyDelete - Nodes in the underlying Scale Set of the node pool are deleted when they're evicted.
	ScaleSetEvictionPolicyDelete ScaleSetEvictionPolicy = "Delete"
)

// PossibleScaleSetEvictionPolicyValues returns the possible values for the ScaleSetEvictionPolicy const type.
func PossibleScaleSetEvictionPolicyValues() []ScaleSetEvictionPolicy {
	return []ScaleSetEvictionPolicy{
		ScaleSetEvictionPolicyDeallocate,
		ScaleSetEvictionPolicyDelete,
	}
}

// ScaleSetPriority - The Virtual Machine Scale Set priority.
type ScaleSetPriority string

const (
	// ScaleSetPriorityRegular - Regular VMs will be used.
	ScaleSetPriorityRegular ScaleSetPriority = "Regular"
	// ScaleSetPrioritySpot - Spot priority VMs will be used. There is no SLA for spot nodes. See [spot on AKS](https://docs.microsoft.com/azure/aks/spot-node-pool)
	// for more information.
	ScaleSetPrioritySpot ScaleSetPriority = "Spot"
)

// PossibleScaleSetPriorityValues returns the possible values for the ScaleSetPriority const type.
func PossibleScaleSetPriorityValues() []ScaleSetPriority {
	return []ScaleSetPriority{
		ScaleSetPriorityRegular,
		ScaleSetPrioritySpot,
	}
}

// SchedulerConfigMode - The config customization mode for this scheduler instance.
type SchedulerConfigMode string

const (
	// SchedulerConfigModeDefault - No config customization. Use default configuration.
	SchedulerConfigModeDefault SchedulerConfigMode = "Default"
	// SchedulerConfigModeManagedByCRD - Enable config customization. Customer can specify scheduler configuration via a CRD.
	// See aka.ms/aks/scheduler-crd for details.
	SchedulerConfigModeManagedByCRD SchedulerConfigMode = "ManagedByCRD"
)

// PossibleSchedulerConfigModeValues returns the possible values for the SchedulerConfigMode const type.
func PossibleSchedulerConfigModeValues() []SchedulerConfigMode {
	return []SchedulerConfigMode{
		SchedulerConfigModeDefault,
		SchedulerConfigModeManagedByCRD,
	}
}

// SeccompDefault - Specifies the default seccomp profile applied to all workloads. If not specified, 'Unconfined' will be
// used by default.
type SeccompDefault string

const (
	// SeccompDefaultRuntimeDefault - The default seccomp profile for container runtime is applied, which restricts certain system
	// calls for enhanced security.
	SeccompDefaultRuntimeDefault SeccompDefault = "RuntimeDefault"
	// SeccompDefaultUnconfined - No seccomp profile is applied, allowing all system calls.
	SeccompDefaultUnconfined SeccompDefault = "Unconfined"
)

// PossibleSeccompDefaultValues returns the possible values for the SeccompDefault const type.
func PossibleSeccompDefaultValues() []SeccompDefault {
	return []SeccompDefault{
		SeccompDefaultRuntimeDefault,
		SeccompDefaultUnconfined,
	}
}

// ServiceMeshMode - Mode of the service mesh.
type ServiceMeshMode string

const (
	// ServiceMeshModeDisabled - Mesh is disabled.
	ServiceMeshModeDisabled ServiceMeshMode = "Disabled"
	// ServiceMeshModeIstio - Istio deployed as an AKS addon.
	ServiceMeshModeIstio ServiceMeshMode = "Istio"
)

// PossibleServiceMeshModeValues returns the possible values for the ServiceMeshMode const type.
func PossibleServiceMeshModeValues() []ServiceMeshMode {
	return []ServiceMeshMode{
		ServiceMeshModeDisabled,
		ServiceMeshModeIstio,
	}
}

// SnapshotType - The type of a snapshot. The default is NodePool.
type SnapshotType string

const (
	// SnapshotTypeManagedCluster - The snapshot is a snapshot of a managed cluster.
	SnapshotTypeManagedCluster SnapshotType = "ManagedCluster"
	// SnapshotTypeNodePool - The snapshot is a snapshot of a node pool.
	SnapshotTypeNodePool SnapshotType = "NodePool"
)

// PossibleSnapshotTypeValues returns the possible values for the SnapshotType const type.
func PossibleSnapshotTypeValues() []SnapshotType {
	return []SnapshotType{
		SnapshotTypeManagedCluster,
		SnapshotTypeNodePool,
	}
}

// TransitEncryptionType - Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified,
// the default value is None.
type TransitEncryptionType string

const (
	// TransitEncryptionTypeNone - Disable Transit encryption
	TransitEncryptionTypeNone TransitEncryptionType = "None"
	// TransitEncryptionTypeWireGuard - Enable WireGuard encryption. Refer to https://docs.cilium.io/en/latest/security/network/encryption-wireguard/
	// on use cases and implementation details
	TransitEncryptionTypeWireGuard TransitEncryptionType = "WireGuard"
)

// PossibleTransitEncryptionTypeValues returns the possible values for the TransitEncryptionType const type.
func PossibleTransitEncryptionTypeValues() []TransitEncryptionType {
	return []TransitEncryptionType{
		TransitEncryptionTypeNone,
		TransitEncryptionTypeWireGuard,
	}
}

// TrustedAccessRoleBindingProvisioningState - The current provisioning state of trusted access role binding.
type TrustedAccessRoleBindingProvisioningState string

const (
	TrustedAccessRoleBindingProvisioningStateCanceled  TrustedAccessRoleBindingProvisioningState = "Canceled"
	TrustedAccessRoleBindingProvisioningStateDeleting  TrustedAccessRoleBindingProvisioningState = "Deleting"
	TrustedAccessRoleBindingProvisioningStateFailed    TrustedAccessRoleBindingProvisioningState = "Failed"
	TrustedAccessRoleBindingProvisioningStateSucceeded TrustedAccessRoleBindingProvisioningState = "Succeeded"
	TrustedAccessRoleBindingProvisioningStateUpdating  TrustedAccessRoleBindingProvisioningState = "Updating"
)

// PossibleTrustedAccessRoleBindingProvisioningStateValues returns the possible values for the TrustedAccessRoleBindingProvisioningState const type.
func PossibleTrustedAccessRoleBindingProvisioningStateValues() []TrustedAccessRoleBindingProvisioningState {
	return []TrustedAccessRoleBindingProvisioningState{
		TrustedAccessRoleBindingProvisioningStateCanceled,
		TrustedAccessRoleBindingProvisioningStateDeleting,
		TrustedAccessRoleBindingProvisioningStateFailed,
		TrustedAccessRoleBindingProvisioningStateSucceeded,
		TrustedAccessRoleBindingProvisioningStateUpdating,
	}
}

// Type - The week index. Specifies on which instance of the allowed days specified in daysOfWeek the maintenance occurs.
type Type string

const (
	// TypeFirst - First.
	TypeFirst Type = "First"
	// TypeFourth - Fourth.
	TypeFourth Type = "Fourth"
	// TypeLast - Last.
	TypeLast Type = "Last"
	// TypeSecond - Second.
	TypeSecond Type = "Second"
	// TypeThird - Third.
	TypeThird Type = "Third"
)

// PossibleTypeValues returns the possible values for the Type const type.
func PossibleTypeValues() []Type {
	return []Type{
		TypeFirst,
		TypeFourth,
		TypeLast,
		TypeSecond,
		TypeThird,
	}
}

// UndrainableNodeBehavior - Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable
// nodes is Pod Disruption Budgets (PDBs), but other issues, such as pod termination grace period is
// exceeding the remaining per-node drain timeout or pod is still being in a running state, can also cause undrainable nodes.
type UndrainableNodeBehavior string

const (
	// UndrainableNodeBehaviorCordon - AKS will cordon the blocked nodes and replace them with surge nodes during upgrade. The
	// blocked nodes will be cordoned and replaced by surge nodes. The blocked nodes will have label 'kubernetes.azure.com/upgrade-status:Quarantined'.
	// A surge node will be retained for each blocked node. A best-effort attempt will be made to delete all other surge nodes.
	// If there are enough surge nodes to replace blocked nodes, then the upgrade operation and the managed cluster will be in
	// failed state. Otherwise, the upgrade operation and the managed cluster will be in canceled state.
	UndrainableNodeBehaviorCordon UndrainableNodeBehavior = "Cordon"
	// UndrainableNodeBehaviorSchedule - AKS will mark the blocked nodes schedulable, but the blocked nodes are not upgraded.
	// A best-effort attempt will be made to delete all surge nodes. The upgrade operation and the managed cluster will be in
	// failed state if there are any blocked nodes.
	UndrainableNodeBehaviorSchedule UndrainableNodeBehavior = "Schedule"
)

// PossibleUndrainableNodeBehaviorValues returns the possible values for the UndrainableNodeBehavior const type.
func PossibleUndrainableNodeBehaviorValues() []UndrainableNodeBehavior {
	return []UndrainableNodeBehavior{
		UndrainableNodeBehaviorCordon,
		UndrainableNodeBehaviorSchedule,
	}
}

// UpgradeChannel - The upgrade channel for auto upgrade. The default is 'none'. For more information see setting the AKS
// cluster auto-upgrade channel
// [https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel].
type UpgradeChannel string

const (
	// UpgradeChannelNodeImage - Automatically upgrade the node image to the latest version available. Consider using nodeOSUpgradeChannel
	// instead as that allows you to configure node OS patching separate from Kubernetes version patching
	UpgradeChannelNodeImage UpgradeChannel = "node-image"
	// UpgradeChannelNone - Disables auto-upgrades and keeps the cluster at its current version of Kubernetes.
	UpgradeChannelNone UpgradeChannel = "none"
	// UpgradeChannelPatch - Automatically upgrade the cluster to the latest supported patch version when it becomes available
	// while keeping the minor version the same. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4,
	// 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.17.9.
	UpgradeChannelPatch UpgradeChannel = "patch"
	// UpgradeChannelRapid - Automatically upgrade the cluster to the latest supported patch release on the latest supported minor
	// version. In cases where the cluster is at a version of Kubernetes that is at an N-2 minor version where N is the latest
	// supported minor version, the cluster first upgrades to the latest supported patch version on N-1 minor version. For example,
	// if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster first
	// is upgraded to 1.18.6, then is upgraded to 1.19.1.
	UpgradeChannelRapid UpgradeChannel = "rapid"
	// UpgradeChannelStable - Automatically upgrade the cluster to the latest supported patch release on minor version N-1, where
	// N is the latest supported minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4,
	// 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.18.6.
	UpgradeChannelStable UpgradeChannel = "stable"
)

// PossibleUpgradeChannelValues returns the possible values for the UpgradeChannel const type.
func PossibleUpgradeChannelValues() []UpgradeChannel {
	return []UpgradeChannel{
		UpgradeChannelNodeImage,
		UpgradeChannelNone,
		UpgradeChannelPatch,
		UpgradeChannelRapid,
		UpgradeChannelStable,
	}
}

// UpgradeStrategy - Defines the upgrade strategy for the agent pool. The default is Rolling.
type UpgradeStrategy string

const (
	// UpgradeStrategyBlueGreen - Specifies that the agent pool will conduct blue-green upgrade.
	UpgradeStrategyBlueGreen UpgradeStrategy = "BlueGreen"
	// UpgradeStrategyRolling - Specifies that the agent pool will conduct rolling upgrade. This is the default upgrade strategy.
	UpgradeStrategyRolling UpgradeStrategy = "Rolling"
)

// PossibleUpgradeStrategyValues returns the possible values for the UpgradeStrategy const type.
func PossibleUpgradeStrategyValues() []UpgradeStrategy {
	return []UpgradeStrategy{
		UpgradeStrategyBlueGreen,
		UpgradeStrategyRolling,
	}
}

// VMState - Virtual machine state. Indicates the current state of the underlying virtual machine.
type VMState string

const (
	// VMStateDeleted - The virtual machine has been deleted by the user or due to spot eviction.
	VMStateDeleted VMState = "Deleted"
	// VMStateRunning - The virtual machine is currently running.
	VMStateRunning VMState = "Running"
)

// PossibleVMStateValues returns the possible values for the VMState const type.
func PossibleVMStateValues() []VMState {
	return []VMState{
		VMStateDeleted,
		VMStateRunning,
	}
}

// WeekDay - The weekday enum.
type WeekDay string

const (
	WeekDayFriday    WeekDay = "Friday"
	WeekDayMonday    WeekDay = "Monday"
	WeekDaySaturday  WeekDay = "Saturday"
	WeekDaySunday    WeekDay = "Sunday"
	WeekDayThursday  WeekDay = "Thursday"
	WeekDayTuesday   WeekDay = "Tuesday"
	WeekDayWednesday WeekDay = "Wednesday"
)

// PossibleWeekDayValues returns the possible values for the WeekDay const type.
func PossibleWeekDayValues() []WeekDay {
	return []WeekDay{
		WeekDayFriday,
		WeekDayMonday,
		WeekDaySaturday,
		WeekDaySunday,
		WeekDayThursday,
		WeekDayTuesday,
		WeekDayWednesday,
	}
}

// WorkloadRuntime - Determines the type of workload a node can run.
type WorkloadRuntime string

const (
	// WorkloadRuntimeKataMshvVMIsolation - Nodes can use (Kata + Cloud Hypervisor + Hyper-V) to enable Nested VM-based pods (Preview).
	// Due to the use Hyper-V, AKS node OS itself is a nested VM (the root OS) of Hyper-V. Thus it can only be used with VM series
	// that support Nested Virtualization such as Dv3 series. This naming convention will be deprecated in future releases in
	// favor of KataVmIsolation.
	WorkloadRuntimeKataMshvVMIsolation WorkloadRuntime = "KataMshvVmIsolation"
	// WorkloadRuntimeKataVMIsolation - Nodes can use (Kata + Cloud Hypervisor + Hyper-V) to enable Nested VM-based pods. Due
	// to the use Hyper-V, AKS node OS itself is a nested VM (the root OS) of Hyper-V. Thus it can only be used with VM series
	// that support Nested Virtualization such as Dv3 series.
	WorkloadRuntimeKataVMIsolation WorkloadRuntime = "KataVmIsolation"
	// WorkloadRuntimeOCIContainer - Nodes will use Kubelet to run standard OCI container workloads.
	WorkloadRuntimeOCIContainer WorkloadRuntime = "OCIContainer"
	// WorkloadRuntimeWasmWasi - Nodes will use Krustlet to run WASM workloads using the WASI provider (Preview).
	WorkloadRuntimeWasmWasi WorkloadRuntime = "WasmWasi"
)

// PossibleWorkloadRuntimeValues returns the possible values for the WorkloadRuntime const type.
func PossibleWorkloadRuntimeValues() []WorkloadRuntime {
	return []WorkloadRuntime{
		WorkloadRuntimeKataMshvVMIsolation,
		WorkloadRuntimeKataVMIsolation,
		WorkloadRuntimeOCIContainer,
		WorkloadRuntimeWasmWasi,
	}
}
