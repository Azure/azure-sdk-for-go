//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/containerservice/armcontainerservice/v4"
	"net/http"
	"net/url"
	"regexp"
	"strconv"
)

// ManagedClustersServer is a fake server for instances of the armcontainerservice.ManagedClustersClient type.
type ManagedClustersServer struct {
	// BeginAbortLatestOperation is the fake for method ManagedClustersClient.BeginAbortLatestOperation
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginAbortLatestOperation func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientBeginAbortLatestOperationOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientAbortLatestOperationResponse], errResp azfake.ErrorResponder)

	// BeginCreateOrUpdate is the fake for method ManagedClustersClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, resourceName string, parameters armcontainerservice.ManagedCluster, options *armcontainerservice.ManagedClustersClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method ManagedClustersClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientBeginDeleteOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method ManagedClustersClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientGetOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientGetResponse], errResp azfake.ErrorResponder)

	// GetAccessProfile is the fake for method ManagedClustersClient.GetAccessProfile
	// HTTP status codes to indicate success: http.StatusOK
	GetAccessProfile func(ctx context.Context, resourceGroupName string, resourceName string, roleName string, options *armcontainerservice.ManagedClustersClientGetAccessProfileOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientGetAccessProfileResponse], errResp azfake.ErrorResponder)

	// GetCommandResult is the fake for method ManagedClustersClient.GetCommandResult
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	GetCommandResult func(ctx context.Context, resourceGroupName string, resourceName string, commandID string, options *armcontainerservice.ManagedClustersClientGetCommandResultOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientGetCommandResultResponse], errResp azfake.ErrorResponder)

	// GetOSOptions is the fake for method ManagedClustersClient.GetOSOptions
	// HTTP status codes to indicate success: http.StatusOK
	GetOSOptions func(ctx context.Context, location string, options *armcontainerservice.ManagedClustersClientGetOSOptionsOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientGetOSOptionsResponse], errResp azfake.ErrorResponder)

	// GetUpgradeProfile is the fake for method ManagedClustersClient.GetUpgradeProfile
	// HTTP status codes to indicate success: http.StatusOK
	GetUpgradeProfile func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientGetUpgradeProfileOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientGetUpgradeProfileResponse], errResp azfake.ErrorResponder)

	// NewListPager is the fake for method ManagedClustersClient.NewListPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListPager func(options *armcontainerservice.ManagedClustersClientListOptions) (resp azfake.PagerResponder[armcontainerservice.ManagedClustersClientListResponse])

	// NewListByResourceGroupPager is the fake for method ManagedClustersClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceGroupName string, options *armcontainerservice.ManagedClustersClientListByResourceGroupOptions) (resp azfake.PagerResponder[armcontainerservice.ManagedClustersClientListByResourceGroupResponse])

	// ListClusterAdminCredentials is the fake for method ManagedClustersClient.ListClusterAdminCredentials
	// HTTP status codes to indicate success: http.StatusOK
	ListClusterAdminCredentials func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientListClusterAdminCredentialsOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientListClusterAdminCredentialsResponse], errResp azfake.ErrorResponder)

	// ListClusterMonitoringUserCredentials is the fake for method ManagedClustersClient.ListClusterMonitoringUserCredentials
	// HTTP status codes to indicate success: http.StatusOK
	ListClusterMonitoringUserCredentials func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientListClusterMonitoringUserCredentialsOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientListClusterMonitoringUserCredentialsResponse], errResp azfake.ErrorResponder)

	// ListClusterUserCredentials is the fake for method ManagedClustersClient.ListClusterUserCredentials
	// HTTP status codes to indicate success: http.StatusOK
	ListClusterUserCredentials func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientListClusterUserCredentialsOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientListClusterUserCredentialsResponse], errResp azfake.ErrorResponder)

	// ListKubernetesVersions is the fake for method ManagedClustersClient.ListKubernetesVersions
	// HTTP status codes to indicate success: http.StatusOK
	ListKubernetesVersions func(ctx context.Context, location string, options *armcontainerservice.ManagedClustersClientListKubernetesVersionsOptions) (resp azfake.Responder[armcontainerservice.ManagedClustersClientListKubernetesVersionsResponse], errResp azfake.ErrorResponder)

	// NewListOutboundNetworkDependenciesEndpointsPager is the fake for method ManagedClustersClient.NewListOutboundNetworkDependenciesEndpointsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListOutboundNetworkDependenciesEndpointsPager func(resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientListOutboundNetworkDependenciesEndpointsOptions) (resp azfake.PagerResponder[armcontainerservice.ManagedClustersClientListOutboundNetworkDependenciesEndpointsResponse])

	// BeginResetAADProfile is the fake for method ManagedClustersClient.BeginResetAADProfile
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginResetAADProfile func(ctx context.Context, resourceGroupName string, resourceName string, parameters armcontainerservice.ManagedClusterAADProfile, options *armcontainerservice.ManagedClustersClientBeginResetAADProfileOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientResetAADProfileResponse], errResp azfake.ErrorResponder)

	// BeginResetServicePrincipalProfile is the fake for method ManagedClustersClient.BeginResetServicePrincipalProfile
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginResetServicePrincipalProfile func(ctx context.Context, resourceGroupName string, resourceName string, parameters armcontainerservice.ManagedClusterServicePrincipalProfile, options *armcontainerservice.ManagedClustersClientBeginResetServicePrincipalProfileOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientResetServicePrincipalProfileResponse], errResp azfake.ErrorResponder)

	// BeginRotateClusterCertificates is the fake for method ManagedClustersClient.BeginRotateClusterCertificates
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginRotateClusterCertificates func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientBeginRotateClusterCertificatesOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientRotateClusterCertificatesResponse], errResp azfake.ErrorResponder)

	// BeginRotateServiceAccountSigningKeys is the fake for method ManagedClustersClient.BeginRotateServiceAccountSigningKeys
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginRotateServiceAccountSigningKeys func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientBeginRotateServiceAccountSigningKeysOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientRotateServiceAccountSigningKeysResponse], errResp azfake.ErrorResponder)

	// BeginRunCommand is the fake for method ManagedClustersClient.BeginRunCommand
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginRunCommand func(ctx context.Context, resourceGroupName string, resourceName string, requestPayload armcontainerservice.RunCommandRequest, options *armcontainerservice.ManagedClustersClientBeginRunCommandOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientRunCommandResponse], errResp azfake.ErrorResponder)

	// BeginStart is the fake for method ManagedClustersClient.BeginStart
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginStart func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientBeginStartOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientStartResponse], errResp azfake.ErrorResponder)

	// BeginStop is the fake for method ManagedClustersClient.BeginStop
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginStop func(ctx context.Context, resourceGroupName string, resourceName string, options *armcontainerservice.ManagedClustersClientBeginStopOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientStopResponse], errResp azfake.ErrorResponder)

	// BeginUpdateTags is the fake for method ManagedClustersClient.BeginUpdateTags
	// HTTP status codes to indicate success: http.StatusOK
	BeginUpdateTags func(ctx context.Context, resourceGroupName string, resourceName string, parameters armcontainerservice.TagsObject, options *armcontainerservice.ManagedClustersClientBeginUpdateTagsOptions) (resp azfake.PollerResponder[armcontainerservice.ManagedClustersClientUpdateTagsResponse], errResp azfake.ErrorResponder)
}

// NewManagedClustersServerTransport creates a new instance of ManagedClustersServerTransport with the provided implementation.
// The returned ManagedClustersServerTransport instance is connected to an instance of armcontainerservice.ManagedClustersClient by way of the
// undefined.Transporter field.
func NewManagedClustersServerTransport(srv *ManagedClustersServer) *ManagedClustersServerTransport {
	return &ManagedClustersServerTransport{srv: srv}
}

// ManagedClustersServerTransport connects instances of armcontainerservice.ManagedClustersClient to instances of ManagedClustersServer.
// Don't use this type directly, use NewManagedClustersServerTransport instead.
type ManagedClustersServerTransport struct {
	srv                                              *ManagedClustersServer
	beginAbortLatestOperation                        *azfake.PollerResponder[armcontainerservice.ManagedClustersClientAbortLatestOperationResponse]
	beginCreateOrUpdate                              *azfake.PollerResponder[armcontainerservice.ManagedClustersClientCreateOrUpdateResponse]
	beginDelete                                      *azfake.PollerResponder[armcontainerservice.ManagedClustersClientDeleteResponse]
	newListPager                                     *azfake.PagerResponder[armcontainerservice.ManagedClustersClientListResponse]
	newListByResourceGroupPager                      *azfake.PagerResponder[armcontainerservice.ManagedClustersClientListByResourceGroupResponse]
	newListOutboundNetworkDependenciesEndpointsPager *azfake.PagerResponder[armcontainerservice.ManagedClustersClientListOutboundNetworkDependenciesEndpointsResponse]
	beginResetAADProfile                             *azfake.PollerResponder[armcontainerservice.ManagedClustersClientResetAADProfileResponse]
	beginResetServicePrincipalProfile                *azfake.PollerResponder[armcontainerservice.ManagedClustersClientResetServicePrincipalProfileResponse]
	beginRotateClusterCertificates                   *azfake.PollerResponder[armcontainerservice.ManagedClustersClientRotateClusterCertificatesResponse]
	beginRotateServiceAccountSigningKeys             *azfake.PollerResponder[armcontainerservice.ManagedClustersClientRotateServiceAccountSigningKeysResponse]
	beginRunCommand                                  *azfake.PollerResponder[armcontainerservice.ManagedClustersClientRunCommandResponse]
	beginStart                                       *azfake.PollerResponder[armcontainerservice.ManagedClustersClientStartResponse]
	beginStop                                        *azfake.PollerResponder[armcontainerservice.ManagedClustersClientStopResponse]
	beginUpdateTags                                  *azfake.PollerResponder[armcontainerservice.ManagedClustersClientUpdateTagsResponse]
}

// Do implements the policy.Transporter interface for ManagedClustersServerTransport.
func (m *ManagedClustersServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "ManagedClustersClient.BeginAbortLatestOperation":
		resp, err = m.dispatchBeginAbortLatestOperation(req)
	case "ManagedClustersClient.BeginCreateOrUpdate":
		resp, err = m.dispatchBeginCreateOrUpdate(req)
	case "ManagedClustersClient.BeginDelete":
		resp, err = m.dispatchBeginDelete(req)
	case "ManagedClustersClient.Get":
		resp, err = m.dispatchGet(req)
	case "ManagedClustersClient.GetAccessProfile":
		resp, err = m.dispatchGetAccessProfile(req)
	case "ManagedClustersClient.GetCommandResult":
		resp, err = m.dispatchGetCommandResult(req)
	case "ManagedClustersClient.GetOSOptions":
		resp, err = m.dispatchGetOSOptions(req)
	case "ManagedClustersClient.GetUpgradeProfile":
		resp, err = m.dispatchGetUpgradeProfile(req)
	case "ManagedClustersClient.NewListPager":
		resp, err = m.dispatchNewListPager(req)
	case "ManagedClustersClient.NewListByResourceGroupPager":
		resp, err = m.dispatchNewListByResourceGroupPager(req)
	case "ManagedClustersClient.ListClusterAdminCredentials":
		resp, err = m.dispatchListClusterAdminCredentials(req)
	case "ManagedClustersClient.ListClusterMonitoringUserCredentials":
		resp, err = m.dispatchListClusterMonitoringUserCredentials(req)
	case "ManagedClustersClient.ListClusterUserCredentials":
		resp, err = m.dispatchListClusterUserCredentials(req)
	case "ManagedClustersClient.ListKubernetesVersions":
		resp, err = m.dispatchListKubernetesVersions(req)
	case "ManagedClustersClient.NewListOutboundNetworkDependenciesEndpointsPager":
		resp, err = m.dispatchNewListOutboundNetworkDependenciesEndpointsPager(req)
	case "ManagedClustersClient.BeginResetAADProfile":
		resp, err = m.dispatchBeginResetAADProfile(req)
	case "ManagedClustersClient.BeginResetServicePrincipalProfile":
		resp, err = m.dispatchBeginResetServicePrincipalProfile(req)
	case "ManagedClustersClient.BeginRotateClusterCertificates":
		resp, err = m.dispatchBeginRotateClusterCertificates(req)
	case "ManagedClustersClient.BeginRotateServiceAccountSigningKeys":
		resp, err = m.dispatchBeginRotateServiceAccountSigningKeys(req)
	case "ManagedClustersClient.BeginRunCommand":
		resp, err = m.dispatchBeginRunCommand(req)
	case "ManagedClustersClient.BeginStart":
		resp, err = m.dispatchBeginStart(req)
	case "ManagedClustersClient.BeginStop":
		resp, err = m.dispatchBeginStop(req)
	case "ManagedClustersClient.BeginUpdateTags":
		resp, err = m.dispatchBeginUpdateTags(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginAbortLatestOperation(req *http.Request) (*http.Response, error) {
	if m.srv.BeginAbortLatestOperation == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginAbortLatestOperation not implemented")}
	}
	if m.beginAbortLatestOperation == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedclusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/abort`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginAbortLatestOperation(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginAbortLatestOperation = &respr
	}

	resp, err := server.PollerResponderNext(m.beginAbortLatestOperation, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginAbortLatestOperation) {
		m.beginAbortLatestOperation = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if m.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	if m.beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcontainerservice.ManagedCluster](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginCreateOrUpdate = &respr
	}

	resp, err := server.PollerResponderNext(m.beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginCreateOrUpdate) {
		m.beginCreateOrUpdate = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if m.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	if m.beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		ignorePodDisruptionBudgetUnescaped, err := url.QueryUnescape(qp.Get("ignore-pod-disruption-budget"))
		if err != nil {
			return nil, err
		}
		ignorePodDisruptionBudgetParam, err := parseOptional(ignorePodDisruptionBudgetUnescaped, strconv.ParseBool)
		if err != nil {
			return nil, err
		}
		var options *armcontainerservice.ManagedClustersClientBeginDeleteOptions
		if ignorePodDisruptionBudgetParam != nil {
			options = &armcontainerservice.ManagedClustersClientBeginDeleteOptions{
				IgnorePodDisruptionBudget: ignorePodDisruptionBudgetParam,
			}
		}
		respr, errRespr := m.srv.BeginDelete(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginDelete = &respr
	}

	resp, err := server.PollerResponderNext(m.beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginDelete) {
		m.beginDelete = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if m.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.Get(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ManagedCluster, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchGetAccessProfile(req *http.Request) (*http.Response, error) {
	if m.srv.GetAccessProfile == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetAccessProfile not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/accessProfiles/(?P<roleName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/listCredential`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	roleNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("roleName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.GetAccessProfile(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, roleNameUnescaped, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ManagedClusterAccessProfile, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchGetCommandResult(req *http.Request) (*http.Response, error) {
	if m.srv.GetCommandResult == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetCommandResult not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/commandResults/(?P<commandId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	commandIDUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("commandId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.GetCommandResult(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, commandIDUnescaped, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK, http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).RunCommandResult, req)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Location; val != nil {
		resp.Header.Set("Location", *val)
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchGetOSOptions(req *http.Request) (*http.Response, error) {
	if m.srv.GetOSOptions == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetOSOptions not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/locations/(?P<location>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/osOptions/default`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	locationUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("location")])
	if err != nil {
		return nil, err
	}
	resourceTypeUnescaped, err := url.QueryUnescape(qp.Get("resource-type"))
	if err != nil {
		return nil, err
	}
	resourceTypeParam := getOptional(resourceTypeUnescaped)
	var options *armcontainerservice.ManagedClustersClientGetOSOptionsOptions
	if resourceTypeParam != nil {
		options = &armcontainerservice.ManagedClustersClientGetOSOptionsOptions{
			ResourceType: resourceTypeParam,
		}
	}
	respr, errRespr := m.srv.GetOSOptions(req.Context(), locationUnescaped, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).OSOptionProfile, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchGetUpgradeProfile(req *http.Request) (*http.Response, error) {
	if m.srv.GetUpgradeProfile == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetUpgradeProfile not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/upgradeProfiles/default`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.GetUpgradeProfile(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ManagedClusterUpgradeProfile, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchNewListPager(req *http.Request) (*http.Response, error) {
	if m.srv.NewListPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListPager not implemented")}
	}
	if m.newListPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resp := m.srv.NewListPager(nil)
		m.newListPager = &resp
		server.PagerResponderInjectNextLinks(m.newListPager, req, func(page *armcontainerservice.ManagedClustersClientListResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(m.newListPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(m.newListPager) {
		m.newListPager = nil
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if m.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	if m.newListByResourceGroupPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resp := m.srv.NewListByResourceGroupPager(resourceGroupNameUnescaped, nil)
		m.newListByResourceGroupPager = &resp
		server.PagerResponderInjectNextLinks(m.newListByResourceGroupPager, req, func(page *armcontainerservice.ManagedClustersClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(m.newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(m.newListByResourceGroupPager) {
		m.newListByResourceGroupPager = nil
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchListClusterAdminCredentials(req *http.Request) (*http.Response, error) {
	if m.srv.ListClusterAdminCredentials == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListClusterAdminCredentials not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/listClusterAdminCredential`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	serverFqdnUnescaped, err := url.QueryUnescape(qp.Get("server-fqdn"))
	if err != nil {
		return nil, err
	}
	serverFqdnParam := getOptional(serverFqdnUnescaped)
	var options *armcontainerservice.ManagedClustersClientListClusterAdminCredentialsOptions
	if serverFqdnParam != nil {
		options = &armcontainerservice.ManagedClustersClientListClusterAdminCredentialsOptions{
			ServerFqdn: serverFqdnParam,
		}
	}
	respr, errRespr := m.srv.ListClusterAdminCredentials(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CredentialResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchListClusterMonitoringUserCredentials(req *http.Request) (*http.Response, error) {
	if m.srv.ListClusterMonitoringUserCredentials == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListClusterMonitoringUserCredentials not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/listClusterMonitoringUserCredential`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	serverFqdnUnescaped, err := url.QueryUnescape(qp.Get("server-fqdn"))
	if err != nil {
		return nil, err
	}
	serverFqdnParam := getOptional(serverFqdnUnescaped)
	var options *armcontainerservice.ManagedClustersClientListClusterMonitoringUserCredentialsOptions
	if serverFqdnParam != nil {
		options = &armcontainerservice.ManagedClustersClientListClusterMonitoringUserCredentialsOptions{
			ServerFqdn: serverFqdnParam,
		}
	}
	respr, errRespr := m.srv.ListClusterMonitoringUserCredentials(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CredentialResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchListClusterUserCredentials(req *http.Request) (*http.Response, error) {
	if m.srv.ListClusterUserCredentials == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListClusterUserCredentials not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/listClusterUserCredential`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
	if err != nil {
		return nil, err
	}
	serverFqdnUnescaped, err := url.QueryUnescape(qp.Get("server-fqdn"))
	if err != nil {
		return nil, err
	}
	serverFqdnParam := getOptional(serverFqdnUnescaped)
	formatUnescaped, err := url.QueryUnescape(qp.Get("format"))
	if err != nil {
		return nil, err
	}
	formatParam := getOptional(armcontainerservice.Format(formatUnescaped))
	var options *armcontainerservice.ManagedClustersClientListClusterUserCredentialsOptions
	if serverFqdnParam != nil || formatParam != nil {
		options = &armcontainerservice.ManagedClustersClientListClusterUserCredentialsOptions{
			ServerFqdn: serverFqdnParam,
			Format:     formatParam,
		}
	}
	respr, errRespr := m.srv.ListClusterUserCredentials(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CredentialResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchListKubernetesVersions(req *http.Request) (*http.Response, error) {
	if m.srv.ListKubernetesVersions == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListKubernetesVersions not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/locations/(?P<location>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/kubernetesVersions`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	locationUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("location")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.ListKubernetesVersions(req.Context(), locationUnescaped, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KubernetesVersionListResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchNewListOutboundNetworkDependenciesEndpointsPager(req *http.Request) (*http.Response, error) {
	if m.srv.NewListOutboundNetworkDependenciesEndpointsPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListOutboundNetworkDependenciesEndpointsPager not implemented")}
	}
	if m.newListOutboundNetworkDependenciesEndpointsPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/outboundNetworkDependenciesEndpoints`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		resp := m.srv.NewListOutboundNetworkDependenciesEndpointsPager(resourceGroupNameUnescaped, resourceNameUnescaped, nil)
		m.newListOutboundNetworkDependenciesEndpointsPager = &resp
		server.PagerResponderInjectNextLinks(m.newListOutboundNetworkDependenciesEndpointsPager, req, func(page *armcontainerservice.ManagedClustersClientListOutboundNetworkDependenciesEndpointsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(m.newListOutboundNetworkDependenciesEndpointsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(m.newListOutboundNetworkDependenciesEndpointsPager) {
		m.newListOutboundNetworkDependenciesEndpointsPager = nil
	}
	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginResetAADProfile(req *http.Request) (*http.Response, error) {
	if m.srv.BeginResetAADProfile == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginResetAADProfile not implemented")}
	}
	if m.beginResetAADProfile == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resetAADProfile`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcontainerservice.ManagedClusterAADProfile](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginResetAADProfile(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginResetAADProfile = &respr
	}

	resp, err := server.PollerResponderNext(m.beginResetAADProfile, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginResetAADProfile) {
		m.beginResetAADProfile = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginResetServicePrincipalProfile(req *http.Request) (*http.Response, error) {
	if m.srv.BeginResetServicePrincipalProfile == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginResetServicePrincipalProfile not implemented")}
	}
	if m.beginResetServicePrincipalProfile == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resetServicePrincipalProfile`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcontainerservice.ManagedClusterServicePrincipalProfile](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginResetServicePrincipalProfile(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginResetServicePrincipalProfile = &respr
	}

	resp, err := server.PollerResponderNext(m.beginResetServicePrincipalProfile, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginResetServicePrincipalProfile) {
		m.beginResetServicePrincipalProfile = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginRotateClusterCertificates(req *http.Request) (*http.Response, error) {
	if m.srv.BeginRotateClusterCertificates == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginRotateClusterCertificates not implemented")}
	}
	if m.beginRotateClusterCertificates == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/rotateClusterCertificates`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginRotateClusterCertificates(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginRotateClusterCertificates = &respr
	}

	resp, err := server.PollerResponderNext(m.beginRotateClusterCertificates, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginRotateClusterCertificates) {
		m.beginRotateClusterCertificates = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginRotateServiceAccountSigningKeys(req *http.Request) (*http.Response, error) {
	if m.srv.BeginRotateServiceAccountSigningKeys == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginRotateServiceAccountSigningKeys not implemented")}
	}
	if m.beginRotateServiceAccountSigningKeys == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/rotateServiceAccountSigningKeys`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginRotateServiceAccountSigningKeys(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginRotateServiceAccountSigningKeys = &respr
	}

	resp, err := server.PollerResponderNext(m.beginRotateServiceAccountSigningKeys, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginRotateServiceAccountSigningKeys) {
		m.beginRotateServiceAccountSigningKeys = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginRunCommand(req *http.Request) (*http.Response, error) {
	if m.srv.BeginRunCommand == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginRunCommand not implemented")}
	}
	if m.beginRunCommand == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/runCommand`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcontainerservice.RunCommandRequest](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginRunCommand(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginRunCommand = &respr
	}

	resp, err := server.PollerResponderNext(m.beginRunCommand, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginRunCommand) {
		m.beginRunCommand = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginStart(req *http.Request) (*http.Response, error) {
	if m.srv.BeginStart == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginStart not implemented")}
	}
	if m.beginStart == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/start`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginStart(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginStart = &respr
	}

	resp, err := server.PollerResponderNext(m.beginStart, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginStart) {
		m.beginStart = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginStop(req *http.Request) (*http.Response, error) {
	if m.srv.BeginStop == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginStop not implemented")}
	}
	if m.beginStop == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/stop`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginStop(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginStop = &respr
	}

	resp, err := server.PollerResponderNext(m.beginStop, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginStop) {
		m.beginStop = nil
	}

	return resp, nil
}

func (m *ManagedClustersServerTransport) dispatchBeginUpdateTags(req *http.Request) (*http.Response, error) {
	if m.srv.BeginUpdateTags == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdateTags not implemented")}
	}
	if m.beginUpdateTags == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft.ContainerService/managedClusters/(?P<resourceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcontainerservice.TagsObject](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resourceNameUnescaped, err := url.PathUnescape(matches[regex.SubexpIndex("resourceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := m.srv.BeginUpdateTags(req.Context(), resourceGroupNameUnescaped, resourceNameUnescaped, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		m.beginUpdateTags = &respr
	}

	resp, err := server.PollerResponderNext(m.beginUpdateTags, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(m.beginUpdateTags) {
		m.beginUpdateTags = nil
	}

	return resp, nil
}
