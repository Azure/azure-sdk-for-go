// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/cosmos/armcosmos/v3"
	"net/http"
	"net/url"
	"regexp"
)

// CassandraResourcesServer is a fake server for instances of the armcosmos.CassandraResourcesClient type.
type CassandraResourcesServer struct {
	// BeginCreateUpdateCassandraKeyspace is the fake for method CassandraResourcesClient.BeginCreateUpdateCassandraKeyspace
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateUpdateCassandraKeyspace func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, createUpdateCassandraKeyspaceParameters armcosmos.CassandraKeyspaceCreateUpdateParameters, options *armcosmos.CassandraResourcesClientBeginCreateUpdateCassandraKeyspaceOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse], errResp azfake.ErrorResponder)

	// BeginCreateUpdateCassandraTable is the fake for method CassandraResourcesClient.BeginCreateUpdateCassandraTable
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateUpdateCassandraTable func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, createUpdateCassandraTableParameters armcosmos.CassandraTableCreateUpdateParameters, options *armcosmos.CassandraResourcesClientBeginCreateUpdateCassandraTableOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientCreateUpdateCassandraTableResponse], errResp azfake.ErrorResponder)

	// BeginDeleteCassandraKeyspace is the fake for method CassandraResourcesClient.BeginDeleteCassandraKeyspace
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteCassandraKeyspace func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, options *armcosmos.CassandraResourcesClientBeginDeleteCassandraKeyspaceOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientDeleteCassandraKeyspaceResponse], errResp azfake.ErrorResponder)

	// BeginDeleteCassandraTable is the fake for method CassandraResourcesClient.BeginDeleteCassandraTable
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteCassandraTable func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, options *armcosmos.CassandraResourcesClientBeginDeleteCassandraTableOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientDeleteCassandraTableResponse], errResp azfake.ErrorResponder)

	// GetCassandraKeyspace is the fake for method CassandraResourcesClient.GetCassandraKeyspace
	// HTTP status codes to indicate success: http.StatusOK
	GetCassandraKeyspace func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, options *armcosmos.CassandraResourcesClientGetCassandraKeyspaceOptions) (resp azfake.Responder[armcosmos.CassandraResourcesClientGetCassandraKeyspaceResponse], errResp azfake.ErrorResponder)

	// GetCassandraKeyspaceThroughput is the fake for method CassandraResourcesClient.GetCassandraKeyspaceThroughput
	// HTTP status codes to indicate success: http.StatusOK
	GetCassandraKeyspaceThroughput func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, options *armcosmos.CassandraResourcesClientGetCassandraKeyspaceThroughputOptions) (resp azfake.Responder[armcosmos.CassandraResourcesClientGetCassandraKeyspaceThroughputResponse], errResp azfake.ErrorResponder)

	// GetCassandraTable is the fake for method CassandraResourcesClient.GetCassandraTable
	// HTTP status codes to indicate success: http.StatusOK
	GetCassandraTable func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, options *armcosmos.CassandraResourcesClientGetCassandraTableOptions) (resp azfake.Responder[armcosmos.CassandraResourcesClientGetCassandraTableResponse], errResp azfake.ErrorResponder)

	// GetCassandraTableThroughput is the fake for method CassandraResourcesClient.GetCassandraTableThroughput
	// HTTP status codes to indicate success: http.StatusOK
	GetCassandraTableThroughput func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, options *armcosmos.CassandraResourcesClientGetCassandraTableThroughputOptions) (resp azfake.Responder[armcosmos.CassandraResourcesClientGetCassandraTableThroughputResponse], errResp azfake.ErrorResponder)

	// NewListCassandraKeyspacesPager is the fake for method CassandraResourcesClient.NewListCassandraKeyspacesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListCassandraKeyspacesPager func(resourceGroupName string, accountName string, options *armcosmos.CassandraResourcesClientListCassandraKeyspacesOptions) (resp azfake.PagerResponder[armcosmos.CassandraResourcesClientListCassandraKeyspacesResponse])

	// NewListCassandraTablesPager is the fake for method CassandraResourcesClient.NewListCassandraTablesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListCassandraTablesPager func(resourceGroupName string, accountName string, keyspaceName string, options *armcosmos.CassandraResourcesClientListCassandraTablesOptions) (resp azfake.PagerResponder[armcosmos.CassandraResourcesClientListCassandraTablesResponse])

	// BeginMigrateCassandraKeyspaceToAutoscale is the fake for method CassandraResourcesClient.BeginMigrateCassandraKeyspaceToAutoscale
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginMigrateCassandraKeyspaceToAutoscale func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, options *armcosmos.CassandraResourcesClientBeginMigrateCassandraKeyspaceToAutoscaleOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse], errResp azfake.ErrorResponder)

	// BeginMigrateCassandraKeyspaceToManualThroughput is the fake for method CassandraResourcesClient.BeginMigrateCassandraKeyspaceToManualThroughput
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginMigrateCassandraKeyspaceToManualThroughput func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, options *armcosmos.CassandraResourcesClientBeginMigrateCassandraKeyspaceToManualThroughputOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse], errResp azfake.ErrorResponder)

	// BeginMigrateCassandraTableToAutoscale is the fake for method CassandraResourcesClient.BeginMigrateCassandraTableToAutoscale
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginMigrateCassandraTableToAutoscale func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, options *armcosmos.CassandraResourcesClientBeginMigrateCassandraTableToAutoscaleOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse], errResp azfake.ErrorResponder)

	// BeginMigrateCassandraTableToManualThroughput is the fake for method CassandraResourcesClient.BeginMigrateCassandraTableToManualThroughput
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginMigrateCassandraTableToManualThroughput func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, options *armcosmos.CassandraResourcesClientBeginMigrateCassandraTableToManualThroughputOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse], errResp azfake.ErrorResponder)

	// BeginUpdateCassandraKeyspaceThroughput is the fake for method CassandraResourcesClient.BeginUpdateCassandraKeyspaceThroughput
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdateCassandraKeyspaceThroughput func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, updateThroughputParameters armcosmos.ThroughputSettingsUpdateParameters, options *armcosmos.CassandraResourcesClientBeginUpdateCassandraKeyspaceThroughputOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse], errResp azfake.ErrorResponder)

	// BeginUpdateCassandraTableThroughput is the fake for method CassandraResourcesClient.BeginUpdateCassandraTableThroughput
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdateCassandraTableThroughput func(ctx context.Context, resourceGroupName string, accountName string, keyspaceName string, tableName string, updateThroughputParameters armcosmos.ThroughputSettingsUpdateParameters, options *armcosmos.CassandraResourcesClientBeginUpdateCassandraTableThroughputOptions) (resp azfake.PollerResponder[armcosmos.CassandraResourcesClientUpdateCassandraTableThroughputResponse], errResp azfake.ErrorResponder)
}

// NewCassandraResourcesServerTransport creates a new instance of CassandraResourcesServerTransport with the provided implementation.
// The returned CassandraResourcesServerTransport instance is connected to an instance of armcosmos.CassandraResourcesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewCassandraResourcesServerTransport(srv *CassandraResourcesServer) *CassandraResourcesServerTransport {
	return &CassandraResourcesServerTransport{
		srv:                                             srv,
		beginCreateUpdateCassandraKeyspace:              newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse]](),
		beginCreateUpdateCassandraTable:                 newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientCreateUpdateCassandraTableResponse]](),
		beginDeleteCassandraKeyspace:                    newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientDeleteCassandraKeyspaceResponse]](),
		beginDeleteCassandraTable:                       newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientDeleteCassandraTableResponse]](),
		newListCassandraKeyspacesPager:                  newTracker[azfake.PagerResponder[armcosmos.CassandraResourcesClientListCassandraKeyspacesResponse]](),
		newListCassandraTablesPager:                     newTracker[azfake.PagerResponder[armcosmos.CassandraResourcesClientListCassandraTablesResponse]](),
		beginMigrateCassandraKeyspaceToAutoscale:        newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse]](),
		beginMigrateCassandraKeyspaceToManualThroughput: newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse]](),
		beginMigrateCassandraTableToAutoscale:           newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse]](),
		beginMigrateCassandraTableToManualThroughput:    newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse]](),
		beginUpdateCassandraKeyspaceThroughput:          newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse]](),
		beginUpdateCassandraTableThroughput:             newTracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientUpdateCassandraTableThroughputResponse]](),
	}
}

// CassandraResourcesServerTransport connects instances of armcosmos.CassandraResourcesClient to instances of CassandraResourcesServer.
// Don't use this type directly, use NewCassandraResourcesServerTransport instead.
type CassandraResourcesServerTransport struct {
	srv                                             *CassandraResourcesServer
	beginCreateUpdateCassandraKeyspace              *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse]]
	beginCreateUpdateCassandraTable                 *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientCreateUpdateCassandraTableResponse]]
	beginDeleteCassandraKeyspace                    *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientDeleteCassandraKeyspaceResponse]]
	beginDeleteCassandraTable                       *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientDeleteCassandraTableResponse]]
	newListCassandraKeyspacesPager                  *tracker[azfake.PagerResponder[armcosmos.CassandraResourcesClientListCassandraKeyspacesResponse]]
	newListCassandraTablesPager                     *tracker[azfake.PagerResponder[armcosmos.CassandraResourcesClientListCassandraTablesResponse]]
	beginMigrateCassandraKeyspaceToAutoscale        *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse]]
	beginMigrateCassandraKeyspaceToManualThroughput *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse]]
	beginMigrateCassandraTableToAutoscale           *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse]]
	beginMigrateCassandraTableToManualThroughput    *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse]]
	beginUpdateCassandraKeyspaceThroughput          *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse]]
	beginUpdateCassandraTableThroughput             *tracker[azfake.PollerResponder[armcosmos.CassandraResourcesClientUpdateCassandraTableThroughputResponse]]
}

// Do implements the policy.Transporter interface for CassandraResourcesServerTransport.
func (c *CassandraResourcesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return c.dispatchToMethodFake(req, method)
}

func (c *CassandraResourcesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if cassandraResourcesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = cassandraResourcesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "CassandraResourcesClient.BeginCreateUpdateCassandraKeyspace":
				res.resp, res.err = c.dispatchBeginCreateUpdateCassandraKeyspace(req)
			case "CassandraResourcesClient.BeginCreateUpdateCassandraTable":
				res.resp, res.err = c.dispatchBeginCreateUpdateCassandraTable(req)
			case "CassandraResourcesClient.BeginDeleteCassandraKeyspace":
				res.resp, res.err = c.dispatchBeginDeleteCassandraKeyspace(req)
			case "CassandraResourcesClient.BeginDeleteCassandraTable":
				res.resp, res.err = c.dispatchBeginDeleteCassandraTable(req)
			case "CassandraResourcesClient.GetCassandraKeyspace":
				res.resp, res.err = c.dispatchGetCassandraKeyspace(req)
			case "CassandraResourcesClient.GetCassandraKeyspaceThroughput":
				res.resp, res.err = c.dispatchGetCassandraKeyspaceThroughput(req)
			case "CassandraResourcesClient.GetCassandraTable":
				res.resp, res.err = c.dispatchGetCassandraTable(req)
			case "CassandraResourcesClient.GetCassandraTableThroughput":
				res.resp, res.err = c.dispatchGetCassandraTableThroughput(req)
			case "CassandraResourcesClient.NewListCassandraKeyspacesPager":
				res.resp, res.err = c.dispatchNewListCassandraKeyspacesPager(req)
			case "CassandraResourcesClient.NewListCassandraTablesPager":
				res.resp, res.err = c.dispatchNewListCassandraTablesPager(req)
			case "CassandraResourcesClient.BeginMigrateCassandraKeyspaceToAutoscale":
				res.resp, res.err = c.dispatchBeginMigrateCassandraKeyspaceToAutoscale(req)
			case "CassandraResourcesClient.BeginMigrateCassandraKeyspaceToManualThroughput":
				res.resp, res.err = c.dispatchBeginMigrateCassandraKeyspaceToManualThroughput(req)
			case "CassandraResourcesClient.BeginMigrateCassandraTableToAutoscale":
				res.resp, res.err = c.dispatchBeginMigrateCassandraTableToAutoscale(req)
			case "CassandraResourcesClient.BeginMigrateCassandraTableToManualThroughput":
				res.resp, res.err = c.dispatchBeginMigrateCassandraTableToManualThroughput(req)
			case "CassandraResourcesClient.BeginUpdateCassandraKeyspaceThroughput":
				res.resp, res.err = c.dispatchBeginUpdateCassandraKeyspaceThroughput(req)
			case "CassandraResourcesClient.BeginUpdateCassandraTableThroughput":
				res.resp, res.err = c.dispatchBeginUpdateCassandraTableThroughput(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (c *CassandraResourcesServerTransport) dispatchBeginCreateUpdateCassandraKeyspace(req *http.Request) (*http.Response, error) {
	if c.srv.BeginCreateUpdateCassandraKeyspace == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateUpdateCassandraKeyspace not implemented")}
	}
	beginCreateUpdateCassandraKeyspace := c.beginCreateUpdateCassandraKeyspace.get(req)
	if beginCreateUpdateCassandraKeyspace == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.CassandraKeyspaceCreateUpdateParameters](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginCreateUpdateCassandraKeyspace(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateUpdateCassandraKeyspace = &respr
		c.beginCreateUpdateCassandraKeyspace.add(req, beginCreateUpdateCassandraKeyspace)
	}

	resp, err := server.PollerResponderNext(beginCreateUpdateCassandraKeyspace, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginCreateUpdateCassandraKeyspace.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateUpdateCassandraKeyspace) {
		c.beginCreateUpdateCassandraKeyspace.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginCreateUpdateCassandraTable(req *http.Request) (*http.Response, error) {
	if c.srv.BeginCreateUpdateCassandraTable == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateUpdateCassandraTable not implemented")}
	}
	beginCreateUpdateCassandraTable := c.beginCreateUpdateCassandraTable.get(req)
	if beginCreateUpdateCassandraTable == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.CassandraTableCreateUpdateParameters](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginCreateUpdateCassandraTable(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateUpdateCassandraTable = &respr
		c.beginCreateUpdateCassandraTable.add(req, beginCreateUpdateCassandraTable)
	}

	resp, err := server.PollerResponderNext(beginCreateUpdateCassandraTable, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginCreateUpdateCassandraTable.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateUpdateCassandraTable) {
		c.beginCreateUpdateCassandraTable.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginDeleteCassandraKeyspace(req *http.Request) (*http.Response, error) {
	if c.srv.BeginDeleteCassandraKeyspace == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteCassandraKeyspace not implemented")}
	}
	beginDeleteCassandraKeyspace := c.beginDeleteCassandraKeyspace.get(req)
	if beginDeleteCassandraKeyspace == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginDeleteCassandraKeyspace(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteCassandraKeyspace = &respr
		c.beginDeleteCassandraKeyspace.add(req, beginDeleteCassandraKeyspace)
	}

	resp, err := server.PollerResponderNext(beginDeleteCassandraKeyspace, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		c.beginDeleteCassandraKeyspace.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteCassandraKeyspace) {
		c.beginDeleteCassandraKeyspace.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginDeleteCassandraTable(req *http.Request) (*http.Response, error) {
	if c.srv.BeginDeleteCassandraTable == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteCassandraTable not implemented")}
	}
	beginDeleteCassandraTable := c.beginDeleteCassandraTable.get(req)
	if beginDeleteCassandraTable == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginDeleteCassandraTable(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteCassandraTable = &respr
		c.beginDeleteCassandraTable.add(req, beginDeleteCassandraTable)
	}

	resp, err := server.PollerResponderNext(beginDeleteCassandraTable, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		c.beginDeleteCassandraTable.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteCassandraTable) {
		c.beginDeleteCassandraTable.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchGetCassandraKeyspace(req *http.Request) (*http.Response, error) {
	if c.srv.GetCassandraKeyspace == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetCassandraKeyspace not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.GetCassandraKeyspace(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CassandraKeyspaceGetResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchGetCassandraKeyspaceThroughput(req *http.Request) (*http.Response, error) {
	if c.srv.GetCassandraKeyspaceThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetCassandraKeyspaceThroughput not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.GetCassandraKeyspaceThroughput(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ThroughputSettingsGetResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchGetCassandraTable(req *http.Request) (*http.Response, error) {
	if c.srv.GetCassandraTable == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetCassandraTable not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
	if err != nil {
		return nil, err
	}
	tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.GetCassandraTable(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CassandraTableGetResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchGetCassandraTableThroughput(req *http.Request) (*http.Response, error) {
	if c.srv.GetCassandraTableThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetCassandraTableThroughput not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
	if err != nil {
		return nil, err
	}
	tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.GetCassandraTableThroughput(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ThroughputSettingsGetResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchNewListCassandraKeyspacesPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListCassandraKeyspacesPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListCassandraKeyspacesPager not implemented")}
	}
	newListCassandraKeyspacesPager := c.newListCassandraKeyspacesPager.get(req)
	if newListCassandraKeyspacesPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		resp := c.srv.NewListCassandraKeyspacesPager(resourceGroupNameParam, accountNameParam, nil)
		newListCassandraKeyspacesPager = &resp
		c.newListCassandraKeyspacesPager.add(req, newListCassandraKeyspacesPager)
	}
	resp, err := server.PagerResponderNext(newListCassandraKeyspacesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListCassandraKeyspacesPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListCassandraKeyspacesPager) {
		c.newListCassandraKeyspacesPager.remove(req)
	}
	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchNewListCassandraTablesPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListCassandraTablesPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListCassandraTablesPager not implemented")}
	}
	newListCassandraTablesPager := c.newListCassandraTablesPager.get(req)
	if newListCassandraTablesPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		resp := c.srv.NewListCassandraTablesPager(resourceGroupNameParam, accountNameParam, keyspaceNameParam, nil)
		newListCassandraTablesPager = &resp
		c.newListCassandraTablesPager.add(req, newListCassandraTablesPager)
	}
	resp, err := server.PagerResponderNext(newListCassandraTablesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListCassandraTablesPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListCassandraTablesPager) {
		c.newListCassandraTablesPager.remove(req)
	}
	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginMigrateCassandraKeyspaceToAutoscale(req *http.Request) (*http.Response, error) {
	if c.srv.BeginMigrateCassandraKeyspaceToAutoscale == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginMigrateCassandraKeyspaceToAutoscale not implemented")}
	}
	beginMigrateCassandraKeyspaceToAutoscale := c.beginMigrateCassandraKeyspaceToAutoscale.get(req)
	if beginMigrateCassandraKeyspaceToAutoscale == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default/migrateToAutoscale`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginMigrateCassandraKeyspaceToAutoscale(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginMigrateCassandraKeyspaceToAutoscale = &respr
		c.beginMigrateCassandraKeyspaceToAutoscale.add(req, beginMigrateCassandraKeyspaceToAutoscale)
	}

	resp, err := server.PollerResponderNext(beginMigrateCassandraKeyspaceToAutoscale, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginMigrateCassandraKeyspaceToAutoscale.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginMigrateCassandraKeyspaceToAutoscale) {
		c.beginMigrateCassandraKeyspaceToAutoscale.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginMigrateCassandraKeyspaceToManualThroughput(req *http.Request) (*http.Response, error) {
	if c.srv.BeginMigrateCassandraKeyspaceToManualThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginMigrateCassandraKeyspaceToManualThroughput not implemented")}
	}
	beginMigrateCassandraKeyspaceToManualThroughput := c.beginMigrateCassandraKeyspaceToManualThroughput.get(req)
	if beginMigrateCassandraKeyspaceToManualThroughput == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default/migrateToManualThroughput`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginMigrateCassandraKeyspaceToManualThroughput(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginMigrateCassandraKeyspaceToManualThroughput = &respr
		c.beginMigrateCassandraKeyspaceToManualThroughput.add(req, beginMigrateCassandraKeyspaceToManualThroughput)
	}

	resp, err := server.PollerResponderNext(beginMigrateCassandraKeyspaceToManualThroughput, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginMigrateCassandraKeyspaceToManualThroughput.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginMigrateCassandraKeyspaceToManualThroughput) {
		c.beginMigrateCassandraKeyspaceToManualThroughput.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginMigrateCassandraTableToAutoscale(req *http.Request) (*http.Response, error) {
	if c.srv.BeginMigrateCassandraTableToAutoscale == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginMigrateCassandraTableToAutoscale not implemented")}
	}
	beginMigrateCassandraTableToAutoscale := c.beginMigrateCassandraTableToAutoscale.get(req)
	if beginMigrateCassandraTableToAutoscale == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default/migrateToAutoscale`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginMigrateCassandraTableToAutoscale(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginMigrateCassandraTableToAutoscale = &respr
		c.beginMigrateCassandraTableToAutoscale.add(req, beginMigrateCassandraTableToAutoscale)
	}

	resp, err := server.PollerResponderNext(beginMigrateCassandraTableToAutoscale, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginMigrateCassandraTableToAutoscale.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginMigrateCassandraTableToAutoscale) {
		c.beginMigrateCassandraTableToAutoscale.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginMigrateCassandraTableToManualThroughput(req *http.Request) (*http.Response, error) {
	if c.srv.BeginMigrateCassandraTableToManualThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginMigrateCassandraTableToManualThroughput not implemented")}
	}
	beginMigrateCassandraTableToManualThroughput := c.beginMigrateCassandraTableToManualThroughput.get(req)
	if beginMigrateCassandraTableToManualThroughput == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default/migrateToManualThroughput`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginMigrateCassandraTableToManualThroughput(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginMigrateCassandraTableToManualThroughput = &respr
		c.beginMigrateCassandraTableToManualThroughput.add(req, beginMigrateCassandraTableToManualThroughput)
	}

	resp, err := server.PollerResponderNext(beginMigrateCassandraTableToManualThroughput, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginMigrateCassandraTableToManualThroughput.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginMigrateCassandraTableToManualThroughput) {
		c.beginMigrateCassandraTableToManualThroughput.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginUpdateCassandraKeyspaceThroughput(req *http.Request) (*http.Response, error) {
	if c.srv.BeginUpdateCassandraKeyspaceThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdateCassandraKeyspaceThroughput not implemented")}
	}
	beginUpdateCassandraKeyspaceThroughput := c.beginUpdateCassandraKeyspaceThroughput.get(req)
	if beginUpdateCassandraKeyspaceThroughput == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.ThroughputSettingsUpdateParameters](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginUpdateCassandraKeyspaceThroughput(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdateCassandraKeyspaceThroughput = &respr
		c.beginUpdateCassandraKeyspaceThroughput.add(req, beginUpdateCassandraKeyspaceThroughput)
	}

	resp, err := server.PollerResponderNext(beginUpdateCassandraKeyspaceThroughput, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginUpdateCassandraKeyspaceThroughput.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdateCassandraKeyspaceThroughput) {
		c.beginUpdateCassandraKeyspaceThroughput.remove(req)
	}

	return resp, nil
}

func (c *CassandraResourcesServerTransport) dispatchBeginUpdateCassandraTableThroughput(req *http.Request) (*http.Response, error) {
	if c.srv.BeginUpdateCassandraTableThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdateCassandraTableThroughput not implemented")}
	}
	beginUpdateCassandraTableThroughput := c.beginUpdateCassandraTableThroughput.get(req)
	if beginUpdateCassandraTableThroughput == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/cassandraKeyspaces/(?P<keyspaceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.ThroughputSettingsUpdateParameters](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		keyspaceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("keyspaceName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginUpdateCassandraTableThroughput(req.Context(), resourceGroupNameParam, accountNameParam, keyspaceNameParam, tableNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdateCassandraTableThroughput = &respr
		c.beginUpdateCassandraTableThroughput.add(req, beginUpdateCassandraTableThroughput)
	}

	resp, err := server.PollerResponderNext(beginUpdateCassandraTableThroughput, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginUpdateCassandraTableThroughput.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdateCassandraTableThroughput) {
		c.beginUpdateCassandraTableThroughput.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to CassandraResourcesServerTransport
var cassandraResourcesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
