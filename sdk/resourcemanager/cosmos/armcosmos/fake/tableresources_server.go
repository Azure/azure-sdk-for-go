// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/cosmos/armcosmos/v4"
	"net/http"
	"net/url"
	"regexp"
)

// TableResourcesServer is a fake server for instances of the armcosmos.TableResourcesClient type.
type TableResourcesServer struct {
	// BeginCreateUpdateTable is the fake for method TableResourcesClient.BeginCreateUpdateTable
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateUpdateTable func(ctx context.Context, resourceGroupName string, accountName string, tableName string, createUpdateTableParameters armcosmos.TableCreateUpdateParameters, options *armcosmos.BeginCreateUpdateTableOptions) (resp azfake.PollerResponder[armcosmos.CreateUpdateTableResponse], errResp azfake.ErrorResponder)

	// BeginCreateUpdateTableRoleAssignment is the fake for method TableResourcesClient.BeginCreateUpdateTableRoleAssignment
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateUpdateTableRoleAssignment func(ctx context.Context, resourceGroupName string, accountName string, roleAssignmentID string, createUpdateTableRoleAssignmentParameters armcosmos.TableRoleAssignmentResource, options *armcosmos.BeginCreateUpdateTableRoleAssignmentOptions) (resp azfake.PollerResponder[armcosmos.CreateUpdateTableRoleAssignmentResponse], errResp azfake.ErrorResponder)

	// BeginCreateUpdateTableRoleDefinition is the fake for method TableResourcesClient.BeginCreateUpdateTableRoleDefinition
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateUpdateTableRoleDefinition func(ctx context.Context, resourceGroupName string, accountName string, roleDefinitionID string, createUpdateTableRoleDefinitionParameters armcosmos.TableRoleDefinitionResource, options *armcosmos.BeginCreateUpdateTableRoleDefinitionOptions) (resp azfake.PollerResponder[armcosmos.CreateUpdateTableRoleDefinitionResponse], errResp azfake.ErrorResponder)

	// BeginDeleteTable is the fake for method TableResourcesClient.BeginDeleteTable
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteTable func(ctx context.Context, resourceGroupName string, accountName string, tableName string, options *armcosmos.BeginDeleteTableOptions) (resp azfake.PollerResponder[armcosmos.DeleteTableResponse], errResp azfake.ErrorResponder)

	// BeginDeleteTableRoleAssignment is the fake for method TableResourcesClient.BeginDeleteTableRoleAssignment
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteTableRoleAssignment func(ctx context.Context, resourceGroupName string, accountName string, roleAssignmentID string, options *armcosmos.BeginDeleteTableRoleAssignmentOptions) (resp azfake.PollerResponder[armcosmos.DeleteTableRoleAssignmentResponse], errResp azfake.ErrorResponder)

	// BeginDeleteTableRoleDefinition is the fake for method TableResourcesClient.BeginDeleteTableRoleDefinition
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteTableRoleDefinition func(ctx context.Context, resourceGroupName string, accountName string, roleDefinitionID string, options *armcosmos.BeginDeleteTableRoleDefinitionOptions) (resp azfake.PollerResponder[armcosmos.DeleteTableRoleDefinitionResponse], errResp azfake.ErrorResponder)

	// GetTable is the fake for method TableResourcesClient.GetTable
	// HTTP status codes to indicate success: http.StatusOK
	GetTable func(ctx context.Context, resourceGroupName string, accountName string, tableName string, options *armcosmos.GetTableOptions) (resp azfake.Responder[armcosmos.GetTableResponse], errResp azfake.ErrorResponder)

	// GetTableRoleAssignment is the fake for method TableResourcesClient.GetTableRoleAssignment
	// HTTP status codes to indicate success: http.StatusOK
	GetTableRoleAssignment func(ctx context.Context, resourceGroupName string, accountName string, roleAssignmentID string, options *armcosmos.GetTableRoleAssignmentOptions) (resp azfake.Responder[armcosmos.GetTableRoleAssignmentResponse], errResp azfake.ErrorResponder)

	// GetTableRoleDefinition is the fake for method TableResourcesClient.GetTableRoleDefinition
	// HTTP status codes to indicate success: http.StatusOK
	GetTableRoleDefinition func(ctx context.Context, resourceGroupName string, accountName string, roleDefinitionID string, options *armcosmos.GetTableRoleDefinitionOptions) (resp azfake.Responder[armcosmos.GetTableRoleDefinitionResponse], errResp azfake.ErrorResponder)

	// GetTableThroughput is the fake for method TableResourcesClient.GetTableThroughput
	// HTTP status codes to indicate success: http.StatusOK
	GetTableThroughput func(ctx context.Context, resourceGroupName string, accountName string, tableName string, options *armcosmos.GetTableThroughputOptions) (resp azfake.Responder[armcosmos.GetTableThroughputResponse], errResp azfake.ErrorResponder)

	// NewListTableRoleAssignmentsPager is the fake for method TableResourcesClient.NewListTableRoleAssignmentsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListTableRoleAssignmentsPager func(resourceGroupName string, accountName string, options *armcosmos.ListTableRoleAssignmentsOptions) (resp azfake.PagerResponder[armcosmos.ListTableRoleAssignmentsResponse])

	// NewListTableRoleDefinitionsPager is the fake for method TableResourcesClient.NewListTableRoleDefinitionsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListTableRoleDefinitionsPager func(resourceGroupName string, accountName string, options *armcosmos.ListTableRoleDefinitionsOptions) (resp azfake.PagerResponder[armcosmos.ListTableRoleDefinitionsResponse])

	// NewListTablesPager is the fake for method TableResourcesClient.NewListTablesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListTablesPager func(resourceGroupName string, accountName string, options *armcosmos.ListTablesOptions) (resp azfake.PagerResponder[armcosmos.ListTablesResponse])

	// BeginMigrateTableToAutoscale is the fake for method TableResourcesClient.BeginMigrateTableToAutoscale
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginMigrateTableToAutoscale func(ctx context.Context, resourceGroupName string, accountName string, tableName string, options *armcosmos.BeginMigrateTableToAutoscaleOptions) (resp azfake.PollerResponder[armcosmos.MigrateTableToAutoscaleResponse], errResp azfake.ErrorResponder)

	// BeginMigrateTableToManualThroughput is the fake for method TableResourcesClient.BeginMigrateTableToManualThroughput
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginMigrateTableToManualThroughput func(ctx context.Context, resourceGroupName string, accountName string, tableName string, options *armcosmos.BeginMigrateTableToManualThroughputOptions) (resp azfake.PollerResponder[armcosmos.MigrateTableToManualThroughputResponse], errResp azfake.ErrorResponder)

	// BeginRetrieveContinuousBackupInformation is the fake for method TableResourcesClient.BeginRetrieveContinuousBackupInformation
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginRetrieveContinuousBackupInformation func(ctx context.Context, resourceGroupName string, accountName string, tableName string, location armcosmos.ContinuousBackupRestoreLocation, options *armcosmos.BeginRetrieveContinuousBackupInformationOptions) (resp azfake.PollerResponder[armcosmos.RetrieveContinuousBackupInformationResponse], errResp azfake.ErrorResponder)

	// BeginUpdateTableThroughput is the fake for method TableResourcesClient.BeginUpdateTableThroughput
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdateTableThroughput func(ctx context.Context, resourceGroupName string, accountName string, tableName string, updateThroughputParameters armcosmos.ThroughputSettingsUpdateParameters, options *armcosmos.BeginUpdateTableThroughputOptions) (resp azfake.PollerResponder[armcosmos.UpdateTableThroughputResponse], errResp azfake.ErrorResponder)
}

// NewTableResourcesServerTransport creates a new instance of TableResourcesServerTransport with the provided implementation.
// The returned TableResourcesServerTransport instance is connected to an instance of armcosmos.TableResourcesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewTableResourcesServerTransport(srv *TableResourcesServer) *TableResourcesServerTransport {
	return &TableResourcesServerTransport{
		srv:                                      srv,
		beginCreateUpdateTable:                   newTracker[azfake.PollerResponder[armcosmos.CreateUpdateTableResponse]](),
		beginCreateUpdateTableRoleAssignment:     newTracker[azfake.PollerResponder[armcosmos.CreateUpdateTableRoleAssignmentResponse]](),
		beginCreateUpdateTableRoleDefinition:     newTracker[azfake.PollerResponder[armcosmos.CreateUpdateTableRoleDefinitionResponse]](),
		beginDeleteTable:                         newTracker[azfake.PollerResponder[armcosmos.DeleteTableResponse]](),
		beginDeleteTableRoleAssignment:           newTracker[azfake.PollerResponder[armcosmos.DeleteTableRoleAssignmentResponse]](),
		beginDeleteTableRoleDefinition:           newTracker[azfake.PollerResponder[armcosmos.DeleteTableRoleDefinitionResponse]](),
		newListTableRoleAssignmentsPager:         newTracker[azfake.PagerResponder[armcosmos.ListTableRoleAssignmentsResponse]](),
		newListTableRoleDefinitionsPager:         newTracker[azfake.PagerResponder[armcosmos.ListTableRoleDefinitionsResponse]](),
		newListTablesPager:                       newTracker[azfake.PagerResponder[armcosmos.ListTablesResponse]](),
		beginMigrateTableToAutoscale:             newTracker[azfake.PollerResponder[armcosmos.MigrateTableToAutoscaleResponse]](),
		beginMigrateTableToManualThroughput:      newTracker[azfake.PollerResponder[armcosmos.MigrateTableToManualThroughputResponse]](),
		beginRetrieveContinuousBackupInformation: newTracker[azfake.PollerResponder[armcosmos.RetrieveContinuousBackupInformationResponse]](),
		beginUpdateTableThroughput:               newTracker[azfake.PollerResponder[armcosmos.UpdateTableThroughputResponse]](),
	}
}

// TableResourcesServerTransport connects instances of armcosmos.TableResourcesClient to instances of TableResourcesServer.
// Don't use this type directly, use NewTableResourcesServerTransport instead.
type TableResourcesServerTransport struct {
	srv                                      *TableResourcesServer
	beginCreateUpdateTable                   *tracker[azfake.PollerResponder[armcosmos.CreateUpdateTableResponse]]
	beginCreateUpdateTableRoleAssignment     *tracker[azfake.PollerResponder[armcosmos.CreateUpdateTableRoleAssignmentResponse]]
	beginCreateUpdateTableRoleDefinition     *tracker[azfake.PollerResponder[armcosmos.CreateUpdateTableRoleDefinitionResponse]]
	beginDeleteTable                         *tracker[azfake.PollerResponder[armcosmos.DeleteTableResponse]]
	beginDeleteTableRoleAssignment           *tracker[azfake.PollerResponder[armcosmos.DeleteTableRoleAssignmentResponse]]
	beginDeleteTableRoleDefinition           *tracker[azfake.PollerResponder[armcosmos.DeleteTableRoleDefinitionResponse]]
	newListTableRoleAssignmentsPager         *tracker[azfake.PagerResponder[armcosmos.ListTableRoleAssignmentsResponse]]
	newListTableRoleDefinitionsPager         *tracker[azfake.PagerResponder[armcosmos.ListTableRoleDefinitionsResponse]]
	newListTablesPager                       *tracker[azfake.PagerResponder[armcosmos.ListTablesResponse]]
	beginMigrateTableToAutoscale             *tracker[azfake.PollerResponder[armcosmos.MigrateTableToAutoscaleResponse]]
	beginMigrateTableToManualThroughput      *tracker[azfake.PollerResponder[armcosmos.MigrateTableToManualThroughputResponse]]
	beginRetrieveContinuousBackupInformation *tracker[azfake.PollerResponder[armcosmos.RetrieveContinuousBackupInformationResponse]]
	beginUpdateTableThroughput               *tracker[azfake.PollerResponder[armcosmos.UpdateTableThroughputResponse]]
}

// Do implements the policy.Transporter interface for TableResourcesServerTransport.
func (t *TableResourcesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return t.dispatchToMethodFake(req, method)
}

func (t *TableResourcesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if tableResourcesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = tableResourcesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "TableResourcesClient.BeginCreateUpdateTable":
				res.resp, res.err = t.dispatchBeginCreateUpdateTable(req)
			case "TableResourcesClient.BeginCreateUpdateTableRoleAssignment":
				res.resp, res.err = t.dispatchBeginCreateUpdateTableRoleAssignment(req)
			case "TableResourcesClient.BeginCreateUpdateTableRoleDefinition":
				res.resp, res.err = t.dispatchBeginCreateUpdateTableRoleDefinition(req)
			case "TableResourcesClient.BeginDeleteTable":
				res.resp, res.err = t.dispatchBeginDeleteTable(req)
			case "TableResourcesClient.BeginDeleteTableRoleAssignment":
				res.resp, res.err = t.dispatchBeginDeleteTableRoleAssignment(req)
			case "TableResourcesClient.BeginDeleteTableRoleDefinition":
				res.resp, res.err = t.dispatchBeginDeleteTableRoleDefinition(req)
			case "TableResourcesClient.GetTable":
				res.resp, res.err = t.dispatchGetTable(req)
			case "TableResourcesClient.GetTableRoleAssignment":
				res.resp, res.err = t.dispatchGetTableRoleAssignment(req)
			case "TableResourcesClient.GetTableRoleDefinition":
				res.resp, res.err = t.dispatchGetTableRoleDefinition(req)
			case "TableResourcesClient.GetTableThroughput":
				res.resp, res.err = t.dispatchGetTableThroughput(req)
			case "TableResourcesClient.NewListTableRoleAssignmentsPager":
				res.resp, res.err = t.dispatchNewListTableRoleAssignmentsPager(req)
			case "TableResourcesClient.NewListTableRoleDefinitionsPager":
				res.resp, res.err = t.dispatchNewListTableRoleDefinitionsPager(req)
			case "TableResourcesClient.NewListTablesPager":
				res.resp, res.err = t.dispatchNewListTablesPager(req)
			case "TableResourcesClient.BeginMigrateTableToAutoscale":
				res.resp, res.err = t.dispatchBeginMigrateTableToAutoscale(req)
			case "TableResourcesClient.BeginMigrateTableToManualThroughput":
				res.resp, res.err = t.dispatchBeginMigrateTableToManualThroughput(req)
			case "TableResourcesClient.BeginRetrieveContinuousBackupInformation":
				res.resp, res.err = t.dispatchBeginRetrieveContinuousBackupInformation(req)
			case "TableResourcesClient.BeginUpdateTableThroughput":
				res.resp, res.err = t.dispatchBeginUpdateTableThroughput(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (t *TableResourcesServerTransport) dispatchBeginCreateUpdateTable(req *http.Request) (*http.Response, error) {
	if t.srv.BeginCreateUpdateTable == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateUpdateTable not implemented")}
	}
	beginCreateUpdateTable := t.beginCreateUpdateTable.get(req)
	if beginCreateUpdateTable == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.TableCreateUpdateParameters](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginCreateUpdateTable(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateUpdateTable = &respr
		t.beginCreateUpdateTable.add(req, beginCreateUpdateTable)
	}

	resp, err := server.PollerResponderNext(beginCreateUpdateTable, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginCreateUpdateTable.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateUpdateTable) {
		t.beginCreateUpdateTable.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginCreateUpdateTableRoleAssignment(req *http.Request) (*http.Response, error) {
	if t.srv.BeginCreateUpdateTableRoleAssignment == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateUpdateTableRoleAssignment not implemented")}
	}
	beginCreateUpdateTableRoleAssignment := t.beginCreateUpdateTableRoleAssignment.get(req)
	if beginCreateUpdateTableRoleAssignment == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleAssignments/(?P<roleAssignmentId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.TableRoleAssignmentResource](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		roleAssignmentIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("roleAssignmentId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginCreateUpdateTableRoleAssignment(req.Context(), resourceGroupNameParam, accountNameParam, roleAssignmentIDParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateUpdateTableRoleAssignment = &respr
		t.beginCreateUpdateTableRoleAssignment.add(req, beginCreateUpdateTableRoleAssignment)
	}

	resp, err := server.PollerResponderNext(beginCreateUpdateTableRoleAssignment, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginCreateUpdateTableRoleAssignment.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateUpdateTableRoleAssignment) {
		t.beginCreateUpdateTableRoleAssignment.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginCreateUpdateTableRoleDefinition(req *http.Request) (*http.Response, error) {
	if t.srv.BeginCreateUpdateTableRoleDefinition == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateUpdateTableRoleDefinition not implemented")}
	}
	beginCreateUpdateTableRoleDefinition := t.beginCreateUpdateTableRoleDefinition.get(req)
	if beginCreateUpdateTableRoleDefinition == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleDefinitions/(?P<roleDefinitionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.TableRoleDefinitionResource](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		roleDefinitionIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("roleDefinitionId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginCreateUpdateTableRoleDefinition(req.Context(), resourceGroupNameParam, accountNameParam, roleDefinitionIDParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateUpdateTableRoleDefinition = &respr
		t.beginCreateUpdateTableRoleDefinition.add(req, beginCreateUpdateTableRoleDefinition)
	}

	resp, err := server.PollerResponderNext(beginCreateUpdateTableRoleDefinition, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginCreateUpdateTableRoleDefinition.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateUpdateTableRoleDefinition) {
		t.beginCreateUpdateTableRoleDefinition.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginDeleteTable(req *http.Request) (*http.Response, error) {
	if t.srv.BeginDeleteTable == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteTable not implemented")}
	}
	beginDeleteTable := t.beginDeleteTable.get(req)
	if beginDeleteTable == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginDeleteTable(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteTable = &respr
		t.beginDeleteTable.add(req, beginDeleteTable)
	}

	resp, err := server.PollerResponderNext(beginDeleteTable, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		t.beginDeleteTable.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteTable) {
		t.beginDeleteTable.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginDeleteTableRoleAssignment(req *http.Request) (*http.Response, error) {
	if t.srv.BeginDeleteTableRoleAssignment == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteTableRoleAssignment not implemented")}
	}
	beginDeleteTableRoleAssignment := t.beginDeleteTableRoleAssignment.get(req)
	if beginDeleteTableRoleAssignment == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleAssignments/(?P<roleAssignmentId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		roleAssignmentIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("roleAssignmentId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginDeleteTableRoleAssignment(req.Context(), resourceGroupNameParam, accountNameParam, roleAssignmentIDParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteTableRoleAssignment = &respr
		t.beginDeleteTableRoleAssignment.add(req, beginDeleteTableRoleAssignment)
	}

	resp, err := server.PollerResponderNext(beginDeleteTableRoleAssignment, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		t.beginDeleteTableRoleAssignment.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteTableRoleAssignment) {
		t.beginDeleteTableRoleAssignment.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginDeleteTableRoleDefinition(req *http.Request) (*http.Response, error) {
	if t.srv.BeginDeleteTableRoleDefinition == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteTableRoleDefinition not implemented")}
	}
	beginDeleteTableRoleDefinition := t.beginDeleteTableRoleDefinition.get(req)
	if beginDeleteTableRoleDefinition == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleDefinitions/(?P<roleDefinitionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		roleDefinitionIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("roleDefinitionId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginDeleteTableRoleDefinition(req.Context(), resourceGroupNameParam, accountNameParam, roleDefinitionIDParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteTableRoleDefinition = &respr
		t.beginDeleteTableRoleDefinition.add(req, beginDeleteTableRoleDefinition)
	}

	resp, err := server.PollerResponderNext(beginDeleteTableRoleDefinition, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		t.beginDeleteTableRoleDefinition.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteTableRoleDefinition) {
		t.beginDeleteTableRoleDefinition.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchGetTable(req *http.Request) (*http.Response, error) {
	if t.srv.GetTable == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetTable not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := t.srv.GetTable(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).TableGetResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchGetTableRoleAssignment(req *http.Request) (*http.Response, error) {
	if t.srv.GetTableRoleAssignment == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetTableRoleAssignment not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleAssignments/(?P<roleAssignmentId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	roleAssignmentIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("roleAssignmentId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := t.srv.GetTableRoleAssignment(req.Context(), resourceGroupNameParam, accountNameParam, roleAssignmentIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).TableRoleAssignmentResource, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchGetTableRoleDefinition(req *http.Request) (*http.Response, error) {
	if t.srv.GetTableRoleDefinition == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetTableRoleDefinition not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleDefinitions/(?P<roleDefinitionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	roleDefinitionIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("roleDefinitionId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := t.srv.GetTableRoleDefinition(req.Context(), resourceGroupNameParam, accountNameParam, roleDefinitionIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).TableRoleDefinitionResource, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchGetTableThroughput(req *http.Request) (*http.Response, error) {
	if t.srv.GetTableThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetTableThroughput not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
	if err != nil {
		return nil, err
	}
	tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := t.srv.GetTableThroughput(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ThroughputSettingsGetResults, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchNewListTableRoleAssignmentsPager(req *http.Request) (*http.Response, error) {
	if t.srv.NewListTableRoleAssignmentsPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListTableRoleAssignmentsPager not implemented")}
	}
	newListTableRoleAssignmentsPager := t.newListTableRoleAssignmentsPager.get(req)
	if newListTableRoleAssignmentsPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleAssignments`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		resp := t.srv.NewListTableRoleAssignmentsPager(resourceGroupNameParam, accountNameParam, nil)
		newListTableRoleAssignmentsPager = &resp
		t.newListTableRoleAssignmentsPager.add(req, newListTableRoleAssignmentsPager)
		server.PagerResponderInjectNextLinks(newListTableRoleAssignmentsPager, req, func(page *armcosmos.ListTableRoleAssignmentsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListTableRoleAssignmentsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		t.newListTableRoleAssignmentsPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListTableRoleAssignmentsPager) {
		t.newListTableRoleAssignmentsPager.remove(req)
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchNewListTableRoleDefinitionsPager(req *http.Request) (*http.Response, error) {
	if t.srv.NewListTableRoleDefinitionsPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListTableRoleDefinitionsPager not implemented")}
	}
	newListTableRoleDefinitionsPager := t.newListTableRoleDefinitionsPager.get(req)
	if newListTableRoleDefinitionsPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tableRoleDefinitions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		resp := t.srv.NewListTableRoleDefinitionsPager(resourceGroupNameParam, accountNameParam, nil)
		newListTableRoleDefinitionsPager = &resp
		t.newListTableRoleDefinitionsPager.add(req, newListTableRoleDefinitionsPager)
		server.PagerResponderInjectNextLinks(newListTableRoleDefinitionsPager, req, func(page *armcosmos.ListTableRoleDefinitionsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListTableRoleDefinitionsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		t.newListTableRoleDefinitionsPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListTableRoleDefinitionsPager) {
		t.newListTableRoleDefinitionsPager.remove(req)
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchNewListTablesPager(req *http.Request) (*http.Response, error) {
	if t.srv.NewListTablesPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListTablesPager not implemented")}
	}
	newListTablesPager := t.newListTablesPager.get(req)
	if newListTablesPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		resp := t.srv.NewListTablesPager(resourceGroupNameParam, accountNameParam, nil)
		newListTablesPager = &resp
		t.newListTablesPager.add(req, newListTablesPager)
		server.PagerResponderInjectNextLinks(newListTablesPager, req, func(page *armcosmos.ListTablesResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListTablesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		t.newListTablesPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListTablesPager) {
		t.newListTablesPager.remove(req)
	}
	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginMigrateTableToAutoscale(req *http.Request) (*http.Response, error) {
	if t.srv.BeginMigrateTableToAutoscale == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginMigrateTableToAutoscale not implemented")}
	}
	beginMigrateTableToAutoscale := t.beginMigrateTableToAutoscale.get(req)
	if beginMigrateTableToAutoscale == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default/migrateToAutoscale`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginMigrateTableToAutoscale(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginMigrateTableToAutoscale = &respr
		t.beginMigrateTableToAutoscale.add(req, beginMigrateTableToAutoscale)
	}

	resp, err := server.PollerResponderNext(beginMigrateTableToAutoscale, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginMigrateTableToAutoscale.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginMigrateTableToAutoscale) {
		t.beginMigrateTableToAutoscale.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginMigrateTableToManualThroughput(req *http.Request) (*http.Response, error) {
	if t.srv.BeginMigrateTableToManualThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginMigrateTableToManualThroughput not implemented")}
	}
	beginMigrateTableToManualThroughput := t.beginMigrateTableToManualThroughput.get(req)
	if beginMigrateTableToManualThroughput == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default/migrateToManualThroughput`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginMigrateTableToManualThroughput(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginMigrateTableToManualThroughput = &respr
		t.beginMigrateTableToManualThroughput.add(req, beginMigrateTableToManualThroughput)
	}

	resp, err := server.PollerResponderNext(beginMigrateTableToManualThroughput, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginMigrateTableToManualThroughput.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginMigrateTableToManualThroughput) {
		t.beginMigrateTableToManualThroughput.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginRetrieveContinuousBackupInformation(req *http.Request) (*http.Response, error) {
	if t.srv.BeginRetrieveContinuousBackupInformation == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginRetrieveContinuousBackupInformation not implemented")}
	}
	beginRetrieveContinuousBackupInformation := t.beginRetrieveContinuousBackupInformation.get(req)
	if beginRetrieveContinuousBackupInformation == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/retrieveContinuousBackupInformation`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.ContinuousBackupRestoreLocation](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginRetrieveContinuousBackupInformation(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginRetrieveContinuousBackupInformation = &respr
		t.beginRetrieveContinuousBackupInformation.add(req, beginRetrieveContinuousBackupInformation)
	}

	resp, err := server.PollerResponderNext(beginRetrieveContinuousBackupInformation, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginRetrieveContinuousBackupInformation.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginRetrieveContinuousBackupInformation) {
		t.beginRetrieveContinuousBackupInformation.remove(req)
	}

	return resp, nil
}

func (t *TableResourcesServerTransport) dispatchBeginUpdateTableThroughput(req *http.Request) (*http.Response, error) {
	if t.srv.BeginUpdateTableThroughput == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdateTableThroughput not implemented")}
	}
	beginUpdateTableThroughput := t.beginUpdateTableThroughput.get(req)
	if beginUpdateTableThroughput == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.DocumentDB/databaseAccounts/(?P<accountName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/tables/(?P<tableName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/throughputSettings/default`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armcosmos.ThroughputSettingsUpdateParameters](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		accountNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("accountName")])
		if err != nil {
			return nil, err
		}
		tableNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("tableName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := t.srv.BeginUpdateTableThroughput(req.Context(), resourceGroupNameParam, accountNameParam, tableNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdateTableThroughput = &respr
		t.beginUpdateTableThroughput.add(req, beginUpdateTableThroughput)
	}

	resp, err := server.PollerResponderNext(beginUpdateTableThroughput, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		t.beginUpdateTableThroughput.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdateTableThroughput) {
		t.beginUpdateTableThroughput.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to TableResourcesServerTransport
var tableResourcesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
