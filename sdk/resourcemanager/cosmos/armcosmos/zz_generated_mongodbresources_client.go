//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// MongoDBResourcesClient contains the methods for the MongoDBResources group.
// Don't use this type directly, use NewMongoDBResourcesClient() instead.
type MongoDBResourcesClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewMongoDBResourcesClient creates a new instance of MongoDBResourcesClient with the specified values.
func NewMongoDBResourcesClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *MongoDBResourcesClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &MongoDBResourcesClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// BeginCreateUpdateMongoDBCollection - Create or update an Azure Cosmos DB MongoDB Collection
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) BeginCreateUpdateMongoDBCollection(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, createUpdateMongoDBCollectionParameters MongoDBCollectionCreateUpdateParameters, options *MongoDBResourcesBeginCreateUpdateMongoDBCollectionOptions) (MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse, error) {
	resp, err := client.createUpdateMongoDBCollection(ctx, resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse{}, err
	}
	result := MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.CreateUpdateMongoDBCollection", "", resp, client.pl, client.createUpdateMongoDBCollectionHandleError)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesCreateUpdateMongoDBCollectionPoller{
		pt: pt,
	}
	return result, nil
}

// CreateUpdateMongoDBCollection - Create or update an Azure Cosmos DB MongoDB Collection
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) createUpdateMongoDBCollection(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, createUpdateMongoDBCollectionParameters MongoDBCollectionCreateUpdateParameters, options *MongoDBResourcesBeginCreateUpdateMongoDBCollectionOptions) (*http.Response, error) {
	req, err := client.createUpdateMongoDBCollectionCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createUpdateMongoDBCollectionHandleError(resp)
	}
	return resp, nil
}

// createUpdateMongoDBCollectionCreateRequest creates the CreateUpdateMongoDBCollection request.
func (client *MongoDBResourcesClient) createUpdateMongoDBCollectionCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, createUpdateMongoDBCollectionParameters MongoDBCollectionCreateUpdateParameters, options *MongoDBResourcesBeginCreateUpdateMongoDBCollectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, createUpdateMongoDBCollectionParameters)
}

// createUpdateMongoDBCollectionHandleError handles the CreateUpdateMongoDBCollection error response.
func (client *MongoDBResourcesClient) createUpdateMongoDBCollectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginCreateUpdateMongoDBDatabase - Create or updates Azure Cosmos DB MongoDB database
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) BeginCreateUpdateMongoDBDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateMongoDBDatabaseParameters MongoDBDatabaseCreateUpdateParameters, options *MongoDBResourcesBeginCreateUpdateMongoDBDatabaseOptions) (MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse, error) {
	resp, err := client.createUpdateMongoDBDatabase(ctx, resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse{}, err
	}
	result := MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.CreateUpdateMongoDBDatabase", "", resp, client.pl, client.createUpdateMongoDBDatabaseHandleError)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesCreateUpdateMongoDBDatabasePoller{
		pt: pt,
	}
	return result, nil
}

// CreateUpdateMongoDBDatabase - Create or updates Azure Cosmos DB MongoDB database
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) createUpdateMongoDBDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateMongoDBDatabaseParameters MongoDBDatabaseCreateUpdateParameters, options *MongoDBResourcesBeginCreateUpdateMongoDBDatabaseOptions) (*http.Response, error) {
	req, err := client.createUpdateMongoDBDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createUpdateMongoDBDatabaseHandleError(resp)
	}
	return resp, nil
}

// createUpdateMongoDBDatabaseCreateRequest creates the CreateUpdateMongoDBDatabase request.
func (client *MongoDBResourcesClient) createUpdateMongoDBDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateMongoDBDatabaseParameters MongoDBDatabaseCreateUpdateParameters, options *MongoDBResourcesBeginCreateUpdateMongoDBDatabaseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, createUpdateMongoDBDatabaseParameters)
}

// createUpdateMongoDBDatabaseHandleError handles the CreateUpdateMongoDBDatabase error response.
func (client *MongoDBResourcesClient) createUpdateMongoDBDatabaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginDeleteMongoDBCollection - Deletes an existing Azure Cosmos DB MongoDB Collection.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) BeginDeleteMongoDBCollection(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginDeleteMongoDBCollectionOptions) (MongoDBResourcesDeleteMongoDBCollectionPollerResponse, error) {
	resp, err := client.deleteMongoDBCollection(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBCollectionPollerResponse{}, err
	}
	result := MongoDBResourcesDeleteMongoDBCollectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.DeleteMongoDBCollection", "", resp, client.pl, client.deleteMongoDBCollectionHandleError)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBCollectionPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesDeleteMongoDBCollectionPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteMongoDBCollection - Deletes an existing Azure Cosmos DB MongoDB Collection.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) deleteMongoDBCollection(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginDeleteMongoDBCollectionOptions) (*http.Response, error) {
	req, err := client.deleteMongoDBCollectionCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteMongoDBCollectionHandleError(resp)
	}
	return resp, nil
}

// deleteMongoDBCollectionCreateRequest creates the DeleteMongoDBCollection request.
func (client *MongoDBResourcesClient) deleteMongoDBCollectionCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginDeleteMongoDBCollectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteMongoDBCollectionHandleError handles the DeleteMongoDBCollection error response.
func (client *MongoDBResourcesClient) deleteMongoDBCollectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginDeleteMongoDBDatabase - Deletes an existing Azure Cosmos DB MongoDB database.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) BeginDeleteMongoDBDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginDeleteMongoDBDatabaseOptions) (MongoDBResourcesDeleteMongoDBDatabasePollerResponse, error) {
	resp, err := client.deleteMongoDBDatabase(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBDatabasePollerResponse{}, err
	}
	result := MongoDBResourcesDeleteMongoDBDatabasePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.DeleteMongoDBDatabase", "", resp, client.pl, client.deleteMongoDBDatabaseHandleError)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBDatabasePollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesDeleteMongoDBDatabasePoller{
		pt: pt,
	}
	return result, nil
}

// DeleteMongoDBDatabase - Deletes an existing Azure Cosmos DB MongoDB database.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) deleteMongoDBDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginDeleteMongoDBDatabaseOptions) (*http.Response, error) {
	req, err := client.deleteMongoDBDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteMongoDBDatabaseHandleError(resp)
	}
	return resp, nil
}

// deleteMongoDBDatabaseCreateRequest creates the DeleteMongoDBDatabase request.
func (client *MongoDBResourcesClient) deleteMongoDBDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginDeleteMongoDBDatabaseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteMongoDBDatabaseHandleError handles the DeleteMongoDBDatabase error response.
func (client *MongoDBResourcesClient) deleteMongoDBDatabaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetMongoDBCollection - Gets the MongoDB collection under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) GetMongoDBCollection(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesGetMongoDBCollectionOptions) (MongoDBResourcesGetMongoDBCollectionResponse, error) {
	req, err := client.getMongoDBCollectionCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return MongoDBResourcesGetMongoDBCollectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesGetMongoDBCollectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MongoDBResourcesGetMongoDBCollectionResponse{}, client.getMongoDBCollectionHandleError(resp)
	}
	return client.getMongoDBCollectionHandleResponse(resp)
}

// getMongoDBCollectionCreateRequest creates the GetMongoDBCollection request.
func (client *MongoDBResourcesClient) getMongoDBCollectionCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesGetMongoDBCollectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMongoDBCollectionHandleResponse handles the GetMongoDBCollection response.
func (client *MongoDBResourcesClient) getMongoDBCollectionHandleResponse(resp *http.Response) (MongoDBResourcesGetMongoDBCollectionResponse, error) {
	result := MongoDBResourcesGetMongoDBCollectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MongoDBCollectionGetResults); err != nil {
		return MongoDBResourcesGetMongoDBCollectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMongoDBCollectionHandleError handles the GetMongoDBCollection error response.
func (client *MongoDBResourcesClient) getMongoDBCollectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetMongoDBCollectionThroughput - Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account with the provided
// name.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) GetMongoDBCollectionThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesGetMongoDBCollectionThroughputOptions) (MongoDBResourcesGetMongoDBCollectionThroughputResponse, error) {
	req, err := client.getMongoDBCollectionThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return MongoDBResourcesGetMongoDBCollectionThroughputResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesGetMongoDBCollectionThroughputResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MongoDBResourcesGetMongoDBCollectionThroughputResponse{}, client.getMongoDBCollectionThroughputHandleError(resp)
	}
	return client.getMongoDBCollectionThroughputHandleResponse(resp)
}

// getMongoDBCollectionThroughputCreateRequest creates the GetMongoDBCollectionThroughput request.
func (client *MongoDBResourcesClient) getMongoDBCollectionThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesGetMongoDBCollectionThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMongoDBCollectionThroughputHandleResponse handles the GetMongoDBCollectionThroughput response.
func (client *MongoDBResourcesClient) getMongoDBCollectionThroughputHandleResponse(resp *http.Response) (MongoDBResourcesGetMongoDBCollectionThroughputResponse, error) {
	result := MongoDBResourcesGetMongoDBCollectionThroughputResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThroughputSettingsGetResults); err != nil {
		return MongoDBResourcesGetMongoDBCollectionThroughputResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMongoDBCollectionThroughputHandleError handles the GetMongoDBCollectionThroughput error response.
func (client *MongoDBResourcesClient) getMongoDBCollectionThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetMongoDBDatabase - Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) GetMongoDBDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesGetMongoDBDatabaseOptions) (MongoDBResourcesGetMongoDBDatabaseResponse, error) {
	req, err := client.getMongoDBDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return MongoDBResourcesGetMongoDBDatabaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesGetMongoDBDatabaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MongoDBResourcesGetMongoDBDatabaseResponse{}, client.getMongoDBDatabaseHandleError(resp)
	}
	return client.getMongoDBDatabaseHandleResponse(resp)
}

// getMongoDBDatabaseCreateRequest creates the GetMongoDBDatabase request.
func (client *MongoDBResourcesClient) getMongoDBDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesGetMongoDBDatabaseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMongoDBDatabaseHandleResponse handles the GetMongoDBDatabase response.
func (client *MongoDBResourcesClient) getMongoDBDatabaseHandleResponse(resp *http.Response) (MongoDBResourcesGetMongoDBDatabaseResponse, error) {
	result := MongoDBResourcesGetMongoDBDatabaseResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MongoDBDatabaseGetResults); err != nil {
		return MongoDBResourcesGetMongoDBDatabaseResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMongoDBDatabaseHandleError handles the GetMongoDBDatabase error response.
func (client *MongoDBResourcesClient) getMongoDBDatabaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetMongoDBDatabaseThroughput - Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) GetMongoDBDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesGetMongoDBDatabaseThroughputOptions) (MongoDBResourcesGetMongoDBDatabaseThroughputResponse, error) {
	req, err := client.getMongoDBDatabaseThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return MongoDBResourcesGetMongoDBDatabaseThroughputResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesGetMongoDBDatabaseThroughputResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MongoDBResourcesGetMongoDBDatabaseThroughputResponse{}, client.getMongoDBDatabaseThroughputHandleError(resp)
	}
	return client.getMongoDBDatabaseThroughputHandleResponse(resp)
}

// getMongoDBDatabaseThroughputCreateRequest creates the GetMongoDBDatabaseThroughput request.
func (client *MongoDBResourcesClient) getMongoDBDatabaseThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesGetMongoDBDatabaseThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMongoDBDatabaseThroughputHandleResponse handles the GetMongoDBDatabaseThroughput response.
func (client *MongoDBResourcesClient) getMongoDBDatabaseThroughputHandleResponse(resp *http.Response) (MongoDBResourcesGetMongoDBDatabaseThroughputResponse, error) {
	result := MongoDBResourcesGetMongoDBDatabaseThroughputResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThroughputSettingsGetResults); err != nil {
		return MongoDBResourcesGetMongoDBDatabaseThroughputResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMongoDBDatabaseThroughputHandleError handles the GetMongoDBDatabaseThroughput error response.
func (client *MongoDBResourcesClient) getMongoDBDatabaseThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListMongoDBCollections - Lists the MongoDB collection under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) ListMongoDBCollections(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesListMongoDBCollectionsOptions) (MongoDBResourcesListMongoDBCollectionsResponse, error) {
	req, err := client.listMongoDBCollectionsCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return MongoDBResourcesListMongoDBCollectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesListMongoDBCollectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MongoDBResourcesListMongoDBCollectionsResponse{}, client.listMongoDBCollectionsHandleError(resp)
	}
	return client.listMongoDBCollectionsHandleResponse(resp)
}

// listMongoDBCollectionsCreateRequest creates the ListMongoDBCollections request.
func (client *MongoDBResourcesClient) listMongoDBCollectionsCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesListMongoDBCollectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMongoDBCollectionsHandleResponse handles the ListMongoDBCollections response.
func (client *MongoDBResourcesClient) listMongoDBCollectionsHandleResponse(resp *http.Response) (MongoDBResourcesListMongoDBCollectionsResponse, error) {
	result := MongoDBResourcesListMongoDBCollectionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MongoDBCollectionListResult); err != nil {
		return MongoDBResourcesListMongoDBCollectionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMongoDBCollectionsHandleError handles the ListMongoDBCollections error response.
func (client *MongoDBResourcesClient) listMongoDBCollectionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListMongoDBDatabases - Lists the MongoDB databases under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) ListMongoDBDatabases(ctx context.Context, resourceGroupName string, accountName string, options *MongoDBResourcesListMongoDBDatabasesOptions) (MongoDBResourcesListMongoDBDatabasesResponse, error) {
	req, err := client.listMongoDBDatabasesCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return MongoDBResourcesListMongoDBDatabasesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesListMongoDBDatabasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MongoDBResourcesListMongoDBDatabasesResponse{}, client.listMongoDBDatabasesHandleError(resp)
	}
	return client.listMongoDBDatabasesHandleResponse(resp)
}

// listMongoDBDatabasesCreateRequest creates the ListMongoDBDatabases request.
func (client *MongoDBResourcesClient) listMongoDBDatabasesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *MongoDBResourcesListMongoDBDatabasesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMongoDBDatabasesHandleResponse handles the ListMongoDBDatabases response.
func (client *MongoDBResourcesClient) listMongoDBDatabasesHandleResponse(resp *http.Response) (MongoDBResourcesListMongoDBDatabasesResponse, error) {
	result := MongoDBResourcesListMongoDBDatabasesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MongoDBDatabaseListResult); err != nil {
		return MongoDBResourcesListMongoDBDatabasesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMongoDBDatabasesHandleError handles the ListMongoDBDatabases error response.
func (client *MongoDBResourcesClient) listMongoDBDatabasesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginMigrateMongoDBCollectionToAutoscale - Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) BeginMigrateMongoDBCollectionToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginMigrateMongoDBCollectionToAutoscaleOptions) (MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse, error) {
	resp, err := client.migrateMongoDBCollectionToAutoscale(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse{}, err
	}
	result := MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.MigrateMongoDBCollectionToAutoscale", "", resp, client.pl, client.migrateMongoDBCollectionToAutoscaleHandleError)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller{
		pt: pt,
	}
	return result, nil
}

// MigrateMongoDBCollectionToAutoscale - Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) migrateMongoDBCollectionToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginMigrateMongoDBCollectionToAutoscaleOptions) (*http.Response, error) {
	req, err := client.migrateMongoDBCollectionToAutoscaleCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateMongoDBCollectionToAutoscaleHandleError(resp)
	}
	return resp, nil
}

// migrateMongoDBCollectionToAutoscaleCreateRequest creates the MigrateMongoDBCollectionToAutoscale request.
func (client *MongoDBResourcesClient) migrateMongoDBCollectionToAutoscaleCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginMigrateMongoDBCollectionToAutoscaleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateMongoDBCollectionToAutoscaleHandleError handles the MigrateMongoDBCollectionToAutoscale error response.
func (client *MongoDBResourcesClient) migrateMongoDBCollectionToAutoscaleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateMongoDBCollectionToManualThroughput - Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) BeginMigrateMongoDBCollectionToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginMigrateMongoDBCollectionToManualThroughputOptions) (MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse, error) {
	resp, err := client.migrateMongoDBCollectionToManualThroughput(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse{}, err
	}
	result := MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.MigrateMongoDBCollectionToManualThroughput", "", resp, client.pl, client.migrateMongoDBCollectionToManualThroughputHandleError)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// MigrateMongoDBCollectionToManualThroughput - Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) migrateMongoDBCollectionToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginMigrateMongoDBCollectionToManualThroughputOptions) (*http.Response, error) {
	req, err := client.migrateMongoDBCollectionToManualThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateMongoDBCollectionToManualThroughputHandleError(resp)
	}
	return resp, nil
}

// migrateMongoDBCollectionToManualThroughputCreateRequest creates the MigrateMongoDBCollectionToManualThroughput request.
func (client *MongoDBResourcesClient) migrateMongoDBCollectionToManualThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, options *MongoDBResourcesBeginMigrateMongoDBCollectionToManualThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateMongoDBCollectionToManualThroughputHandleError handles the MigrateMongoDBCollectionToManualThroughput error response.
func (client *MongoDBResourcesClient) migrateMongoDBCollectionToManualThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateMongoDBDatabaseToAutoscale - Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) BeginMigrateMongoDBDatabaseToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginMigrateMongoDBDatabaseToAutoscaleOptions) (MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse, error) {
	resp, err := client.migrateMongoDBDatabaseToAutoscale(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse{}, err
	}
	result := MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.MigrateMongoDBDatabaseToAutoscale", "", resp, client.pl, client.migrateMongoDBDatabaseToAutoscaleHandleError)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller{
		pt: pt,
	}
	return result, nil
}

// MigrateMongoDBDatabaseToAutoscale - Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) migrateMongoDBDatabaseToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginMigrateMongoDBDatabaseToAutoscaleOptions) (*http.Response, error) {
	req, err := client.migrateMongoDBDatabaseToAutoscaleCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateMongoDBDatabaseToAutoscaleHandleError(resp)
	}
	return resp, nil
}

// migrateMongoDBDatabaseToAutoscaleCreateRequest creates the MigrateMongoDBDatabaseToAutoscale request.
func (client *MongoDBResourcesClient) migrateMongoDBDatabaseToAutoscaleCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginMigrateMongoDBDatabaseToAutoscaleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateMongoDBDatabaseToAutoscaleHandleError handles the MigrateMongoDBDatabaseToAutoscale error response.
func (client *MongoDBResourcesClient) migrateMongoDBDatabaseToAutoscaleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateMongoDBDatabaseToManualThroughput - Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) BeginMigrateMongoDBDatabaseToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginMigrateMongoDBDatabaseToManualThroughputOptions) (MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse, error) {
	resp, err := client.migrateMongoDBDatabaseToManualThroughput(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse{}, err
	}
	result := MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.MigrateMongoDBDatabaseToManualThroughput", "", resp, client.pl, client.migrateMongoDBDatabaseToManualThroughputHandleError)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// MigrateMongoDBDatabaseToManualThroughput - Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) migrateMongoDBDatabaseToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginMigrateMongoDBDatabaseToManualThroughputOptions) (*http.Response, error) {
	req, err := client.migrateMongoDBDatabaseToManualThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateMongoDBDatabaseToManualThroughputHandleError(resp)
	}
	return resp, nil
}

// migrateMongoDBDatabaseToManualThroughputCreateRequest creates the MigrateMongoDBDatabaseToManualThroughput request.
func (client *MongoDBResourcesClient) migrateMongoDBDatabaseToManualThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *MongoDBResourcesBeginMigrateMongoDBDatabaseToManualThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateMongoDBDatabaseToManualThroughputHandleError handles the MigrateMongoDBDatabaseToManualThroughput error response.
func (client *MongoDBResourcesClient) migrateMongoDBDatabaseToManualThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRetrieveContinuousBackupInformation - Retrieves continuous backup information for a Mongodb collection.
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) BeginRetrieveContinuousBackupInformation(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, location ContinuousBackupRestoreLocation, options *MongoDBResourcesBeginRetrieveContinuousBackupInformationOptions) (MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse, error) {
	resp, err := client.retrieveContinuousBackupInformation(ctx, resourceGroupName, accountName, databaseName, collectionName, location, options)
	if err != nil {
		return MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse{}, err
	}
	result := MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.RetrieveContinuousBackupInformation", "location", resp, client.pl, client.retrieveContinuousBackupInformationHandleError)
	if err != nil {
		return MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesRetrieveContinuousBackupInformationPoller{
		pt: pt,
	}
	return result, nil
}

// RetrieveContinuousBackupInformation - Retrieves continuous backup information for a Mongodb collection.
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) retrieveContinuousBackupInformation(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, location ContinuousBackupRestoreLocation, options *MongoDBResourcesBeginRetrieveContinuousBackupInformationOptions) (*http.Response, error) {
	req, err := client.retrieveContinuousBackupInformationCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, location, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.retrieveContinuousBackupInformationHandleError(resp)
	}
	return resp, nil
}

// retrieveContinuousBackupInformationCreateRequest creates the RetrieveContinuousBackupInformation request.
func (client *MongoDBResourcesClient) retrieveContinuousBackupInformationCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, location ContinuousBackupRestoreLocation, options *MongoDBResourcesBeginRetrieveContinuousBackupInformationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, location)
}

// retrieveContinuousBackupInformationHandleError handles the RetrieveContinuousBackupInformation error response.
func (client *MongoDBResourcesClient) retrieveContinuousBackupInformationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateMongoDBCollectionThroughput - Update the RUs per second of an Azure Cosmos DB MongoDB collection
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) BeginUpdateMongoDBCollectionThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *MongoDBResourcesBeginUpdateMongoDBCollectionThroughputOptions) (MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse, error) {
	resp, err := client.updateMongoDBCollectionThroughput(ctx, resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse{}, err
	}
	result := MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.UpdateMongoDBCollectionThroughput", "", resp, client.pl, client.updateMongoDBCollectionThroughputHandleError)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesUpdateMongoDBCollectionThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateMongoDBCollectionThroughput - Update the RUs per second of an Azure Cosmos DB MongoDB collection
// If the operation fails it returns a generic error.
func (client *MongoDBResourcesClient) updateMongoDBCollectionThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *MongoDBResourcesBeginUpdateMongoDBCollectionThroughputOptions) (*http.Response, error) {
	req, err := client.updateMongoDBCollectionThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateMongoDBCollectionThroughputHandleError(resp)
	}
	return resp, nil
}

// updateMongoDBCollectionThroughputCreateRequest creates the UpdateMongoDBCollectionThroughput request.
func (client *MongoDBResourcesClient) updateMongoDBCollectionThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, collectionName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *MongoDBResourcesBeginUpdateMongoDBCollectionThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if collectionName == "" {
		return nil, errors.New("parameter collectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionName}", url.PathEscape(collectionName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, updateThroughputParameters)
}

// updateMongoDBCollectionThroughputHandleError handles the UpdateMongoDBCollectionThroughput error response.
func (client *MongoDBResourcesClient) updateMongoDBCollectionThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginUpdateMongoDBDatabaseThroughput - Update RUs per second of the an Azure Cosmos DB MongoDB database
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) BeginUpdateMongoDBDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *MongoDBResourcesBeginUpdateMongoDBDatabaseThroughputOptions) (MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse, error) {
	resp, err := client.updateMongoDBDatabaseThroughput(ctx, resourceGroupName, accountName, databaseName, updateThroughputParameters, options)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse{}, err
	}
	result := MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("MongoDBResourcesClient.UpdateMongoDBDatabaseThroughput", "", resp, client.pl, client.updateMongoDBDatabaseThroughputHandleError)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse{}, err
	}
	result.Poller = &MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateMongoDBDatabaseThroughput - Update RUs per second of the an Azure Cosmos DB MongoDB database
// If the operation fails it returns the *CloudError error type.
func (client *MongoDBResourcesClient) updateMongoDBDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *MongoDBResourcesBeginUpdateMongoDBDatabaseThroughputOptions) (*http.Response, error) {
	req, err := client.updateMongoDBDatabaseThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, updateThroughputParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateMongoDBDatabaseThroughputHandleError(resp)
	}
	return resp, nil
}

// updateMongoDBDatabaseThroughputCreateRequest creates the UpdateMongoDBDatabaseThroughput request.
func (client *MongoDBResourcesClient) updateMongoDBDatabaseThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *MongoDBResourcesBeginUpdateMongoDBDatabaseThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, updateThroughputParameters)
}

// updateMongoDBDatabaseThroughputHandleError handles the UpdateMongoDBDatabaseThroughput error response.
func (client *MongoDBResourcesClient) updateMongoDBDatabaseThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
