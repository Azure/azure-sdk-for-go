//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// CassandraClustersClientCreateUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersClientCreateUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersClientCreateUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersClientCreateUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersClientCreateUpdateResponse will be returned.
func (p *CassandraClustersClientCreateUpdatePoller) FinalResponse(ctx context.Context) (CassandraClustersClientCreateUpdateResponse, error) {
	respType := CassandraClustersClientCreateUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ClusterResource)
	if err != nil {
		return CassandraClustersClientCreateUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersClientCreateUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersClientDeallocatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersClientDeallocatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersClientDeallocatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersClientDeallocatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersClientDeallocateResponse will be returned.
func (p *CassandraClustersClientDeallocatePoller) FinalResponse(ctx context.Context) (CassandraClustersClientDeallocateResponse, error) {
	respType := CassandraClustersClientDeallocateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraClustersClientDeallocateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersClientDeallocatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersClientDeleteResponse will be returned.
func (p *CassandraClustersClientDeletePoller) FinalResponse(ctx context.Context) (CassandraClustersClientDeleteResponse, error) {
	respType := CassandraClustersClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraClustersClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersClientInvokeCommandPoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersClientInvokeCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersClientInvokeCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersClientInvokeCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersClientInvokeCommandResponse will be returned.
func (p *CassandraClustersClientInvokeCommandPoller) FinalResponse(ctx context.Context) (CassandraClustersClientInvokeCommandResponse, error) {
	respType := CassandraClustersClientInvokeCommandResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CommandOutput)
	if err != nil {
		return CassandraClustersClientInvokeCommandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersClientInvokeCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersClientStartPoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersClientStartResponse will be returned.
func (p *CassandraClustersClientStartPoller) FinalResponse(ctx context.Context) (CassandraClustersClientStartResponse, error) {
	respType := CassandraClustersClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraClustersClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersClientUpdateResponse will be returned.
func (p *CassandraClustersClientUpdatePoller) FinalResponse(ctx context.Context) (CassandraClustersClientUpdateResponse, error) {
	respType := CassandraClustersClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ClusterResource)
	if err != nil {
		return CassandraClustersClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraDataCentersClientCreateUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraDataCentersClientCreateUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraDataCentersClientCreateUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraDataCentersClientCreateUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraDataCentersClientCreateUpdateResponse will be returned.
func (p *CassandraDataCentersClientCreateUpdatePoller) FinalResponse(ctx context.Context) (CassandraDataCentersClientCreateUpdateResponse, error) {
	respType := CassandraDataCentersClientCreateUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataCenterResource)
	if err != nil {
		return CassandraDataCentersClientCreateUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraDataCentersClientCreateUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraDataCentersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type CassandraDataCentersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraDataCentersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraDataCentersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraDataCentersClientDeleteResponse will be returned.
func (p *CassandraDataCentersClientDeletePoller) FinalResponse(ctx context.Context) (CassandraDataCentersClientDeleteResponse, error) {
	respType := CassandraDataCentersClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraDataCentersClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraDataCentersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraDataCentersClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraDataCentersClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraDataCentersClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraDataCentersClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraDataCentersClientUpdateResponse will be returned.
func (p *CassandraDataCentersClientUpdatePoller) FinalResponse(ctx context.Context) (CassandraDataCentersClientUpdateResponse, error) {
	respType := CassandraDataCentersClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataCenterResource)
	if err != nil {
		return CassandraDataCentersClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraDataCentersClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientCreateUpdateCassandraKeyspacePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientCreateUpdateCassandraKeyspacePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientCreateUpdateCassandraKeyspacePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientCreateUpdateCassandraKeyspacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse will be returned.
func (p *CassandraResourcesClientCreateUpdateCassandraKeyspacePoller) FinalResponse(ctx context.Context) (CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CassandraKeyspaceGetResults)
	if err != nil {
		return CassandraResourcesClientCreateUpdateCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientCreateUpdateCassandraKeyspacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientCreateUpdateCassandraTablePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientCreateUpdateCassandraTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientCreateUpdateCassandraTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientCreateUpdateCassandraTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientCreateUpdateCassandraTableResponse will be returned.
func (p *CassandraResourcesClientCreateUpdateCassandraTablePoller) FinalResponse(ctx context.Context) (CassandraResourcesClientCreateUpdateCassandraTableResponse, error) {
	respType := CassandraResourcesClientCreateUpdateCassandraTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CassandraTableGetResults)
	if err != nil {
		return CassandraResourcesClientCreateUpdateCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientCreateUpdateCassandraTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientDeleteCassandraKeyspacePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientDeleteCassandraKeyspacePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientDeleteCassandraKeyspacePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientDeleteCassandraKeyspacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientDeleteCassandraKeyspaceResponse will be returned.
func (p *CassandraResourcesClientDeleteCassandraKeyspacePoller) FinalResponse(ctx context.Context) (CassandraResourcesClientDeleteCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesClientDeleteCassandraKeyspaceResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraResourcesClientDeleteCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientDeleteCassandraKeyspacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientDeleteCassandraTablePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientDeleteCassandraTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientDeleteCassandraTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientDeleteCassandraTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientDeleteCassandraTableResponse will be returned.
func (p *CassandraResourcesClientDeleteCassandraTablePoller) FinalResponse(ctx context.Context) (CassandraResourcesClientDeleteCassandraTableResponse, error) {
	respType := CassandraResourcesClientDeleteCassandraTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraResourcesClientDeleteCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientDeleteCassandraTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientMigrateCassandraKeyspaceToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientMigrateCassandraKeyspaceToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse will be returned.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToAutoscalePoller) FinalResponse(ctx context.Context) (CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse, error) {
	respType := CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesClientMigrateCassandraKeyspaceToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse will be returned.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse, error) {
	respType := CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientMigrateCassandraKeyspaceToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientMigrateCassandraTableToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientMigrateCassandraTableToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientMigrateCassandraTableToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientMigrateCassandraTableToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse will be returned.
func (p *CassandraResourcesClientMigrateCassandraTableToAutoscalePoller) FinalResponse(ctx context.Context) (CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse, error) {
	respType := CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesClientMigrateCassandraTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientMigrateCassandraTableToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientMigrateCassandraTableToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientMigrateCassandraTableToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientMigrateCassandraTableToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientMigrateCassandraTableToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse will be returned.
func (p *CassandraResourcesClientMigrateCassandraTableToManualThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse, error) {
	respType := CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesClientMigrateCassandraTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientMigrateCassandraTableToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientUpdateCassandraKeyspaceThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientUpdateCassandraKeyspaceThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientUpdateCassandraKeyspaceThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientUpdateCassandraKeyspaceThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse will be returned.
func (p *CassandraResourcesClientUpdateCassandraKeyspaceThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse, error) {
	respType := CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesClientUpdateCassandraKeyspaceThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientUpdateCassandraKeyspaceThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesClientUpdateCassandraTableThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesClientUpdateCassandraTableThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesClientUpdateCassandraTableThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesClientUpdateCassandraTableThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesClientUpdateCassandraTableThroughputResponse will be returned.
func (p *CassandraResourcesClientUpdateCassandraTableThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesClientUpdateCassandraTableThroughputResponse, error) {
	respType := CassandraResourcesClientUpdateCassandraTableThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesClientUpdateCassandraTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesClientUpdateCassandraTableThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientCreateOrUpdateResponse will be returned.
func (p *DatabaseAccountsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientCreateOrUpdateResponse, error) {
	respType := DatabaseAccountsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientDeleteResponse will be returned.
func (p *DatabaseAccountsClientDeletePoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientDeleteResponse, error) {
	respType := DatabaseAccountsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientFailoverPriorityChangePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientFailoverPriorityChangePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientFailoverPriorityChangePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientFailoverPriorityChangePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientFailoverPriorityChangeResponse will be returned.
func (p *DatabaseAccountsClientFailoverPriorityChangePoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientFailoverPriorityChangeResponse, error) {
	respType := DatabaseAccountsClientFailoverPriorityChangeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsClientFailoverPriorityChangeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientFailoverPriorityChangePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientOfflineRegionPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientOfflineRegionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientOfflineRegionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientOfflineRegionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientOfflineRegionResponse will be returned.
func (p *DatabaseAccountsClientOfflineRegionPoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientOfflineRegionResponse, error) {
	respType := DatabaseAccountsClientOfflineRegionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsClientOfflineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientOfflineRegionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientOnlineRegionPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientOnlineRegionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientOnlineRegionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientOnlineRegionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientOnlineRegionResponse will be returned.
func (p *DatabaseAccountsClientOnlineRegionPoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientOnlineRegionResponse, error) {
	respType := DatabaseAccountsClientOnlineRegionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsClientOnlineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientOnlineRegionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientRegenerateKeyPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientRegenerateKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientRegenerateKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientRegenerateKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientRegenerateKeyResponse will be returned.
func (p *DatabaseAccountsClientRegenerateKeyPoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientRegenerateKeyResponse, error) {
	respType := DatabaseAccountsClientRegenerateKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsClientRegenerateKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientRegenerateKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsClientUpdateResponse will be returned.
func (p *DatabaseAccountsClientUpdatePoller) FinalResponse(ctx context.Context) (DatabaseAccountsClientUpdateResponse, error) {
	respType := DatabaseAccountsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientCreateUpdateGremlinDatabasePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientCreateUpdateGremlinDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientCreateUpdateGremlinDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientCreateUpdateGremlinDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientCreateUpdateGremlinDatabaseResponse will be returned.
func (p *GremlinResourcesClientCreateUpdateGremlinDatabasePoller) FinalResponse(ctx context.Context) (GremlinResourcesClientCreateUpdateGremlinDatabaseResponse, error) {
	respType := GremlinResourcesClientCreateUpdateGremlinDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GremlinDatabaseGetResults)
	if err != nil {
		return GremlinResourcesClientCreateUpdateGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientCreateUpdateGremlinDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientCreateUpdateGremlinGraphPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientCreateUpdateGremlinGraphPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientCreateUpdateGremlinGraphPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientCreateUpdateGremlinGraphPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientCreateUpdateGremlinGraphResponse will be returned.
func (p *GremlinResourcesClientCreateUpdateGremlinGraphPoller) FinalResponse(ctx context.Context) (GremlinResourcesClientCreateUpdateGremlinGraphResponse, error) {
	respType := GremlinResourcesClientCreateUpdateGremlinGraphResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GremlinGraphGetResults)
	if err != nil {
		return GremlinResourcesClientCreateUpdateGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientCreateUpdateGremlinGraphPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientDeleteGremlinDatabasePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientDeleteGremlinDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientDeleteGremlinDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientDeleteGremlinDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientDeleteGremlinDatabaseResponse will be returned.
func (p *GremlinResourcesClientDeleteGremlinDatabasePoller) FinalResponse(ctx context.Context) (GremlinResourcesClientDeleteGremlinDatabaseResponse, error) {
	respType := GremlinResourcesClientDeleteGremlinDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GremlinResourcesClientDeleteGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientDeleteGremlinDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientDeleteGremlinGraphPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientDeleteGremlinGraphPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientDeleteGremlinGraphPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientDeleteGremlinGraphPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientDeleteGremlinGraphResponse will be returned.
func (p *GremlinResourcesClientDeleteGremlinGraphPoller) FinalResponse(ctx context.Context) (GremlinResourcesClientDeleteGremlinGraphResponse, error) {
	respType := GremlinResourcesClientDeleteGremlinGraphResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GremlinResourcesClientDeleteGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientDeleteGremlinGraphPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientMigrateGremlinDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientMigrateGremlinDatabaseToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientMigrateGremlinDatabaseToAutoscaleResponse will be returned.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (GremlinResourcesClientMigrateGremlinDatabaseToAutoscaleResponse, error) {
	respType := GremlinResourcesClientMigrateGremlinDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesClientMigrateGremlinDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputResponse will be returned.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputResponse, error) {
	respType := GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientMigrateGremlinDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientMigrateGremlinGraphToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientMigrateGremlinGraphToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientMigrateGremlinGraphToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientMigrateGremlinGraphToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientMigrateGremlinGraphToAutoscaleResponse will be returned.
func (p *GremlinResourcesClientMigrateGremlinGraphToAutoscalePoller) FinalResponse(ctx context.Context) (GremlinResourcesClientMigrateGremlinGraphToAutoscaleResponse, error) {
	respType := GremlinResourcesClientMigrateGremlinGraphToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesClientMigrateGremlinGraphToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientMigrateGremlinGraphToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientMigrateGremlinGraphToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientMigrateGremlinGraphToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientMigrateGremlinGraphToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientMigrateGremlinGraphToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientMigrateGremlinGraphToManualThroughputResponse will be returned.
func (p *GremlinResourcesClientMigrateGremlinGraphToManualThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesClientMigrateGremlinGraphToManualThroughputResponse, error) {
	respType := GremlinResourcesClientMigrateGremlinGraphToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesClientMigrateGremlinGraphToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientMigrateGremlinGraphToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientUpdateGremlinDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientUpdateGremlinDatabaseThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientUpdateGremlinDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientUpdateGremlinDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientUpdateGremlinDatabaseThroughputResponse will be returned.
func (p *GremlinResourcesClientUpdateGremlinDatabaseThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesClientUpdateGremlinDatabaseThroughputResponse, error) {
	respType := GremlinResourcesClientUpdateGremlinDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesClientUpdateGremlinDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientUpdateGremlinDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesClientUpdateGremlinGraphThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesClientUpdateGremlinGraphThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesClientUpdateGremlinGraphThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesClientUpdateGremlinGraphThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesClientUpdateGremlinGraphThroughputResponse will be returned.
func (p *GremlinResourcesClientUpdateGremlinGraphThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesClientUpdateGremlinGraphThroughputResponse, error) {
	respType := GremlinResourcesClientUpdateGremlinGraphThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesClientUpdateGremlinGraphThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesClientUpdateGremlinGraphThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientCreateUpdateMongoDBCollectionPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientCreateUpdateMongoDBCollectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientCreateUpdateMongoDBCollectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientCreateUpdateMongoDBCollectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientCreateUpdateMongoDBCollectionResponse will be returned.
func (p *MongoDBResourcesClientCreateUpdateMongoDBCollectionPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientCreateUpdateMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesClientCreateUpdateMongoDBCollectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MongoDBCollectionGetResults)
	if err != nil {
		return MongoDBResourcesClientCreateUpdateMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientCreateUpdateMongoDBCollectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientCreateUpdateMongoDBDatabasePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientCreateUpdateMongoDBDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientCreateUpdateMongoDBDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientCreateUpdateMongoDBDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientCreateUpdateMongoDBDatabaseResponse will be returned.
func (p *MongoDBResourcesClientCreateUpdateMongoDBDatabasePoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientCreateUpdateMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesClientCreateUpdateMongoDBDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MongoDBDatabaseGetResults)
	if err != nil {
		return MongoDBResourcesClientCreateUpdateMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientCreateUpdateMongoDBDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientDeleteMongoDBCollectionPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientDeleteMongoDBCollectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientDeleteMongoDBCollectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientDeleteMongoDBCollectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientDeleteMongoDBCollectionResponse will be returned.
func (p *MongoDBResourcesClientDeleteMongoDBCollectionPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientDeleteMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesClientDeleteMongoDBCollectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return MongoDBResourcesClientDeleteMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientDeleteMongoDBCollectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientDeleteMongoDBDatabasePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientDeleteMongoDBDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientDeleteMongoDBDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientDeleteMongoDBDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientDeleteMongoDBDatabaseResponse will be returned.
func (p *MongoDBResourcesClientDeleteMongoDBDatabasePoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientDeleteMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesClientDeleteMongoDBDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return MongoDBResourcesClientDeleteMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientDeleteMongoDBDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientMigrateMongoDBCollectionToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientMigrateMongoDBCollectionToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientMigrateMongoDBCollectionToAutoscaleResponse will be returned.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToAutoscalePoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientMigrateMongoDBCollectionToAutoscaleResponse, error) {
	respType := MongoDBResourcesClientMigrateMongoDBCollectionToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesClientMigrateMongoDBCollectionToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputResponse will be returned.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputResponse, error) {
	respType := MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientMigrateMongoDBCollectionToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscaleResponse will be returned.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscaleResponse, error) {
	respType := MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputResponse will be returned.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputResponse, error) {
	respType := MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientMigrateMongoDBDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientRetrieveContinuousBackupInformationPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientRetrieveContinuousBackupInformationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientRetrieveContinuousBackupInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientRetrieveContinuousBackupInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientRetrieveContinuousBackupInformationResponse will be returned.
func (p *MongoDBResourcesClientRetrieveContinuousBackupInformationPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientRetrieveContinuousBackupInformationResponse, error) {
	respType := MongoDBResourcesClientRetrieveContinuousBackupInformationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupInformation)
	if err != nil {
		return MongoDBResourcesClientRetrieveContinuousBackupInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientRetrieveContinuousBackupInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientUpdateMongoDBCollectionThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientUpdateMongoDBCollectionThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientUpdateMongoDBCollectionThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientUpdateMongoDBCollectionThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientUpdateMongoDBCollectionThroughputResponse will be returned.
func (p *MongoDBResourcesClientUpdateMongoDBCollectionThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientUpdateMongoDBCollectionThroughputResponse, error) {
	respType := MongoDBResourcesClientUpdateMongoDBCollectionThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesClientUpdateMongoDBCollectionThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientUpdateMongoDBCollectionThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesClientUpdateMongoDBDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesClientUpdateMongoDBDatabaseThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesClientUpdateMongoDBDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesClientUpdateMongoDBDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesClientUpdateMongoDBDatabaseThroughputResponse will be returned.
func (p *MongoDBResourcesClientUpdateMongoDBDatabaseThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesClientUpdateMongoDBDatabaseThroughputResponse, error) {
	respType := MongoDBResourcesClientUpdateMongoDBDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesClientUpdateMongoDBDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesClientUpdateMongoDBDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesClientCreateOrUpdateResponse will be returned.
func (p *NotebookWorkspacesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NotebookWorkspacesClientCreateOrUpdateResponse, error) {
	respType := NotebookWorkspacesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NotebookWorkspace)
	if err != nil {
		return NotebookWorkspacesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesClientDeleteResponse will be returned.
func (p *NotebookWorkspacesClientDeletePoller) FinalResponse(ctx context.Context) (NotebookWorkspacesClientDeleteResponse, error) {
	respType := NotebookWorkspacesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesClientRegenerateAuthTokenPoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesClientRegenerateAuthTokenPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesClientRegenerateAuthTokenPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesClientRegenerateAuthTokenPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesClientRegenerateAuthTokenResponse will be returned.
func (p *NotebookWorkspacesClientRegenerateAuthTokenPoller) FinalResponse(ctx context.Context) (NotebookWorkspacesClientRegenerateAuthTokenResponse, error) {
	respType := NotebookWorkspacesClientRegenerateAuthTokenResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesClientRegenerateAuthTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesClientRegenerateAuthTokenPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesClientStartPoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesClientStartResponse will be returned.
func (p *NotebookWorkspacesClientStartPoller) FinalResponse(ctx context.Context) (NotebookWorkspacesClientStartResponse, error) {
	respType := NotebookWorkspacesClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientCreateOrUpdateResponse will be returned.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsClientDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLContainerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLContainerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLContainerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLContainerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLContainerResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLContainerPoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLContainerResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLContainerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLContainerGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLContainerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLDatabasePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLDatabaseResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLDatabasePoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLDatabaseResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLDatabaseGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLRoleAssignmentPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLRoleAssignmentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLRoleAssignmentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLRoleAssignmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLRoleAssignmentResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLRoleAssignmentPoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLRoleAssignmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLRoleAssignmentGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLRoleAssignmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLRoleDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLRoleDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLRoleDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLRoleDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLRoleDefinitionResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLRoleDefinitionPoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLRoleDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLRoleDefinitionGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLRoleDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLStoredProcedurePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLStoredProcedurePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLStoredProcedurePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLStoredProcedurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLStoredProcedureResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLStoredProcedurePoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLStoredProcedureResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLStoredProcedureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLStoredProcedureGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLStoredProcedurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLTriggerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLTriggerResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLTriggerPoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLTriggerResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLTriggerGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientCreateUpdateSQLUserDefinedFunctionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientCreateUpdateSQLUserDefinedFunctionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientCreateUpdateSQLUserDefinedFunctionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientCreateUpdateSQLUserDefinedFunctionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientCreateUpdateSQLUserDefinedFunctionResponse will be returned.
func (p *SQLResourcesClientCreateUpdateSQLUserDefinedFunctionPoller) FinalResponse(ctx context.Context) (SQLResourcesClientCreateUpdateSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesClientCreateUpdateSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLUserDefinedFunctionGetResults)
	if err != nil {
		return SQLResourcesClientCreateUpdateSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientCreateUpdateSQLUserDefinedFunctionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLContainerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLContainerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLContainerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLContainerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLContainerResponse will be returned.
func (p *SQLResourcesClientDeleteSQLContainerPoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLContainerResponse, error) {
	respType := SQLResourcesClientDeleteSQLContainerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLContainerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLDatabasePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLDatabaseResponse will be returned.
func (p *SQLResourcesClientDeleteSQLDatabasePoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLDatabaseResponse, error) {
	respType := SQLResourcesClientDeleteSQLDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLRoleAssignmentPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLRoleAssignmentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLRoleAssignmentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLRoleAssignmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLRoleAssignmentResponse will be returned.
func (p *SQLResourcesClientDeleteSQLRoleAssignmentPoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesClientDeleteSQLRoleAssignmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLRoleAssignmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLRoleDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLRoleDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLRoleDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLRoleDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLRoleDefinitionResponse will be returned.
func (p *SQLResourcesClientDeleteSQLRoleDefinitionPoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesClientDeleteSQLRoleDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLRoleDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLStoredProcedurePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLStoredProcedurePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLStoredProcedurePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLStoredProcedurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLStoredProcedureResponse will be returned.
func (p *SQLResourcesClientDeleteSQLStoredProcedurePoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLStoredProcedureResponse, error) {
	respType := SQLResourcesClientDeleteSQLStoredProcedureResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLStoredProcedurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLTriggerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLTriggerResponse will be returned.
func (p *SQLResourcesClientDeleteSQLTriggerPoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLTriggerResponse, error) {
	respType := SQLResourcesClientDeleteSQLTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientDeleteSQLUserDefinedFunctionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientDeleteSQLUserDefinedFunctionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientDeleteSQLUserDefinedFunctionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientDeleteSQLUserDefinedFunctionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientDeleteSQLUserDefinedFunctionResponse will be returned.
func (p *SQLResourcesClientDeleteSQLUserDefinedFunctionPoller) FinalResponse(ctx context.Context) (SQLResourcesClientDeleteSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesClientDeleteSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesClientDeleteSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientDeleteSQLUserDefinedFunctionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientMigrateSQLContainerToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientMigrateSQLContainerToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientMigrateSQLContainerToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientMigrateSQLContainerToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientMigrateSQLContainerToAutoscaleResponse will be returned.
func (p *SQLResourcesClientMigrateSQLContainerToAutoscalePoller) FinalResponse(ctx context.Context) (SQLResourcesClientMigrateSQLContainerToAutoscaleResponse, error) {
	respType := SQLResourcesClientMigrateSQLContainerToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesClientMigrateSQLContainerToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientMigrateSQLContainerToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientMigrateSQLContainerToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientMigrateSQLContainerToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientMigrateSQLContainerToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientMigrateSQLContainerToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientMigrateSQLContainerToManualThroughputResponse will be returned.
func (p *SQLResourcesClientMigrateSQLContainerToManualThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesClientMigrateSQLContainerToManualThroughputResponse, error) {
	respType := SQLResourcesClientMigrateSQLContainerToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesClientMigrateSQLContainerToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientMigrateSQLContainerToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientMigrateSQLDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientMigrateSQLDatabaseToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientMigrateSQLDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientMigrateSQLDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientMigrateSQLDatabaseToAutoscaleResponse will be returned.
func (p *SQLResourcesClientMigrateSQLDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (SQLResourcesClientMigrateSQLDatabaseToAutoscaleResponse, error) {
	respType := SQLResourcesClientMigrateSQLDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesClientMigrateSQLDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientMigrateSQLDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientMigrateSQLDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientMigrateSQLDatabaseToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientMigrateSQLDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientMigrateSQLDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientMigrateSQLDatabaseToManualThroughputResponse will be returned.
func (p *SQLResourcesClientMigrateSQLDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesClientMigrateSQLDatabaseToManualThroughputResponse, error) {
	respType := SQLResourcesClientMigrateSQLDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesClientMigrateSQLDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientMigrateSQLDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientRetrieveContinuousBackupInformationPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientRetrieveContinuousBackupInformationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientRetrieveContinuousBackupInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientRetrieveContinuousBackupInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientRetrieveContinuousBackupInformationResponse will be returned.
func (p *SQLResourcesClientRetrieveContinuousBackupInformationPoller) FinalResponse(ctx context.Context) (SQLResourcesClientRetrieveContinuousBackupInformationResponse, error) {
	respType := SQLResourcesClientRetrieveContinuousBackupInformationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupInformation)
	if err != nil {
		return SQLResourcesClientRetrieveContinuousBackupInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientRetrieveContinuousBackupInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientUpdateSQLContainerThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientUpdateSQLContainerThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientUpdateSQLContainerThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientUpdateSQLContainerThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientUpdateSQLContainerThroughputResponse will be returned.
func (p *SQLResourcesClientUpdateSQLContainerThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesClientUpdateSQLContainerThroughputResponse, error) {
	respType := SQLResourcesClientUpdateSQLContainerThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesClientUpdateSQLContainerThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientUpdateSQLContainerThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesClientUpdateSQLDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesClientUpdateSQLDatabaseThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesClientUpdateSQLDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesClientUpdateSQLDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesClientUpdateSQLDatabaseThroughputResponse will be returned.
func (p *SQLResourcesClientUpdateSQLDatabaseThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesClientUpdateSQLDatabaseThroughputResponse, error) {
	respType := SQLResourcesClientUpdateSQLDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesClientUpdateSQLDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesClientUpdateSQLDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesClientCreateUpdateTablePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesClientCreateUpdateTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesClientCreateUpdateTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesClientCreateUpdateTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesClientCreateUpdateTableResponse will be returned.
func (p *TableResourcesClientCreateUpdateTablePoller) FinalResponse(ctx context.Context) (TableResourcesClientCreateUpdateTableResponse, error) {
	respType := TableResourcesClientCreateUpdateTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TableGetResults)
	if err != nil {
		return TableResourcesClientCreateUpdateTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesClientCreateUpdateTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesClientDeleteTablePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesClientDeleteTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesClientDeleteTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesClientDeleteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesClientDeleteTableResponse will be returned.
func (p *TableResourcesClientDeleteTablePoller) FinalResponse(ctx context.Context) (TableResourcesClientDeleteTableResponse, error) {
	respType := TableResourcesClientDeleteTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TableResourcesClientDeleteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesClientDeleteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesClientMigrateTableToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesClientMigrateTableToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesClientMigrateTableToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesClientMigrateTableToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesClientMigrateTableToAutoscaleResponse will be returned.
func (p *TableResourcesClientMigrateTableToAutoscalePoller) FinalResponse(ctx context.Context) (TableResourcesClientMigrateTableToAutoscaleResponse, error) {
	respType := TableResourcesClientMigrateTableToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesClientMigrateTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesClientMigrateTableToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesClientMigrateTableToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesClientMigrateTableToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesClientMigrateTableToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesClientMigrateTableToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesClientMigrateTableToManualThroughputResponse will be returned.
func (p *TableResourcesClientMigrateTableToManualThroughputPoller) FinalResponse(ctx context.Context) (TableResourcesClientMigrateTableToManualThroughputResponse, error) {
	respType := TableResourcesClientMigrateTableToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesClientMigrateTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesClientMigrateTableToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesClientUpdateTableThroughputPoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesClientUpdateTableThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesClientUpdateTableThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesClientUpdateTableThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesClientUpdateTableThroughputResponse will be returned.
func (p *TableResourcesClientUpdateTableThroughputPoller) FinalResponse(ctx context.Context) (TableResourcesClientUpdateTableThroughputResponse, error) {
	respType := TableResourcesClientUpdateTableThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesClientUpdateTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesClientUpdateTableThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
