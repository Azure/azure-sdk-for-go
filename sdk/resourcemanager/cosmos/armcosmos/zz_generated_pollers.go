//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// CassandraClustersCreateUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersCreateUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersCreateUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersCreateUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersCreateUpdateResponse will be returned.
func (p *CassandraClustersCreateUpdatePoller) FinalResponse(ctx context.Context) (CassandraClustersCreateUpdateResponse, error) {
	respType := CassandraClustersCreateUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ClusterResource)
	if err != nil {
		return CassandraClustersCreateUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersCreateUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersDeallocatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersDeallocatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersDeallocatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersDeallocatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersDeallocateResponse will be returned.
func (p *CassandraClustersDeallocatePoller) FinalResponse(ctx context.Context) (CassandraClustersDeallocateResponse, error) {
	respType := CassandraClustersDeallocateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraClustersDeallocateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersDeallocatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersDeletePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersDeleteResponse will be returned.
func (p *CassandraClustersDeletePoller) FinalResponse(ctx context.Context) (CassandraClustersDeleteResponse, error) {
	respType := CassandraClustersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersInvokeCommandPoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersInvokeCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersInvokeCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersInvokeCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersInvokeCommandResponse will be returned.
func (p *CassandraClustersInvokeCommandPoller) FinalResponse(ctx context.Context) (CassandraClustersInvokeCommandResponse, error) {
	respType := CassandraClustersInvokeCommandResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CommandOutput)
	if err != nil {
		return CassandraClustersInvokeCommandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersInvokeCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersStartPoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersStartResponse will be returned.
func (p *CassandraClustersStartPoller) FinalResponse(ctx context.Context) (CassandraClustersStartResponse, error) {
	respType := CassandraClustersStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraClustersStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraClustersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraClustersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraClustersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraClustersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraClustersUpdateResponse will be returned.
func (p *CassandraClustersUpdatePoller) FinalResponse(ctx context.Context) (CassandraClustersUpdateResponse, error) {
	respType := CassandraClustersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ClusterResource)
	if err != nil {
		return CassandraClustersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraClustersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraDataCentersCreateUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraDataCentersCreateUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraDataCentersCreateUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraDataCentersCreateUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraDataCentersCreateUpdateResponse will be returned.
func (p *CassandraDataCentersCreateUpdatePoller) FinalResponse(ctx context.Context) (CassandraDataCentersCreateUpdateResponse, error) {
	respType := CassandraDataCentersCreateUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataCenterResource)
	if err != nil {
		return CassandraDataCentersCreateUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraDataCentersCreateUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraDataCentersDeletePoller provides polling facilities until the operation reaches a terminal state.
type CassandraDataCentersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraDataCentersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraDataCentersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraDataCentersDeleteResponse will be returned.
func (p *CassandraDataCentersDeletePoller) FinalResponse(ctx context.Context) (CassandraDataCentersDeleteResponse, error) {
	respType := CassandraDataCentersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraDataCentersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraDataCentersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraDataCentersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CassandraDataCentersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraDataCentersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraDataCentersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraDataCentersUpdateResponse will be returned.
func (p *CassandraDataCentersUpdatePoller) FinalResponse(ctx context.Context) (CassandraDataCentersUpdateResponse, error) {
	respType := CassandraDataCentersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataCenterResource)
	if err != nil {
		return CassandraDataCentersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraDataCentersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesCreateUpdateCassandraKeyspacePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesCreateUpdateCassandraKeyspacePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesCreateUpdateCassandraKeyspacePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesCreateUpdateCassandraKeyspacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesCreateUpdateCassandraKeyspaceResponse will be returned.
func (p *CassandraResourcesCreateUpdateCassandraKeyspacePoller) FinalResponse(ctx context.Context) (CassandraResourcesCreateUpdateCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CassandraKeyspaceGetResults)
	if err != nil {
		return CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesCreateUpdateCassandraKeyspacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesCreateUpdateCassandraTablePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesCreateUpdateCassandraTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesCreateUpdateCassandraTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesCreateUpdateCassandraTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesCreateUpdateCassandraTableResponse will be returned.
func (p *CassandraResourcesCreateUpdateCassandraTablePoller) FinalResponse(ctx context.Context) (CassandraResourcesCreateUpdateCassandraTableResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CassandraTableGetResults)
	if err != nil {
		return CassandraResourcesCreateUpdateCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesCreateUpdateCassandraTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesDeleteCassandraKeyspacePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesDeleteCassandraKeyspacePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesDeleteCassandraKeyspacePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesDeleteCassandraKeyspacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesDeleteCassandraKeyspaceResponse will be returned.
func (p *CassandraResourcesDeleteCassandraKeyspacePoller) FinalResponse(ctx context.Context) (CassandraResourcesDeleteCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesDeleteCassandraKeyspaceResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraResourcesDeleteCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesDeleteCassandraKeyspacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesDeleteCassandraTablePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesDeleteCassandraTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesDeleteCassandraTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesDeleteCassandraTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesDeleteCassandraTableResponse will be returned.
func (p *CassandraResourcesDeleteCassandraTablePoller) FinalResponse(ctx context.Context) (CassandraResourcesDeleteCassandraTableResponse, error) {
	respType := CassandraResourcesDeleteCassandraTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraResourcesDeleteCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesDeleteCassandraTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse will be returned.
func (p *CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse will be returned.
func (p *CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesMigrateCassandraTableToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraTableToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesMigrateCassandraTableToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesMigrateCassandraTableToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesMigrateCassandraTableToAutoscaleResponse will be returned.
func (p *CassandraResourcesMigrateCassandraTableToAutoscalePoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraTableToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesMigrateCassandraTableToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesMigrateCassandraTableToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraTableToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesMigrateCassandraTableToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesMigrateCassandraTableToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesMigrateCassandraTableToManualThroughputResponse will be returned.
func (p *CassandraResourcesMigrateCassandraTableToManualThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraTableToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesMigrateCassandraTableToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesUpdateCassandraKeyspaceThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesUpdateCassandraKeyspaceThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesUpdateCassandraKeyspaceThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesUpdateCassandraKeyspaceThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesUpdateCassandraKeyspaceThroughputResponse will be returned.
func (p *CassandraResourcesUpdateCassandraKeyspaceThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesUpdateCassandraKeyspaceThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesUpdateCassandraKeyspaceThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CassandraResourcesUpdateCassandraTableThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesUpdateCassandraTableThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CassandraResourcesUpdateCassandraTableThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CassandraResourcesUpdateCassandraTableThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CassandraResourcesUpdateCassandraTableThroughputResponse will be returned.
func (p *CassandraResourcesUpdateCassandraTableThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesUpdateCassandraTableThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraTableThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesUpdateCassandraTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CassandraResourcesUpdateCassandraTableThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsCreateOrUpdateResponse will be returned.
func (p *DatabaseAccountsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabaseAccountsCreateOrUpdateResponse, error) {
	respType := DatabaseAccountsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsDeleteResponse will be returned.
func (p *DatabaseAccountsDeletePoller) FinalResponse(ctx context.Context) (DatabaseAccountsDeleteResponse, error) {
	respType := DatabaseAccountsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsFailoverPriorityChangePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsFailoverPriorityChangePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsFailoverPriorityChangePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsFailoverPriorityChangePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsFailoverPriorityChangeResponse will be returned.
func (p *DatabaseAccountsFailoverPriorityChangePoller) FinalResponse(ctx context.Context) (DatabaseAccountsFailoverPriorityChangeResponse, error) {
	respType := DatabaseAccountsFailoverPriorityChangeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsFailoverPriorityChangeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsFailoverPriorityChangePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsOfflineRegionPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsOfflineRegionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsOfflineRegionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsOfflineRegionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsOfflineRegionResponse will be returned.
func (p *DatabaseAccountsOfflineRegionPoller) FinalResponse(ctx context.Context) (DatabaseAccountsOfflineRegionResponse, error) {
	respType := DatabaseAccountsOfflineRegionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsOfflineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsOfflineRegionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsOnlineRegionPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsOnlineRegionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsOnlineRegionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsOnlineRegionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsOnlineRegionResponse will be returned.
func (p *DatabaseAccountsOnlineRegionPoller) FinalResponse(ctx context.Context) (DatabaseAccountsOnlineRegionResponse, error) {
	respType := DatabaseAccountsOnlineRegionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsOnlineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsOnlineRegionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsRegenerateKeyPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsRegenerateKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsRegenerateKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsRegenerateKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsRegenerateKeyResponse will be returned.
func (p *DatabaseAccountsRegenerateKeyPoller) FinalResponse(ctx context.Context) (DatabaseAccountsRegenerateKeyResponse, error) {
	respType := DatabaseAccountsRegenerateKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsRegenerateKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsRegenerateKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseAccountsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseAccountsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseAccountsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseAccountsUpdateResponse will be returned.
func (p *DatabaseAccountsUpdatePoller) FinalResponse(ctx context.Context) (DatabaseAccountsUpdateResponse, error) {
	respType := DatabaseAccountsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseAccountsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesCreateUpdateGremlinDatabasePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesCreateUpdateGremlinDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesCreateUpdateGremlinDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesCreateUpdateGremlinDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesCreateUpdateGremlinDatabaseResponse will be returned.
func (p *GremlinResourcesCreateUpdateGremlinDatabasePoller) FinalResponse(ctx context.Context) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GremlinDatabaseGetResults)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesCreateUpdateGremlinDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesCreateUpdateGremlinGraphPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesCreateUpdateGremlinGraphPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesCreateUpdateGremlinGraphPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesCreateUpdateGremlinGraphPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesCreateUpdateGremlinGraphResponse will be returned.
func (p *GremlinResourcesCreateUpdateGremlinGraphPoller) FinalResponse(ctx context.Context) (GremlinResourcesCreateUpdateGremlinGraphResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinGraphResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GremlinGraphGetResults)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesCreateUpdateGremlinGraphPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesDeleteGremlinDatabasePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesDeleteGremlinDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesDeleteGremlinDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesDeleteGremlinDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesDeleteGremlinDatabaseResponse will be returned.
func (p *GremlinResourcesDeleteGremlinDatabasePoller) FinalResponse(ctx context.Context) (GremlinResourcesDeleteGremlinDatabaseResponse, error) {
	respType := GremlinResourcesDeleteGremlinDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesDeleteGremlinDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesDeleteGremlinGraphPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesDeleteGremlinGraphPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesDeleteGremlinGraphPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesDeleteGremlinGraphPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesDeleteGremlinGraphResponse will be returned.
func (p *GremlinResourcesDeleteGremlinGraphPoller) FinalResponse(ctx context.Context) (GremlinResourcesDeleteGremlinGraphResponse, error) {
	respType := GremlinResourcesDeleteGremlinGraphResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesDeleteGremlinGraphPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse will be returned.
func (p *GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse will be returned.
func (p *GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesMigrateGremlinGraphToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinGraphToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesMigrateGremlinGraphToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesMigrateGremlinGraphToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesMigrateGremlinGraphToAutoscaleResponse will be returned.
func (p *GremlinResourcesMigrateGremlinGraphToAutoscalePoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesMigrateGremlinGraphToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesMigrateGremlinGraphToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinGraphToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesMigrateGremlinGraphToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesMigrateGremlinGraphToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesMigrateGremlinGraphToManualThroughputResponse will be returned.
func (p *GremlinResourcesMigrateGremlinGraphToManualThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesMigrateGremlinGraphToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesUpdateGremlinDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesUpdateGremlinDatabaseThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesUpdateGremlinDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesUpdateGremlinDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesUpdateGremlinDatabaseThroughputResponse will be returned.
func (p *GremlinResourcesUpdateGremlinDatabaseThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesUpdateGremlinDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GremlinResourcesUpdateGremlinGraphThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesUpdateGremlinGraphThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GremlinResourcesUpdateGremlinGraphThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GremlinResourcesUpdateGremlinGraphThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GremlinResourcesUpdateGremlinGraphThroughputResponse will be returned.
func (p *GremlinResourcesUpdateGremlinGraphThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinGraphThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GremlinResourcesUpdateGremlinGraphThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesCreateUpdateMongoDBCollectionPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesCreateUpdateMongoDBCollectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesCreateUpdateMongoDBCollectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesCreateUpdateMongoDBCollectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesCreateUpdateMongoDBCollectionResponse will be returned.
func (p *MongoDBResourcesCreateUpdateMongoDBCollectionPoller) FinalResponse(ctx context.Context) (MongoDBResourcesCreateUpdateMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MongoDBCollectionGetResults)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesCreateUpdateMongoDBCollectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesCreateUpdateMongoDBDatabasePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesCreateUpdateMongoDBDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesCreateUpdateMongoDBDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesCreateUpdateMongoDBDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesCreateUpdateMongoDBDatabaseResponse will be returned.
func (p *MongoDBResourcesCreateUpdateMongoDBDatabasePoller) FinalResponse(ctx context.Context) (MongoDBResourcesCreateUpdateMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MongoDBDatabaseGetResults)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesCreateUpdateMongoDBDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesDeleteMongoDBCollectionPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesDeleteMongoDBCollectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesDeleteMongoDBCollectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesDeleteMongoDBCollectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesDeleteMongoDBCollectionResponse will be returned.
func (p *MongoDBResourcesDeleteMongoDBCollectionPoller) FinalResponse(ctx context.Context) (MongoDBResourcesDeleteMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBCollectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesDeleteMongoDBCollectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesDeleteMongoDBDatabasePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesDeleteMongoDBDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesDeleteMongoDBDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesDeleteMongoDBDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesDeleteMongoDBDatabaseResponse will be returned.
func (p *MongoDBResourcesDeleteMongoDBDatabasePoller) FinalResponse(ctx context.Context) (MongoDBResourcesDeleteMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesDeleteMongoDBDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse will be returned.
func (p *MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse will be returned.
func (p *MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse will be returned.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse will be returned.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesRetrieveContinuousBackupInformationPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesRetrieveContinuousBackupInformationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesRetrieveContinuousBackupInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesRetrieveContinuousBackupInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesRetrieveContinuousBackupInformationResponse will be returned.
func (p *MongoDBResourcesRetrieveContinuousBackupInformationPoller) FinalResponse(ctx context.Context) (MongoDBResourcesRetrieveContinuousBackupInformationResponse, error) {
	respType := MongoDBResourcesRetrieveContinuousBackupInformationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupInformation)
	if err != nil {
		return MongoDBResourcesRetrieveContinuousBackupInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesRetrieveContinuousBackupInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesUpdateMongoDBCollectionThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesUpdateMongoDBCollectionThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesUpdateMongoDBCollectionThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesUpdateMongoDBCollectionThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesUpdateMongoDBCollectionThroughputResponse will be returned.
func (p *MongoDBResourcesUpdateMongoDBCollectionThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesUpdateMongoDBCollectionThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesUpdateMongoDBCollectionThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse will be returned.
func (p *MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesCreateOrUpdateResponse will be returned.
func (p *NotebookWorkspacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NotebookWorkspacesCreateOrUpdateResponse, error) {
	respType := NotebookWorkspacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NotebookWorkspace)
	if err != nil {
		return NotebookWorkspacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesDeleteResponse will be returned.
func (p *NotebookWorkspacesDeletePoller) FinalResponse(ctx context.Context) (NotebookWorkspacesDeleteResponse, error) {
	respType := NotebookWorkspacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesRegenerateAuthTokenPoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesRegenerateAuthTokenPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesRegenerateAuthTokenPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesRegenerateAuthTokenPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesRegenerateAuthTokenResponse will be returned.
func (p *NotebookWorkspacesRegenerateAuthTokenPoller) FinalResponse(ctx context.Context) (NotebookWorkspacesRegenerateAuthTokenResponse, error) {
	respType := NotebookWorkspacesRegenerateAuthTokenResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesRegenerateAuthTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesRegenerateAuthTokenPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookWorkspacesStartPoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookWorkspacesStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookWorkspacesStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookWorkspacesStartResponse will be returned.
func (p *NotebookWorkspacesStartPoller) FinalResponse(ctx context.Context) (NotebookWorkspacesStartResponse, error) {
	respType := NotebookWorkspacesStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookWorkspacesStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsCreateOrUpdateResponse will be returned.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLContainerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLContainerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLContainerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLContainerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLContainerResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLContainerPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLContainerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLContainerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLContainerGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLContainerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLDatabasePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLDatabaseResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLDatabasePoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLDatabaseResponse, error) {
	respType := SQLResourcesCreateUpdateSQLDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLDatabaseGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLRoleAssignmentPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLRoleAssignmentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLRoleAssignmentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLRoleAssignmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLRoleAssignmentResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLRoleAssignmentPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLRoleAssignmentGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLRoleAssignmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLRoleDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLRoleDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLRoleDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLRoleDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLRoleDefinitionResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLRoleDefinitionPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLRoleDefinitionGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLRoleDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLStoredProcedurePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLStoredProcedurePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLStoredProcedurePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLStoredProcedurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLStoredProcedureResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLStoredProcedurePoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLStoredProcedureResponse, error) {
	respType := SQLResourcesCreateUpdateSQLStoredProcedureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLStoredProcedureGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLStoredProcedurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLTriggerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLTriggerResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLTriggerPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLTriggerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLTriggerGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse will be returned.
func (p *SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLUserDefinedFunctionGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLContainerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLContainerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLContainerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLContainerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLContainerResponse will be returned.
func (p *SQLResourcesDeleteSQLContainerPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLContainerResponse, error) {
	respType := SQLResourcesDeleteSQLContainerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLContainerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLDatabasePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLDatabaseResponse will be returned.
func (p *SQLResourcesDeleteSQLDatabasePoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLDatabaseResponse, error) {
	respType := SQLResourcesDeleteSQLDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLRoleAssignmentPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLRoleAssignmentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLRoleAssignmentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLRoleAssignmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLRoleAssignmentResponse will be returned.
func (p *SQLResourcesDeleteSQLRoleAssignmentPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesDeleteSQLRoleAssignmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLRoleAssignmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLRoleDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLRoleDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLRoleDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLRoleDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLRoleDefinitionResponse will be returned.
func (p *SQLResourcesDeleteSQLRoleDefinitionPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesDeleteSQLRoleDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLRoleDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLStoredProcedurePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLStoredProcedurePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLStoredProcedurePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLStoredProcedurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLStoredProcedureResponse will be returned.
func (p *SQLResourcesDeleteSQLStoredProcedurePoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLStoredProcedureResponse, error) {
	respType := SQLResourcesDeleteSQLStoredProcedureResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLStoredProcedurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLTriggerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLTriggerResponse will be returned.
func (p *SQLResourcesDeleteSQLTriggerPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLTriggerResponse, error) {
	respType := SQLResourcesDeleteSQLTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesDeleteSQLUserDefinedFunctionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLUserDefinedFunctionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesDeleteSQLUserDefinedFunctionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesDeleteSQLUserDefinedFunctionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesDeleteSQLUserDefinedFunctionResponse will be returned.
func (p *SQLResourcesDeleteSQLUserDefinedFunctionPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesDeleteSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesDeleteSQLUserDefinedFunctionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesMigrateSQLContainerToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLContainerToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesMigrateSQLContainerToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesMigrateSQLContainerToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesMigrateSQLContainerToAutoscaleResponse will be returned.
func (p *SQLResourcesMigrateSQLContainerToAutoscalePoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLContainerToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLContainerToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesMigrateSQLContainerToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesMigrateSQLContainerToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLContainerToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesMigrateSQLContainerToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesMigrateSQLContainerToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesMigrateSQLContainerToManualThroughputResponse will be returned.
func (p *SQLResourcesMigrateSQLContainerToManualThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLContainerToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLContainerToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesMigrateSQLContainerToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesMigrateSQLDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLDatabaseToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesMigrateSQLDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesMigrateSQLDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesMigrateSQLDatabaseToAutoscaleResponse will be returned.
func (p *SQLResourcesMigrateSQLDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLDatabaseToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesMigrateSQLDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesMigrateSQLDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLDatabaseToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesMigrateSQLDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesMigrateSQLDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesMigrateSQLDatabaseToManualThroughputResponse will be returned.
func (p *SQLResourcesMigrateSQLDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLDatabaseToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesMigrateSQLDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesRetrieveContinuousBackupInformationPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesRetrieveContinuousBackupInformationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesRetrieveContinuousBackupInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesRetrieveContinuousBackupInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesRetrieveContinuousBackupInformationResponse will be returned.
func (p *SQLResourcesRetrieveContinuousBackupInformationPoller) FinalResponse(ctx context.Context) (SQLResourcesRetrieveContinuousBackupInformationResponse, error) {
	respType := SQLResourcesRetrieveContinuousBackupInformationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupInformation)
	if err != nil {
		return SQLResourcesRetrieveContinuousBackupInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesRetrieveContinuousBackupInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesUpdateSQLContainerThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesUpdateSQLContainerThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesUpdateSQLContainerThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesUpdateSQLContainerThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesUpdateSQLContainerThroughputResponse will be returned.
func (p *SQLResourcesUpdateSQLContainerThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesUpdateSQLContainerThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLContainerThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesUpdateSQLContainerThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesUpdateSQLContainerThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLResourcesUpdateSQLDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesUpdateSQLDatabaseThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLResourcesUpdateSQLDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLResourcesUpdateSQLDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLResourcesUpdateSQLDatabaseThroughputResponse will be returned.
func (p *SQLResourcesUpdateSQLDatabaseThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesUpdateSQLDatabaseThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesUpdateSQLDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLResourcesUpdateSQLDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesCreateUpdateTablePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesCreateUpdateTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesCreateUpdateTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesCreateUpdateTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesCreateUpdateTableResponse will be returned.
func (p *TableResourcesCreateUpdateTablePoller) FinalResponse(ctx context.Context) (TableResourcesCreateUpdateTableResponse, error) {
	respType := TableResourcesCreateUpdateTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TableGetResults)
	if err != nil {
		return TableResourcesCreateUpdateTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesCreateUpdateTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesDeleteTablePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesDeleteTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesDeleteTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesDeleteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesDeleteTableResponse will be returned.
func (p *TableResourcesDeleteTablePoller) FinalResponse(ctx context.Context) (TableResourcesDeleteTableResponse, error) {
	respType := TableResourcesDeleteTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TableResourcesDeleteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesDeleteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesMigrateTableToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesMigrateTableToAutoscalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesMigrateTableToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesMigrateTableToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesMigrateTableToAutoscaleResponse will be returned.
func (p *TableResourcesMigrateTableToAutoscalePoller) FinalResponse(ctx context.Context) (TableResourcesMigrateTableToAutoscaleResponse, error) {
	respType := TableResourcesMigrateTableToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesMigrateTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesMigrateTableToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesMigrateTableToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesMigrateTableToManualThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesMigrateTableToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesMigrateTableToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesMigrateTableToManualThroughputResponse will be returned.
func (p *TableResourcesMigrateTableToManualThroughputPoller) FinalResponse(ctx context.Context) (TableResourcesMigrateTableToManualThroughputResponse, error) {
	respType := TableResourcesMigrateTableToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesMigrateTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesMigrateTableToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TableResourcesUpdateTableThroughputPoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesUpdateTableThroughputPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TableResourcesUpdateTableThroughputPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TableResourcesUpdateTableThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TableResourcesUpdateTableThroughputResponse will be returned.
func (p *TableResourcesUpdateTableThroughputPoller) FinalResponse(ctx context.Context) (TableResourcesUpdateTableThroughputResponse, error) {
	respType := TableResourcesUpdateTableThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesUpdateTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TableResourcesUpdateTableThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
