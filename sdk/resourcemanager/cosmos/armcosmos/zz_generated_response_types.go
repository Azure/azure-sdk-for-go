//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// CassandraClustersCreateUpdatePollerResponse contains the response from method CassandraClusters.CreateUpdate.
type CassandraClustersCreateUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraClustersCreateUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraClustersCreateUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraClustersCreateUpdateResponse, error) {
	respType := CassandraClustersCreateUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ClusterResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraClustersCreateUpdatePollerResponse from the provided client and resume token.
func (l *CassandraClustersCreateUpdatePollerResponse) Resume(ctx context.Context, client *CassandraClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraClustersClient.CreateUpdate", token, client.pl, client.createUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraClustersCreateUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraClustersCreateUpdateResponse contains the response from method CassandraClusters.CreateUpdate.
type CassandraClustersCreateUpdateResponse struct {
	CassandraClustersCreateUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersCreateUpdateResult contains the result from method CassandraClusters.CreateUpdate.
type CassandraClustersCreateUpdateResult struct {
	ClusterResource
}

// CassandraClustersDeallocatePollerResponse contains the response from method CassandraClusters.Deallocate.
type CassandraClustersDeallocatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraClustersDeallocatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraClustersDeallocatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraClustersDeallocateResponse, error) {
	respType := CassandraClustersDeallocateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraClustersDeallocatePollerResponse from the provided client and resume token.
func (l *CassandraClustersDeallocatePollerResponse) Resume(ctx context.Context, client *CassandraClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraClustersClient.Deallocate", token, client.pl, client.deallocateHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraClustersDeallocatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraClustersDeallocateResponse contains the response from method CassandraClusters.Deallocate.
type CassandraClustersDeallocateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersDeletePollerResponse contains the response from method CassandraClusters.Delete.
type CassandraClustersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraClustersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraClustersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraClustersDeleteResponse, error) {
	respType := CassandraClustersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraClustersDeletePollerResponse from the provided client and resume token.
func (l *CassandraClustersDeletePollerResponse) Resume(ctx context.Context, client *CassandraClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraClustersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraClustersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraClustersDeleteResponse contains the response from method CassandraClusters.Delete.
type CassandraClustersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersGetResponse contains the response from method CassandraClusters.Get.
type CassandraClustersGetResponse struct {
	CassandraClustersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersGetResult contains the result from method CassandraClusters.Get.
type CassandraClustersGetResult struct {
	ClusterResource
}

// CassandraClustersInvokeCommandPollerResponse contains the response from method CassandraClusters.InvokeCommand.
type CassandraClustersInvokeCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraClustersInvokeCommandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraClustersInvokeCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraClustersInvokeCommandResponse, error) {
	respType := CassandraClustersInvokeCommandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CommandOutput)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraClustersInvokeCommandPollerResponse from the provided client and resume token.
func (l *CassandraClustersInvokeCommandPollerResponse) Resume(ctx context.Context, client *CassandraClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraClustersClient.InvokeCommand", token, client.pl, client.invokeCommandHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraClustersInvokeCommandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraClustersInvokeCommandResponse contains the response from method CassandraClusters.InvokeCommand.
type CassandraClustersInvokeCommandResponse struct {
	CassandraClustersInvokeCommandResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersInvokeCommandResult contains the result from method CassandraClusters.InvokeCommand.
type CassandraClustersInvokeCommandResult struct {
	CommandOutput
}

// CassandraClustersListByResourceGroupResponse contains the response from method CassandraClusters.ListByResourceGroup.
type CassandraClustersListByResourceGroupResponse struct {
	CassandraClustersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersListByResourceGroupResult contains the result from method CassandraClusters.ListByResourceGroup.
type CassandraClustersListByResourceGroupResult struct {
	ListClusters
}

// CassandraClustersListBySubscriptionResponse contains the response from method CassandraClusters.ListBySubscription.
type CassandraClustersListBySubscriptionResponse struct {
	CassandraClustersListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersListBySubscriptionResult contains the result from method CassandraClusters.ListBySubscription.
type CassandraClustersListBySubscriptionResult struct {
	ListClusters
}

// CassandraClustersStartPollerResponse contains the response from method CassandraClusters.Start.
type CassandraClustersStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraClustersStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraClustersStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraClustersStartResponse, error) {
	respType := CassandraClustersStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraClustersStartPollerResponse from the provided client and resume token.
func (l *CassandraClustersStartPollerResponse) Resume(ctx context.Context, client *CassandraClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraClustersClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraClustersStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraClustersStartResponse contains the response from method CassandraClusters.Start.
type CassandraClustersStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersStatusResponse contains the response from method CassandraClusters.Status.
type CassandraClustersStatusResponse struct {
	CassandraClustersStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersStatusResult contains the result from method CassandraClusters.Status.
type CassandraClustersStatusResult struct {
	CassandraClusterPublicStatus
}

// CassandraClustersUpdatePollerResponse contains the response from method CassandraClusters.Update.
type CassandraClustersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraClustersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraClustersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraClustersUpdateResponse, error) {
	respType := CassandraClustersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ClusterResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraClustersUpdatePollerResponse from the provided client and resume token.
func (l *CassandraClustersUpdatePollerResponse) Resume(ctx context.Context, client *CassandraClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraClustersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraClustersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraClustersUpdateResponse contains the response from method CassandraClusters.Update.
type CassandraClustersUpdateResponse struct {
	CassandraClustersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraClustersUpdateResult contains the result from method CassandraClusters.Update.
type CassandraClustersUpdateResult struct {
	ClusterResource
}

// CassandraDataCentersCreateUpdatePollerResponse contains the response from method CassandraDataCenters.CreateUpdate.
type CassandraDataCentersCreateUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraDataCentersCreateUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraDataCentersCreateUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraDataCentersCreateUpdateResponse, error) {
	respType := CassandraDataCentersCreateUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataCenterResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraDataCentersCreateUpdatePollerResponse from the provided client and resume token.
func (l *CassandraDataCentersCreateUpdatePollerResponse) Resume(ctx context.Context, client *CassandraDataCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraDataCentersClient.CreateUpdate", token, client.pl, client.createUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraDataCentersCreateUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraDataCentersCreateUpdateResponse contains the response from method CassandraDataCenters.CreateUpdate.
type CassandraDataCentersCreateUpdateResponse struct {
	CassandraDataCentersCreateUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraDataCentersCreateUpdateResult contains the result from method CassandraDataCenters.CreateUpdate.
type CassandraDataCentersCreateUpdateResult struct {
	DataCenterResource
}

// CassandraDataCentersDeletePollerResponse contains the response from method CassandraDataCenters.Delete.
type CassandraDataCentersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraDataCentersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraDataCentersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraDataCentersDeleteResponse, error) {
	respType := CassandraDataCentersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraDataCentersDeletePollerResponse from the provided client and resume token.
func (l *CassandraDataCentersDeletePollerResponse) Resume(ctx context.Context, client *CassandraDataCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraDataCentersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraDataCentersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraDataCentersDeleteResponse contains the response from method CassandraDataCenters.Delete.
type CassandraDataCentersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraDataCentersGetResponse contains the response from method CassandraDataCenters.Get.
type CassandraDataCentersGetResponse struct {
	CassandraDataCentersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraDataCentersGetResult contains the result from method CassandraDataCenters.Get.
type CassandraDataCentersGetResult struct {
	DataCenterResource
}

// CassandraDataCentersListResponse contains the response from method CassandraDataCenters.List.
type CassandraDataCentersListResponse struct {
	CassandraDataCentersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraDataCentersListResult contains the result from method CassandraDataCenters.List.
type CassandraDataCentersListResult struct {
	ListDataCenters
}

// CassandraDataCentersUpdatePollerResponse contains the response from method CassandraDataCenters.Update.
type CassandraDataCentersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraDataCentersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraDataCentersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraDataCentersUpdateResponse, error) {
	respType := CassandraDataCentersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataCenterResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraDataCentersUpdatePollerResponse from the provided client and resume token.
func (l *CassandraDataCentersUpdatePollerResponse) Resume(ctx context.Context, client *CassandraDataCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraDataCentersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraDataCentersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraDataCentersUpdateResponse contains the response from method CassandraDataCenters.Update.
type CassandraDataCentersUpdateResponse struct {
	CassandraDataCentersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraDataCentersUpdateResult contains the result from method CassandraDataCenters.Update.
type CassandraDataCentersUpdateResult struct {
	DataCenterResource
}

// CassandraResourcesCreateUpdateCassandraKeyspacePollerResponse contains the response from method CassandraResources.CreateUpdateCassandraKeyspace.
type CassandraResourcesCreateUpdateCassandraKeyspacePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesCreateUpdateCassandraKeyspacePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesCreateUpdateCassandraKeyspacePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesCreateUpdateCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CassandraKeyspaceGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesCreateUpdateCassandraKeyspacePollerResponse from the provided client and resume token.
func (l *CassandraResourcesCreateUpdateCassandraKeyspacePollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.CreateUpdateCassandraKeyspace", token, client.pl, client.createUpdateCassandraKeyspaceHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesCreateUpdateCassandraKeyspacePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesCreateUpdateCassandraKeyspaceResponse contains the response from method CassandraResources.CreateUpdateCassandraKeyspace.
type CassandraResourcesCreateUpdateCassandraKeyspaceResponse struct {
	CassandraResourcesCreateUpdateCassandraKeyspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesCreateUpdateCassandraKeyspaceResult contains the result from method CassandraResources.CreateUpdateCassandraKeyspace.
type CassandraResourcesCreateUpdateCassandraKeyspaceResult struct {
	CassandraKeyspaceGetResults
}

// CassandraResourcesCreateUpdateCassandraTablePollerResponse contains the response from method CassandraResources.CreateUpdateCassandraTable.
type CassandraResourcesCreateUpdateCassandraTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesCreateUpdateCassandraTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesCreateUpdateCassandraTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesCreateUpdateCassandraTableResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CassandraTableGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesCreateUpdateCassandraTablePollerResponse from the provided client and resume token.
func (l *CassandraResourcesCreateUpdateCassandraTablePollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.CreateUpdateCassandraTable", token, client.pl, client.createUpdateCassandraTableHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesCreateUpdateCassandraTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesCreateUpdateCassandraTableResponse contains the response from method CassandraResources.CreateUpdateCassandraTable.
type CassandraResourcesCreateUpdateCassandraTableResponse struct {
	CassandraResourcesCreateUpdateCassandraTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesCreateUpdateCassandraTableResult contains the result from method CassandraResources.CreateUpdateCassandraTable.
type CassandraResourcesCreateUpdateCassandraTableResult struct {
	CassandraTableGetResults
}

// CassandraResourcesDeleteCassandraKeyspacePollerResponse contains the response from method CassandraResources.DeleteCassandraKeyspace.
type CassandraResourcesDeleteCassandraKeyspacePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesDeleteCassandraKeyspacePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesDeleteCassandraKeyspacePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesDeleteCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesDeleteCassandraKeyspaceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesDeleteCassandraKeyspacePollerResponse from the provided client and resume token.
func (l *CassandraResourcesDeleteCassandraKeyspacePollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.DeleteCassandraKeyspace", token, client.pl, client.deleteCassandraKeyspaceHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesDeleteCassandraKeyspacePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesDeleteCassandraKeyspaceResponse contains the response from method CassandraResources.DeleteCassandraKeyspace.
type CassandraResourcesDeleteCassandraKeyspaceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesDeleteCassandraTablePollerResponse contains the response from method CassandraResources.DeleteCassandraTable.
type CassandraResourcesDeleteCassandraTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesDeleteCassandraTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesDeleteCassandraTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesDeleteCassandraTableResponse, error) {
	respType := CassandraResourcesDeleteCassandraTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesDeleteCassandraTablePollerResponse from the provided client and resume token.
func (l *CassandraResourcesDeleteCassandraTablePollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.DeleteCassandraTable", token, client.pl, client.deleteCassandraTableHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesDeleteCassandraTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesDeleteCassandraTableResponse contains the response from method CassandraResources.DeleteCassandraTable.
type CassandraResourcesDeleteCassandraTableResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesGetCassandraKeyspaceResponse contains the response from method CassandraResources.GetCassandraKeyspace.
type CassandraResourcesGetCassandraKeyspaceResponse struct {
	CassandraResourcesGetCassandraKeyspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesGetCassandraKeyspaceResult contains the result from method CassandraResources.GetCassandraKeyspace.
type CassandraResourcesGetCassandraKeyspaceResult struct {
	CassandraKeyspaceGetResults
}

// CassandraResourcesGetCassandraKeyspaceThroughputResponse contains the response from method CassandraResources.GetCassandraKeyspaceThroughput.
type CassandraResourcesGetCassandraKeyspaceThroughputResponse struct {
	CassandraResourcesGetCassandraKeyspaceThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesGetCassandraKeyspaceThroughputResult contains the result from method CassandraResources.GetCassandraKeyspaceThroughput.
type CassandraResourcesGetCassandraKeyspaceThroughputResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesGetCassandraTableResponse contains the response from method CassandraResources.GetCassandraTable.
type CassandraResourcesGetCassandraTableResponse struct {
	CassandraResourcesGetCassandraTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesGetCassandraTableResult contains the result from method CassandraResources.GetCassandraTable.
type CassandraResourcesGetCassandraTableResult struct {
	CassandraTableGetResults
}

// CassandraResourcesGetCassandraTableThroughputResponse contains the response from method CassandraResources.GetCassandraTableThroughput.
type CassandraResourcesGetCassandraTableThroughputResponse struct {
	CassandraResourcesGetCassandraTableThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesGetCassandraTableThroughputResult contains the result from method CassandraResources.GetCassandraTableThroughput.
type CassandraResourcesGetCassandraTableThroughputResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesListCassandraKeyspacesResponse contains the response from method CassandraResources.ListCassandraKeyspaces.
type CassandraResourcesListCassandraKeyspacesResponse struct {
	CassandraResourcesListCassandraKeyspacesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesListCassandraKeyspacesResult contains the result from method CassandraResources.ListCassandraKeyspaces.
type CassandraResourcesListCassandraKeyspacesResult struct {
	CassandraKeyspaceListResult
}

// CassandraResourcesListCassandraTablesResponse contains the response from method CassandraResources.ListCassandraTables.
type CassandraResourcesListCassandraTablesResponse struct {
	CassandraResourcesListCassandraTablesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesListCassandraTablesResult contains the result from method CassandraResources.ListCassandraTables.
type CassandraResourcesListCassandraTablesResult struct {
	CassandraTableListResult
}

// CassandraResourcesMigrateCassandraKeyspaceToAutoscalePollerResponse contains the response from method CassandraResources.MigrateCassandraKeyspaceToAutoscale.
type CassandraResourcesMigrateCassandraKeyspaceToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesMigrateCassandraKeyspaceToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesMigrateCassandraKeyspaceToAutoscalePollerResponse from the provided client and resume token.
func (l *CassandraResourcesMigrateCassandraKeyspaceToAutoscalePollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.MigrateCassandraKeyspaceToAutoscale", token, client.pl, client.migrateCassandraKeyspaceToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse contains the response from method CassandraResources.MigrateCassandraKeyspaceToAutoscale.
type CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse struct {
	CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResult contains the result from method CassandraResources.MigrateCassandraKeyspaceToAutoscale.
type CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPollerResponse contains the response from method CassandraResources.MigrateCassandraKeyspaceToManualThroughput.
type CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPollerResponse from the provided client and resume token.
func (l *CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.MigrateCassandraKeyspaceToManualThroughput", token, client.pl, client.migrateCassandraKeyspaceToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse contains the response from method CassandraResources.MigrateCassandraKeyspaceToManualThroughput.
type CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse struct {
	CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResult contains the result from method CassandraResources.MigrateCassandraKeyspaceToManualThroughput.
type CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesMigrateCassandraTableToAutoscalePollerResponse contains the response from method CassandraResources.MigrateCassandraTableToAutoscale.
type CassandraResourcesMigrateCassandraTableToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesMigrateCassandraTableToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesMigrateCassandraTableToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraTableToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesMigrateCassandraTableToAutoscalePollerResponse from the provided client and resume token.
func (l *CassandraResourcesMigrateCassandraTableToAutoscalePollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.MigrateCassandraTableToAutoscale", token, client.pl, client.migrateCassandraTableToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesMigrateCassandraTableToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesMigrateCassandraTableToAutoscaleResponse contains the response from method CassandraResources.MigrateCassandraTableToAutoscale.
type CassandraResourcesMigrateCassandraTableToAutoscaleResponse struct {
	CassandraResourcesMigrateCassandraTableToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesMigrateCassandraTableToAutoscaleResult contains the result from method CassandraResources.MigrateCassandraTableToAutoscale.
type CassandraResourcesMigrateCassandraTableToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesMigrateCassandraTableToManualThroughputPollerResponse contains the response from method CassandraResources.MigrateCassandraTableToManualThroughput.
type CassandraResourcesMigrateCassandraTableToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesMigrateCassandraTableToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesMigrateCassandraTableToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraTableToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesMigrateCassandraTableToManualThroughputPollerResponse from the provided client and resume token.
func (l *CassandraResourcesMigrateCassandraTableToManualThroughputPollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.MigrateCassandraTableToManualThroughput", token, client.pl, client.migrateCassandraTableToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesMigrateCassandraTableToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesMigrateCassandraTableToManualThroughputResponse contains the response from method CassandraResources.MigrateCassandraTableToManualThroughput.
type CassandraResourcesMigrateCassandraTableToManualThroughputResponse struct {
	CassandraResourcesMigrateCassandraTableToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesMigrateCassandraTableToManualThroughputResult contains the result from method CassandraResources.MigrateCassandraTableToManualThroughput.
type CassandraResourcesMigrateCassandraTableToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesUpdateCassandraKeyspaceThroughputPollerResponse contains the response from method CassandraResources.UpdateCassandraKeyspaceThroughput.
type CassandraResourcesUpdateCassandraKeyspaceThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesUpdateCassandraKeyspaceThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesUpdateCassandraKeyspaceThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesUpdateCassandraKeyspaceThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesUpdateCassandraKeyspaceThroughputPollerResponse from the provided client and resume token.
func (l *CassandraResourcesUpdateCassandraKeyspaceThroughputPollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.UpdateCassandraKeyspaceThroughput", token, client.pl, client.updateCassandraKeyspaceThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesUpdateCassandraKeyspaceThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesUpdateCassandraKeyspaceThroughputResponse contains the response from method CassandraResources.UpdateCassandraKeyspaceThroughput.
type CassandraResourcesUpdateCassandraKeyspaceThroughputResponse struct {
	CassandraResourcesUpdateCassandraKeyspaceThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesUpdateCassandraKeyspaceThroughputResult contains the result from method CassandraResources.UpdateCassandraKeyspaceThroughput.
type CassandraResourcesUpdateCassandraKeyspaceThroughputResult struct {
	ThroughputSettingsGetResults
}

// CassandraResourcesUpdateCassandraTableThroughputPollerResponse contains the response from method CassandraResources.UpdateCassandraTableThroughput.
type CassandraResourcesUpdateCassandraTableThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CassandraResourcesUpdateCassandraTableThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CassandraResourcesUpdateCassandraTableThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesUpdateCassandraTableThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraTableThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CassandraResourcesUpdateCassandraTableThroughputPollerResponse from the provided client and resume token.
func (l *CassandraResourcesUpdateCassandraTableThroughputPollerResponse) Resume(ctx context.Context, client *CassandraResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CassandraResourcesClient.UpdateCassandraTableThroughput", token, client.pl, client.updateCassandraTableThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &CassandraResourcesUpdateCassandraTableThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CassandraResourcesUpdateCassandraTableThroughputResponse contains the response from method CassandraResources.UpdateCassandraTableThroughput.
type CassandraResourcesUpdateCassandraTableThroughputResponse struct {
	CassandraResourcesUpdateCassandraTableThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CassandraResourcesUpdateCassandraTableThroughputResult contains the result from method CassandraResources.UpdateCassandraTableThroughput.
type CassandraResourcesUpdateCassandraTableThroughputResult struct {
	ThroughputSettingsGetResults
}

// CollectionListMetricDefinitionsResponse contains the response from method Collection.ListMetricDefinitions.
type CollectionListMetricDefinitionsResponse struct {
	CollectionListMetricDefinitionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionListMetricDefinitionsResult contains the result from method Collection.ListMetricDefinitions.
type CollectionListMetricDefinitionsResult struct {
	MetricDefinitionsListResult
}

// CollectionListMetricsResponse contains the response from method Collection.ListMetrics.
type CollectionListMetricsResponse struct {
	CollectionListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionListMetricsResult contains the result from method Collection.ListMetrics.
type CollectionListMetricsResult struct {
	MetricListResult
}

// CollectionListUsagesResponse contains the response from method Collection.ListUsages.
type CollectionListUsagesResponse struct {
	CollectionListUsagesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionListUsagesResult contains the result from method Collection.ListUsages.
type CollectionListUsagesResult struct {
	UsagesResult
}

// CollectionPartitionListMetricsResponse contains the response from method CollectionPartition.ListMetrics.
type CollectionPartitionListMetricsResponse struct {
	CollectionPartitionListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionPartitionListMetricsResult contains the result from method CollectionPartition.ListMetrics.
type CollectionPartitionListMetricsResult struct {
	PartitionMetricListResult
}

// CollectionPartitionListUsagesResponse contains the response from method CollectionPartition.ListUsages.
type CollectionPartitionListUsagesResponse struct {
	CollectionPartitionListUsagesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionPartitionListUsagesResult contains the result from method CollectionPartition.ListUsages.
type CollectionPartitionListUsagesResult struct {
	PartitionUsagesResult
}

// CollectionPartitionRegionListMetricsResponse contains the response from method CollectionPartitionRegion.ListMetrics.
type CollectionPartitionRegionListMetricsResponse struct {
	CollectionPartitionRegionListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionPartitionRegionListMetricsResult contains the result from method CollectionPartitionRegion.ListMetrics.
type CollectionPartitionRegionListMetricsResult struct {
	PartitionMetricListResult
}

// CollectionRegionListMetricsResponse contains the response from method CollectionRegion.ListMetrics.
type CollectionRegionListMetricsResponse struct {
	CollectionRegionListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CollectionRegionListMetricsResult contains the result from method CollectionRegion.ListMetrics.
type CollectionRegionListMetricsResult struct {
	MetricListResult
}

// DatabaseAccountRegionListMetricsResponse contains the response from method DatabaseAccountRegion.ListMetrics.
type DatabaseAccountRegionListMetricsResponse struct {
	DatabaseAccountRegionListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountRegionListMetricsResult contains the result from method DatabaseAccountRegion.ListMetrics.
type DatabaseAccountRegionListMetricsResult struct {
	MetricListResult
}

// DatabaseAccountsCheckNameExistsResponse contains the response from method DatabaseAccounts.CheckNameExists.
type DatabaseAccountsCheckNameExistsResponse struct {
	DatabaseAccountsCheckNameExistsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsCheckNameExistsResult contains the result from method DatabaseAccounts.CheckNameExists.
type DatabaseAccountsCheckNameExistsResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// DatabaseAccountsCreateOrUpdatePollerResponse contains the response from method DatabaseAccounts.CreateOrUpdate.
type DatabaseAccountsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsCreateOrUpdateResponse, error) {
	respType := DatabaseAccountsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseAccountGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabaseAccountsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsCreateOrUpdateResponse contains the response from method DatabaseAccounts.CreateOrUpdate.
type DatabaseAccountsCreateOrUpdateResponse struct {
	DatabaseAccountsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsCreateOrUpdateResult contains the result from method DatabaseAccounts.CreateOrUpdate.
type DatabaseAccountsCreateOrUpdateResult struct {
	DatabaseAccountGetResults
}

// DatabaseAccountsDeletePollerResponse contains the response from method DatabaseAccounts.Delete.
type DatabaseAccountsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsDeleteResponse, error) {
	respType := DatabaseAccountsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsDeletePollerResponse from the provided client and resume token.
func (l *DatabaseAccountsDeletePollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsDeleteResponse contains the response from method DatabaseAccounts.Delete.
type DatabaseAccountsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsFailoverPriorityChangePollerResponse contains the response from method DatabaseAccounts.FailoverPriorityChange.
type DatabaseAccountsFailoverPriorityChangePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsFailoverPriorityChangePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsFailoverPriorityChangePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsFailoverPriorityChangeResponse, error) {
	respType := DatabaseAccountsFailoverPriorityChangeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsFailoverPriorityChangePollerResponse from the provided client and resume token.
func (l *DatabaseAccountsFailoverPriorityChangePollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.FailoverPriorityChange", token, client.pl, client.failoverPriorityChangeHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsFailoverPriorityChangePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsFailoverPriorityChangeResponse contains the response from method DatabaseAccounts.FailoverPriorityChange.
type DatabaseAccountsFailoverPriorityChangeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsGetReadOnlyKeysResponse contains the response from method DatabaseAccounts.GetReadOnlyKeys.
type DatabaseAccountsGetReadOnlyKeysResponse struct {
	DatabaseAccountsGetReadOnlyKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsGetReadOnlyKeysResult contains the result from method DatabaseAccounts.GetReadOnlyKeys.
type DatabaseAccountsGetReadOnlyKeysResult struct {
	DatabaseAccountListReadOnlyKeysResult
}

// DatabaseAccountsGetResponse contains the response from method DatabaseAccounts.Get.
type DatabaseAccountsGetResponse struct {
	DatabaseAccountsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsGetResult contains the result from method DatabaseAccounts.Get.
type DatabaseAccountsGetResult struct {
	DatabaseAccountGetResults
}

// DatabaseAccountsListByResourceGroupResponse contains the response from method DatabaseAccounts.ListByResourceGroup.
type DatabaseAccountsListByResourceGroupResponse struct {
	DatabaseAccountsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListByResourceGroupResult contains the result from method DatabaseAccounts.ListByResourceGroup.
type DatabaseAccountsListByResourceGroupResult struct {
	DatabaseAccountsListResult
}

// DatabaseAccountsListConnectionStringsResponse contains the response from method DatabaseAccounts.ListConnectionStrings.
type DatabaseAccountsListConnectionStringsResponse struct {
	DatabaseAccountsListConnectionStringsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListConnectionStringsResult contains the result from method DatabaseAccounts.ListConnectionStrings.
type DatabaseAccountsListConnectionStringsResult struct {
	DatabaseAccountListConnectionStringsResult
}

// DatabaseAccountsListKeysResponse contains the response from method DatabaseAccounts.ListKeys.
type DatabaseAccountsListKeysResponse struct {
	DatabaseAccountsListKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListKeysResult contains the result from method DatabaseAccounts.ListKeys.
type DatabaseAccountsListKeysResult struct {
	DatabaseAccountListKeysResult
}

// DatabaseAccountsListMetricDefinitionsResponse contains the response from method DatabaseAccounts.ListMetricDefinitions.
type DatabaseAccountsListMetricDefinitionsResponse struct {
	DatabaseAccountsListMetricDefinitionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListMetricDefinitionsResult contains the result from method DatabaseAccounts.ListMetricDefinitions.
type DatabaseAccountsListMetricDefinitionsResult struct {
	MetricDefinitionsListResult
}

// DatabaseAccountsListMetricsResponse contains the response from method DatabaseAccounts.ListMetrics.
type DatabaseAccountsListMetricsResponse struct {
	DatabaseAccountsListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListMetricsResult contains the result from method DatabaseAccounts.ListMetrics.
type DatabaseAccountsListMetricsResult struct {
	MetricListResult
}

// DatabaseAccountsListReadOnlyKeysResponse contains the response from method DatabaseAccounts.ListReadOnlyKeys.
type DatabaseAccountsListReadOnlyKeysResponse struct {
	DatabaseAccountsListReadOnlyKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListReadOnlyKeysResult contains the result from method DatabaseAccounts.ListReadOnlyKeys.
type DatabaseAccountsListReadOnlyKeysResult struct {
	DatabaseAccountListReadOnlyKeysResult
}

// DatabaseAccountsListResponse contains the response from method DatabaseAccounts.List.
type DatabaseAccountsListResponse struct {
	DatabaseAccountsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListResultEnvelope contains the result from method DatabaseAccounts.List.
type DatabaseAccountsListResultEnvelope struct {
	DatabaseAccountsListResult
}

// DatabaseAccountsListUsagesResponse contains the response from method DatabaseAccounts.ListUsages.
type DatabaseAccountsListUsagesResponse struct {
	DatabaseAccountsListUsagesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsListUsagesResult contains the result from method DatabaseAccounts.ListUsages.
type DatabaseAccountsListUsagesResult struct {
	UsagesResult
}

// DatabaseAccountsOfflineRegionPollerResponse contains the response from method DatabaseAccounts.OfflineRegion.
type DatabaseAccountsOfflineRegionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsOfflineRegionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsOfflineRegionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsOfflineRegionResponse, error) {
	respType := DatabaseAccountsOfflineRegionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsOfflineRegionPollerResponse from the provided client and resume token.
func (l *DatabaseAccountsOfflineRegionPollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.OfflineRegion", token, client.pl, client.offlineRegionHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsOfflineRegionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsOfflineRegionResponse contains the response from method DatabaseAccounts.OfflineRegion.
type DatabaseAccountsOfflineRegionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsOnlineRegionPollerResponse contains the response from method DatabaseAccounts.OnlineRegion.
type DatabaseAccountsOnlineRegionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsOnlineRegionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsOnlineRegionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsOnlineRegionResponse, error) {
	respType := DatabaseAccountsOnlineRegionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsOnlineRegionPollerResponse from the provided client and resume token.
func (l *DatabaseAccountsOnlineRegionPollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.OnlineRegion", token, client.pl, client.onlineRegionHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsOnlineRegionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsOnlineRegionResponse contains the response from method DatabaseAccounts.OnlineRegion.
type DatabaseAccountsOnlineRegionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsRegenerateKeyPollerResponse contains the response from method DatabaseAccounts.RegenerateKey.
type DatabaseAccountsRegenerateKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsRegenerateKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsRegenerateKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsRegenerateKeyResponse, error) {
	respType := DatabaseAccountsRegenerateKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsRegenerateKeyPollerResponse from the provided client and resume token.
func (l *DatabaseAccountsRegenerateKeyPollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.RegenerateKey", token, client.pl, client.regenerateKeyHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsRegenerateKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsRegenerateKeyResponse contains the response from method DatabaseAccounts.RegenerateKey.
type DatabaseAccountsRegenerateKeyResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsUpdatePollerResponse contains the response from method DatabaseAccounts.Update.
type DatabaseAccountsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseAccountsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseAccountsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsUpdateResponse, error) {
	respType := DatabaseAccountsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseAccountGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseAccountsUpdatePollerResponse from the provided client and resume token.
func (l *DatabaseAccountsUpdatePollerResponse) Resume(ctx context.Context, client *DatabaseAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseAccountsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseAccountsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseAccountsUpdateResponse contains the response from method DatabaseAccounts.Update.
type DatabaseAccountsUpdateResponse struct {
	DatabaseAccountsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAccountsUpdateResult contains the result from method DatabaseAccounts.Update.
type DatabaseAccountsUpdateResult struct {
	DatabaseAccountGetResults
}

// DatabaseListMetricDefinitionsResponse contains the response from method Database.ListMetricDefinitions.
type DatabaseListMetricDefinitionsResponse struct {
	DatabaseListMetricDefinitionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseListMetricDefinitionsResult contains the result from method Database.ListMetricDefinitions.
type DatabaseListMetricDefinitionsResult struct {
	MetricDefinitionsListResult
}

// DatabaseListMetricsResponse contains the response from method Database.ListMetrics.
type DatabaseListMetricsResponse struct {
	DatabaseListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseListMetricsResult contains the result from method Database.ListMetrics.
type DatabaseListMetricsResult struct {
	MetricListResult
}

// DatabaseListUsagesResponse contains the response from method Database.ListUsages.
type DatabaseListUsagesResponse struct {
	DatabaseListUsagesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseListUsagesResult contains the result from method Database.ListUsages.
type DatabaseListUsagesResult struct {
	UsagesResult
}

// GremlinResourcesCreateUpdateGremlinDatabasePollerResponse contains the response from method GremlinResources.CreateUpdateGremlinDatabase.
type GremlinResourcesCreateUpdateGremlinDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesCreateUpdateGremlinDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesCreateUpdateGremlinDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GremlinDatabaseGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesCreateUpdateGremlinDatabasePollerResponse from the provided client and resume token.
func (l *GremlinResourcesCreateUpdateGremlinDatabasePollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.CreateUpdateGremlinDatabase", token, client.pl, client.createUpdateGremlinDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesCreateUpdateGremlinDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesCreateUpdateGremlinDatabaseResponse contains the response from method GremlinResources.CreateUpdateGremlinDatabase.
type GremlinResourcesCreateUpdateGremlinDatabaseResponse struct {
	GremlinResourcesCreateUpdateGremlinDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesCreateUpdateGremlinDatabaseResult contains the result from method GremlinResources.CreateUpdateGremlinDatabase.
type GremlinResourcesCreateUpdateGremlinDatabaseResult struct {
	GremlinDatabaseGetResults
}

// GremlinResourcesCreateUpdateGremlinGraphPollerResponse contains the response from method GremlinResources.CreateUpdateGremlinGraph.
type GremlinResourcesCreateUpdateGremlinGraphPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesCreateUpdateGremlinGraphPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesCreateUpdateGremlinGraphPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesCreateUpdateGremlinGraphResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinGraphResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GremlinGraphGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesCreateUpdateGremlinGraphPollerResponse from the provided client and resume token.
func (l *GremlinResourcesCreateUpdateGremlinGraphPollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.CreateUpdateGremlinGraph", token, client.pl, client.createUpdateGremlinGraphHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesCreateUpdateGremlinGraphPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesCreateUpdateGremlinGraphResponse contains the response from method GremlinResources.CreateUpdateGremlinGraph.
type GremlinResourcesCreateUpdateGremlinGraphResponse struct {
	GremlinResourcesCreateUpdateGremlinGraphResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesCreateUpdateGremlinGraphResult contains the result from method GremlinResources.CreateUpdateGremlinGraph.
type GremlinResourcesCreateUpdateGremlinGraphResult struct {
	GremlinGraphGetResults
}

// GremlinResourcesDeleteGremlinDatabasePollerResponse contains the response from method GremlinResources.DeleteGremlinDatabase.
type GremlinResourcesDeleteGremlinDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesDeleteGremlinDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesDeleteGremlinDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesDeleteGremlinDatabaseResponse, error) {
	respType := GremlinResourcesDeleteGremlinDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesDeleteGremlinDatabasePollerResponse from the provided client and resume token.
func (l *GremlinResourcesDeleteGremlinDatabasePollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.DeleteGremlinDatabase", token, client.pl, client.deleteGremlinDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesDeleteGremlinDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesDeleteGremlinDatabaseResponse contains the response from method GremlinResources.DeleteGremlinDatabase.
type GremlinResourcesDeleteGremlinDatabaseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesDeleteGremlinGraphPollerResponse contains the response from method GremlinResources.DeleteGremlinGraph.
type GremlinResourcesDeleteGremlinGraphPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesDeleteGremlinGraphPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesDeleteGremlinGraphPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesDeleteGremlinGraphResponse, error) {
	respType := GremlinResourcesDeleteGremlinGraphResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesDeleteGremlinGraphPollerResponse from the provided client and resume token.
func (l *GremlinResourcesDeleteGremlinGraphPollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.DeleteGremlinGraph", token, client.pl, client.deleteGremlinGraphHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesDeleteGremlinGraphPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesDeleteGremlinGraphResponse contains the response from method GremlinResources.DeleteGremlinGraph.
type GremlinResourcesDeleteGremlinGraphResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesGetGremlinDatabaseResponse contains the response from method GremlinResources.GetGremlinDatabase.
type GremlinResourcesGetGremlinDatabaseResponse struct {
	GremlinResourcesGetGremlinDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesGetGremlinDatabaseResult contains the result from method GremlinResources.GetGremlinDatabase.
type GremlinResourcesGetGremlinDatabaseResult struct {
	GremlinDatabaseGetResults
}

// GremlinResourcesGetGremlinDatabaseThroughputResponse contains the response from method GremlinResources.GetGremlinDatabaseThroughput.
type GremlinResourcesGetGremlinDatabaseThroughputResponse struct {
	GremlinResourcesGetGremlinDatabaseThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesGetGremlinDatabaseThroughputResult contains the result from method GremlinResources.GetGremlinDatabaseThroughput.
type GremlinResourcesGetGremlinDatabaseThroughputResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesGetGremlinGraphResponse contains the response from method GremlinResources.GetGremlinGraph.
type GremlinResourcesGetGremlinGraphResponse struct {
	GremlinResourcesGetGremlinGraphResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesGetGremlinGraphResult contains the result from method GremlinResources.GetGremlinGraph.
type GremlinResourcesGetGremlinGraphResult struct {
	GremlinGraphGetResults
}

// GremlinResourcesGetGremlinGraphThroughputResponse contains the response from method GremlinResources.GetGremlinGraphThroughput.
type GremlinResourcesGetGremlinGraphThroughputResponse struct {
	GremlinResourcesGetGremlinGraphThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesGetGremlinGraphThroughputResult contains the result from method GremlinResources.GetGremlinGraphThroughput.
type GremlinResourcesGetGremlinGraphThroughputResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesListGremlinDatabasesResponse contains the response from method GremlinResources.ListGremlinDatabases.
type GremlinResourcesListGremlinDatabasesResponse struct {
	GremlinResourcesListGremlinDatabasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesListGremlinDatabasesResult contains the result from method GremlinResources.ListGremlinDatabases.
type GremlinResourcesListGremlinDatabasesResult struct {
	GremlinDatabaseListResult
}

// GremlinResourcesListGremlinGraphsResponse contains the response from method GremlinResources.ListGremlinGraphs.
type GremlinResourcesListGremlinGraphsResponse struct {
	GremlinResourcesListGremlinGraphsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesListGremlinGraphsResult contains the result from method GremlinResources.ListGremlinGraphs.
type GremlinResourcesListGremlinGraphsResult struct {
	GremlinGraphListResult
}

// GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse contains the response from method GremlinResources.MigrateGremlinDatabaseToAutoscale.
type GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse from the provided client and resume token.
func (l *GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinDatabaseToAutoscale", token, client.pl, client.migrateGremlinDatabaseToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse contains the response from method GremlinResources.MigrateGremlinDatabaseToAutoscale.
type GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse struct {
	GremlinResourcesMigrateGremlinDatabaseToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesMigrateGremlinDatabaseToAutoscaleResult contains the result from method GremlinResources.MigrateGremlinDatabaseToAutoscale.
type GremlinResourcesMigrateGremlinDatabaseToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse contains the response from method GremlinResources.MigrateGremlinDatabaseToManualThroughput.
type GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse from the provided client and resume token.
func (l *GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinDatabaseToManualThroughput", token, client.pl, client.migrateGremlinDatabaseToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse contains the response from method GremlinResources.MigrateGremlinDatabaseToManualThroughput.
type GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse struct {
	GremlinResourcesMigrateGremlinDatabaseToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesMigrateGremlinDatabaseToManualThroughputResult contains the result from method GremlinResources.MigrateGremlinDatabaseToManualThroughput.
type GremlinResourcesMigrateGremlinDatabaseToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse contains the response from method GremlinResources.MigrateGremlinGraphToAutoscale.
type GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesMigrateGremlinGraphToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse from the provided client and resume token.
func (l *GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinGraphToAutoscale", token, client.pl, client.migrateGremlinGraphToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesMigrateGremlinGraphToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesMigrateGremlinGraphToAutoscaleResponse contains the response from method GremlinResources.MigrateGremlinGraphToAutoscale.
type GremlinResourcesMigrateGremlinGraphToAutoscaleResponse struct {
	GremlinResourcesMigrateGremlinGraphToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesMigrateGremlinGraphToAutoscaleResult contains the result from method GremlinResources.MigrateGremlinGraphToAutoscale.
type GremlinResourcesMigrateGremlinGraphToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse contains the response from method GremlinResources.MigrateGremlinGraphToManualThroughput.
type GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesMigrateGremlinGraphToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse from the provided client and resume token.
func (l *GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinGraphToManualThroughput", token, client.pl, client.migrateGremlinGraphToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesMigrateGremlinGraphToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesMigrateGremlinGraphToManualThroughputResponse contains the response from method GremlinResources.MigrateGremlinGraphToManualThroughput.
type GremlinResourcesMigrateGremlinGraphToManualThroughputResponse struct {
	GremlinResourcesMigrateGremlinGraphToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesMigrateGremlinGraphToManualThroughputResult contains the result from method GremlinResources.MigrateGremlinGraphToManualThroughput.
type GremlinResourcesMigrateGremlinGraphToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse contains the response from method GremlinResources.UpdateGremlinDatabaseThroughput.
type GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesUpdateGremlinDatabaseThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse from the provided client and resume token.
func (l *GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.UpdateGremlinDatabaseThroughput", token, client.pl, client.updateGremlinDatabaseThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesUpdateGremlinDatabaseThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesUpdateGremlinDatabaseThroughputResponse contains the response from method GremlinResources.UpdateGremlinDatabaseThroughput.
type GremlinResourcesUpdateGremlinDatabaseThroughputResponse struct {
	GremlinResourcesUpdateGremlinDatabaseThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesUpdateGremlinDatabaseThroughputResult contains the result from method GremlinResources.UpdateGremlinDatabaseThroughput.
type GremlinResourcesUpdateGremlinDatabaseThroughputResult struct {
	ThroughputSettingsGetResults
}

// GremlinResourcesUpdateGremlinGraphThroughputPollerResponse contains the response from method GremlinResources.UpdateGremlinGraphThroughput.
type GremlinResourcesUpdateGremlinGraphThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GremlinResourcesUpdateGremlinGraphThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GremlinResourcesUpdateGremlinGraphThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinGraphThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GremlinResourcesUpdateGremlinGraphThroughputPollerResponse from the provided client and resume token.
func (l *GremlinResourcesUpdateGremlinGraphThroughputPollerResponse) Resume(ctx context.Context, client *GremlinResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GremlinResourcesClient.UpdateGremlinGraphThroughput", token, client.pl, client.updateGremlinGraphThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &GremlinResourcesUpdateGremlinGraphThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GremlinResourcesUpdateGremlinGraphThroughputResponse contains the response from method GremlinResources.UpdateGremlinGraphThroughput.
type GremlinResourcesUpdateGremlinGraphThroughputResponse struct {
	GremlinResourcesUpdateGremlinGraphThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GremlinResourcesUpdateGremlinGraphThroughputResult contains the result from method GremlinResources.UpdateGremlinGraphThroughput.
type GremlinResourcesUpdateGremlinGraphThroughputResult struct {
	ThroughputSettingsGetResults
}

// LocationsGetResponse contains the response from method Locations.Get.
type LocationsGetResponse struct {
	LocationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationsGetResult contains the result from method Locations.Get.
type LocationsGetResult struct {
	LocationGetResult
}

// LocationsListResponse contains the response from method Locations.List.
type LocationsListResponse struct {
	LocationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationsListResult contains the result from method Locations.List.
type LocationsListResult struct {
	LocationListResult
}

// MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse contains the response from method MongoDBResources.CreateUpdateMongoDBCollection.
type MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesCreateUpdateMongoDBCollectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesCreateUpdateMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MongoDBCollectionGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesCreateUpdateMongoDBCollectionPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.CreateUpdateMongoDBCollection", token, client.pl, client.createUpdateMongoDBCollectionHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesCreateUpdateMongoDBCollectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesCreateUpdateMongoDBCollectionResponse contains the response from method MongoDBResources.CreateUpdateMongoDBCollection.
type MongoDBResourcesCreateUpdateMongoDBCollectionResponse struct {
	MongoDBResourcesCreateUpdateMongoDBCollectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesCreateUpdateMongoDBCollectionResult contains the result from method MongoDBResources.CreateUpdateMongoDBCollection.
type MongoDBResourcesCreateUpdateMongoDBCollectionResult struct {
	MongoDBCollectionGetResults
}

// MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse contains the response from method MongoDBResources.CreateUpdateMongoDBDatabase.
type MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesCreateUpdateMongoDBDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesCreateUpdateMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MongoDBDatabaseGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse from the provided client and resume token.
func (l *MongoDBResourcesCreateUpdateMongoDBDatabasePollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.CreateUpdateMongoDBDatabase", token, client.pl, client.createUpdateMongoDBDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesCreateUpdateMongoDBDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesCreateUpdateMongoDBDatabaseResponse contains the response from method MongoDBResources.CreateUpdateMongoDBDatabase.
type MongoDBResourcesCreateUpdateMongoDBDatabaseResponse struct {
	MongoDBResourcesCreateUpdateMongoDBDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesCreateUpdateMongoDBDatabaseResult contains the result from method MongoDBResources.CreateUpdateMongoDBDatabase.
type MongoDBResourcesCreateUpdateMongoDBDatabaseResult struct {
	MongoDBDatabaseGetResults
}

// MongoDBResourcesDeleteMongoDBCollectionPollerResponse contains the response from method MongoDBResources.DeleteMongoDBCollection.
type MongoDBResourcesDeleteMongoDBCollectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesDeleteMongoDBCollectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesDeleteMongoDBCollectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesDeleteMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBCollectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesDeleteMongoDBCollectionPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesDeleteMongoDBCollectionPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.DeleteMongoDBCollection", token, client.pl, client.deleteMongoDBCollectionHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesDeleteMongoDBCollectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesDeleteMongoDBCollectionResponse contains the response from method MongoDBResources.DeleteMongoDBCollection.
type MongoDBResourcesDeleteMongoDBCollectionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesDeleteMongoDBDatabasePollerResponse contains the response from method MongoDBResources.DeleteMongoDBDatabase.
type MongoDBResourcesDeleteMongoDBDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesDeleteMongoDBDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesDeleteMongoDBDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesDeleteMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesDeleteMongoDBDatabasePollerResponse from the provided client and resume token.
func (l *MongoDBResourcesDeleteMongoDBDatabasePollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.DeleteMongoDBDatabase", token, client.pl, client.deleteMongoDBDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesDeleteMongoDBDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesDeleteMongoDBDatabaseResponse contains the response from method MongoDBResources.DeleteMongoDBDatabase.
type MongoDBResourcesDeleteMongoDBDatabaseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesGetMongoDBCollectionResponse contains the response from method MongoDBResources.GetMongoDBCollection.
type MongoDBResourcesGetMongoDBCollectionResponse struct {
	MongoDBResourcesGetMongoDBCollectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesGetMongoDBCollectionResult contains the result from method MongoDBResources.GetMongoDBCollection.
type MongoDBResourcesGetMongoDBCollectionResult struct {
	MongoDBCollectionGetResults
}

// MongoDBResourcesGetMongoDBCollectionThroughputResponse contains the response from method MongoDBResources.GetMongoDBCollectionThroughput.
type MongoDBResourcesGetMongoDBCollectionThroughputResponse struct {
	MongoDBResourcesGetMongoDBCollectionThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesGetMongoDBCollectionThroughputResult contains the result from method MongoDBResources.GetMongoDBCollectionThroughput.
type MongoDBResourcesGetMongoDBCollectionThroughputResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesGetMongoDBDatabaseResponse contains the response from method MongoDBResources.GetMongoDBDatabase.
type MongoDBResourcesGetMongoDBDatabaseResponse struct {
	MongoDBResourcesGetMongoDBDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesGetMongoDBDatabaseResult contains the result from method MongoDBResources.GetMongoDBDatabase.
type MongoDBResourcesGetMongoDBDatabaseResult struct {
	MongoDBDatabaseGetResults
}

// MongoDBResourcesGetMongoDBDatabaseThroughputResponse contains the response from method MongoDBResources.GetMongoDBDatabaseThroughput.
type MongoDBResourcesGetMongoDBDatabaseThroughputResponse struct {
	MongoDBResourcesGetMongoDBDatabaseThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesGetMongoDBDatabaseThroughputResult contains the result from method MongoDBResources.GetMongoDBDatabaseThroughput.
type MongoDBResourcesGetMongoDBDatabaseThroughputResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesListMongoDBCollectionsResponse contains the response from method MongoDBResources.ListMongoDBCollections.
type MongoDBResourcesListMongoDBCollectionsResponse struct {
	MongoDBResourcesListMongoDBCollectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesListMongoDBCollectionsResult contains the result from method MongoDBResources.ListMongoDBCollections.
type MongoDBResourcesListMongoDBCollectionsResult struct {
	MongoDBCollectionListResult
}

// MongoDBResourcesListMongoDBDatabasesResponse contains the response from method MongoDBResources.ListMongoDBDatabases.
type MongoDBResourcesListMongoDBDatabasesResponse struct {
	MongoDBResourcesListMongoDBDatabasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesListMongoDBDatabasesResult contains the result from method MongoDBResources.ListMongoDBDatabases.
type MongoDBResourcesListMongoDBDatabasesResult struct {
	MongoDBDatabaseListResult
}

// MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse contains the response from method MongoDBResources.MigrateMongoDBCollectionToAutoscale.
type MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse from the provided client and resume token.
func (l *MongoDBResourcesMigrateMongoDBCollectionToAutoscalePollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.MigrateMongoDBCollectionToAutoscale", token, client.pl, client.migrateMongoDBCollectionToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse contains the response from method MongoDBResources.MigrateMongoDBCollectionToAutoscale.
type MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse struct {
	MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResult contains the result from method MongoDBResources.MigrateMongoDBCollectionToAutoscale.
type MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse contains the response from method MongoDBResources.MigrateMongoDBCollectionToManualThroughput.
type MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.MigrateMongoDBCollectionToManualThroughput", token, client.pl, client.migrateMongoDBCollectionToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse contains the response from method MongoDBResources.MigrateMongoDBCollectionToManualThroughput.
type MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse struct {
	MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResult contains the result from method MongoDBResources.MigrateMongoDBCollectionToManualThroughput.
type MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse contains the response from method MongoDBResources.MigrateMongoDBDatabaseToAutoscale.
type MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse from the provided client and resume token.
func (l *MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.MigrateMongoDBDatabaseToAutoscale", token, client.pl, client.migrateMongoDBDatabaseToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse contains the response from method MongoDBResources.MigrateMongoDBDatabaseToAutoscale.
type MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse struct {
	MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResult contains the result from method MongoDBResources.MigrateMongoDBDatabaseToAutoscale.
type MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse contains the response from method MongoDBResources.MigrateMongoDBDatabaseToManualThroughput.
type MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.MigrateMongoDBDatabaseToManualThroughput", token, client.pl, client.migrateMongoDBDatabaseToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse contains the response from method MongoDBResources.MigrateMongoDBDatabaseToManualThroughput.
type MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse struct {
	MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResult contains the result from method MongoDBResources.MigrateMongoDBDatabaseToManualThroughput.
type MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse contains the response from method MongoDBResources.RetrieveContinuousBackupInformation.
type MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesRetrieveContinuousBackupInformationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesRetrieveContinuousBackupInformationResponse, error) {
	respType := MongoDBResourcesRetrieveContinuousBackupInformationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackupInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesRetrieveContinuousBackupInformationPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.RetrieveContinuousBackupInformation", token, client.pl, client.retrieveContinuousBackupInformationHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesRetrieveContinuousBackupInformationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesRetrieveContinuousBackupInformationResponse contains the response from method MongoDBResources.RetrieveContinuousBackupInformation.
type MongoDBResourcesRetrieveContinuousBackupInformationResponse struct {
	MongoDBResourcesRetrieveContinuousBackupInformationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesRetrieveContinuousBackupInformationResult contains the result from method MongoDBResources.RetrieveContinuousBackupInformation.
type MongoDBResourcesRetrieveContinuousBackupInformationResult struct {
	BackupInformation
}

// MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse contains the response from method MongoDBResources.UpdateMongoDBCollectionThroughput.
type MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesUpdateMongoDBCollectionThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesUpdateMongoDBCollectionThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesUpdateMongoDBCollectionThroughputPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.UpdateMongoDBCollectionThroughput", token, client.pl, client.updateMongoDBCollectionThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesUpdateMongoDBCollectionThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesUpdateMongoDBCollectionThroughputResponse contains the response from method MongoDBResources.UpdateMongoDBCollectionThroughput.
type MongoDBResourcesUpdateMongoDBCollectionThroughputResponse struct {
	MongoDBResourcesUpdateMongoDBCollectionThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesUpdateMongoDBCollectionThroughputResult contains the result from method MongoDBResources.UpdateMongoDBCollectionThroughput.
type MongoDBResourcesUpdateMongoDBCollectionThroughputResult struct {
	ThroughputSettingsGetResults
}

// MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse contains the response from method MongoDBResources.UpdateMongoDBDatabaseThroughput.
type MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse from the provided client and resume token.
func (l *MongoDBResourcesUpdateMongoDBDatabaseThroughputPollerResponse) Resume(ctx context.Context, client *MongoDBResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MongoDBResourcesClient.UpdateMongoDBDatabaseThroughput", token, client.pl, client.updateMongoDBDatabaseThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse contains the response from method MongoDBResources.UpdateMongoDBDatabaseThroughput.
type MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse struct {
	MongoDBResourcesUpdateMongoDBDatabaseThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoDBResourcesUpdateMongoDBDatabaseThroughputResult contains the result from method MongoDBResources.UpdateMongoDBDatabaseThroughput.
type MongoDBResourcesUpdateMongoDBDatabaseThroughputResult struct {
	ThroughputSettingsGetResults
}

// NotebookWorkspacesCreateOrUpdatePollerResponse contains the response from method NotebookWorkspaces.CreateOrUpdate.
type NotebookWorkspacesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookWorkspacesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NotebookWorkspacesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesCreateOrUpdateResponse, error) {
	respType := NotebookWorkspacesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NotebookWorkspace)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookWorkspacesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NotebookWorkspacesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NotebookWorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NotebookWorkspacesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookWorkspacesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookWorkspacesCreateOrUpdateResponse contains the response from method NotebookWorkspaces.CreateOrUpdate.
type NotebookWorkspacesCreateOrUpdateResponse struct {
	NotebookWorkspacesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookWorkspacesCreateOrUpdateResult contains the result from method NotebookWorkspaces.CreateOrUpdate.
type NotebookWorkspacesCreateOrUpdateResult struct {
	NotebookWorkspace
}

// NotebookWorkspacesDeletePollerResponse contains the response from method NotebookWorkspaces.Delete.
type NotebookWorkspacesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookWorkspacesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NotebookWorkspacesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesDeleteResponse, error) {
	respType := NotebookWorkspacesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookWorkspacesDeletePollerResponse from the provided client and resume token.
func (l *NotebookWorkspacesDeletePollerResponse) Resume(ctx context.Context, client *NotebookWorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NotebookWorkspacesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookWorkspacesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookWorkspacesDeleteResponse contains the response from method NotebookWorkspaces.Delete.
type NotebookWorkspacesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookWorkspacesGetResponse contains the response from method NotebookWorkspaces.Get.
type NotebookWorkspacesGetResponse struct {
	NotebookWorkspacesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookWorkspacesGetResult contains the result from method NotebookWorkspaces.Get.
type NotebookWorkspacesGetResult struct {
	NotebookWorkspace
}

// NotebookWorkspacesListByDatabaseAccountResponse contains the response from method NotebookWorkspaces.ListByDatabaseAccount.
type NotebookWorkspacesListByDatabaseAccountResponse struct {
	NotebookWorkspacesListByDatabaseAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookWorkspacesListByDatabaseAccountResult contains the result from method NotebookWorkspaces.ListByDatabaseAccount.
type NotebookWorkspacesListByDatabaseAccountResult struct {
	NotebookWorkspaceListResult
}

// NotebookWorkspacesListConnectionInfoResponse contains the response from method NotebookWorkspaces.ListConnectionInfo.
type NotebookWorkspacesListConnectionInfoResponse struct {
	NotebookWorkspacesListConnectionInfoResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookWorkspacesListConnectionInfoResult contains the result from method NotebookWorkspaces.ListConnectionInfo.
type NotebookWorkspacesListConnectionInfoResult struct {
	NotebookWorkspaceConnectionInfoResult
}

// NotebookWorkspacesRegenerateAuthTokenPollerResponse contains the response from method NotebookWorkspaces.RegenerateAuthToken.
type NotebookWorkspacesRegenerateAuthTokenPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookWorkspacesRegenerateAuthTokenPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NotebookWorkspacesRegenerateAuthTokenPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesRegenerateAuthTokenResponse, error) {
	respType := NotebookWorkspacesRegenerateAuthTokenResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookWorkspacesRegenerateAuthTokenPollerResponse from the provided client and resume token.
func (l *NotebookWorkspacesRegenerateAuthTokenPollerResponse) Resume(ctx context.Context, client *NotebookWorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NotebookWorkspacesClient.RegenerateAuthToken", token, client.pl, client.regenerateAuthTokenHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookWorkspacesRegenerateAuthTokenPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookWorkspacesRegenerateAuthTokenResponse contains the response from method NotebookWorkspaces.RegenerateAuthToken.
type NotebookWorkspacesRegenerateAuthTokenResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookWorkspacesStartPollerResponse contains the response from method NotebookWorkspaces.Start.
type NotebookWorkspacesStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookWorkspacesStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NotebookWorkspacesStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesStartResponse, error) {
	respType := NotebookWorkspacesStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookWorkspacesStartPollerResponse from the provided client and resume token.
func (l *NotebookWorkspacesStartPollerResponse) Resume(ctx context.Context, client *NotebookWorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NotebookWorkspacesClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookWorkspacesStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookWorkspacesStartResponse contains the response from method NotebookWorkspaces.Start.
type NotebookWorkspacesStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// PartitionKeyRangeIDListMetricsResponse contains the response from method PartitionKeyRangeID.ListMetrics.
type PartitionKeyRangeIDListMetricsResponse struct {
	PartitionKeyRangeIDListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PartitionKeyRangeIDListMetricsResult contains the result from method PartitionKeyRangeID.ListMetrics.
type PartitionKeyRangeIDListMetricsResult struct {
	PartitionMetricListResult
}

// PartitionKeyRangeIDRegionListMetricsResponse contains the response from method PartitionKeyRangeIDRegion.ListMetrics.
type PartitionKeyRangeIDRegionListMetricsResponse struct {
	PartitionKeyRangeIDRegionListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PartitionKeyRangeIDRegionListMetricsResult contains the result from method PartitionKeyRangeIDRegion.ListMetrics.
type PartitionKeyRangeIDRegionListMetricsResult struct {
	PartitionMetricListResult
}

// PercentileListMetricsResponse contains the response from method Percentile.ListMetrics.
type PercentileListMetricsResponse struct {
	PercentileListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PercentileListMetricsResult contains the result from method Percentile.ListMetrics.
type PercentileListMetricsResult struct {
	PercentileMetricListResult
}

// PercentileSourceTargetListMetricsResponse contains the response from method PercentileSourceTarget.ListMetrics.
type PercentileSourceTargetListMetricsResponse struct {
	PercentileSourceTargetListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PercentileSourceTargetListMetricsResult contains the result from method PercentileSourceTarget.ListMetrics.
type PercentileSourceTargetListMetricsResult struct {
	PercentileMetricListResult
}

// PercentileTargetListMetricsResponse contains the response from method PercentileTarget.ListMetrics.
type PercentileTargetListMetricsResponse struct {
	PercentileTargetListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PercentileTargetListMetricsResult contains the result from method PercentileTarget.ListMetrics.
type PercentileTargetListMetricsResult struct {
	PercentileMetricListResult
}

// PrivateEndpointConnectionsCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsCreateOrUpdateResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsCreateOrUpdateResult contains the result from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsDeletePollerResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsDeleteResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResponse contains the response from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResponse struct {
	PrivateEndpointConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResult contains the result from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsListByDatabaseAccountResponse contains the response from method PrivateEndpointConnections.ListByDatabaseAccount.
type PrivateEndpointConnectionsListByDatabaseAccountResponse struct {
	PrivateEndpointConnectionsListByDatabaseAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsListByDatabaseAccountResult contains the result from method PrivateEndpointConnections.ListByDatabaseAccount.
type PrivateEndpointConnectionsListByDatabaseAccountResult struct {
	PrivateEndpointConnectionListResult
}

// PrivateLinkResourcesGetResponse contains the response from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResponse struct {
	PrivateLinkResourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesGetResult contains the result from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResult struct {
	PrivateLinkResource
}

// PrivateLinkResourcesListByDatabaseAccountResponse contains the response from method PrivateLinkResources.ListByDatabaseAccount.
type PrivateLinkResourcesListByDatabaseAccountResponse struct {
	PrivateLinkResourcesListByDatabaseAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesListByDatabaseAccountResult contains the result from method PrivateLinkResources.ListByDatabaseAccount.
type PrivateLinkResourcesListByDatabaseAccountResult struct {
	PrivateLinkResourceListResult
}

// RestorableDatabaseAccountsGetByLocationResponse contains the response from method RestorableDatabaseAccounts.GetByLocation.
type RestorableDatabaseAccountsGetByLocationResponse struct {
	RestorableDatabaseAccountsGetByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDatabaseAccountsGetByLocationResult contains the result from method RestorableDatabaseAccounts.GetByLocation.
type RestorableDatabaseAccountsGetByLocationResult struct {
	RestorableDatabaseAccountGetResult
}

// RestorableDatabaseAccountsListByLocationResponse contains the response from method RestorableDatabaseAccounts.ListByLocation.
type RestorableDatabaseAccountsListByLocationResponse struct {
	RestorableDatabaseAccountsListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDatabaseAccountsListByLocationResult contains the result from method RestorableDatabaseAccounts.ListByLocation.
type RestorableDatabaseAccountsListByLocationResult struct {
	RestorableDatabaseAccountsListResult
}

// RestorableDatabaseAccountsListResponse contains the response from method RestorableDatabaseAccounts.List.
type RestorableDatabaseAccountsListResponse struct {
	RestorableDatabaseAccountsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDatabaseAccountsListResultEnvelope contains the result from method RestorableDatabaseAccounts.List.
type RestorableDatabaseAccountsListResultEnvelope struct {
	RestorableDatabaseAccountsListResult
}

// RestorableMongodbCollectionsListResponse contains the response from method RestorableMongodbCollections.List.
type RestorableMongodbCollectionsListResponse struct {
	RestorableMongodbCollectionsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableMongodbCollectionsListResultEnvelope contains the result from method RestorableMongodbCollections.List.
type RestorableMongodbCollectionsListResultEnvelope struct {
	RestorableMongodbCollectionsListResult
}

// RestorableMongodbDatabasesListResponse contains the response from method RestorableMongodbDatabases.List.
type RestorableMongodbDatabasesListResponse struct {
	RestorableMongodbDatabasesListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableMongodbDatabasesListResultEnvelope contains the result from method RestorableMongodbDatabases.List.
type RestorableMongodbDatabasesListResultEnvelope struct {
	RestorableMongodbDatabasesListResult
}

// RestorableMongodbResourcesListResponse contains the response from method RestorableMongodbResources.List.
type RestorableMongodbResourcesListResponse struct {
	RestorableMongodbResourcesListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableMongodbResourcesListResultEnvelope contains the result from method RestorableMongodbResources.List.
type RestorableMongodbResourcesListResultEnvelope struct {
	RestorableMongodbResourcesListResult
}

// RestorableSQLContainersListResponse contains the response from method RestorableSQLContainers.List.
type RestorableSQLContainersListResponse struct {
	RestorableSQLContainersListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableSQLContainersListResultEnvelope contains the result from method RestorableSQLContainers.List.
type RestorableSQLContainersListResultEnvelope struct {
	RestorableSQLContainersListResult
}

// RestorableSQLDatabasesListResponse contains the response from method RestorableSQLDatabases.List.
type RestorableSQLDatabasesListResponse struct {
	RestorableSQLDatabasesListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableSQLDatabasesListResultEnvelope contains the result from method RestorableSQLDatabases.List.
type RestorableSQLDatabasesListResultEnvelope struct {
	RestorableSQLDatabasesListResult
}

// RestorableSQLResourcesListResponse contains the response from method RestorableSQLResources.List.
type RestorableSQLResourcesListResponse struct {
	RestorableSQLResourcesListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableSQLResourcesListResultEnvelope contains the result from method RestorableSQLResources.List.
type RestorableSQLResourcesListResultEnvelope struct {
	RestorableSQLResourcesListResult
}

// SQLResourcesCreateUpdateSQLContainerPollerResponse contains the response from method SQLResources.CreateUpdateSQLContainer.
type SQLResourcesCreateUpdateSQLContainerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLContainerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLContainerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLContainerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLContainerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLContainerGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLContainerPollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLContainerPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLContainer", token, client.pl, client.createUpdateSQLContainerHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLContainerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLContainerResponse contains the response from method SQLResources.CreateUpdateSQLContainer.
type SQLResourcesCreateUpdateSQLContainerResponse struct {
	SQLResourcesCreateUpdateSQLContainerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLContainerResult contains the result from method SQLResources.CreateUpdateSQLContainer.
type SQLResourcesCreateUpdateSQLContainerResult struct {
	SQLContainerGetResults
}

// SQLResourcesCreateUpdateSQLDatabasePollerResponse contains the response from method SQLResources.CreateUpdateSQLDatabase.
type SQLResourcesCreateUpdateSQLDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLDatabaseResponse, error) {
	respType := SQLResourcesCreateUpdateSQLDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLDatabaseGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLDatabasePollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLDatabasePollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLDatabase", token, client.pl, client.createUpdateSQLDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLDatabaseResponse contains the response from method SQLResources.CreateUpdateSQLDatabase.
type SQLResourcesCreateUpdateSQLDatabaseResponse struct {
	SQLResourcesCreateUpdateSQLDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLDatabaseResult contains the result from method SQLResources.CreateUpdateSQLDatabase.
type SQLResourcesCreateUpdateSQLDatabaseResult struct {
	SQLDatabaseGetResults
}

// SQLResourcesCreateUpdateSQLRoleAssignmentPollerResponse contains the response from method SQLResources.CreateUpdateSQLRoleAssignment.
type SQLResourcesCreateUpdateSQLRoleAssignmentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLRoleAssignmentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLRoleAssignmentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLRoleAssignmentGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLRoleAssignmentPollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLRoleAssignmentPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLRoleAssignment", token, client.pl, client.createUpdateSQLRoleAssignmentHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLRoleAssignmentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLRoleAssignmentResponse contains the response from method SQLResources.CreateUpdateSQLRoleAssignment.
type SQLResourcesCreateUpdateSQLRoleAssignmentResponse struct {
	SQLResourcesCreateUpdateSQLRoleAssignmentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLRoleAssignmentResult contains the result from method SQLResources.CreateUpdateSQLRoleAssignment.
type SQLResourcesCreateUpdateSQLRoleAssignmentResult struct {
	SQLRoleAssignmentGetResults
}

// SQLResourcesCreateUpdateSQLRoleDefinitionPollerResponse contains the response from method SQLResources.CreateUpdateSQLRoleDefinition.
type SQLResourcesCreateUpdateSQLRoleDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLRoleDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLRoleDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLRoleDefinitionGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLRoleDefinitionPollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLRoleDefinitionPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLRoleDefinition", token, client.pl, client.createUpdateSQLRoleDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLRoleDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLRoleDefinitionResponse contains the response from method SQLResources.CreateUpdateSQLRoleDefinition.
type SQLResourcesCreateUpdateSQLRoleDefinitionResponse struct {
	SQLResourcesCreateUpdateSQLRoleDefinitionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLRoleDefinitionResult contains the result from method SQLResources.CreateUpdateSQLRoleDefinition.
type SQLResourcesCreateUpdateSQLRoleDefinitionResult struct {
	SQLRoleDefinitionGetResults
}

// SQLResourcesCreateUpdateSQLStoredProcedurePollerResponse contains the response from method SQLResources.CreateUpdateSQLStoredProcedure.
type SQLResourcesCreateUpdateSQLStoredProcedurePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLStoredProcedurePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLStoredProcedurePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLStoredProcedureResponse, error) {
	respType := SQLResourcesCreateUpdateSQLStoredProcedureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLStoredProcedureGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLStoredProcedurePollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLStoredProcedurePollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLStoredProcedure", token, client.pl, client.createUpdateSQLStoredProcedureHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLStoredProcedurePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLStoredProcedureResponse contains the response from method SQLResources.CreateUpdateSQLStoredProcedure.
type SQLResourcesCreateUpdateSQLStoredProcedureResponse struct {
	SQLResourcesCreateUpdateSQLStoredProcedureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLStoredProcedureResult contains the result from method SQLResources.CreateUpdateSQLStoredProcedure.
type SQLResourcesCreateUpdateSQLStoredProcedureResult struct {
	SQLStoredProcedureGetResults
}

// SQLResourcesCreateUpdateSQLTriggerPollerResponse contains the response from method SQLResources.CreateUpdateSQLTrigger.
type SQLResourcesCreateUpdateSQLTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLTriggerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLTriggerGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLTriggerPollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLTriggerPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLTrigger", token, client.pl, client.createUpdateSQLTriggerHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLTriggerResponse contains the response from method SQLResources.CreateUpdateSQLTrigger.
type SQLResourcesCreateUpdateSQLTriggerResponse struct {
	SQLResourcesCreateUpdateSQLTriggerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLTriggerResult contains the result from method SQLResources.CreateUpdateSQLTrigger.
type SQLResourcesCreateUpdateSQLTriggerResult struct {
	SQLTriggerGetResults
}

// SQLResourcesCreateUpdateSQLUserDefinedFunctionPollerResponse contains the response from method SQLResources.CreateUpdateSQLUserDefinedFunction.
type SQLResourcesCreateUpdateSQLUserDefinedFunctionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesCreateUpdateSQLUserDefinedFunctionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLUserDefinedFunctionGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesCreateUpdateSQLUserDefinedFunctionPollerResponse from the provided client and resume token.
func (l *SQLResourcesCreateUpdateSQLUserDefinedFunctionPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.CreateUpdateSQLUserDefinedFunction", token, client.pl, client.createUpdateSQLUserDefinedFunctionHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse contains the response from method SQLResources.CreateUpdateSQLUserDefinedFunction.
type SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse struct {
	SQLResourcesCreateUpdateSQLUserDefinedFunctionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesCreateUpdateSQLUserDefinedFunctionResult contains the result from method SQLResources.CreateUpdateSQLUserDefinedFunction.
type SQLResourcesCreateUpdateSQLUserDefinedFunctionResult struct {
	SQLUserDefinedFunctionGetResults
}

// SQLResourcesDeleteSQLContainerPollerResponse contains the response from method SQLResources.DeleteSQLContainer.
type SQLResourcesDeleteSQLContainerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLContainerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLContainerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLContainerResponse, error) {
	respType := SQLResourcesDeleteSQLContainerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLContainerPollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLContainerPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLContainer", token, client.pl, client.deleteSQLContainerHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLContainerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLContainerResponse contains the response from method SQLResources.DeleteSQLContainer.
type SQLResourcesDeleteSQLContainerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesDeleteSQLDatabasePollerResponse contains the response from method SQLResources.DeleteSQLDatabase.
type SQLResourcesDeleteSQLDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLDatabaseResponse, error) {
	respType := SQLResourcesDeleteSQLDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLDatabasePollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLDatabasePollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLDatabase", token, client.pl, client.deleteSQLDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLDatabaseResponse contains the response from method SQLResources.DeleteSQLDatabase.
type SQLResourcesDeleteSQLDatabaseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesDeleteSQLRoleAssignmentPollerResponse contains the response from method SQLResources.DeleteSQLRoleAssignment.
type SQLResourcesDeleteSQLRoleAssignmentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLRoleAssignmentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLRoleAssignmentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesDeleteSQLRoleAssignmentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLRoleAssignmentPollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLRoleAssignmentPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLRoleAssignment", token, client.pl, client.deleteSQLRoleAssignmentHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLRoleAssignmentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLRoleAssignmentResponse contains the response from method SQLResources.DeleteSQLRoleAssignment.
type SQLResourcesDeleteSQLRoleAssignmentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesDeleteSQLRoleDefinitionPollerResponse contains the response from method SQLResources.DeleteSQLRoleDefinition.
type SQLResourcesDeleteSQLRoleDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLRoleDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLRoleDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesDeleteSQLRoleDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLRoleDefinitionPollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLRoleDefinitionPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLRoleDefinition", token, client.pl, client.deleteSQLRoleDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLRoleDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLRoleDefinitionResponse contains the response from method SQLResources.DeleteSQLRoleDefinition.
type SQLResourcesDeleteSQLRoleDefinitionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesDeleteSQLStoredProcedurePollerResponse contains the response from method SQLResources.DeleteSQLStoredProcedure.
type SQLResourcesDeleteSQLStoredProcedurePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLStoredProcedurePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLStoredProcedurePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLStoredProcedureResponse, error) {
	respType := SQLResourcesDeleteSQLStoredProcedureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLStoredProcedurePollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLStoredProcedurePollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLStoredProcedure", token, client.pl, client.deleteSQLStoredProcedureHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLStoredProcedurePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLStoredProcedureResponse contains the response from method SQLResources.DeleteSQLStoredProcedure.
type SQLResourcesDeleteSQLStoredProcedureResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesDeleteSQLTriggerPollerResponse contains the response from method SQLResources.DeleteSQLTrigger.
type SQLResourcesDeleteSQLTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLTriggerResponse, error) {
	respType := SQLResourcesDeleteSQLTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLTriggerPollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLTriggerPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLTrigger", token, client.pl, client.deleteSQLTriggerHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLTriggerResponse contains the response from method SQLResources.DeleteSQLTrigger.
type SQLResourcesDeleteSQLTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesDeleteSQLUserDefinedFunctionPollerResponse contains the response from method SQLResources.DeleteSQLUserDefinedFunction.
type SQLResourcesDeleteSQLUserDefinedFunctionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesDeleteSQLUserDefinedFunctionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesDeleteSQLUserDefinedFunctionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesDeleteSQLUserDefinedFunctionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesDeleteSQLUserDefinedFunctionPollerResponse from the provided client and resume token.
func (l *SQLResourcesDeleteSQLUserDefinedFunctionPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.DeleteSQLUserDefinedFunction", token, client.pl, client.deleteSQLUserDefinedFunctionHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesDeleteSQLUserDefinedFunctionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesDeleteSQLUserDefinedFunctionResponse contains the response from method SQLResources.DeleteSQLUserDefinedFunction.
type SQLResourcesDeleteSQLUserDefinedFunctionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLContainerResponse contains the response from method SQLResources.GetSQLContainer.
type SQLResourcesGetSQLContainerResponse struct {
	SQLResourcesGetSQLContainerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLContainerResult contains the result from method SQLResources.GetSQLContainer.
type SQLResourcesGetSQLContainerResult struct {
	SQLContainerGetResults
}

// SQLResourcesGetSQLContainerThroughputResponse contains the response from method SQLResources.GetSQLContainerThroughput.
type SQLResourcesGetSQLContainerThroughputResponse struct {
	SQLResourcesGetSQLContainerThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLContainerThroughputResult contains the result from method SQLResources.GetSQLContainerThroughput.
type SQLResourcesGetSQLContainerThroughputResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesGetSQLDatabaseResponse contains the response from method SQLResources.GetSQLDatabase.
type SQLResourcesGetSQLDatabaseResponse struct {
	SQLResourcesGetSQLDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLDatabaseResult contains the result from method SQLResources.GetSQLDatabase.
type SQLResourcesGetSQLDatabaseResult struct {
	SQLDatabaseGetResults
}

// SQLResourcesGetSQLDatabaseThroughputResponse contains the response from method SQLResources.GetSQLDatabaseThroughput.
type SQLResourcesGetSQLDatabaseThroughputResponse struct {
	SQLResourcesGetSQLDatabaseThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLDatabaseThroughputResult contains the result from method SQLResources.GetSQLDatabaseThroughput.
type SQLResourcesGetSQLDatabaseThroughputResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesGetSQLRoleAssignmentResponse contains the response from method SQLResources.GetSQLRoleAssignment.
type SQLResourcesGetSQLRoleAssignmentResponse struct {
	SQLResourcesGetSQLRoleAssignmentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLRoleAssignmentResult contains the result from method SQLResources.GetSQLRoleAssignment.
type SQLResourcesGetSQLRoleAssignmentResult struct {
	SQLRoleAssignmentGetResults
}

// SQLResourcesGetSQLRoleDefinitionResponse contains the response from method SQLResources.GetSQLRoleDefinition.
type SQLResourcesGetSQLRoleDefinitionResponse struct {
	SQLResourcesGetSQLRoleDefinitionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLRoleDefinitionResult contains the result from method SQLResources.GetSQLRoleDefinition.
type SQLResourcesGetSQLRoleDefinitionResult struct {
	SQLRoleDefinitionGetResults
}

// SQLResourcesGetSQLStoredProcedureResponse contains the response from method SQLResources.GetSQLStoredProcedure.
type SQLResourcesGetSQLStoredProcedureResponse struct {
	SQLResourcesGetSQLStoredProcedureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLStoredProcedureResult contains the result from method SQLResources.GetSQLStoredProcedure.
type SQLResourcesGetSQLStoredProcedureResult struct {
	SQLStoredProcedureGetResults
}

// SQLResourcesGetSQLTriggerResponse contains the response from method SQLResources.GetSQLTrigger.
type SQLResourcesGetSQLTriggerResponse struct {
	SQLResourcesGetSQLTriggerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLTriggerResult contains the result from method SQLResources.GetSQLTrigger.
type SQLResourcesGetSQLTriggerResult struct {
	SQLTriggerGetResults
}

// SQLResourcesGetSQLUserDefinedFunctionResponse contains the response from method SQLResources.GetSQLUserDefinedFunction.
type SQLResourcesGetSQLUserDefinedFunctionResponse struct {
	SQLResourcesGetSQLUserDefinedFunctionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesGetSQLUserDefinedFunctionResult contains the result from method SQLResources.GetSQLUserDefinedFunction.
type SQLResourcesGetSQLUserDefinedFunctionResult struct {
	SQLUserDefinedFunctionGetResults
}

// SQLResourcesListSQLContainersResponse contains the response from method SQLResources.ListSQLContainers.
type SQLResourcesListSQLContainersResponse struct {
	SQLResourcesListSQLContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLContainersResult contains the result from method SQLResources.ListSQLContainers.
type SQLResourcesListSQLContainersResult struct {
	SQLContainerListResult
}

// SQLResourcesListSQLDatabasesResponse contains the response from method SQLResources.ListSQLDatabases.
type SQLResourcesListSQLDatabasesResponse struct {
	SQLResourcesListSQLDatabasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLDatabasesResult contains the result from method SQLResources.ListSQLDatabases.
type SQLResourcesListSQLDatabasesResult struct {
	SQLDatabaseListResult
}

// SQLResourcesListSQLRoleAssignmentsResponse contains the response from method SQLResources.ListSQLRoleAssignments.
type SQLResourcesListSQLRoleAssignmentsResponse struct {
	SQLResourcesListSQLRoleAssignmentsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLRoleAssignmentsResult contains the result from method SQLResources.ListSQLRoleAssignments.
type SQLResourcesListSQLRoleAssignmentsResult struct {
	SQLRoleAssignmentListResult
}

// SQLResourcesListSQLRoleDefinitionsResponse contains the response from method SQLResources.ListSQLRoleDefinitions.
type SQLResourcesListSQLRoleDefinitionsResponse struct {
	SQLResourcesListSQLRoleDefinitionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLRoleDefinitionsResult contains the result from method SQLResources.ListSQLRoleDefinitions.
type SQLResourcesListSQLRoleDefinitionsResult struct {
	SQLRoleDefinitionListResult
}

// SQLResourcesListSQLStoredProceduresResponse contains the response from method SQLResources.ListSQLStoredProcedures.
type SQLResourcesListSQLStoredProceduresResponse struct {
	SQLResourcesListSQLStoredProceduresResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLStoredProceduresResult contains the result from method SQLResources.ListSQLStoredProcedures.
type SQLResourcesListSQLStoredProceduresResult struct {
	SQLStoredProcedureListResult
}

// SQLResourcesListSQLTriggersResponse contains the response from method SQLResources.ListSQLTriggers.
type SQLResourcesListSQLTriggersResponse struct {
	SQLResourcesListSQLTriggersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLTriggersResult contains the result from method SQLResources.ListSQLTriggers.
type SQLResourcesListSQLTriggersResult struct {
	SQLTriggerListResult
}

// SQLResourcesListSQLUserDefinedFunctionsResponse contains the response from method SQLResources.ListSQLUserDefinedFunctions.
type SQLResourcesListSQLUserDefinedFunctionsResponse struct {
	SQLResourcesListSQLUserDefinedFunctionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesListSQLUserDefinedFunctionsResult contains the result from method SQLResources.ListSQLUserDefinedFunctions.
type SQLResourcesListSQLUserDefinedFunctionsResult struct {
	SQLUserDefinedFunctionListResult
}

// SQLResourcesMigrateSQLContainerToAutoscalePollerResponse contains the response from method SQLResources.MigrateSQLContainerToAutoscale.
type SQLResourcesMigrateSQLContainerToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesMigrateSQLContainerToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesMigrateSQLContainerToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLContainerToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesMigrateSQLContainerToAutoscalePollerResponse from the provided client and resume token.
func (l *SQLResourcesMigrateSQLContainerToAutoscalePollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.MigrateSQLContainerToAutoscale", token, client.pl, client.migrateSQLContainerToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesMigrateSQLContainerToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesMigrateSQLContainerToAutoscaleResponse contains the response from method SQLResources.MigrateSQLContainerToAutoscale.
type SQLResourcesMigrateSQLContainerToAutoscaleResponse struct {
	SQLResourcesMigrateSQLContainerToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesMigrateSQLContainerToAutoscaleResult contains the result from method SQLResources.MigrateSQLContainerToAutoscale.
type SQLResourcesMigrateSQLContainerToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesMigrateSQLContainerToManualThroughputPollerResponse contains the response from method SQLResources.MigrateSQLContainerToManualThroughput.
type SQLResourcesMigrateSQLContainerToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesMigrateSQLContainerToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesMigrateSQLContainerToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLContainerToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesMigrateSQLContainerToManualThroughputPollerResponse from the provided client and resume token.
func (l *SQLResourcesMigrateSQLContainerToManualThroughputPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.MigrateSQLContainerToManualThroughput", token, client.pl, client.migrateSQLContainerToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesMigrateSQLContainerToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesMigrateSQLContainerToManualThroughputResponse contains the response from method SQLResources.MigrateSQLContainerToManualThroughput.
type SQLResourcesMigrateSQLContainerToManualThroughputResponse struct {
	SQLResourcesMigrateSQLContainerToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesMigrateSQLContainerToManualThroughputResult contains the result from method SQLResources.MigrateSQLContainerToManualThroughput.
type SQLResourcesMigrateSQLContainerToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesMigrateSQLDatabaseToAutoscalePollerResponse contains the response from method SQLResources.MigrateSQLDatabaseToAutoscale.
type SQLResourcesMigrateSQLDatabaseToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesMigrateSQLDatabaseToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesMigrateSQLDatabaseToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLDatabaseToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesMigrateSQLDatabaseToAutoscalePollerResponse from the provided client and resume token.
func (l *SQLResourcesMigrateSQLDatabaseToAutoscalePollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.MigrateSQLDatabaseToAutoscale", token, client.pl, client.migrateSQLDatabaseToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesMigrateSQLDatabaseToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesMigrateSQLDatabaseToAutoscaleResponse contains the response from method SQLResources.MigrateSQLDatabaseToAutoscale.
type SQLResourcesMigrateSQLDatabaseToAutoscaleResponse struct {
	SQLResourcesMigrateSQLDatabaseToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesMigrateSQLDatabaseToAutoscaleResult contains the result from method SQLResources.MigrateSQLDatabaseToAutoscale.
type SQLResourcesMigrateSQLDatabaseToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesMigrateSQLDatabaseToManualThroughputPollerResponse contains the response from method SQLResources.MigrateSQLDatabaseToManualThroughput.
type SQLResourcesMigrateSQLDatabaseToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesMigrateSQLDatabaseToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesMigrateSQLDatabaseToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLDatabaseToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesMigrateSQLDatabaseToManualThroughputPollerResponse from the provided client and resume token.
func (l *SQLResourcesMigrateSQLDatabaseToManualThroughputPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.MigrateSQLDatabaseToManualThroughput", token, client.pl, client.migrateSQLDatabaseToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesMigrateSQLDatabaseToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesMigrateSQLDatabaseToManualThroughputResponse contains the response from method SQLResources.MigrateSQLDatabaseToManualThroughput.
type SQLResourcesMigrateSQLDatabaseToManualThroughputResponse struct {
	SQLResourcesMigrateSQLDatabaseToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesMigrateSQLDatabaseToManualThroughputResult contains the result from method SQLResources.MigrateSQLDatabaseToManualThroughput.
type SQLResourcesMigrateSQLDatabaseToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesRetrieveContinuousBackupInformationPollerResponse contains the response from method SQLResources.RetrieveContinuousBackupInformation.
type SQLResourcesRetrieveContinuousBackupInformationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesRetrieveContinuousBackupInformationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesRetrieveContinuousBackupInformationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesRetrieveContinuousBackupInformationResponse, error) {
	respType := SQLResourcesRetrieveContinuousBackupInformationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackupInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesRetrieveContinuousBackupInformationPollerResponse from the provided client and resume token.
func (l *SQLResourcesRetrieveContinuousBackupInformationPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.RetrieveContinuousBackupInformation", token, client.pl, client.retrieveContinuousBackupInformationHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesRetrieveContinuousBackupInformationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesRetrieveContinuousBackupInformationResponse contains the response from method SQLResources.RetrieveContinuousBackupInformation.
type SQLResourcesRetrieveContinuousBackupInformationResponse struct {
	SQLResourcesRetrieveContinuousBackupInformationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesRetrieveContinuousBackupInformationResult contains the result from method SQLResources.RetrieveContinuousBackupInformation.
type SQLResourcesRetrieveContinuousBackupInformationResult struct {
	BackupInformation
}

// SQLResourcesUpdateSQLContainerThroughputPollerResponse contains the response from method SQLResources.UpdateSQLContainerThroughput.
type SQLResourcesUpdateSQLContainerThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesUpdateSQLContainerThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesUpdateSQLContainerThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesUpdateSQLContainerThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLContainerThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesUpdateSQLContainerThroughputPollerResponse from the provided client and resume token.
func (l *SQLResourcesUpdateSQLContainerThroughputPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.UpdateSQLContainerThroughput", token, client.pl, client.updateSQLContainerThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesUpdateSQLContainerThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesUpdateSQLContainerThroughputResponse contains the response from method SQLResources.UpdateSQLContainerThroughput.
type SQLResourcesUpdateSQLContainerThroughputResponse struct {
	SQLResourcesUpdateSQLContainerThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesUpdateSQLContainerThroughputResult contains the result from method SQLResources.UpdateSQLContainerThroughput.
type SQLResourcesUpdateSQLContainerThroughputResult struct {
	ThroughputSettingsGetResults
}

// SQLResourcesUpdateSQLDatabaseThroughputPollerResponse contains the response from method SQLResources.UpdateSQLDatabaseThroughput.
type SQLResourcesUpdateSQLDatabaseThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLResourcesUpdateSQLDatabaseThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLResourcesUpdateSQLDatabaseThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesUpdateSQLDatabaseThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLDatabaseThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLResourcesUpdateSQLDatabaseThroughputPollerResponse from the provided client and resume token.
func (l *SQLResourcesUpdateSQLDatabaseThroughputPollerResponse) Resume(ctx context.Context, client *SQLResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLResourcesClient.UpdateSQLDatabaseThroughput", token, client.pl, client.updateSQLDatabaseThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &SQLResourcesUpdateSQLDatabaseThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLResourcesUpdateSQLDatabaseThroughputResponse contains the response from method SQLResources.UpdateSQLDatabaseThroughput.
type SQLResourcesUpdateSQLDatabaseThroughputResponse struct {
	SQLResourcesUpdateSQLDatabaseThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLResourcesUpdateSQLDatabaseThroughputResult contains the result from method SQLResources.UpdateSQLDatabaseThroughput.
type SQLResourcesUpdateSQLDatabaseThroughputResult struct {
	ThroughputSettingsGetResults
}

// TableResourcesCreateUpdateTablePollerResponse contains the response from method TableResources.CreateUpdateTable.
type TableResourcesCreateUpdateTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TableResourcesCreateUpdateTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TableResourcesCreateUpdateTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesCreateUpdateTableResponse, error) {
	respType := TableResourcesCreateUpdateTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TableGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TableResourcesCreateUpdateTablePollerResponse from the provided client and resume token.
func (l *TableResourcesCreateUpdateTablePollerResponse) Resume(ctx context.Context, client *TableResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TableResourcesClient.CreateUpdateTable", token, client.pl, client.createUpdateTableHandleError)
	if err != nil {
		return err
	}
	poller := &TableResourcesCreateUpdateTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TableResourcesCreateUpdateTableResponse contains the response from method TableResources.CreateUpdateTable.
type TableResourcesCreateUpdateTableResponse struct {
	TableResourcesCreateUpdateTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesCreateUpdateTableResult contains the result from method TableResources.CreateUpdateTable.
type TableResourcesCreateUpdateTableResult struct {
	TableGetResults
}

// TableResourcesDeleteTablePollerResponse contains the response from method TableResources.DeleteTable.
type TableResourcesDeleteTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TableResourcesDeleteTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TableResourcesDeleteTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesDeleteTableResponse, error) {
	respType := TableResourcesDeleteTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TableResourcesDeleteTablePollerResponse from the provided client and resume token.
func (l *TableResourcesDeleteTablePollerResponse) Resume(ctx context.Context, client *TableResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TableResourcesClient.DeleteTable", token, client.pl, client.deleteTableHandleError)
	if err != nil {
		return err
	}
	poller := &TableResourcesDeleteTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TableResourcesDeleteTableResponse contains the response from method TableResources.DeleteTable.
type TableResourcesDeleteTableResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesGetTableResponse contains the response from method TableResources.GetTable.
type TableResourcesGetTableResponse struct {
	TableResourcesGetTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesGetTableResult contains the result from method TableResources.GetTable.
type TableResourcesGetTableResult struct {
	TableGetResults
}

// TableResourcesGetTableThroughputResponse contains the response from method TableResources.GetTableThroughput.
type TableResourcesGetTableThroughputResponse struct {
	TableResourcesGetTableThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesGetTableThroughputResult contains the result from method TableResources.GetTableThroughput.
type TableResourcesGetTableThroughputResult struct {
	ThroughputSettingsGetResults
}

// TableResourcesListTablesResponse contains the response from method TableResources.ListTables.
type TableResourcesListTablesResponse struct {
	TableResourcesListTablesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesListTablesResult contains the result from method TableResources.ListTables.
type TableResourcesListTablesResult struct {
	TableListResult
}

// TableResourcesMigrateTableToAutoscalePollerResponse contains the response from method TableResources.MigrateTableToAutoscale.
type TableResourcesMigrateTableToAutoscalePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TableResourcesMigrateTableToAutoscalePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TableResourcesMigrateTableToAutoscalePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesMigrateTableToAutoscaleResponse, error) {
	respType := TableResourcesMigrateTableToAutoscaleResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TableResourcesMigrateTableToAutoscalePollerResponse from the provided client and resume token.
func (l *TableResourcesMigrateTableToAutoscalePollerResponse) Resume(ctx context.Context, client *TableResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TableResourcesClient.MigrateTableToAutoscale", token, client.pl, client.migrateTableToAutoscaleHandleError)
	if err != nil {
		return err
	}
	poller := &TableResourcesMigrateTableToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TableResourcesMigrateTableToAutoscaleResponse contains the response from method TableResources.MigrateTableToAutoscale.
type TableResourcesMigrateTableToAutoscaleResponse struct {
	TableResourcesMigrateTableToAutoscaleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesMigrateTableToAutoscaleResult contains the result from method TableResources.MigrateTableToAutoscale.
type TableResourcesMigrateTableToAutoscaleResult struct {
	ThroughputSettingsGetResults
}

// TableResourcesMigrateTableToManualThroughputPollerResponse contains the response from method TableResources.MigrateTableToManualThroughput.
type TableResourcesMigrateTableToManualThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TableResourcesMigrateTableToManualThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TableResourcesMigrateTableToManualThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesMigrateTableToManualThroughputResponse, error) {
	respType := TableResourcesMigrateTableToManualThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TableResourcesMigrateTableToManualThroughputPollerResponse from the provided client and resume token.
func (l *TableResourcesMigrateTableToManualThroughputPollerResponse) Resume(ctx context.Context, client *TableResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TableResourcesClient.MigrateTableToManualThroughput", token, client.pl, client.migrateTableToManualThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &TableResourcesMigrateTableToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TableResourcesMigrateTableToManualThroughputResponse contains the response from method TableResources.MigrateTableToManualThroughput.
type TableResourcesMigrateTableToManualThroughputResponse struct {
	TableResourcesMigrateTableToManualThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesMigrateTableToManualThroughputResult contains the result from method TableResources.MigrateTableToManualThroughput.
type TableResourcesMigrateTableToManualThroughputResult struct {
	ThroughputSettingsGetResults
}

// TableResourcesUpdateTableThroughputPollerResponse contains the response from method TableResources.UpdateTableThroughput.
type TableResourcesUpdateTableThroughputPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TableResourcesUpdateTableThroughputPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TableResourcesUpdateTableThroughputPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesUpdateTableThroughputResponse, error) {
	respType := TableResourcesUpdateTableThroughputResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TableResourcesUpdateTableThroughputPollerResponse from the provided client and resume token.
func (l *TableResourcesUpdateTableThroughputPollerResponse) Resume(ctx context.Context, client *TableResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TableResourcesClient.UpdateTableThroughput", token, client.pl, client.updateTableThroughputHandleError)
	if err != nil {
		return err
	}
	poller := &TableResourcesUpdateTableThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TableResourcesUpdateTableThroughputResponse contains the response from method TableResources.UpdateTableThroughput.
type TableResourcesUpdateTableThroughputResponse struct {
	TableResourcesUpdateTableThroughputResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TableResourcesUpdateTableThroughputResult contains the result from method TableResources.UpdateTableThroughput.
type TableResourcesUpdateTableThroughputResult struct {
	ThroughputSettingsGetResults
}
