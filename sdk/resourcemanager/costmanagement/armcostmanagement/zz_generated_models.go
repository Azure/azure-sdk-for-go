//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcostmanagement

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// Alert - An individual alert.
type Alert struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating
	// the latest version or not.
	ETag *string `json:"eTag,omitempty"`

	// Alert properties.
	Properties *AlertProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// AlertProperties - Alert properties.
type AlertProperties struct {
	// dateTime in which alert was closed
	CloseTime *string `json:"closeTime,omitempty"`

	// related budget
	CostEntityID *string `json:"costEntityId,omitempty"`

	// dateTime in which alert was created
	CreationTime *string `json:"creationTime,omitempty"`

	// defines the type of alert
	Definition *AlertPropertiesDefinition `json:"definition,omitempty"`

	// Alert description
	Description *string `json:"description,omitempty"`

	// Alert details
	Details *AlertPropertiesDetails `json:"details,omitempty"`

	// dateTime in which alert was last modified
	ModificationTime *string `json:"modificationTime,omitempty"`

	// Source of alert
	Source *AlertSource `json:"source,omitempty"`

	// alert status
	Status *AlertStatus `json:"status,omitempty"`

	// dateTime in which the alert status was last modified
	StatusModificationTime *string `json:"statusModificationTime,omitempty"`

	// User who last modified the alert
	StatusModificationUserName *string `json:"statusModificationUserName,omitempty"`
}

// AlertPropertiesDefinition - defines the type of alert
type AlertPropertiesDefinition struct {
	// Alert category
	Category *AlertCategory `json:"category,omitempty"`

	// Criteria that triggered alert
	Criteria *AlertCriteria `json:"criteria,omitempty"`

	// type of alert
	Type *AlertType `json:"type,omitempty"`
}

// AlertPropertiesDetails - Alert details
type AlertPropertiesDetails struct {
	// budget threshold amount
	Amount *float64 `json:"amount,omitempty"`

	// company name
	CompanyName *string `json:"companyName,omitempty"`

	// list of emails to contact
	ContactEmails []*string `json:"contactEmails,omitempty"`

	// list of action groups to broadcast to
	ContactGroups []*string `json:"contactGroups,omitempty"`

	// list of contact roles
	ContactRoles []*string `json:"contactRoles,omitempty"`

	// current spend
	CurrentSpend *float64 `json:"currentSpend,omitempty"`

	// department name
	DepartmentName *string `json:"departmentName,omitempty"`

	// datetime of enrollmentEndDate
	EnrollmentEndDate *string `json:"enrollmentEndDate,omitempty"`

	// enrollment number
	EnrollmentNumber *string `json:"enrollmentNumber,omitempty"`

	// datetime of enrollmentStartDate
	EnrollmentStartDate *string `json:"enrollmentStartDate,omitempty"`

	// invoicing threshold
	InvoicingThreshold *float64 `json:"invoicingThreshold,omitempty"`

	// array of meters to filter by
	MeterFilter []interface{} `json:"meterFilter,omitempty"`

	// operator used to compare currentSpend with amount
	Operator *AlertOperator `json:"operator,omitempty"`

	// overriding alert
	OverridingAlert *string `json:"overridingAlert,omitempty"`

	// datetime of periodStartDate
	PeriodStartDate *string `json:"periodStartDate,omitempty"`

	// array of resources to filter by
	ResourceFilter []interface{} `json:"resourceFilter,omitempty"`

	// array of resourceGroups to filter by
	ResourceGroupFilter []interface{} `json:"resourceGroupFilter,omitempty"`

	// tags to filter by
	TagFilter map[string]interface{} `json:"tagFilter,omitempty"`

	// notification threshold percentage as a decimal which activated this alert
	Threshold *float64 `json:"threshold,omitempty"`

	// Type of timegrain cadence
	TimeGrainType *AlertTimeGrainType `json:"timeGrainType,omitempty"`

	// notificationId that triggered this alert
	TriggeredBy *string `json:"triggeredBy,omitempty"`

	// unit of currency being used
	Unit *string `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertPropertiesDetails.
func (a AlertPropertiesDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "amount", a.Amount)
	populate(objectMap, "companyName", a.CompanyName)
	populate(objectMap, "contactEmails", a.ContactEmails)
	populate(objectMap, "contactGroups", a.ContactGroups)
	populate(objectMap, "contactRoles", a.ContactRoles)
	populate(objectMap, "currentSpend", a.CurrentSpend)
	populate(objectMap, "departmentName", a.DepartmentName)
	populate(objectMap, "enrollmentEndDate", a.EnrollmentEndDate)
	populate(objectMap, "enrollmentNumber", a.EnrollmentNumber)
	populate(objectMap, "enrollmentStartDate", a.EnrollmentStartDate)
	populate(objectMap, "invoicingThreshold", a.InvoicingThreshold)
	populate(objectMap, "meterFilter", a.MeterFilter)
	populate(objectMap, "operator", a.Operator)
	populate(objectMap, "overridingAlert", a.OverridingAlert)
	populate(objectMap, "periodStartDate", a.PeriodStartDate)
	populate(objectMap, "resourceFilter", a.ResourceFilter)
	populate(objectMap, "resourceGroupFilter", a.ResourceGroupFilter)
	populate(objectMap, "tagFilter", a.TagFilter)
	populate(objectMap, "threshold", a.Threshold)
	populate(objectMap, "timeGrainType", a.TimeGrainType)
	populate(objectMap, "triggeredBy", a.TriggeredBy)
	populate(objectMap, "unit", a.Unit)
	return json.Marshal(objectMap)
}

// AlertsClientDismissOptions contains the optional parameters for the AlertsClient.Dismiss method.
type AlertsClientDismissOptions struct {
	// placeholder for future optional parameters
}

// AlertsClientGetOptions contains the optional parameters for the AlertsClient.Get method.
type AlertsClientGetOptions struct {
	// placeholder for future optional parameters
}

// AlertsClientListExternalOptions contains the optional parameters for the AlertsClient.ListExternal method.
type AlertsClientListExternalOptions struct {
	// placeholder for future optional parameters
}

// AlertsClientListOptions contains the optional parameters for the AlertsClient.List method.
type AlertsClientListOptions struct {
	// placeholder for future optional parameters
}

// AlertsResult - Result of alerts.
type AlertsResult struct {
	// READ-ONLY; URL to get the next set of alerts results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of alerts.
	Value []*Alert `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertsResult.
func (a AlertsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// CommonExportProperties - The common properties of the export.
type CommonExportProperties struct {
	// REQUIRED; Has the definition for the export.
	Definition *ExportDefinition `json:"definition,omitempty"`

	// REQUIRED; Has delivery information for the export.
	DeliveryInfo *ExportDeliveryInfo `json:"deliveryInfo,omitempty"`

	// The format of the export being delivered. Currently only 'Csv' is supported.
	Format *FormatType `json:"format,omitempty"`

	// If set to true, exported data will be partitioned by size and placed in a blob directory together with a manifest file.
	// Note: this option is currently available only for modern commerce scopes.
	PartitionData *bool `json:"partitionData,omitempty"`

	// If requested, has the most recent execution history for the export.
	RunHistory *ExportExecutionListResult `json:"runHistory,omitempty"`

	// READ-ONLY; If the export has an active schedule, provides an estimate of the next execution time.
	NextRunTimeEstimate *time.Time `json:"nextRunTimeEstimate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonExportProperties.
func (c CommonExportProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "definition", c.Definition)
	populate(objectMap, "deliveryInfo", c.DeliveryInfo)
	populate(objectMap, "format", c.Format)
	populateTimeRFC3339(objectMap, "nextRunTimeEstimate", c.NextRunTimeEstimate)
	populate(objectMap, "partitionData", c.PartitionData)
	populate(objectMap, "runHistory", c.RunHistory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonExportProperties.
func (c *CommonExportProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "definition":
			err = unpopulate(val, &c.Definition)
			delete(rawMsg, key)
		case "deliveryInfo":
			err = unpopulate(val, &c.DeliveryInfo)
			delete(rawMsg, key)
		case "format":
			err = unpopulate(val, &c.Format)
			delete(rawMsg, key)
		case "nextRunTimeEstimate":
			err = unpopulateTimeRFC3339(val, &c.NextRunTimeEstimate)
			delete(rawMsg, key)
		case "partitionData":
			err = unpopulate(val, &c.PartitionData)
			delete(rawMsg, key)
		case "runHistory":
			err = unpopulate(val, &c.RunHistory)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Dimension - List of Dimension.
type Dimension struct {
	// Dimension properties.
	Properties *DimensionProperties `json:"properties,omitempty"`

	// READ-ONLY; ETag of the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Location of the resource.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; SKU of the resource.
	SKU *string `json:"sku,omitempty" azure:"ro"`

	// READ-ONLY; Resource tags.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Dimension.
func (d Dimension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", d.ETag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "sku", d.SKU)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// DimensionProperties - Dimension properties.
type DimensionProperties struct {
	// Dimension data.
	Data []*string `json:"data,omitempty"`

	// READ-ONLY; Dimension category.
	Category *string `json:"category,omitempty" azure:"ro"`

	// READ-ONLY; Dimension description.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Filter enabled.
	FilterEnabled *bool `json:"filterEnabled,omitempty" azure:"ro"`

	// READ-ONLY; Grouping enabled.
	GroupingEnabled *bool `json:"groupingEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Total number of data for the dimension.
	Total *int32 `json:"total,omitempty" azure:"ro"`

	// READ-ONLY; Usage end.
	UsageEnd *time.Time `json:"usageEnd,omitempty" azure:"ro"`

	// READ-ONLY; Usage start.
	UsageStart *time.Time `json:"usageStart,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DimensionProperties.
func (d DimensionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", d.Category)
	populate(objectMap, "data", d.Data)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "filterEnabled", d.FilterEnabled)
	populate(objectMap, "groupingEnabled", d.GroupingEnabled)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "total", d.Total)
	populateTimeRFC3339(objectMap, "usageEnd", d.UsageEnd)
	populateTimeRFC3339(objectMap, "usageStart", d.UsageStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DimensionProperties.
func (d *DimensionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, &d.Category)
			delete(rawMsg, key)
		case "data":
			err = unpopulate(val, &d.Data)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "filterEnabled":
			err = unpopulate(val, &d.FilterEnabled)
			delete(rawMsg, key)
		case "groupingEnabled":
			err = unpopulate(val, &d.GroupingEnabled)
			delete(rawMsg, key)
		case "nextLink":
			err = unpopulate(val, &d.NextLink)
			delete(rawMsg, key)
		case "total":
			err = unpopulate(val, &d.Total)
			delete(rawMsg, key)
		case "usageEnd":
			err = unpopulateTimeRFC3339(val, &d.UsageEnd)
			delete(rawMsg, key)
		case "usageStart":
			err = unpopulateTimeRFC3339(val, &d.UsageStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DimensionsClientByExternalCloudProviderTypeOptions contains the optional parameters for the DimensionsClient.ByExternalCloudProviderType
// method.
type DimensionsClientByExternalCloudProviderTypeOptions struct {
	// May be used to expand the properties/data within a dimension category. By default, data is not included when listing dimensions.
	Expand *string
	// May be used to filter dimensions by properties/category, properties/usageStart, properties/usageEnd. Supported operators
	// are 'eq','lt', 'gt', 'le', 'ge'.
	Filter *string
	// Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element,
	// the value of the nextLink element will include a skiptoken parameter that
	// specifies a starting point to use for subsequent calls.
	Skiptoken *string
	// May be used to limit the number of results to the most recent N dimension data.
	Top *int32
}

// DimensionsClientListOptions contains the optional parameters for the DimensionsClient.List method.
type DimensionsClientListOptions struct {
	// May be used to expand the properties/data within a dimension category. By default, data is not included when listing dimensions.
	Expand *string
	// May be used to filter dimensions by properties/category, properties/usageStart, properties/usageEnd. Supported operators
	// are 'eq','lt', 'gt', 'le', 'ge'.
	Filter *string
	// Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element,
	// the value of the nextLink element will include a skiptoken parameter that
	// specifies a starting point to use for subsequent calls.
	Skiptoken *string
	// May be used to limit the number of results to the most recent N dimension data.
	Top *int32
}

// DimensionsListResult - Result of listing dimensions. It contains a list of available dimensions.
type DimensionsListResult struct {
	// READ-ONLY; The list of dimensions.
	Value []*Dimension `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DimensionsListResult.
func (d DimensionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DismissAlertPayload - The request payload to update an alert
type DismissAlertPayload struct {
	// Alert properties.
	Properties *AlertProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DismissAlertPayload.
func (d DismissAlertPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// DownloadURL - The URL to download the generated report.
type DownloadURL struct {
	// The URL to download the generated report.
	DownloadURL *string `json:"downloadUrl,omitempty"`

	// The time at which report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z.
	ValidTill *time.Time `json:"validTill,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DownloadURL.
func (d DownloadURL) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "downloadUrl", d.DownloadURL)
	populateTimeRFC3339(objectMap, "validTill", d.ValidTill)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadURL.
func (d *DownloadURL) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "downloadUrl":
			err = unpopulate(val, &d.DownloadURL)
			delete(rawMsg, key)
		case "validTill":
			err = unpopulateTimeRFC3339(val, &d.ValidTill)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ErrorDetails - The details of the error.
type ErrorDetails struct {
	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ErrorResponse - Error response indicates that the service is not able to process the incoming request. The reason is provided
// in the error message.
// Some Error responses:
// * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after"
// header.
//
//
// * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After"
// header.
type ErrorResponse struct {
	// The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`
}

// Export - An export resource.
type Export struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating
	// the latest version or not.
	ETag *string `json:"eTag,omitempty"`

	// The properties of the export.
	Properties *ExportProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ExportDataset - The definition for data in the export.
type ExportDataset struct {
	// The export dataset configuration.
	Configuration *ExportDatasetConfiguration `json:"configuration,omitempty"`

	// The granularity of rows in the export. Currently only 'Daily' is supported.
	Granularity *GranularityType `json:"granularity,omitempty"`
}

// ExportDatasetConfiguration - The export dataset configuration. Allows columns to be selected for the export. If not provided
// then the export will include all available columns.
type ExportDatasetConfiguration struct {
	// Array of column names to be included in the export. If not provided then the export will include all available columns.
	// The available columns can vary by customer channel (see examples).
	Columns []*string `json:"columns,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportDatasetConfiguration.
func (e ExportDatasetConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", e.Columns)
	return json.Marshal(objectMap)
}

// ExportDefinition - The definition of an export.
type ExportDefinition struct {
	// REQUIRED; The time frame for pulling data for the export. If custom, then a specific time period must be provided.
	Timeframe *TimeframeType `json:"timeframe,omitempty"`

	// REQUIRED; The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to exports that do
	// not yet provide data for charges or amortization for service reservations.
	Type *ExportType `json:"type,omitempty"`

	// The definition for data in the export.
	DataSet *ExportDataset `json:"dataSet,omitempty"`

	// Has time period for pulling data for the export.
	TimePeriod *ExportTimePeriod `json:"timePeriod,omitempty"`
}

// ExportDeliveryDestination - This represents the blob storage account location where exports of costs will be delivered.
// There are two ways to configure the destination. The approach recommended for most customers is to specify
// the resourceId of the storage account. This requires a one-time registration of the account's subscription with the Microsoft.CostManagementExports
// resource provider in order to give Azure Cost
// Management services access to the storage. When creating an export in the Azure portal this registration is performed automatically
// but API users may need to register the subscription explicitly (for
// more information see https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services
// ). Another way to configure the destination is available ONLY to Partners with a
// Microsoft Partner Agreement plan who are global admins of their billing account. These Partners, instead of specifying
// the resourceId of a storage account, can specify the storage account name along
// with a SAS token for the account. This allows exports of costs to a storage account in any tenant. The SAS token should
// be created for the blob service with Service/Container/Object resource types and
// with Read/Write/Delete/List/Add/Create permissions (for more information see https://docs.microsoft.com/en-us/azure/cost-management-billing/costs/export-cost-data-storage-account-sas-key
// ).
type ExportDeliveryDestination struct {
	// REQUIRED; The name of the container where exports will be uploaded. If the container does not exist it will be created.
	Container *string `json:"container,omitempty"`

	// The resource id of the storage account where exports will be delivered. This is not required if a sasToken and storageAccount
	// are specified.
	ResourceID *string `json:"resourceId,omitempty"`

	// The name of the directory where exports will be uploaded.
	RootFolderPath *string `json:"rootFolderPath,omitempty"`

	// A SAS token for the storage account. For a restricted set of Azure customers this together with storageAccount can be specified
	// instead of resourceId. Note: the value returned by the API for this
	// property will always be obfuscated. Returning this same obfuscated value will not result in the SAS token being updated.
	// To update this value a new SAS token must be specified.
	SasToken *string `json:"sasToken,omitempty"`

	// The storage account where exports will be uploaded. For a restricted set of Azure customers this together with sasToken
	// can be specified instead of resourceId.
	StorageAccount *string `json:"storageAccount,omitempty"`
}

// ExportDeliveryInfo - The delivery information associated with a export.
type ExportDeliveryInfo struct {
	// REQUIRED; Has destination for the export being delivered.
	Destination *ExportDeliveryDestination `json:"destination,omitempty"`
}

// ExportExecution - An export execution.
type ExportExecution struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating
	// the latest version or not.
	ETag *string `json:"eTag,omitempty"`

	// The properties of the export execution.
	Properties *ExportExecutionProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ExportExecutionListResult - Result of listing the execution history of an export.
type ExportExecutionListResult struct {
	// READ-ONLY; A list of export executions.
	Value []*ExportExecution `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportExecutionListResult.
func (e ExportExecutionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExportExecutionProperties - The properties of the export execution.
type ExportExecutionProperties struct {
	// The details of any error.
	Error *ErrorDetails `json:"error,omitempty"`

	// The type of the export execution.
	ExecutionType *ExecutionType `json:"executionType,omitempty"`

	// The name of the exported file.
	FileName *string `json:"fileName,omitempty"`

	// The time when the export execution finished.
	ProcessingEndTime *time.Time `json:"processingEndTime,omitempty"`

	// The time when export was picked up to be executed.
	ProcessingStartTime *time.Time `json:"processingStartTime,omitempty"`

	// The export settings that were in effect for this execution.
	RunSettings *CommonExportProperties `json:"runSettings,omitempty"`

	// The last known status of the export execution.
	Status *ExecutionStatus `json:"status,omitempty"`

	// The identifier for the entity that executed the export. For OnDemand executions it is the user email. For scheduled executions
	// it is 'System'.
	SubmittedBy *string `json:"submittedBy,omitempty"`

	// The time when export was queued to be executed.
	SubmittedTime *time.Time `json:"submittedTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportExecutionProperties.
func (e ExportExecutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", e.Error)
	populate(objectMap, "executionType", e.ExecutionType)
	populate(objectMap, "fileName", e.FileName)
	populateTimeRFC3339(objectMap, "processingEndTime", e.ProcessingEndTime)
	populateTimeRFC3339(objectMap, "processingStartTime", e.ProcessingStartTime)
	populate(objectMap, "runSettings", e.RunSettings)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "submittedBy", e.SubmittedBy)
	populateTimeRFC3339(objectMap, "submittedTime", e.SubmittedTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportExecutionProperties.
func (e *ExportExecutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &e.Error)
			delete(rawMsg, key)
		case "executionType":
			err = unpopulate(val, &e.ExecutionType)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &e.FileName)
			delete(rawMsg, key)
		case "processingEndTime":
			err = unpopulateTimeRFC3339(val, &e.ProcessingEndTime)
			delete(rawMsg, key)
		case "processingStartTime":
			err = unpopulateTimeRFC3339(val, &e.ProcessingStartTime)
			delete(rawMsg, key)
		case "runSettings":
			err = unpopulate(val, &e.RunSettings)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &e.Status)
			delete(rawMsg, key)
		case "submittedBy":
			err = unpopulate(val, &e.SubmittedBy)
			delete(rawMsg, key)
		case "submittedTime":
			err = unpopulateTimeRFC3339(val, &e.SubmittedTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExportListResult - Result of listing exports. It contains a list of available exports in the scope provided.
type ExportListResult struct {
	// READ-ONLY; The list of exports.
	Value []*Export `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportListResult.
func (e ExportListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExportProperties - The properties of the export.
type ExportProperties struct {
	// REQUIRED; Has the definition for the export.
	Definition *ExportDefinition `json:"definition,omitempty"`

	// REQUIRED; Has delivery information for the export.
	DeliveryInfo *ExportDeliveryInfo `json:"deliveryInfo,omitempty"`

	// The format of the export being delivered. Currently only 'Csv' is supported.
	Format *FormatType `json:"format,omitempty"`

	// If set to true, exported data will be partitioned by size and placed in a blob directory together with a manifest file.
	// Note: this option is currently available only for modern commerce scopes.
	PartitionData *bool `json:"partitionData,omitempty"`

	// If requested, has the most recent execution history for the export.
	RunHistory *ExportExecutionListResult `json:"runHistory,omitempty"`

	// Has schedule information for the export.
	Schedule *ExportSchedule `json:"schedule,omitempty"`

	// READ-ONLY; If the export has an active schedule, provides an estimate of the next execution time.
	NextRunTimeEstimate *time.Time `json:"nextRunTimeEstimate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportProperties.
func (e ExportProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "definition", e.Definition)
	populate(objectMap, "deliveryInfo", e.DeliveryInfo)
	populate(objectMap, "format", e.Format)
	populateTimeRFC3339(objectMap, "nextRunTimeEstimate", e.NextRunTimeEstimate)
	populate(objectMap, "partitionData", e.PartitionData)
	populate(objectMap, "runHistory", e.RunHistory)
	populate(objectMap, "schedule", e.Schedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportProperties.
func (e *ExportProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "definition":
			err = unpopulate(val, &e.Definition)
			delete(rawMsg, key)
		case "deliveryInfo":
			err = unpopulate(val, &e.DeliveryInfo)
			delete(rawMsg, key)
		case "format":
			err = unpopulate(val, &e.Format)
			delete(rawMsg, key)
		case "nextRunTimeEstimate":
			err = unpopulateTimeRFC3339(val, &e.NextRunTimeEstimate)
			delete(rawMsg, key)
		case "partitionData":
			err = unpopulate(val, &e.PartitionData)
			delete(rawMsg, key)
		case "runHistory":
			err = unpopulate(val, &e.RunHistory)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, &e.Schedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExportRecurrencePeriod - The start and end date for recurrence schedule.
type ExportRecurrencePeriod struct {
	// REQUIRED; The start date of recurrence.
	From *time.Time `json:"from,omitempty"`

	// The end date of recurrence.
	To *time.Time `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportRecurrencePeriod.
func (e ExportRecurrencePeriod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "from", e.From)
	populateTimeRFC3339(objectMap, "to", e.To)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportRecurrencePeriod.
func (e *ExportRecurrencePeriod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "from":
			err = unpopulateTimeRFC3339(val, &e.From)
			delete(rawMsg, key)
		case "to":
			err = unpopulateTimeRFC3339(val, &e.To)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExportSchedule - The schedule associated with the export.
type ExportSchedule struct {
	// The schedule recurrence.
	Recurrence *RecurrenceType `json:"recurrence,omitempty"`

	// Has start and end date of the recurrence. The start date must be in future. If present, the end date must be greater than
	// start date.
	RecurrencePeriod *ExportRecurrencePeriod `json:"recurrencePeriod,omitempty"`

	// The status of the export's schedule. If 'Inactive', the export's schedule is paused.
	Status *StatusType `json:"status,omitempty"`
}

// ExportTimePeriod - The date range for data in the export. This should only be specified with timeFrame set to 'Custom'.
// The maximum date range is 3 months.
type ExportTimePeriod struct {
	// REQUIRED; The start date for export data.
	From *time.Time `json:"from,omitempty"`

	// REQUIRED; The end date for export data.
	To *time.Time `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportTimePeriod.
func (e ExportTimePeriod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "from", e.From)
	populateTimeRFC3339(objectMap, "to", e.To)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportTimePeriod.
func (e *ExportTimePeriod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "from":
			err = unpopulateTimeRFC3339(val, &e.From)
			delete(rawMsg, key)
		case "to":
			err = unpopulateTimeRFC3339(val, &e.To)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExportsClientCreateOrUpdateOptions contains the optional parameters for the ExportsClient.CreateOrUpdate method.
type ExportsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ExportsClientDeleteOptions contains the optional parameters for the ExportsClient.Delete method.
type ExportsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ExportsClientExecuteOptions contains the optional parameters for the ExportsClient.Execute method.
type ExportsClientExecuteOptions struct {
	// placeholder for future optional parameters
}

// ExportsClientGetExecutionHistoryOptions contains the optional parameters for the ExportsClient.GetExecutionHistory method.
type ExportsClientGetExecutionHistoryOptions struct {
	// placeholder for future optional parameters
}

// ExportsClientGetOptions contains the optional parameters for the ExportsClient.Get method.
type ExportsClientGetOptions struct {
	// May be used to expand the properties within an export. Currently only 'runHistory' is supported and will return information
	// for the last 10 executions of the export.
	Expand *string
}

// ExportsClientListOptions contains the optional parameters for the ExportsClient.List method.
type ExportsClientListOptions struct {
	// May be used to expand the properties within an export. Currently only 'runHistory' is supported and will return information
	// for the last execution of each export.
	Expand *string
}

// ForecastClientExternalCloudProviderUsageOptions contains the optional parameters for the ForecastClient.ExternalCloudProviderUsage
// method.
type ForecastClientExternalCloudProviderUsageOptions struct {
	// May be used to filter forecasts by properties/usageDate (Utc time), properties/chargeType or properties/grain. The filter
	// supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently
	// support 'ne', 'or', or 'not'.
	Filter *string
}

// ForecastClientUsageOptions contains the optional parameters for the ForecastClient.Usage method.
type ForecastClientUsageOptions struct {
	// May be used to filter forecasts by properties/usageDate (Utc time), properties/chargeType or properties/grain. The filter
	// supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently
	// support 'ne', 'or', or 'not'.
	Filter *string
}

// ForecastDataset - The definition of data present in the forecast.
type ForecastDataset struct {
	// Dictionary of aggregation expression to use in the forecast. The key of each item in the dictionary is the alias for the
	// aggregated column. forecast can have up to 2 aggregation clauses.
	Aggregation map[string]*QueryAggregation `json:"aggregation,omitempty"`

	// Has configuration information for the data in the export. The configuration will be ignored if aggregation and grouping
	// are provided.
	Configuration *QueryDatasetConfiguration `json:"configuration,omitempty"`

	// Has filter expression to use in the forecast.
	Filter *QueryFilter `json:"filter,omitempty"`

	// The granularity of rows in the forecast.
	Granularity *GranularityType `json:"granularity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ForecastDataset.
func (f ForecastDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregation", f.Aggregation)
	populate(objectMap, "configuration", f.Configuration)
	populate(objectMap, "filter", f.Filter)
	populate(objectMap, "granularity", f.Granularity)
	return json.Marshal(objectMap)
}

// ForecastDefinition - The definition of a forecast.
type ForecastDefinition struct {
	// REQUIRED; Has definition for data in this forecast.
	Dataset *ForecastDataset `json:"dataset,omitempty"`

	// REQUIRED; The time frame for pulling data for the forecast. If custom, then a specific time period must be provided.
	Timeframe *ForecastTimeframeType `json:"timeframe,omitempty"`

	// REQUIRED; The type of the forecast.
	Type *ForecastType `json:"type,omitempty"`

	// a boolean determining if actualCost will be included
	IncludeActualCost *bool `json:"includeActualCost,omitempty"`

	// a boolean determining if FreshPartialCost will be included
	IncludeFreshPartialCost *bool `json:"includeFreshPartialCost,omitempty"`

	// Has time period for pulling data for the forecast.
	TimePeriod *QueryTimePeriod `json:"timePeriod,omitempty"`
}

// GenerateDetailedCostReportClientBeginCreateOperationOptions contains the optional parameters for the GenerateDetailedCostReportClient.BeginCreateOperation
// method.
type GenerateDetailedCostReportClientBeginCreateOperationOptions struct {
	// placeholder for future optional parameters
}

// GenerateDetailedCostReportDefinition - The definition of a cost detailed report.
type GenerateDetailedCostReportDefinition struct {
	// Billing Period in YearMonth(e.g. 202008) format. Only for legacy enterprise customers can use this. Can only have one of
	// either timePeriod or invoiceId or billingPeriod parameters. If none provided
	// current month cost is provided.
	BillingPeriod *string `json:"billingPeriod,omitempty"`

	// Customer Id for Modern (Invoice Id and billing profile is also required for this).
	CustomerID *string `json:"customerId,omitempty"`

	// Invoice Id for PayAsYouGo customers and Modern billing profile scope. Can only have one of either timePeriod or invoiceId
	// or billingPeriod parameters. If none provided current month cost is provided.
	InvoiceID *string `json:"invoiceId,omitempty"`

	// The type of the detailed report. By default ActualCost is provided
	Metric *GenerateDetailedCostReportMetricType `json:"metric,omitempty"`

	// Has time period for pulling data for the cost detailed report. Can only have one of either timePeriod or invoiceId or billingPeriod
	// parameters. If none provided current month cost is provided.
	TimePeriod *GenerateDetailedCostReportTimePeriod `json:"timePeriod,omitempty"`
}

// GenerateDetailedCostReportErrorResponse - Error response indicates that the service is not able to process the incoming
// request. The reason is provided in the error message.
// Some Error responses:
// * 413 Request Entity Too Large - Request is throttled. The amount of data required to fulfill the request exceeds the maximum
// size permitted of 2Gb. Please utilize our Exports feature instead.
//
//
// * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after"
// header.
//
//
// * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After"
// header.
type GenerateDetailedCostReportErrorResponse struct {
	// The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`
}

// GenerateDetailedCostReportOperationResult - The result of the long running operation for cost detailed report.
type GenerateDetailedCostReportOperationResult struct {
	// The id of the long running operation.
	ID *string `json:"id,omitempty"`

	// The name of the long running operation.
	Name *string `json:"name,omitempty"`

	// The properties of the resource generated.
	Properties *DownloadURL `json:"properties,omitempty"`

	// The type of the long running operation.
	Type *string `json:"type,omitempty"`
}

// GenerateDetailedCostReportOperationResultsClientGetOptions contains the optional parameters for the GenerateDetailedCostReportOperationResultsClient.Get
// method.
type GenerateDetailedCostReportOperationResultsClientGetOptions struct {
	// placeholder for future optional parameters
}

// GenerateDetailedCostReportOperationStatusClientGetOptions contains the optional parameters for the GenerateDetailedCostReportOperationStatusClient.Get
// method.
type GenerateDetailedCostReportOperationStatusClientGetOptions struct {
	// placeholder for future optional parameters
}

// GenerateDetailedCostReportOperationStatuses - The status of the long running operation for cost detailed report.
type GenerateDetailedCostReportOperationStatuses struct {
	// The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`

	// The id of the long running operation.
	ID *string `json:"id,omitempty"`

	// The name of the long running operation.
	Name *string `json:"name,omitempty"`

	// The properties of the resource generated.
	Properties *DownloadURL `json:"properties,omitempty"`

	// The status of the long running operation.
	Status *Status `json:"status,omitempty"`

	// The type of the long running operation.
	Type *string `json:"type,omitempty"`
}

// GenerateDetailedCostReportTimePeriod - The start and end date for pulling data for the cost detailed report.
type GenerateDetailedCostReportTimePeriod struct {
	// REQUIRED; The end date to pull data to. example format 2020-03-15
	End *string `json:"end,omitempty"`

	// REQUIRED; The start date to pull data from. example format 2020-03-15
	Start *string `json:"start,omitempty"`
}

// KpiProperties - Each KPI must contain a 'type' and 'enabled' key.
type KpiProperties struct {
	// show the KPI in the UI?
	Enabled *bool `json:"enabled,omitempty"`

	// ID of resource related to metric (budget).
	ID *string `json:"id,omitempty"`

	// KPI type (Forecast, Budget).
	Type *KpiType `json:"type,omitempty"`
}

// Operation - A Cost management REST API operation.
type Operation struct {
	// The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// OperationDisplay - The object that represents the operation.
type OperationDisplay struct {
	// READ-ONLY; Operation type: Read, write, delete, etc.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Service provider: Microsoft.CostManagement.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource on which the operation is performed: Dimensions, Query.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - Result of listing cost management operations. It contains a list of operations and a URL link to
// get the next set of results.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of cost management operations supported by the Microsoft.CostManagement resource provider.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// PivotProperties - Each pivot must contain a 'type' and 'name'.
type PivotProperties struct {
	// Data field to show in view.
	Name *string `json:"name,omitempty"`

	// Data type to show in view.
	Type *PivotType `json:"type,omitempty"`
}

// ProxyResource - The Resource model definition.
type ProxyResource struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating
	// the latest version or not.
	ETag *string `json:"eTag,omitempty"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// QueryAggregation - The aggregation expression to be used in the query.
type QueryAggregation struct {
	// REQUIRED; The name of the aggregation function to use.
	Function *FunctionType `json:"function,omitempty"`

	// REQUIRED; The name of the column to aggregate.
	Name *string `json:"name,omitempty"`
}

// QueryClientUsageByExternalCloudProviderTypeOptions contains the optional parameters for the QueryClient.UsageByExternalCloudProviderType
// method.
type QueryClientUsageByExternalCloudProviderTypeOptions struct {
	// placeholder for future optional parameters
}

// QueryClientUsageOptions contains the optional parameters for the QueryClient.Usage method.
type QueryClientUsageOptions struct {
	// placeholder for future optional parameters
}

// QueryColumn properties
type QueryColumn struct {
	// The name of column.
	Name *string `json:"name,omitempty"`

	// The type of column.
	Type *string `json:"type,omitempty"`
}

// QueryComparisonExpression - The comparison expression to be used in the query.
type QueryComparisonExpression struct {
	// REQUIRED; The name of the column to use in comparison.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The operator to use for comparison.
	Operator *QueryOperatorType `json:"operator,omitempty"`

	// REQUIRED; Array of values to use for comparison
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryComparisonExpression.
func (q QueryComparisonExpression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", q.Name)
	populate(objectMap, "operator", q.Operator)
	populate(objectMap, "values", q.Values)
	return json.Marshal(objectMap)
}

// QueryDataset - The definition of data present in the query.
type QueryDataset struct {
	// Dictionary of aggregation expression to use in the query. The key of each item in the dictionary is the alias for the aggregated
	// column. Query can have up to 2 aggregation clauses.
	Aggregation map[string]*QueryAggregation `json:"aggregation,omitempty"`

	// Has configuration information for the data in the export. The configuration will be ignored if aggregation and grouping
	// are provided.
	Configuration *QueryDatasetConfiguration `json:"configuration,omitempty"`

	// The filter expression to use in the query. Please reference our Query API REST documentation for how to properly format
	// the filter.
	Filter *QueryFilter `json:"filter,omitempty"`

	// The granularity of rows in the query.
	Granularity *GranularityType `json:"granularity,omitempty"`

	// Array of group by expression to use in the query. Query can have up to 2 group by clauses.
	Grouping []*QueryGrouping `json:"grouping,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryDataset.
func (q QueryDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregation", q.Aggregation)
	populate(objectMap, "configuration", q.Configuration)
	populate(objectMap, "filter", q.Filter)
	populate(objectMap, "granularity", q.Granularity)
	populate(objectMap, "grouping", q.Grouping)
	return json.Marshal(objectMap)
}

// QueryDatasetConfiguration - The configuration of dataset in the query.
type QueryDatasetConfiguration struct {
	// Array of column names to be included in the query. Any valid query column name is allowed. If not provided, then query
	// includes all columns.
	Columns []*string `json:"columns,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryDatasetConfiguration.
func (q QueryDatasetConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", q.Columns)
	return json.Marshal(objectMap)
}

// QueryDefinition - The definition of a query.
type QueryDefinition struct {
	// REQUIRED; Has definition for data in this query.
	Dataset *QueryDataset `json:"dataset,omitempty"`

	// REQUIRED; The time frame for pulling data for the query. If custom, then a specific time period must be provided.
	Timeframe *TimeframeType `json:"timeframe,omitempty"`

	// REQUIRED; The type of the query.
	Type *ExportType `json:"type,omitempty"`

	// Has time period for pulling data for the query.
	TimePeriod *QueryTimePeriod `json:"timePeriod,omitempty"`
}

// QueryFilter - The filter expression to be used in the export.
type QueryFilter struct {
	// The logical "AND" expression. Must have at least 2 items.
	And []*QueryFilter `json:"and,omitempty"`

	// Has comparison expression for a dimension
	Dimension *QueryComparisonExpression `json:"dimension,omitempty"`

	// The logical "NOT" expression.
	Not *QueryFilter `json:"not,omitempty"`

	// The logical "OR" expression. Must have at least 2 items.
	Or []*QueryFilter `json:"or,omitempty"`

	// Has comparison expression for a tag
	Tag *QueryComparisonExpression `json:"tag,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryFilter.
func (q QueryFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "and", q.And)
	populate(objectMap, "dimension", q.Dimension)
	populate(objectMap, "not", q.Not)
	populate(objectMap, "or", q.Or)
	populate(objectMap, "tag", q.Tag)
	return json.Marshal(objectMap)
}

// QueryGrouping - The group by expression to be used in the query.
type QueryGrouping struct {
	// REQUIRED; The name of the column to group.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Has type of the column to group.
	Type *QueryColumnType `json:"type,omitempty"`
}

// QueryProperties - Query properties
type QueryProperties struct {
	// Array of columns
	Columns []*QueryColumn `json:"columns,omitempty"`

	// The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Array of rows
	Rows [][]interface{} `json:"rows,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryProperties.
func (q QueryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", q.Columns)
	populate(objectMap, "nextLink", q.NextLink)
	populate(objectMap, "rows", q.Rows)
	return json.Marshal(objectMap)
}

// QueryResult - Result of query. It contains all columns listed under groupings and aggregation.
type QueryResult struct {
	// Query properties
	Properties *QueryProperties `json:"properties,omitempty"`

	// READ-ONLY; ETag of the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Location of the resource.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; SKU of the resource.
	SKU *string `json:"sku,omitempty" azure:"ro"`

	// READ-ONLY; Resource tags.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryResult.
func (q QueryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", q.ETag)
	populate(objectMap, "id", q.ID)
	populate(objectMap, "location", q.Location)
	populate(objectMap, "name", q.Name)
	populate(objectMap, "properties", q.Properties)
	populate(objectMap, "sku", q.SKU)
	populate(objectMap, "tags", q.Tags)
	populate(objectMap, "type", q.Type)
	return json.Marshal(objectMap)
}

// QueryTimePeriod - The start and end date for pulling data for the query.
type QueryTimePeriod struct {
	// REQUIRED; The start date to pull data from.
	From *time.Time `json:"from,omitempty"`

	// REQUIRED; The end date to pull data to.
	To *time.Time `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryTimePeriod.
func (q QueryTimePeriod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "from", q.From)
	populateTimeRFC3339(objectMap, "to", q.To)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueryTimePeriod.
func (q *QueryTimePeriod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "from":
			err = unpopulateTimeRFC3339(val, &q.From)
			delete(rawMsg, key)
		case "to":
			err = unpopulateTimeRFC3339(val, &q.To)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ReportConfigAggregation - The aggregation expression to be used in the report.
type ReportConfigAggregation struct {
	// REQUIRED; The name of the aggregation function to use.
	Function *FunctionType `json:"function,omitempty"`

	// REQUIRED; The name of the column to aggregate.
	Name *string `json:"name,omitempty"`
}

// ReportConfigComparisonExpression - The comparison expression to be used in the report.
type ReportConfigComparisonExpression struct {
	// REQUIRED; The name of the column to use in comparison.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The operator to use for comparison.
	Operator *OperatorType `json:"operator,omitempty"`

	// REQUIRED; Array of values to use for comparison
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReportConfigComparisonExpression.
func (r ReportConfigComparisonExpression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", r.Name)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// ReportConfigDataset - The definition of data present in the report.
type ReportConfigDataset struct {
	// Dictionary of aggregation expression to use in the report. The key of each item in the dictionary is the alias for the
	// aggregated column. Report can have up to 2 aggregation clauses.
	Aggregation map[string]*ReportConfigAggregation `json:"aggregation,omitempty"`

	// Has configuration information for the data in the report. The configuration will be ignored if aggregation and grouping
	// are provided.
	Configuration *ReportConfigDatasetConfiguration `json:"configuration,omitempty"`

	// Has filter expression to use in the report.
	Filter *ReportConfigFilter `json:"filter,omitempty"`

	// The granularity of rows in the report.
	Granularity *ReportGranularityType `json:"granularity,omitempty"`

	// Array of group by expression to use in the report. Report can have up to 2 group by clauses.
	Grouping []*ReportConfigGrouping `json:"grouping,omitempty"`

	// Array of order by expression to use in the report.
	Sorting []*ReportConfigSorting `json:"sorting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReportConfigDataset.
func (r ReportConfigDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregation", r.Aggregation)
	populate(objectMap, "configuration", r.Configuration)
	populate(objectMap, "filter", r.Filter)
	populate(objectMap, "granularity", r.Granularity)
	populate(objectMap, "grouping", r.Grouping)
	populate(objectMap, "sorting", r.Sorting)
	return json.Marshal(objectMap)
}

// ReportConfigDatasetConfiguration - The configuration of dataset in the report.
type ReportConfigDatasetConfiguration struct {
	// Array of column names to be included in the report. Any valid report column name is allowed. If not provided, then report
	// includes all columns.
	Columns []*string `json:"columns,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReportConfigDatasetConfiguration.
func (r ReportConfigDatasetConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", r.Columns)
	return json.Marshal(objectMap)
}

// ReportConfigDefinition - The definition of a report config.
type ReportConfigDefinition struct {
	// REQUIRED; The time frame for pulling data for the report. If custom, then a specific time period must be provided.
	Timeframe *ReportTimeframeType `json:"timeframe,omitempty"`

	// REQUIRED; The type of the report. Usage represents actual usage, forecast represents forecasted data and UsageAndForecast
	// represents both usage and forecasted data. Actual usage and forecasted data can be
	// differentiated based on dates.
	Type *ReportType `json:"type,omitempty"`

	// Has definition for data in this report config.
	DataSet *ReportConfigDataset `json:"dataSet,omitempty"`

	// If true, report includes monetary commitment.
	IncludeMonetaryCommitment *bool `json:"includeMonetaryCommitment,omitempty"`

	// Has time period for pulling data for the report.
	TimePeriod *ReportConfigTimePeriod `json:"timePeriod,omitempty"`
}

// ReportConfigFilter - The filter expression to be used in the report.
type ReportConfigFilter struct {
	// The logical "AND" expression. Must have at least 2 items.
	And []*ReportConfigFilter `json:"and,omitempty"`

	// Has comparison expression for a dimension
	Dimensions *ReportConfigComparisonExpression `json:"dimensions,omitempty"`

	// The logical "NOT" expression.
	Not *ReportConfigFilter `json:"not,omitempty"`

	// The logical "OR" expression. Must have at least 2 items.
	Or []*ReportConfigFilter `json:"or,omitempty"`

	// Has comparison expression for a tag
	Tags *ReportConfigComparisonExpression `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReportConfigFilter.
func (r ReportConfigFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "and", r.And)
	populate(objectMap, "dimensions", r.Dimensions)
	populate(objectMap, "not", r.Not)
	populate(objectMap, "or", r.Or)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// ReportConfigGrouping - The group by expression to be used in the report.
type ReportConfigGrouping struct {
	// REQUIRED; The name of the column to group. This version supports subscription lowest possible grain.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Has type of the column to group.
	Type *ReportConfigColumnType `json:"type,omitempty"`
}

// ReportConfigSorting - The order by expression to be used in the report.
type ReportConfigSorting struct {
	// REQUIRED; The name of the column to sort.
	Name *string `json:"name,omitempty"`

	// Direction of sort.
	Direction *ReportConfigSortingDirection `json:"direction,omitempty"`
}

// ReportConfigTimePeriod - The start and end date for pulling data for the report.
type ReportConfigTimePeriod struct {
	// REQUIRED; The start date to pull data from.
	From *time.Time `json:"from,omitempty"`

	// REQUIRED; The end date to pull data to.
	To *time.Time `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReportConfigTimePeriod.
func (r ReportConfigTimePeriod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "from", r.From)
	populateTimeRFC3339(objectMap, "to", r.To)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReportConfigTimePeriod.
func (r *ReportConfigTimePeriod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "from":
			err = unpopulateTimeRFC3339(val, &r.From)
			delete(rawMsg, key)
		case "to":
			err = unpopulateTimeRFC3339(val, &r.To)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - The Resource model definition.
type Resource struct {
	// READ-ONLY; ETag of the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Location of the resource.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; SKU of the resource.
	SKU *string `json:"sku,omitempty" azure:"ro"`

	// READ-ONLY; Resource tags.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", r.ETag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// ResourceAutoGenerated - The Resource model definition.
type ResourceAutoGenerated struct {
	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource tags.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceAutoGenerated.
func (r ResourceAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// Status - The status of the long running operation.
type Status struct {
	// The status of the long running operation.
	Status *OperationStatusType `json:"status,omitempty"`
}

// View - States and configurations of Cost Analysis.
type View struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating
	// the latest version or not.
	ETag *string `json:"eTag,omitempty"`

	// The properties of the view.
	Properties *ViewProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ViewListResult - Result of listing views. It contains a list of available views.
type ViewListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of views.
	Value []*View `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ViewListResult.
func (v ViewListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// ViewProperties - The properties of the view.
type ViewProperties struct {
	// Show costs accumulated over time.
	Accumulated *AccumulatedType `json:"accumulated,omitempty"`

	// Chart type of the main view in Cost Analysis. Required.
	Chart *ChartType `json:"chart,omitempty"`

	// User input name of the view. Required.
	DisplayName *string `json:"displayName,omitempty"`

	// List of KPIs to show in Cost Analysis UI.
	Kpis []*KpiProperties `json:"kpis,omitempty"`

	// Metric to use when displaying costs.
	Metric *MetricType `json:"metric,omitempty"`

	// Configuration of 3 sub-views in the Cost Analysis UI.
	Pivots []*PivotProperties `json:"pivots,omitempty"`

	// Query body configuration. Required.
	Query *ReportConfigDefinition `json:"query,omitempty"`

	// Cost Management scope to save the view on. This includes 'subscriptions/{subscriptionId}' for subscription scope, 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}'
	// for resourceGroup
	// scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
	// for
	// Department scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
	// for EnrollmentAccount scope,
	// 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}' for BillingProfile
	// scope,
	// 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}' for InvoiceSection
	// scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
	// Management Group scope, '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
	// ExternalBillingAccount scope, and
	// '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for ExternalSubscription scope.
	Scope *string `json:"scope,omitempty"`

	// READ-ONLY; Date the user created this view.
	CreatedOn *time.Time `json:"createdOn,omitempty" azure:"ro"`

	// READ-ONLY; Currency of the current view.
	Currency *string `json:"currency,omitempty" azure:"ro"`

	// READ-ONLY; Date range of the current view.
	DateRange *string `json:"dateRange,omitempty" azure:"ro"`

	// READ-ONLY; Date when the user last modified this view.
	ModifiedOn *time.Time `json:"modifiedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ViewProperties.
func (v ViewProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accumulated", v.Accumulated)
	populate(objectMap, "chart", v.Chart)
	populateTimeRFC3339(objectMap, "createdOn", v.CreatedOn)
	populate(objectMap, "currency", v.Currency)
	populate(objectMap, "dateRange", v.DateRange)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "kpis", v.Kpis)
	populate(objectMap, "metric", v.Metric)
	populateTimeRFC3339(objectMap, "modifiedOn", v.ModifiedOn)
	populate(objectMap, "pivots", v.Pivots)
	populate(objectMap, "query", v.Query)
	populate(objectMap, "scope", v.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewProperties.
func (v *ViewProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accumulated":
			err = unpopulate(val, &v.Accumulated)
			delete(rawMsg, key)
		case "chart":
			err = unpopulate(val, &v.Chart)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &v.CreatedOn)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, &v.Currency)
			delete(rawMsg, key)
		case "dateRange":
			err = unpopulate(val, &v.DateRange)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &v.DisplayName)
			delete(rawMsg, key)
		case "kpis":
			err = unpopulate(val, &v.Kpis)
			delete(rawMsg, key)
		case "metric":
			err = unpopulate(val, &v.Metric)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, &v.ModifiedOn)
			delete(rawMsg, key)
		case "pivots":
			err = unpopulate(val, &v.Pivots)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &v.Query)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &v.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ViewsClientCreateOrUpdateByScopeOptions contains the optional parameters for the ViewsClient.CreateOrUpdateByScope method.
type ViewsClientCreateOrUpdateByScopeOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientCreateOrUpdateOptions contains the optional parameters for the ViewsClient.CreateOrUpdate method.
type ViewsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientDeleteByScopeOptions contains the optional parameters for the ViewsClient.DeleteByScope method.
type ViewsClientDeleteByScopeOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientDeleteOptions contains the optional parameters for the ViewsClient.Delete method.
type ViewsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientGetByScopeOptions contains the optional parameters for the ViewsClient.GetByScope method.
type ViewsClientGetByScopeOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientGetOptions contains the optional parameters for the ViewsClient.Get method.
type ViewsClientGetOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientListByScopeOptions contains the optional parameters for the ViewsClient.ListByScope method.
type ViewsClientListByScopeOptions struct {
	// placeholder for future optional parameters
}

// ViewsClientListOptions contains the optional parameters for the ViewsClient.List method.
type ViewsClientListOptions struct {
	// placeholder for future optional parameters
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
