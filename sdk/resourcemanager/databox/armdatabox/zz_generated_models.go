//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatabox

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// Implements the error and azcore.HTTPResponse interfaces.
type APIError struct {
	raw string
	// REQUIRED
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type APIError.
// The contents of the error text are not contractual and subject to change.
func (e APIError) Error() string {
	return e.raw
}

// AccountCredentialDetails - Credential details of the account.
type AccountCredentialDetails struct {
	// READ-ONLY; Connection string of the account endpoint to use the account as a storage endpoint on the device.
	AccountConnectionString *string `json:"accountConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; Name of the account.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; Type of the account.
	DataAccountType *DataAccountType `json:"dataAccountType,omitempty" azure:"ro"`

	// READ-ONLY; Per share level unencrypted access credentials.
	ShareCredentialDetails []*ShareCredentialDetails `json:"shareCredentialDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountCredentialDetails.
func (a AccountCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountConnectionString", a.AccountConnectionString)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "dataAccountType", a.DataAccountType)
	populate(objectMap, "shareCredentialDetails", a.ShareCredentialDetails)
	return json.Marshal(objectMap)
}

// AdditionalErrorInfo - Additional error info.
type AdditionalErrorInfo struct {
	// Additional error info.
	Info map[string]interface{} `json:"info,omitempty"`

	// Additional error type.
	Type *string `json:"type,omitempty"`
}

// AddressValidationOutput - Output of the address validation api.
type AddressValidationOutput struct {
	// READ-ONLY; The address validation properties.
	Properties *AddressValidationProperties `json:"properties,omitempty" azure:"ro"`
}

// AddressValidationProperties - The address validation output.
type AddressValidationProperties struct {
	ValidationInputResponse
	// READ-ONLY; List of alternate addresses.
	AlternateAddresses []*ShippingAddress `json:"alternateAddresses,omitempty" azure:"ro"`

	// READ-ONLY; The address validation status.
	ValidationStatus *AddressValidationStatus `json:"validationStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AddressValidationProperties.
func (a AddressValidationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ValidationInputResponse.marshalInternal(objectMap, ValidationInputDiscriminatorValidateAddress)
	populate(objectMap, "alternateAddresses", a.AlternateAddresses)
	populate(objectMap, "validationStatus", a.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddressValidationProperties.
func (a *AddressValidationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateAddresses":
			err = unpopulate(val, &a.AlternateAddresses)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, &a.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ValidationInputResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ApplianceNetworkConfiguration - The Network Adapter configuration of a DataBox.
type ApplianceNetworkConfiguration struct {
	// READ-ONLY; Mac Address.
	MacAddress *string `json:"macAddress,omitempty" azure:"ro"`

	// READ-ONLY; Name of the network.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// ArmBaseObject - Base class for all objects under resource.
type ArmBaseObject struct {
	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// AvailableSKURequest - The filters for showing the available skus.
type AvailableSKURequest struct {
	// REQUIRED; ISO country code. Country for hardware shipment. For codes check: https://en.wikipedia.org/wiki/ISO3166-1alpha-2#Officiallyassignedcode_elements
	Country *string `json:"country,omitempty"`

	// REQUIRED; Location for data transfer. For locations check: https://management.azure.com/subscriptions/SUBSCRIPTIONID/locations?api-version=2018-01-01
	Location *string `json:"location,omitempty"`

	// REQUIRED; Type of the transfer.
	TransferType *TransferType `json:"transferType,omitempty"`

	// Sku Names to filter for available skus
	SKUNames []*SKUName `json:"skuNames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableSKURequest.
func (a AvailableSKURequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "country", a.Country)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "skuNames", a.SKUNames)
	populate(objectMap, "transferType", a.TransferType)
	return json.Marshal(objectMap)
}

// AvailableSKUsResult - The available skus operation response.
type AvailableSKUsResult struct {
	// Link for the next set of skus.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of available skus.
	Value []*SKUInformation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableSKUsResult.
func (a AvailableSKUsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AzureFileFilterDetails - Filter details to transfer Azure files
type AzureFileFilterDetails struct {
	// List of full path of the files to be transferred.
	FilePathList []*string `json:"filePathList,omitempty"`

	// Prefix list of the Azure files to be transferred.
	FilePrefixList []*string `json:"filePrefixList,omitempty"`

	// List of file shares to be transferred.
	FileShareList []*string `json:"fileShareList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileFilterDetails.
func (a AzureFileFilterDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filePathList", a.FilePathList)
	populate(objectMap, "filePrefixList", a.FilePrefixList)
	populate(objectMap, "fileShareList", a.FileShareList)
	return json.Marshal(objectMap)
}

// BlobFilterDetails - Filter details to transfer Azure Blobs
type BlobFilterDetails struct {
	// List of full path of the blobs to be transferred.
	BlobPathList []*string `json:"blobPathList,omitempty"`

	// Prefix list of the Azure blobs to be transferred.
	BlobPrefixList []*string `json:"blobPrefixList,omitempty"`

	// List of blob containers to be transferred.
	ContainerList []*string `json:"containerList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobFilterDetails.
func (b BlobFilterDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobPathList", b.BlobPathList)
	populate(objectMap, "blobPrefixList", b.BlobPrefixList)
	populate(objectMap, "containerList", b.ContainerList)
	return json.Marshal(objectMap)
}

// CancellationReason - Reason for cancellation.
type CancellationReason struct {
	// REQUIRED; Reason for cancellation.
	Reason *string `json:"reason,omitempty"`
}

// CloudError - Cloud error.
type CloudError struct {
	// Cloud error code.
	Code *string `json:"code,omitempty"`

	// Cloud error message.
	Message *string `json:"message,omitempty"`

	// Cloud error target.
	Target *string `json:"target,omitempty"`

	// READ-ONLY; Cloud error additional info.
	AdditionalInfo []*AdditionalErrorInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; Cloud error details.
	Details []*CloudError `json:"details,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudError.
func (c CloudError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", c.AdditionalInfo)
	populate(objectMap, "code", c.Code)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// ContactDetails - Contact Details.
type ContactDetails struct {
	// REQUIRED; Contact name of the person.
	ContactName *string `json:"contactName,omitempty"`

	// REQUIRED; List of Email-ids to be notified about job progress.
	EmailList []*string `json:"emailList,omitempty"`

	// REQUIRED; Phone number of the contact person.
	Phone *string `json:"phone,omitempty"`

	// Mobile number of the contact person.
	Mobile *string `json:"mobile,omitempty"`

	// Notification preference for a job stage.
	NotificationPreference []*NotificationPreference `json:"notificationPreference,omitempty"`

	// Phone extension number of the contact person.
	PhoneExtension *string `json:"phoneExtension,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContactDetails.
func (c ContactDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contactName", c.ContactName)
	populate(objectMap, "emailList", c.EmailList)
	populate(objectMap, "mobile", c.Mobile)
	populate(objectMap, "notificationPreference", c.NotificationPreference)
	populate(objectMap, "phone", c.Phone)
	populate(objectMap, "phoneExtension", c.PhoneExtension)
	return json.Marshal(objectMap)
}

// CopyLogDetailsClassification provides polymorphic access to related types.
// Call the interface's GetCopyLogDetails() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CopyLogDetails, *DataBoxAccountCopyLogDetails, *DataBoxCustomerDiskCopyLogDetails, *DataBoxDiskCopyLogDetails, *DataBoxHeavyAccountCopyLogDetails
type CopyLogDetailsClassification interface {
	// GetCopyLogDetails returns the CopyLogDetails content of the underlying type.
	GetCopyLogDetails() *CopyLogDetails
}

// CopyLogDetails - Details for log generated during copy.
type CopyLogDetails struct {
	// REQUIRED; Indicates the type of job details.
	CopyLogDetailsType *ClassDiscriminator `json:"copyLogDetailsType,omitempty"`
}

// GetCopyLogDetails implements the CopyLogDetailsClassification interface for type CopyLogDetails.
func (c *CopyLogDetails) GetCopyLogDetails() *CopyLogDetails { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyLogDetails.
func (c *CopyLogDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CopyLogDetails) marshalInternal(objectMap map[string]interface{}, discValue ClassDiscriminator) {
	c.CopyLogDetailsType = &discValue
	objectMap["copyLogDetailsType"] = c.CopyLogDetailsType
}

func (c *CopyLogDetails) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyLogDetailsType":
			err = unpopulate(val, &c.CopyLogDetailsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyProgress - Copy progress.
type CopyProgress struct {
	// READ-ONLY; Id of the account where the data needs to be uploaded.
	AccountID *string `json:"accountId,omitempty" azure:"ro"`

	// READ-ONLY; To indicate bytes transferred.
	BytesProcessed *int64 `json:"bytesProcessed,omitempty" azure:"ro"`

	// READ-ONLY; Data Account Type.
	DataAccountType *DataAccountType `json:"dataAccountType,omitempty" azure:"ro"`

	// READ-ONLY; To indicate directories errored out in the job.
	DirectoriesErroredOut *int64 `json:"directoriesErroredOut,omitempty" azure:"ro"`

	// READ-ONLY; Number of files which could not be copied
	FilesErroredOut *int64 `json:"filesErroredOut,omitempty" azure:"ro"`

	// READ-ONLY; Number of files processed
	FilesProcessed *int64 `json:"filesProcessed,omitempty" azure:"ro"`

	// READ-ONLY; To indicate directories renamed
	InvalidDirectoriesProcessed *int64 `json:"invalidDirectoriesProcessed,omitempty" azure:"ro"`

	// READ-ONLY; Total amount of data not adhering to azure naming conventions which were processed by automatic renaming
	InvalidFileBytesUploaded *int64 `json:"invalidFileBytesUploaded,omitempty" azure:"ro"`

	// READ-ONLY; Number of files not adhering to azure naming conventions which were processed by automatic renaming
	InvalidFilesProcessed *int64 `json:"invalidFilesProcessed,omitempty" azure:"ro"`

	// READ-ONLY; To indicate if enumeration of data is in progress. Until this is true, the TotalBytesToProcess may not be valid.
	IsEnumerationInProgress *bool `json:"isEnumerationInProgress,omitempty" azure:"ro"`

	// READ-ONLY; Number of folders not adhering to azure naming conventions which were processed by automatic renaming
	RenamedContainerCount *int64 `json:"renamedContainerCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the storage account. This will be empty for data account types other than storage account.
	StorageAccountName *string `json:"storageAccountName,omitempty" azure:"ro"`

	// READ-ONLY; Total amount of data to be processed by the job.
	TotalBytesToProcess *int64 `json:"totalBytesToProcess,omitempty" azure:"ro"`

	// READ-ONLY; Total files to process
	TotalFilesToProcess *int64 `json:"totalFilesToProcess,omitempty" azure:"ro"`

	// READ-ONLY; Transfer type of data
	TransferType *TransferType `json:"transferType,omitempty" azure:"ro"`
}

// CreateJobValidations - It does all pre-job creation validations.
type CreateJobValidations struct {
	ValidationRequest
}

// MarshalJSON implements the json.Marshaller interface for type CreateJobValidations.
func (c CreateJobValidations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ValidationRequest.marshalInternal(objectMap, "JobCreationValidation")
	return json.Marshal(objectMap)
}

// CreateOrderLimitForSubscriptionValidationRequest - Request to validate create order limit for current subscription.
type CreateOrderLimitForSubscriptionValidationRequest struct {
	ValidationInputRequest
	// REQUIRED; Device type to be used for the job.
	DeviceType *SKUName `json:"deviceType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CreateOrderLimitForSubscriptionValidationRequest.
func (c CreateOrderLimitForSubscriptionValidationRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ValidationInputRequest.marshalInternal(objectMap, ValidationInputDiscriminatorValidateCreateOrderLimit)
	populate(objectMap, "deviceType", c.DeviceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateOrderLimitForSubscriptionValidationRequest.
func (c *CreateOrderLimitForSubscriptionValidationRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceType":
			err = unpopulate(val, &c.DeviceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ValidationInputRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CreateOrderLimitForSubscriptionValidationResponseProperties - Properties of create order limit for subscription validation response.
type CreateOrderLimitForSubscriptionValidationResponseProperties struct {
	ValidationInputResponse
	// READ-ONLY; Create order limit validation status.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CreateOrderLimitForSubscriptionValidationResponseProperties.
func (c CreateOrderLimitForSubscriptionValidationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ValidationInputResponse.marshalInternal(objectMap, ValidationInputDiscriminatorValidateCreateOrderLimit)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateOrderLimitForSubscriptionValidationResponseProperties.
func (c *CreateOrderLimitForSubscriptionValidationResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, &c.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ValidationInputResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CustomerDiskJobSecrets - The secrets related to customer disk job.
type CustomerDiskJobSecrets struct {
	JobSecrets
	// READ-ONLY; Carrier Account Number of the customer
	CarrierAccountNumber *string `json:"carrierAccountNumber,omitempty" azure:"ro"`

	// READ-ONLY; Contains the list of secrets object for that device.
	DiskSecrets []*DiskSecret `json:"diskSecrets,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomerDiskJobSecrets.
func (c CustomerDiskJobSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.JobSecrets.marshalInternal(objectMap, ClassDiscriminatorDataBoxCustomerDisk)
	populate(objectMap, "carrierAccountNumber", c.CarrierAccountNumber)
	populate(objectMap, "diskSecrets", c.DiskSecrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerDiskJobSecrets.
func (c *CustomerDiskJobSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "carrierAccountNumber":
			err = unpopulate(val, &c.CarrierAccountNumber)
			delete(rawMsg, key)
		case "diskSecrets":
			err = unpopulate(val, &c.DiskSecrets)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.JobSecrets.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataAccountDetailsClassification provides polymorphic access to related types.
// Call the interface's GetDataAccountDetails() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DataAccountDetails, *ManagedDiskDetails, *StorageAccountDetails
type DataAccountDetailsClassification interface {
	// GetDataAccountDetails returns the DataAccountDetails content of the underlying type.
	GetDataAccountDetails() *DataAccountDetails
}

// DataAccountDetails - Account details of the data to be transferred
type DataAccountDetails struct {
	// REQUIRED; Account Type of the data to be transferred.
	DataAccountType *DataAccountType `json:"dataAccountType,omitempty"`

	// Password for all the shares to be created on the device. Should not be passed for TransferType:ExportFromAzure jobs. If this is not passed, the service
	// will generate password itself. This will not be
	// returned in Get Call. Password Requirements : Password must be minimum of 12 and maximum of 64 characters. Password must have at least one uppercase
	// alphabet, one number and one special character.
	// Password cannot have the following characters : IilLoO0 Password can have only alphabets, numbers and these characters : @#-$%^!+=;:_()]+
	SharePassword *string `json:"sharePassword,omitempty"`
}

// GetDataAccountDetails implements the DataAccountDetailsClassification interface for type DataAccountDetails.
func (d *DataAccountDetails) GetDataAccountDetails() *DataAccountDetails { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DataAccountDetails.
func (d *DataAccountDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DataAccountDetails) marshalInternal(objectMap map[string]interface{}, discValue DataAccountType) {
	d.DataAccountType = &discValue
	objectMap["dataAccountType"] = d.DataAccountType
	populate(objectMap, "sharePassword", d.SharePassword)
}

func (d *DataAccountDetails) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataAccountType":
			err = unpopulate(val, &d.DataAccountType)
			delete(rawMsg, key)
		case "sharePassword":
			err = unpopulate(val, &d.SharePassword)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataBoxAccountCopyLogDetails - Copy log details for a storage account of a DataBox job
type DataBoxAccountCopyLogDetails struct {
	CopyLogDetails
	// READ-ONLY; Account name.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy logs.
	CopyLogLink *string `json:"copyLogLink,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy verbose logs. This will be set only when LogCollectionLevel is set to Verbose.
	CopyVerboseLogLink *string `json:"copyVerboseLogLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxAccountCopyLogDetails.
func (d DataBoxAccountCopyLogDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.CopyLogDetails.marshalInternal(objectMap, ClassDiscriminatorDataBox)
	populate(objectMap, "accountName", d.AccountName)
	populate(objectMap, "copyLogLink", d.CopyLogLink)
	populate(objectMap, "copyVerboseLogLink", d.CopyVerboseLogLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxAccountCopyLogDetails.
func (d *DataBoxAccountCopyLogDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &d.AccountName)
			delete(rawMsg, key)
		case "copyLogLink":
			err = unpopulate(val, &d.CopyLogLink)
			delete(rawMsg, key)
		case "copyVerboseLogLink":
			err = unpopulate(val, &d.CopyVerboseLogLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.CopyLogDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxCustomerDiskCopyLogDetails - Copy Log Details for customer disk
type DataBoxCustomerDiskCopyLogDetails struct {
	CopyLogDetails
	// READ-ONLY; Link for copy error logs.
	ErrorLogLink *string `json:"errorLogLink,omitempty" azure:"ro"`

	// READ-ONLY; Disk Serial Number.
	SerialNumber *string `json:"serialNumber,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy verbose logs.
	VerboseLogLink *string `json:"verboseLogLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxCustomerDiskCopyLogDetails.
func (d DataBoxCustomerDiskCopyLogDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.CopyLogDetails.marshalInternal(objectMap, ClassDiscriminatorDataBoxCustomerDisk)
	populate(objectMap, "errorLogLink", d.ErrorLogLink)
	populate(objectMap, "serialNumber", d.SerialNumber)
	populate(objectMap, "verboseLogLink", d.VerboseLogLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxCustomerDiskCopyLogDetails.
func (d *DataBoxCustomerDiskCopyLogDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorLogLink":
			err = unpopulate(val, &d.ErrorLogLink)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, &d.SerialNumber)
			delete(rawMsg, key)
		case "verboseLogLink":
			err = unpopulate(val, &d.VerboseLogLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.CopyLogDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxCustomerDiskCopyProgress - DataBox CustomerDisk Copy Progress
type DataBoxCustomerDiskCopyProgress struct {
	CopyProgress
	// READ-ONLY; The Status of the copy
	CopyStatus *CopyStatus `json:"copyStatus,omitempty" azure:"ro"`

	// READ-ONLY; Disk Serial Number.
	SerialNumber *string `json:"serialNumber,omitempty" azure:"ro"`
}

// DataBoxCustomerDiskJobDetails - Customer disk job details.
type DataBoxCustomerDiskJobDetails struct {
	JobDetails
	// REQUIRED; Return package shipping details.
	ReturnToCustomerPackageDetails *PackageCarrierDetails `json:"returnToCustomerPackageDetails,omitempty"`

	// Flag to indicate if disk manifest should be backed-up in the Storage Account.
	EnableManifestBackup *bool `json:"enableManifestBackup,omitempty"`

	// Contains the map of disk serial number to the disk details for import jobs.
	ImportDiskDetailsCollection map[string]*ImportDiskDetails `json:"importDiskDetailsCollection,omitempty"`

	// READ-ONLY; Copy progress per disk.
	CopyProgress []*DataBoxCustomerDiskCopyProgress `json:"copyProgress,omitempty" azure:"ro"`

	// READ-ONLY; Delivery package shipping details.
	DeliverToDcPackageDetails *PackageCarrierInfo `json:"deliverToDcPackageDetails,omitempty" azure:"ro"`

	// READ-ONLY; Contains the map of disk serial number to the disk details for export jobs.
	ExportDiskDetailsCollection map[string]*ExportDiskDetails `json:"exportDiskDetailsCollection,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxCustomerDiskJobDetails.
func (d DataBoxCustomerDiskJobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobDetails.marshalInternal(objectMap, ClassDiscriminatorDataBoxCustomerDisk)
	populate(objectMap, "copyProgress", d.CopyProgress)
	populate(objectMap, "deliverToDcPackageDetails", d.DeliverToDcPackageDetails)
	populate(objectMap, "enableManifestBackup", d.EnableManifestBackup)
	populate(objectMap, "exportDiskDetailsCollection", d.ExportDiskDetailsCollection)
	populate(objectMap, "importDiskDetailsCollection", d.ImportDiskDetailsCollection)
	populate(objectMap, "returnToCustomerPackageDetails", d.ReturnToCustomerPackageDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxCustomerDiskJobDetails.
func (d *DataBoxCustomerDiskJobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyProgress":
			err = unpopulate(val, &d.CopyProgress)
			delete(rawMsg, key)
		case "deliverToDcPackageDetails":
			err = unpopulate(val, &d.DeliverToDcPackageDetails)
			delete(rawMsg, key)
		case "enableManifestBackup":
			err = unpopulate(val, &d.EnableManifestBackup)
			delete(rawMsg, key)
		case "exportDiskDetailsCollection":
			err = unpopulate(val, &d.ExportDiskDetailsCollection)
			delete(rawMsg, key)
		case "importDiskDetailsCollection":
			err = unpopulate(val, &d.ImportDiskDetailsCollection)
			delete(rawMsg, key)
		case "returnToCustomerPackageDetails":
			err = unpopulate(val, &d.ReturnToCustomerPackageDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxDiskCopyLogDetails - Copy Log Details for a disk
type DataBoxDiskCopyLogDetails struct {
	CopyLogDetails
	// READ-ONLY; Disk Serial Number.
	DiskSerialNumber *string `json:"diskSerialNumber,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy error logs.
	ErrorLogLink *string `json:"errorLogLink,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy verbose logs.
	VerboseLogLink *string `json:"verboseLogLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxDiskCopyLogDetails.
func (d DataBoxDiskCopyLogDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.CopyLogDetails.marshalInternal(objectMap, ClassDiscriminatorDataBoxDisk)
	populate(objectMap, "diskSerialNumber", d.DiskSerialNumber)
	populate(objectMap, "errorLogLink", d.ErrorLogLink)
	populate(objectMap, "verboseLogLink", d.VerboseLogLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxDiskCopyLogDetails.
func (d *DataBoxDiskCopyLogDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskSerialNumber":
			err = unpopulate(val, &d.DiskSerialNumber)
			delete(rawMsg, key)
		case "errorLogLink":
			err = unpopulate(val, &d.ErrorLogLink)
			delete(rawMsg, key)
		case "verboseLogLink":
			err = unpopulate(val, &d.VerboseLogLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.CopyLogDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxDiskCopyProgress - DataBox Disk Copy Progress
type DataBoxDiskCopyProgress struct {
	// READ-ONLY; Bytes copied during the copy of disk.
	BytesCopied *int64 `json:"bytesCopied,omitempty" azure:"ro"`

	// READ-ONLY; Indicates the percentage completed for the copy of the disk.
	PercentComplete *int32 `json:"percentComplete,omitempty" azure:"ro"`

	// READ-ONLY; The serial number of the disk
	SerialNumber *string `json:"serialNumber,omitempty" azure:"ro"`

	// READ-ONLY; The Status of the copy
	Status *CopyStatus `json:"status,omitempty" azure:"ro"`
}

// DataBoxDiskJobDetails - DataBox Disk Job Details.
type DataBoxDiskJobDetails struct {
	JobDetails
	// User entered passkey for DataBox Disk job.
	Passkey *string `json:"passkey,omitempty"`

	// User preference on what size disks are needed for the job. The map is from the disk size in TB to the count. Eg. {2,5} means 5 disks of 2 TB size. Key
	// is string but will be checked against an int.
	PreferredDisks map[string]*int32 `json:"preferredDisks,omitempty"`

	// READ-ONLY; Copy progress per disk.
	CopyProgress []*DataBoxDiskCopyProgress `json:"copyProgress,omitempty" azure:"ro"`

	// READ-ONLY; Contains the map of disk serial number to the disk size being used for the job. Is returned only after the disks are shipped to the customer.
	DisksAndSizeDetails map[string]*int32 `json:"disksAndSizeDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxDiskJobDetails.
func (d DataBoxDiskJobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobDetails.marshalInternal(objectMap, ClassDiscriminatorDataBoxDisk)
	populate(objectMap, "copyProgress", d.CopyProgress)
	populate(objectMap, "disksAndSizeDetails", d.DisksAndSizeDetails)
	populate(objectMap, "passkey", d.Passkey)
	populate(objectMap, "preferredDisks", d.PreferredDisks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxDiskJobDetails.
func (d *DataBoxDiskJobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyProgress":
			err = unpopulate(val, &d.CopyProgress)
			delete(rawMsg, key)
		case "disksAndSizeDetails":
			err = unpopulate(val, &d.DisksAndSizeDetails)
			delete(rawMsg, key)
		case "passkey":
			err = unpopulate(val, &d.Passkey)
			delete(rawMsg, key)
		case "preferredDisks":
			err = unpopulate(val, &d.PreferredDisks)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxDiskJobSecrets - The secrets related to disk job.
type DataBoxDiskJobSecrets struct {
	JobSecrets
	// READ-ONLY; Contains the list of secrets object for that device.
	DiskSecrets []*DiskSecret `json:"diskSecrets,omitempty" azure:"ro"`

	// READ-ONLY; Whether passkey was provided by user.
	IsPasskeyUserDefined *bool `json:"isPasskeyUserDefined,omitempty" azure:"ro"`

	// READ-ONLY; PassKey for the disk Job.
	PassKey *string `json:"passKey,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxDiskJobSecrets.
func (d DataBoxDiskJobSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobSecrets.marshalInternal(objectMap, ClassDiscriminatorDataBoxDisk)
	populate(objectMap, "diskSecrets", d.DiskSecrets)
	populate(objectMap, "isPasskeyUserDefined", d.IsPasskeyUserDefined)
	populate(objectMap, "passKey", d.PassKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxDiskJobSecrets.
func (d *DataBoxDiskJobSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskSecrets":
			err = unpopulate(val, &d.DiskSecrets)
			delete(rawMsg, key)
		case "isPasskeyUserDefined":
			err = unpopulate(val, &d.IsPasskeyUserDefined)
			delete(rawMsg, key)
		case "passKey":
			err = unpopulate(val, &d.PassKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobSecrets.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxHeavyAccountCopyLogDetails - Copy log details for a storage account for Databox heavy
type DataBoxHeavyAccountCopyLogDetails struct {
	CopyLogDetails
	// READ-ONLY; Account name.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy logs.
	CopyLogLink []*string `json:"copyLogLink,omitempty" azure:"ro"`

	// READ-ONLY; Link for copy verbose logs. This will be set only when the LogCollectionLevel is set to verbose.
	CopyVerboseLogLink []*string `json:"copyVerboseLogLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxHeavyAccountCopyLogDetails.
func (d DataBoxHeavyAccountCopyLogDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.CopyLogDetails.marshalInternal(objectMap, ClassDiscriminatorDataBoxHeavy)
	populate(objectMap, "accountName", d.AccountName)
	populate(objectMap, "copyLogLink", d.CopyLogLink)
	populate(objectMap, "copyVerboseLogLink", d.CopyVerboseLogLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxHeavyAccountCopyLogDetails.
func (d *DataBoxHeavyAccountCopyLogDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &d.AccountName)
			delete(rawMsg, key)
		case "copyLogLink":
			err = unpopulate(val, &d.CopyLogLink)
			delete(rawMsg, key)
		case "copyVerboseLogLink":
			err = unpopulate(val, &d.CopyVerboseLogLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.CopyLogDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxHeavyJobDetails - Databox Heavy Device Job Details
type DataBoxHeavyJobDetails struct {
	JobDetails
	// Set Device password for unlocking Databox Heavy. Should not be passed for TransferType:ExportFromAzure jobs. If this is not passed, the service will
	// generate password itself. This will not be returned
	// in Get Call. Password Requirements : Password must be minimum of 12 and maximum of 64 characters. Password must have at least one uppercase alphabet,
	// one number and one special character. Password
	// cannot have the following characters : IilLoO0 Password can have only alphabets, numbers and these characters : @#-$%^!+=;:_()]+
	DevicePassword *string `json:"devicePassword,omitempty"`

	// READ-ONLY; Copy progress per account.
	CopyProgress []*CopyProgress `json:"copyProgress,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxHeavyJobDetails.
func (d DataBoxHeavyJobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobDetails.marshalInternal(objectMap, ClassDiscriminatorDataBoxHeavy)
	populate(objectMap, "copyProgress", d.CopyProgress)
	populate(objectMap, "devicePassword", d.DevicePassword)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxHeavyJobDetails.
func (d *DataBoxHeavyJobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyProgress":
			err = unpopulate(val, &d.CopyProgress)
			delete(rawMsg, key)
		case "devicePassword":
			err = unpopulate(val, &d.DevicePassword)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxHeavyJobSecrets - The secrets related to a databox heavy job.
type DataBoxHeavyJobSecrets struct {
	JobSecrets
	// READ-ONLY; Contains the list of secret objects for a databox heavy job.
	CabinetPodSecrets []*DataBoxHeavySecret `json:"cabinetPodSecrets,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxHeavyJobSecrets.
func (d DataBoxHeavyJobSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobSecrets.marshalInternal(objectMap, ClassDiscriminatorDataBoxHeavy)
	populate(objectMap, "cabinetPodSecrets", d.CabinetPodSecrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxHeavyJobSecrets.
func (d *DataBoxHeavyJobSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cabinetPodSecrets":
			err = unpopulate(val, &d.CabinetPodSecrets)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobSecrets.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxHeavySecret - The secrets related to a databox heavy.
type DataBoxHeavySecret struct {
	// READ-ONLY; Per account level access credentials.
	AccountCredentialDetails []*AccountCredentialDetails `json:"accountCredentialDetails,omitempty" azure:"ro"`

	// READ-ONLY; Password for out of the box experience on device.
	DevicePassword *string `json:"devicePassword,omitempty" azure:"ro"`

	// READ-ONLY; Serial number of the assigned device.
	DeviceSerialNumber *string `json:"deviceSerialNumber,omitempty" azure:"ro"`

	// READ-ONLY; The base 64 encoded public key to authenticate with the device
	EncodedValidationCertPubKey *string `json:"encodedValidationCertPubKey,omitempty" azure:"ro"`

	// READ-ONLY; Network configuration of the appliance.
	NetworkConfigurations []*ApplianceNetworkConfiguration `json:"networkConfigurations,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxHeavySecret.
func (d DataBoxHeavySecret) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountCredentialDetails", d.AccountCredentialDetails)
	populate(objectMap, "devicePassword", d.DevicePassword)
	populate(objectMap, "deviceSerialNumber", d.DeviceSerialNumber)
	populate(objectMap, "encodedValidationCertPubKey", d.EncodedValidationCertPubKey)
	populate(objectMap, "networkConfigurations", d.NetworkConfigurations)
	return json.Marshal(objectMap)
}

// DataBoxJobDetails - Databox Job Details
type DataBoxJobDetails struct {
	JobDetails
	// Set Device password for unlocking Databox. Should not be passed for TransferType:ExportFromAzure jobs. If this is not passed, the service will generate
	// password itself. This will not be returned in
	// Get Call. Password Requirements : Password must be minimum of 12 and maximum of 64 characters. Password must have at least one uppercase alphabet, one
	// number and one special character. Password cannot
	// have the following characters : IilLoO0 Password can have only alphabets, numbers and these characters : @#-$%^!+=;:_()]+
	DevicePassword *string `json:"devicePassword,omitempty"`

	// READ-ONLY; Copy progress per storage account.
	CopyProgress []*CopyProgress `json:"copyProgress,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxJobDetails.
func (d DataBoxJobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobDetails.marshalInternal(objectMap, ClassDiscriminatorDataBox)
	populate(objectMap, "copyProgress", d.CopyProgress)
	populate(objectMap, "devicePassword", d.DevicePassword)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxJobDetails.
func (d *DataBoxJobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyProgress":
			err = unpopulate(val, &d.CopyProgress)
			delete(rawMsg, key)
		case "devicePassword":
			err = unpopulate(val, &d.DevicePassword)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxManagementClientMitigateOptions contains the optional parameters for the DataBoxManagementClient.Mitigate method.
type DataBoxManagementClientMitigateOptions struct {
	// placeholder for future optional parameters
}

// DataBoxScheduleAvailabilityRequest - Request body to get the availability for scheduling data box orders orders.
type DataBoxScheduleAvailabilityRequest struct {
	ScheduleAvailabilityRequest
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxScheduleAvailabilityRequest.
func (d DataBoxScheduleAvailabilityRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ScheduleAvailabilityRequest.marshalInternal(objectMap, SKUNameDataBox)
	return json.Marshal(objectMap)
}

// DataBoxSecret - The secrets related to a DataBox.
type DataBoxSecret struct {
	// READ-ONLY; Per account level access credentials.
	AccountCredentialDetails []*AccountCredentialDetails `json:"accountCredentialDetails,omitempty" azure:"ro"`

	// READ-ONLY; Password for out of the box experience on device.
	DevicePassword *string `json:"devicePassword,omitempty" azure:"ro"`

	// READ-ONLY; Serial number of the assigned device.
	DeviceSerialNumber *string `json:"deviceSerialNumber,omitempty" azure:"ro"`

	// READ-ONLY; The base 64 encoded public key to authenticate with the device
	EncodedValidationCertPubKey *string `json:"encodedValidationCertPubKey,omitempty" azure:"ro"`

	// READ-ONLY; Network configuration of the appliance.
	NetworkConfigurations []*ApplianceNetworkConfiguration `json:"networkConfigurations,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxSecret.
func (d DataBoxSecret) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountCredentialDetails", d.AccountCredentialDetails)
	populate(objectMap, "devicePassword", d.DevicePassword)
	populate(objectMap, "deviceSerialNumber", d.DeviceSerialNumber)
	populate(objectMap, "encodedValidationCertPubKey", d.EncodedValidationCertPubKey)
	populate(objectMap, "networkConfigurations", d.NetworkConfigurations)
	return json.Marshal(objectMap)
}

// DataExportDetails - Details of the data to be used for exporting data from azure.
type DataExportDetails struct {
	// REQUIRED; Account details of the data to be transferred
	AccountDetails DataAccountDetailsClassification `json:"accountDetails,omitempty"`

	// REQUIRED; Configuration for the data transfer.
	TransferConfiguration *TransferConfiguration `json:"transferConfiguration,omitempty"`

	// Level of the logs to be collected.
	LogCollectionLevel *LogCollectionLevel `json:"logCollectionLevel,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataExportDetails.
func (d DataExportDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountDetails", d.AccountDetails)
	populate(objectMap, "logCollectionLevel", d.LogCollectionLevel)
	populate(objectMap, "transferConfiguration", d.TransferConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataExportDetails.
func (d *DataExportDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountDetails":
			d.AccountDetails, err = unmarshalDataAccountDetailsClassification(val)
			delete(rawMsg, key)
		case "logCollectionLevel":
			err = unpopulate(val, &d.LogCollectionLevel)
			delete(rawMsg, key)
		case "transferConfiguration":
			err = unpopulate(val, &d.TransferConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataImportDetails - Details of the data to be used for importing data to azure.
type DataImportDetails struct {
	// REQUIRED; Account details of the data to be transferred
	AccountDetails DataAccountDetailsClassification `json:"accountDetails,omitempty"`

	// Level of the logs to be collected.
	LogCollectionLevel *LogCollectionLevel `json:"logCollectionLevel,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataImportDetails.
func (d DataImportDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountDetails", d.AccountDetails)
	populate(objectMap, "logCollectionLevel", d.LogCollectionLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataImportDetails.
func (d *DataImportDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountDetails":
			d.AccountDetails, err = unmarshalDataAccountDetailsClassification(val)
			delete(rawMsg, key)
		case "logCollectionLevel":
			err = unpopulate(val, &d.LogCollectionLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataLocationToServiceLocationMap - Map of data location to service location
type DataLocationToServiceLocationMap struct {
	// READ-ONLY; Location of the data.
	DataLocation *string `json:"dataLocation,omitempty" azure:"ro"`

	// READ-ONLY; Location of the service.
	ServiceLocation *string `json:"serviceLocation,omitempty" azure:"ro"`
}

// DataTransferDetailsValidationRequest - Request to validate export and import data details.
type DataTransferDetailsValidationRequest struct {
	ValidationInputRequest
	// REQUIRED; Device type.
	DeviceType *SKUName `json:"deviceType,omitempty"`

	// REQUIRED; Type of the transfer.
	TransferType *TransferType `json:"transferType,omitempty"`

	// List of DataTransfer details to be used to export data from azure.
	DataExportDetails []*DataExportDetails `json:"dataExportDetails,omitempty"`

	// List of DataTransfer details to be used to import data to azure.
	DataImportDetails []*DataImportDetails `json:"dataImportDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataTransferDetailsValidationRequest.
func (d DataTransferDetailsValidationRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ValidationInputRequest.marshalInternal(objectMap, ValidationInputDiscriminatorValidateDataTransferDetails)
	populate(objectMap, "dataExportDetails", d.DataExportDetails)
	populate(objectMap, "dataImportDetails", d.DataImportDetails)
	populate(objectMap, "deviceType", d.DeviceType)
	populate(objectMap, "transferType", d.TransferType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataTransferDetailsValidationRequest.
func (d *DataTransferDetailsValidationRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataExportDetails":
			err = unpopulate(val, &d.DataExportDetails)
			delete(rawMsg, key)
		case "dataImportDetails":
			err = unpopulate(val, &d.DataImportDetails)
			delete(rawMsg, key)
		case "deviceType":
			err = unpopulate(val, &d.DeviceType)
			delete(rawMsg, key)
		case "transferType":
			err = unpopulate(val, &d.TransferType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ValidationInputRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataTransferDetailsValidationResponseProperties - Properties of data transfer details validation response.
type DataTransferDetailsValidationResponseProperties struct {
	ValidationInputResponse
	// READ-ONLY; Data transfer details validation status.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataTransferDetailsValidationResponseProperties.
func (d DataTransferDetailsValidationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ValidationInputResponse.marshalInternal(objectMap, ValidationInputDiscriminatorValidateDataTransferDetails)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataTransferDetailsValidationResponseProperties.
func (d *DataTransferDetailsValidationResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ValidationInputResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataboxJobSecrets - The secrets related to a databox job.
type DataboxJobSecrets struct {
	JobSecrets
	// Contains the list of secret objects for a job.
	PodSecrets []*DataBoxSecret `json:"podSecrets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataboxJobSecrets.
func (d DataboxJobSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.JobSecrets.marshalInternal(objectMap, ClassDiscriminatorDataBox)
	populate(objectMap, "podSecrets", d.PodSecrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataboxJobSecrets.
func (d *DataboxJobSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "podSecrets":
			err = unpopulate(val, &d.PodSecrets)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.JobSecrets.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatacenterAddressInstructionResponse - Datacenter instruction for given storage location.
type DatacenterAddressInstructionResponse struct {
	DatacenterAddressResponse
	// READ-ONLY; Data center communication instruction
	CommunicationInstruction *string `json:"communicationInstruction,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatacenterAddressInstructionResponse.
func (d DatacenterAddressInstructionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DatacenterAddressResponse.marshalInternal(objectMap, DatacenterAddressTypeDatacenterAddressInstruction)
	populate(objectMap, "communicationInstruction", d.CommunicationInstruction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatacenterAddressInstructionResponse.
func (d *DatacenterAddressInstructionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "communicationInstruction":
			err = unpopulate(val, &d.CommunicationInstruction)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DatacenterAddressResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatacenterAddressLocationResponse - Datacenter address for given storage location.
type DatacenterAddressLocationResponse struct {
	DatacenterAddressResponse
	// READ-ONLY; Special instruction for shipping
	AdditionalShippingInformation *string `json:"additionalShippingInformation,omitempty" azure:"ro"`

	// READ-ONLY; Address type
	AddressType *string `json:"addressType,omitempty" azure:"ro"`

	// READ-ONLY; City name
	City *string `json:"city,omitempty" azure:"ro"`

	// READ-ONLY; Company name
	Company *string `json:"company,omitempty" azure:"ro"`

	// READ-ONLY; Contact person name
	ContactPersonName *string `json:"contactPersonName,omitempty" azure:"ro"`

	// READ-ONLY; name of the country
	Country *string `json:"country,omitempty" azure:"ro"`

	// READ-ONLY; Phone number
	Phone *string `json:"phone,omitempty" azure:"ro"`

	// READ-ONLY; Phone extension
	PhoneExtension *string `json:"phoneExtension,omitempty" azure:"ro"`

	// READ-ONLY; name of the state
	State *string `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Street address line 1
	Street1 *string `json:"street1,omitempty" azure:"ro"`

	// READ-ONLY; Street address line 2
	Street2 *string `json:"street2,omitempty" azure:"ro"`

	// READ-ONLY; Street address line 3
	Street3 *string `json:"street3,omitempty" azure:"ro"`

	// READ-ONLY; Zip code
	Zip *string `json:"zip,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatacenterAddressLocationResponse.
func (d DatacenterAddressLocationResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DatacenterAddressResponse.marshalInternal(objectMap, DatacenterAddressTypeDatacenterAddressLocation)
	populate(objectMap, "additionalShippingInformation", d.AdditionalShippingInformation)
	populate(objectMap, "addressType", d.AddressType)
	populate(objectMap, "city", d.City)
	populate(objectMap, "company", d.Company)
	populate(objectMap, "contactPersonName", d.ContactPersonName)
	populate(objectMap, "country", d.Country)
	populate(objectMap, "phone", d.Phone)
	populate(objectMap, "phoneExtension", d.PhoneExtension)
	populate(objectMap, "state", d.State)
	populate(objectMap, "street1", d.Street1)
	populate(objectMap, "street2", d.Street2)
	populate(objectMap, "street3", d.Street3)
	populate(objectMap, "zip", d.Zip)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatacenterAddressLocationResponse.
func (d *DatacenterAddressLocationResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalShippingInformation":
			err = unpopulate(val, &d.AdditionalShippingInformation)
			delete(rawMsg, key)
		case "addressType":
			err = unpopulate(val, &d.AddressType)
			delete(rawMsg, key)
		case "city":
			err = unpopulate(val, &d.City)
			delete(rawMsg, key)
		case "company":
			err = unpopulate(val, &d.Company)
			delete(rawMsg, key)
		case "contactPersonName":
			err = unpopulate(val, &d.ContactPersonName)
			delete(rawMsg, key)
		case "country":
			err = unpopulate(val, &d.Country)
			delete(rawMsg, key)
		case "phone":
			err = unpopulate(val, &d.Phone)
			delete(rawMsg, key)
		case "phoneExtension":
			err = unpopulate(val, &d.PhoneExtension)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &d.State)
			delete(rawMsg, key)
		case "street1":
			err = unpopulate(val, &d.Street1)
			delete(rawMsg, key)
		case "street2":
			err = unpopulate(val, &d.Street2)
			delete(rawMsg, key)
		case "street3":
			err = unpopulate(val, &d.Street3)
			delete(rawMsg, key)
		case "zip":
			err = unpopulate(val, &d.Zip)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DatacenterAddressResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatacenterAddressRequest - Request body to get the datacenter address.
type DatacenterAddressRequest struct {
	// REQUIRED; Sku Name for which the data center address requested.
	SKUName *SKUName `json:"skuName,omitempty"`

	// REQUIRED; Storage location. For locations check: https://management.azure.com/subscriptions/SUBSCRIPTIONID/locations?api-version=2018-01-01
	StorageLocation *string `json:"storageLocation,omitempty"`
}

// DatacenterAddressResponseClassification provides polymorphic access to related types.
// Call the interface's GetDatacenterAddressResponse() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DatacenterAddressInstructionResponse, *DatacenterAddressLocationResponse, *DatacenterAddressResponse
type DatacenterAddressResponseClassification interface {
	// GetDatacenterAddressResponse returns the DatacenterAddressResponse content of the underlying type.
	GetDatacenterAddressResponse() *DatacenterAddressResponse
}

// DatacenterAddressResponse - Datacenter address for given storage location.
type DatacenterAddressResponse struct {
	// REQUIRED; Data center address type
	DatacenterAddressType *DatacenterAddressType `json:"datacenterAddressType,omitempty"`

	// READ-ONLY; Azure Location where the Data Center serves primarily.
	DataCenterAzureLocation *string `json:"dataCenterAzureLocation,omitempty" azure:"ro"`

	// READ-ONLY; List of supported carriers for return shipment.
	SupportedCarriersForReturnShipment []*string `json:"supportedCarriersForReturnShipment,omitempty" azure:"ro"`
}

// GetDatacenterAddressResponse implements the DatacenterAddressResponseClassification interface for type DatacenterAddressResponse.
func (d *DatacenterAddressResponse) GetDatacenterAddressResponse() *DatacenterAddressResponse {
	return d
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatacenterAddressResponse.
func (d *DatacenterAddressResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DatacenterAddressResponse) marshalInternal(objectMap map[string]interface{}, discValue DatacenterAddressType) {
	populate(objectMap, "dataCenterAzureLocation", d.DataCenterAzureLocation)
	d.DatacenterAddressType = &discValue
	objectMap["datacenterAddressType"] = d.DatacenterAddressType
	populate(objectMap, "supportedCarriersForReturnShipment", d.SupportedCarriersForReturnShipment)
}

func (d *DatacenterAddressResponse) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataCenterAzureLocation":
			err = unpopulate(val, &d.DataCenterAzureLocation)
			delete(rawMsg, key)
		case "datacenterAddressType":
			err = unpopulate(val, &d.DatacenterAddressType)
			delete(rawMsg, key)
		case "supportedCarriersForReturnShipment":
			err = unpopulate(val, &d.SupportedCarriersForReturnShipment)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DcAccessSecurityCode - Dc access security code
type DcAccessSecurityCode struct {
	// Forward Dc access security code.
	ForwardDCAccessCode *string `json:"forwardDCAccessCode,omitempty"`

	// Reverse Dc access security code.
	ReverseDCAccessCode *string `json:"reverseDCAccessCode,omitempty"`
}

type Details struct {
	// REQUIRED
	Code *string `json:"code,omitempty"`

	// REQUIRED
	Message *string `json:"message,omitempty"`
}

// DiskScheduleAvailabilityRequest - Request body to get the availability for scheduling disk orders.
type DiskScheduleAvailabilityRequest struct {
	ScheduleAvailabilityRequest
	// REQUIRED; The expected size of the data, which needs to be transferred in this job, in terabytes.
	ExpectedDataSizeInTeraBytes *int32 `json:"expectedDataSizeInTeraBytes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskScheduleAvailabilityRequest.
func (d DiskScheduleAvailabilityRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ScheduleAvailabilityRequest.marshalInternal(objectMap, SKUNameDataBoxDisk)
	populate(objectMap, "expectedDataSizeInTeraBytes", d.ExpectedDataSizeInTeraBytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskScheduleAvailabilityRequest.
func (d *DiskScheduleAvailabilityRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expectedDataSizeInTeraBytes":
			err = unpopulate(val, &d.ExpectedDataSizeInTeraBytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ScheduleAvailabilityRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DiskSecret - Contains all the secrets of a Disk.
type DiskSecret struct {
	// READ-ONLY; Bit Locker key of the disk which can be used to unlock the disk to copy data.
	BitLockerKey *string `json:"bitLockerKey,omitempty" azure:"ro"`

	// READ-ONLY; Serial number of the assigned disk.
	DiskSerialNumber *string `json:"diskSerialNumber,omitempty" azure:"ro"`
}

// EncryptionPreferences - Preferences related to the Encryption.
type EncryptionPreferences struct {
	// Defines secondary layer of software-based encryption enablement.
	DoubleEncryption *DoubleEncryption `json:"doubleEncryption,omitempty"`
}

type ErrorDetail struct {
	// REQUIRED
	Code *string `json:"code,omitempty"`

	// REQUIRED
	Message *string    `json:"message,omitempty"`
	Details []*Details `json:"details,omitempty"`
	Target  *string    `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ExportDiskDetails - Export disk details
type ExportDiskDetails struct {
	// READ-ONLY; Path to backed up manifest, only returned if enableManifestBackup is true.
	BackupManifestCloudPath *string `json:"backupManifestCloudPath,omitempty" azure:"ro"`

	// READ-ONLY; The relative path of the manifest file on the disk.
	ManifestFile *string `json:"manifestFile,omitempty" azure:"ro"`

	// READ-ONLY; The Base16-encoded MD5 hash of the manifest file on the disk.
	ManifestHash *string `json:"manifestHash,omitempty" azure:"ro"`
}

// FilterFileDetails - Details of the filter files to be used for data transfer.
type FilterFileDetails struct {
	// REQUIRED; Path of the file that contains the details of all items to transfer.
	FilterFilePath *string `json:"filterFilePath,omitempty"`

	// REQUIRED; Type of the filter file.
	FilterFileType *FilterFileType `json:"filterFileType,omitempty"`
}

// HeavyScheduleAvailabilityRequest - Request body to get the availability for scheduling heavy orders.
type HeavyScheduleAvailabilityRequest struct {
	ScheduleAvailabilityRequest
}

// MarshalJSON implements the json.Marshaller interface for type HeavyScheduleAvailabilityRequest.
func (h HeavyScheduleAvailabilityRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.ScheduleAvailabilityRequest.marshalInternal(objectMap, SKUNameDataBoxHeavy)
	return json.Marshal(objectMap)
}

// IdentityProperties - Managed identity properties.
type IdentityProperties struct {
	// Managed service identity type.
	Type *string `json:"type,omitempty"`

	// User assigned identity properties.
	UserAssigned *UserAssignedProperties `json:"userAssigned,omitempty"`
}

// ImportDiskDetails - Import disk details
type ImportDiskDetails struct {
	// REQUIRED; BitLocker key used to encrypt the disk.
	BitLockerKey *string `json:"bitLockerKey,omitempty"`

	// REQUIRED; The relative path of the manifest file on the disk.
	ManifestFile *string `json:"manifestFile,omitempty"`

	// REQUIRED; The Base16-encoded MD5 hash of the manifest file on the disk.
	ManifestHash *string `json:"manifestHash,omitempty"`

	// READ-ONLY; Path to backed up manifest, only returned if enableManifestBackup is true.
	BackupManifestCloudPath *string `json:"backupManifestCloudPath,omitempty" azure:"ro"`
}

// JobDeliveryInfo - Additional delivery info.
type JobDeliveryInfo struct {
	// Scheduled date time.
	ScheduledDateTime *time.Time `json:"scheduledDateTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobDeliveryInfo.
func (j JobDeliveryInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "scheduledDateTime", j.ScheduledDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobDeliveryInfo.
func (j *JobDeliveryInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scheduledDateTime":
			err = unpopulateTimeRFC3339(val, &j.ScheduledDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobDetailsClassification provides polymorphic access to related types.
// Call the interface's GetJobDetails() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DataBoxCustomerDiskJobDetails, *DataBoxDiskJobDetails, *DataBoxHeavyJobDetails, *DataBoxJobDetails, *JobDetails
type JobDetailsClassification interface {
	// GetJobDetails returns the JobDetails content of the underlying type.
	GetJobDetails() *JobDetails
}

// JobDetails - Job details.
type JobDetails struct {
	// REQUIRED; Contact details for notification and shipping.
	ContactDetails *ContactDetails `json:"contactDetails,omitempty"`

	// REQUIRED; Indicates the type of job details.
	JobDetailsType *ClassDiscriminator `json:"jobDetailsType,omitempty"`

	// Details of the data to be exported from azure.
	DataExportDetails []*DataExportDetails `json:"dataExportDetails,omitempty"`

	// Details of the data to be imported into azure.
	DataImportDetails []*DataImportDetails `json:"dataImportDetails,omitempty"`

	// The expected size of the data, which needs to be transferred in this job, in terabytes.
	ExpectedDataSizeInTeraBytes *int32 `json:"expectedDataSizeInTeraBytes,omitempty"`

	// Details about which key encryption type is being used.
	KeyEncryptionKey *KeyEncryptionKey `json:"keyEncryptionKey,omitempty"`

	// Preferences for the order.
	Preferences *Preferences `json:"preferences,omitempty"`

	// Shipping address of the customer.
	ShippingAddress *ShippingAddress `json:"shippingAddress,omitempty"`

	// READ-ONLY; Available actions on the job.
	Actions []*CustomerResolutionCode `json:"actions,omitempty" azure:"ro"`

	// READ-ONLY; Shared access key to download the chain of custody logs
	ChainOfCustodySasKey *string `json:"chainOfCustodySasKey,omitempty" azure:"ro"`

	// READ-ONLY; List of copy log details.
	CopyLogDetails []CopyLogDetailsClassification `json:"copyLogDetails,omitempty" azure:"ro"`

	// READ-ONLY; DataCenter code.
	DataCenterCode *DataCenterCode `json:"dataCenterCode,omitempty" azure:"ro"`

	// READ-ONLY; Datacenter address to ship to, for the given sku and storage location.
	DatacenterAddress DatacenterAddressResponseClassification `json:"datacenterAddress,omitempty" azure:"ro"`

	// READ-ONLY; Delivery package shipping details.
	DeliveryPackage *PackageShippingDetails `json:"deliveryPackage,omitempty" azure:"ro"`

	// READ-ONLY; List of stages that run in the job.
	JobStages []*JobStages `json:"jobStages,omitempty" azure:"ro"`

	// READ-ONLY; Last mitigation action performed on the job.
	LastMitigationActionOnJob *LastMitigationActionOnJob `json:"lastMitigationActionOnJob,omitempty" azure:"ro"`

	// READ-ONLY; Return package shipping details.
	ReturnPackage *PackageShippingDetails `json:"returnPackage,omitempty" azure:"ro"`

	// READ-ONLY; Shared access key to download the return shipment label
	ReverseShipmentLabelSasKey *string `json:"reverseShipmentLabelSasKey,omitempty" azure:"ro"`
}

// GetJobDetails implements the JobDetailsClassification interface for type JobDetails.
func (j *JobDetails) GetJobDetails() *JobDetails { return j }

// UnmarshalJSON implements the json.Unmarshaller interface for type JobDetails.
func (j *JobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return j.unmarshalInternal(rawMsg)
}

func (j JobDetails) marshalInternal(objectMap map[string]interface{}, discValue ClassDiscriminator) {
	populate(objectMap, "actions", j.Actions)
	populate(objectMap, "chainOfCustodySasKey", j.ChainOfCustodySasKey)
	populate(objectMap, "contactDetails", j.ContactDetails)
	populate(objectMap, "copyLogDetails", j.CopyLogDetails)
	populate(objectMap, "dataCenterCode", j.DataCenterCode)
	populate(objectMap, "dataExportDetails", j.DataExportDetails)
	populate(objectMap, "dataImportDetails", j.DataImportDetails)
	populate(objectMap, "datacenterAddress", j.DatacenterAddress)
	populate(objectMap, "deliveryPackage", j.DeliveryPackage)
	populate(objectMap, "expectedDataSizeInTeraBytes", j.ExpectedDataSizeInTeraBytes)
	j.JobDetailsType = &discValue
	objectMap["jobDetailsType"] = j.JobDetailsType
	populate(objectMap, "jobStages", j.JobStages)
	populate(objectMap, "keyEncryptionKey", j.KeyEncryptionKey)
	populate(objectMap, "lastMitigationActionOnJob", j.LastMitigationActionOnJob)
	populate(objectMap, "preferences", j.Preferences)
	populate(objectMap, "returnPackage", j.ReturnPackage)
	populate(objectMap, "reverseShipmentLabelSasKey", j.ReverseShipmentLabelSasKey)
	populate(objectMap, "shippingAddress", j.ShippingAddress)
}

func (j *JobDetails) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			err = unpopulate(val, &j.Actions)
			delete(rawMsg, key)
		case "chainOfCustodySasKey":
			err = unpopulate(val, &j.ChainOfCustodySasKey)
			delete(rawMsg, key)
		case "contactDetails":
			err = unpopulate(val, &j.ContactDetails)
			delete(rawMsg, key)
		case "copyLogDetails":
			j.CopyLogDetails, err = unmarshalCopyLogDetailsClassificationArray(val)
			delete(rawMsg, key)
		case "dataCenterCode":
			err = unpopulate(val, &j.DataCenterCode)
			delete(rawMsg, key)
		case "dataExportDetails":
			err = unpopulate(val, &j.DataExportDetails)
			delete(rawMsg, key)
		case "dataImportDetails":
			err = unpopulate(val, &j.DataImportDetails)
			delete(rawMsg, key)
		case "datacenterAddress":
			j.DatacenterAddress, err = unmarshalDatacenterAddressResponseClassification(val)
			delete(rawMsg, key)
		case "deliveryPackage":
			err = unpopulate(val, &j.DeliveryPackage)
			delete(rawMsg, key)
		case "expectedDataSizeInTeraBytes":
			err = unpopulate(val, &j.ExpectedDataSizeInTeraBytes)
			delete(rawMsg, key)
		case "jobDetailsType":
			err = unpopulate(val, &j.JobDetailsType)
			delete(rawMsg, key)
		case "jobStages":
			err = unpopulate(val, &j.JobStages)
			delete(rawMsg, key)
		case "keyEncryptionKey":
			err = unpopulate(val, &j.KeyEncryptionKey)
			delete(rawMsg, key)
		case "lastMitigationActionOnJob":
			err = unpopulate(val, &j.LastMitigationActionOnJob)
			delete(rawMsg, key)
		case "preferences":
			err = unpopulate(val, &j.Preferences)
			delete(rawMsg, key)
		case "returnPackage":
			err = unpopulate(val, &j.ReturnPackage)
			delete(rawMsg, key)
		case "reverseShipmentLabelSasKey":
			err = unpopulate(val, &j.ReverseShipmentLabelSasKey)
			delete(rawMsg, key)
		case "shippingAddress":
			err = unpopulate(val, &j.ShippingAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobProperties - Job Properties
type JobProperties struct {
	// REQUIRED; Type of the data transfer.
	TransferType *TransferType `json:"transferType,omitempty"`

	// Delivery Info of Job.
	DeliveryInfo *JobDeliveryInfo `json:"deliveryInfo,omitempty"`

	// Delivery type of Job.
	DeliveryType *JobDeliveryType `json:"deliveryType,omitempty"`

	// Details of a job run. This field will only be sent for expand details filter.
	Details JobDetailsClassification `json:"details,omitempty"`

	// READ-ONLY; Reason for cancellation.
	CancellationReason *string `json:"cancellationReason,omitempty" azure:"ro"`

	// READ-ONLY; Top level error for the job.
	Error *CloudError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Describes whether the job is cancellable or not.
	IsCancellable *bool `json:"isCancellable,omitempty" azure:"ro"`

	// READ-ONLY; Flag to indicate cancellation of scheduled job.
	IsCancellableWithoutFee *bool `json:"isCancellableWithoutFee,omitempty" azure:"ro"`

	// READ-ONLY; Describes whether the job is deletable or not.
	IsDeletable *bool `json:"isDeletable,omitempty" azure:"ro"`

	// READ-ONLY; Is Prepare To Ship Enabled on this job
	IsPrepareToShipEnabled *bool `json:"isPrepareToShipEnabled,omitempty" azure:"ro"`

	// READ-ONLY; Describes whether the shipping address is editable or not.
	IsShippingAddressEditable *bool `json:"isShippingAddressEditable,omitempty" azure:"ro"`

	// READ-ONLY; Time at which the job was started in UTC ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; Name of the stage which is in progress.
	Status *StageName `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cancellationReason", j.CancellationReason)
	populate(objectMap, "deliveryInfo", j.DeliveryInfo)
	populate(objectMap, "deliveryType", j.DeliveryType)
	populate(objectMap, "details", j.Details)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "isCancellable", j.IsCancellable)
	populate(objectMap, "isCancellableWithoutFee", j.IsCancellableWithoutFee)
	populate(objectMap, "isDeletable", j.IsDeletable)
	populate(objectMap, "isPrepareToShipEnabled", j.IsPrepareToShipEnabled)
	populate(objectMap, "isShippingAddressEditable", j.IsShippingAddressEditable)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "transferType", j.TransferType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cancellationReason":
			err = unpopulate(val, &j.CancellationReason)
			delete(rawMsg, key)
		case "deliveryInfo":
			err = unpopulate(val, &j.DeliveryInfo)
			delete(rawMsg, key)
		case "deliveryType":
			err = unpopulate(val, &j.DeliveryType)
			delete(rawMsg, key)
		case "details":
			j.Details, err = unmarshalJobDetailsClassification(val)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "isCancellable":
			err = unpopulate(val, &j.IsCancellable)
			delete(rawMsg, key)
		case "isCancellableWithoutFee":
			err = unpopulate(val, &j.IsCancellableWithoutFee)
			delete(rawMsg, key)
		case "isDeletable":
			err = unpopulate(val, &j.IsDeletable)
			delete(rawMsg, key)
		case "isPrepareToShipEnabled":
			err = unpopulate(val, &j.IsPrepareToShipEnabled)
			delete(rawMsg, key)
		case "isShippingAddressEditable":
			err = unpopulate(val, &j.IsShippingAddressEditable)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		case "transferType":
			err = unpopulate(val, &j.TransferType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobResource - Job Resource.
type JobResource struct {
	Resource
	// REQUIRED; Properties of a job.
	Properties *JobProperties `json:"properties,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResource.
func (j JobResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.Resource.marshalInternal(objectMap)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// JobResourceList - Job Resource Collection
type JobResourceList struct {
	// Link for the next set of job resources.
	NextLink *string `json:"nextLink,omitempty"`

	// List of job resources.
	Value []*JobResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceList.
func (j JobResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// JobResourceUpdateParameter - The JobResourceUpdateParameter.
type JobResourceUpdateParameter struct {
	// Msi identity of the resource
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// Properties of a job to be updated.
	Properties *UpdateJobProperties `json:"properties,omitempty"`

	// The list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups).
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceUpdateParameter.
func (j JobResourceUpdateParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", j.Identity)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "tags", j.Tags)
	return json.Marshal(objectMap)
}

// JobSecretsClassification provides polymorphic access to related types.
// Call the interface's GetJobSecrets() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CustomerDiskJobSecrets, *DataBoxDiskJobSecrets, *DataBoxHeavyJobSecrets, *DataboxJobSecrets, *JobSecrets
type JobSecretsClassification interface {
	// GetJobSecrets returns the JobSecrets content of the underlying type.
	GetJobSecrets() *JobSecrets
}

// JobSecrets - The base class for the secrets
type JobSecrets struct {
	// REQUIRED; Used to indicate what type of job secrets object.
	JobSecretsType *ClassDiscriminator `json:"jobSecretsType,omitempty"`

	// READ-ONLY; Dc Access Security Code for Customer Managed Shipping
	DcAccessSecurityCode *DcAccessSecurityCode `json:"dcAccessSecurityCode,omitempty" azure:"ro"`

	// READ-ONLY; Error while fetching the secrets.
	Error *CloudError `json:"error,omitempty" azure:"ro"`
}

// GetJobSecrets implements the JobSecretsClassification interface for type JobSecrets.
func (j *JobSecrets) GetJobSecrets() *JobSecrets { return j }

// UnmarshalJSON implements the json.Unmarshaller interface for type JobSecrets.
func (j *JobSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return j.unmarshalInternal(rawMsg)
}

func (j JobSecrets) marshalInternal(objectMap map[string]interface{}, discValue ClassDiscriminator) {
	populate(objectMap, "dcAccessSecurityCode", j.DcAccessSecurityCode)
	populate(objectMap, "error", j.Error)
	j.JobSecretsType = &discValue
	objectMap["jobSecretsType"] = j.JobSecretsType
}

func (j *JobSecrets) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dcAccessSecurityCode":
			err = unpopulate(val, &j.DcAccessSecurityCode)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "jobSecretsType":
			err = unpopulate(val, &j.JobSecretsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobStages - Job stages.
type JobStages struct {
	// READ-ONLY; Display name of the job stage.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; Job Stage Details
	JobStageDetails map[string]interface{} `json:"jobStageDetails,omitempty" azure:"ro"`

	// READ-ONLY; Name of the job stage.
	StageName *StageName `json:"stageName,omitempty" azure:"ro"`

	// READ-ONLY; Status of the job stage.
	StageStatus *StageStatus `json:"stageStatus,omitempty" azure:"ro"`

	// READ-ONLY; Time for the job stage in UTC ISO 8601 format.
	StageTime *time.Time `json:"stageTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobStages.
func (j JobStages) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "jobStageDetails", j.JobStageDetails)
	populate(objectMap, "stageName", j.StageName)
	populate(objectMap, "stageStatus", j.StageStatus)
	populateTimeRFC3339(objectMap, "stageTime", j.StageTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobStages.
func (j *JobStages) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, &j.DisplayName)
			delete(rawMsg, key)
		case "jobStageDetails":
			err = unpopulate(val, &j.JobStageDetails)
			delete(rawMsg, key)
		case "stageName":
			err = unpopulate(val, &j.StageName)
			delete(rawMsg, key)
		case "stageStatus":
			err = unpopulate(val, &j.StageStatus)
			delete(rawMsg, key)
		case "stageTime":
			err = unpopulateTimeRFC3339(val, &j.StageTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobsBeginCreateOptions contains the optional parameters for the Jobs.BeginCreate method.
type JobsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// JobsBeginDeleteOptions contains the optional parameters for the Jobs.BeginDelete method.
type JobsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobsBeginUpdateOptions contains the optional parameters for the Jobs.BeginUpdate method.
type JobsBeginUpdateOptions struct {
	// Defines the If-Match condition. The patch will be performed only if the ETag of the job on the server matches this value.
	IfMatch *string
}

// JobsBookShipmentPickUpOptions contains the optional parameters for the Jobs.BookShipmentPickUp method.
type JobsBookShipmentPickUpOptions struct {
	// placeholder for future optional parameters
}

// JobsCancelOptions contains the optional parameters for the Jobs.Cancel method.
type JobsCancelOptions struct {
	// placeholder for future optional parameters
}

// JobsGetOptions contains the optional parameters for the Jobs.Get method.
type JobsGetOptions struct {
	// $expand is supported on details parameter for job, which provides details on the job stages.
	Expand *string
}

// JobsListByResourceGroupOptions contains the optional parameters for the Jobs.ListByResourceGroup method.
type JobsListByResourceGroupOptions struct {
	// $skipToken is supported on Get list of jobs, which provides the next page in the list of jobs.
	SkipToken *string
}

// JobsListCredentialsOptions contains the optional parameters for the Jobs.ListCredentials method.
type JobsListCredentialsOptions struct {
	// placeholder for future optional parameters
}

// JobsListOptions contains the optional parameters for the Jobs.List method.
type JobsListOptions struct {
	// $skipToken is supported on Get list of jobs, which provides the next page in the list of jobs.
	SkipToken *string
}

// JobsMarkDevicesShippedOptions contains the optional parameters for the Jobs.MarkDevicesShipped method.
type JobsMarkDevicesShippedOptions struct {
	// placeholder for future optional parameters
}

// KeyEncryptionKey - Encryption key containing details about key to encrypt different keys.
type KeyEncryptionKey struct {
	// REQUIRED; Type of encryption key used for key encryption.
	KekType *KekType `json:"kekType,omitempty"`

	// Managed identity properties used for key encryption.
	IdentityProperties *IdentityProperties `json:"identityProperties,omitempty"`

	// Key encryption key. It is required in case of Customer managed KekType.
	KekURL *string `json:"kekUrl,omitempty"`

	// Kek vault resource id. It is required in case of Customer managed KekType.
	KekVaultResourceID *string `json:"kekVaultResourceID,omitempty"`
}

// LastMitigationActionOnJob - Last Mitigation Action Performed On Job
type LastMitigationActionOnJob struct {
	// Action performed date time
	ActionDateTimeInUTC *time.Time `json:"actionDateTimeInUtc,omitempty"`

	// Resolution code provided by customer
	CustomerResolution *CustomerResolutionCode `json:"customerResolution,omitempty"`

	// Action performed by customer, possibility is that mitigation might happen by customer or service or by ops
	IsPerformedByCustomer *bool `json:"isPerformedByCustomer,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LastMitigationActionOnJob.
func (l LastMitigationActionOnJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "actionDateTimeInUtc", l.ActionDateTimeInUTC)
	populate(objectMap, "customerResolution", l.CustomerResolution)
	populate(objectMap, "isPerformedByCustomer", l.IsPerformedByCustomer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LastMitigationActionOnJob.
func (l *LastMitigationActionOnJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionDateTimeInUtc":
			err = unpopulateTimeRFC3339(val, &l.ActionDateTimeInUTC)
			delete(rawMsg, key)
		case "customerResolution":
			err = unpopulate(val, &l.CustomerResolution)
			delete(rawMsg, key)
		case "isPerformedByCustomer":
			err = unpopulate(val, &l.IsPerformedByCustomer)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedDiskDetails - Details of the managed disks.
type ManagedDiskDetails struct {
	DataAccountDetails
	// REQUIRED; Resource Group Id of the compute disks.
	ResourceGroupID *string `json:"resourceGroupId,omitempty"`

	// REQUIRED; Resource Id of the storage account that can be used to copy the vhd for staging.
	StagingStorageAccountID *string `json:"stagingStorageAccountId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedDiskDetails.
func (m ManagedDiskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.DataAccountDetails.marshalInternal(objectMap, DataAccountTypeManagedDisk)
	populate(objectMap, "resourceGroupId", m.ResourceGroupID)
	populate(objectMap, "stagingStorageAccountId", m.StagingStorageAccountID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedDiskDetails.
func (m *ManagedDiskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceGroupId":
			err = unpopulate(val, &m.ResourceGroupID)
			delete(rawMsg, key)
		case "stagingStorageAccountId":
			err = unpopulate(val, &m.StagingStorageAccountID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.DataAccountDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MarkDevicesShippedRequest - The request body to provide the delivery package details of job
type MarkDevicesShippedRequest struct {
	// REQUIRED; Delivery package details
	DeliverToDcPackageDetails *PackageCarrierInfo `json:"deliverToDcPackageDetails,omitempty"`
}

// MitigateJobRequest - The Mitigate Job captured from request body for Mitigate API
type MitigateJobRequest struct {
	// REQUIRED; Resolution code for the job
	CustomerResolutionCode *CustomerResolutionCode `json:"customerResolutionCode,omitempty"`
}

// NotificationPreference - Notification preference for a job stage.
type NotificationPreference struct {
	// REQUIRED; Notification is required or not.
	SendNotification *bool `json:"sendNotification,omitempty"`

	// REQUIRED; Name of the stage.
	StageName *NotificationStageName `json:"stageName,omitempty"`
}

// Operation entity.
type Operation struct {
	// Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// READ-ONLY; Operation display values.
	Display *OperationDisplay `json:"display,omitempty" azure:"ro"`

	// READ-ONLY; Name of the operation. Format: {resourceProviderNamespace}/{resourceType}/{read|write|delete|action}
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Origin of the operation. Can be : user|system|user,system
	Origin *string `json:"origin,omitempty" azure:"ro"`

	// READ-ONLY; Operation properties.
	Properties map[string]interface{} `json:"properties,omitempty" azure:"ro"`
}

// OperationDisplay - Operation display
type OperationDisplay struct {
	// Localized description of the operation for display purpose.
	Description *string `json:"description,omitempty"`

	// Localized name of the operation for display purpose.
	Operation *string `json:"operation,omitempty"`

	// Provider name.
	Provider *string `json:"provider,omitempty"`

	// Resource name.
	Resource *string `json:"resource,omitempty"`
}

// OperationList - Operation Collection.
type OperationList struct {
	// Link for the next set of operations.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of operations.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationList.
func (o OperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PackageCarrierDetails - Package carrier details.
type PackageCarrierDetails struct {
	// Carrier Account Number of customer for customer disk.
	CarrierAccountNumber *string `json:"carrierAccountNumber,omitempty"`

	// Name of the carrier.
	CarrierName *string `json:"carrierName,omitempty"`

	// Tracking Id of shipment.
	TrackingID *string `json:"trackingId,omitempty"`
}

// PackageCarrierInfo - package carrier info
type PackageCarrierInfo struct {
	// Name of the carrier.
	CarrierName *string `json:"carrierName,omitempty"`

	// Tracking Id of shipment.
	TrackingID *string `json:"trackingId,omitempty"`
}

// PackageShippingDetails - package shipping details
type PackageShippingDetails struct {
	// READ-ONLY; Name of the carrier.
	CarrierName *string `json:"carrierName,omitempty" azure:"ro"`

	// READ-ONLY; Tracking Id of shipment.
	TrackingID *string `json:"trackingId,omitempty" azure:"ro"`

	// READ-ONLY; Url where shipment can be tracked.
	TrackingURL *string `json:"trackingUrl,omitempty" azure:"ro"`
}

// Preferences related to the order
type Preferences struct {
	// Preferences related to the Encryption.
	EncryptionPreferences *EncryptionPreferences `json:"encryptionPreferences,omitempty"`

	// Preferred data center region.
	PreferredDataCenterRegion []*string `json:"preferredDataCenterRegion,omitempty"`

	// Preferences related to the shipment logistics of the sku.
	TransportPreferences *TransportPreferences `json:"transportPreferences,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Preferences.
func (p Preferences) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptionPreferences", p.EncryptionPreferences)
	populate(objectMap, "preferredDataCenterRegion", p.PreferredDataCenterRegion)
	populate(objectMap, "transportPreferences", p.TransportPreferences)
	return json.Marshal(objectMap)
}

// PreferencesValidationRequest - Request to validate preference of transport and data center.
type PreferencesValidationRequest struct {
	ValidationInputRequest
	// REQUIRED; Device type to be used for the job.
	DeviceType *SKUName `json:"deviceType,omitempty"`

	// Preference of transport and data center.
	Preference *Preferences `json:"preference,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PreferencesValidationRequest.
func (p PreferencesValidationRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ValidationInputRequest.marshalInternal(objectMap, ValidationInputDiscriminatorValidatePreferences)
	populate(objectMap, "deviceType", p.DeviceType)
	populate(objectMap, "preference", p.Preference)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PreferencesValidationRequest.
func (p *PreferencesValidationRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceType":
			err = unpopulate(val, &p.DeviceType)
			delete(rawMsg, key)
		case "preference":
			err = unpopulate(val, &p.Preference)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.ValidationInputRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PreferencesValidationResponseProperties - Properties of data center and transport preference validation response.
type PreferencesValidationResponseProperties struct {
	ValidationInputResponse
	// READ-ONLY; Validation status of requested data center and transport.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PreferencesValidationResponseProperties.
func (p PreferencesValidationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ValidationInputResponse.marshalInternal(objectMap, ValidationInputDiscriminatorValidatePreferences)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PreferencesValidationResponseProperties.
func (p *PreferencesValidationResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.ValidationInputResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RegionConfigurationRequest - Request body to get the configuration for the region.
type RegionConfigurationRequest struct {
	// Request body to get the datacenter address for given sku.
	DatacenterAddressRequest *DatacenterAddressRequest `json:"datacenterAddressRequest,omitempty"`

	// Request body to get the availability for scheduling orders.
	ScheduleAvailabilityRequest ScheduleAvailabilityRequestClassification `json:"scheduleAvailabilityRequest,omitempty"`

	// Request body to get the transport availability for given sku.
	TransportAvailabilityRequest *TransportAvailabilityRequest `json:"transportAvailabilityRequest,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegionConfigurationRequest.
func (r RegionConfigurationRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datacenterAddressRequest", r.DatacenterAddressRequest)
	populate(objectMap, "scheduleAvailabilityRequest", r.ScheduleAvailabilityRequest)
	populate(objectMap, "transportAvailabilityRequest", r.TransportAvailabilityRequest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegionConfigurationRequest.
func (r *RegionConfigurationRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datacenterAddressRequest":
			err = unpopulate(val, &r.DatacenterAddressRequest)
			delete(rawMsg, key)
		case "scheduleAvailabilityRequest":
			r.ScheduleAvailabilityRequest, err = unmarshalScheduleAvailabilityRequestClassification(val)
			delete(rawMsg, key)
		case "transportAvailabilityRequest":
			err = unpopulate(val, &r.TransportAvailabilityRequest)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RegionConfigurationResponse - Configuration response specific to a region.
type RegionConfigurationResponse struct {
	// READ-ONLY; Datacenter address for given sku in a region.
	DatacenterAddressResponse DatacenterAddressResponseClassification `json:"datacenterAddressResponse,omitempty" azure:"ro"`

	// READ-ONLY; Schedule availability for given sku in a region.
	ScheduleAvailabilityResponse *ScheduleAvailabilityResponse `json:"scheduleAvailabilityResponse,omitempty" azure:"ro"`

	// READ-ONLY; Transport options available for given sku in a region.
	TransportAvailabilityResponse *TransportAvailabilityResponse `json:"transportAvailabilityResponse,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RegionConfigurationResponse.
func (r RegionConfigurationResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datacenterAddressResponse", r.DatacenterAddressResponse)
	populate(objectMap, "scheduleAvailabilityResponse", r.ScheduleAvailabilityResponse)
	populate(objectMap, "transportAvailabilityResponse", r.TransportAvailabilityResponse)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegionConfigurationResponse.
func (r *RegionConfigurationResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datacenterAddressResponse":
			r.DatacenterAddressResponse, err = unmarshalDatacenterAddressResponseClassification(val)
			delete(rawMsg, key)
		case "scheduleAvailabilityResponse":
			err = unpopulate(val, &r.ScheduleAvailabilityResponse)
			delete(rawMsg, key)
		case "transportAvailabilityResponse":
			err = unpopulate(val, &r.TransportAvailabilityResponse)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - Model of the Resource.
type Resource struct {
	// REQUIRED; The location of the resource. This will be one of the supported and registered Azure Regions (e.g. West US, East US, Southeast Asia, etc.).
	// The region of a resource cannot be changed once it is
	// created, but if an identical region is specified on update the request will succeed.
	Location *string `json:"location,omitempty"`

	// REQUIRED; The sku type.
	SKU *SKU `json:"sku,omitempty"`

	// Msi identity of the resource
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// The list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups).
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
}

// ResourceIdentity - Msi identity details of the resource
type ResourceIdentity struct {
	// Identity type
	Type *string `json:"type,omitempty"`

	// User Assigned Identities
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; Service Principal Id backing the Msi
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; Home Tenant Id
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceIdentity.
func (r ResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "tenantId", r.TenantID)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "userAssignedIdentities", r.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// SKU - The Sku.
type SKU struct {
	// REQUIRED; The sku name.
	Name *SKUName `json:"name,omitempty"`

	// The display name of the sku.
	DisplayName *string `json:"displayName,omitempty"`

	// The sku family.
	Family *string `json:"family,omitempty"`
}

// SKUAvailabilityValidationRequest - Request to validate sku availability.
type SKUAvailabilityValidationRequest struct {
	ValidationInputRequest
	// REQUIRED; ISO country code. Country for hardware shipment. For codes check: https://en.wikipedia.org/wiki/ISO3166-1alpha-2#Officiallyassignedcode_elements
	Country *string `json:"country,omitempty"`

	// REQUIRED; Device type to be used for the job.
	DeviceType *SKUName `json:"deviceType,omitempty"`

	// REQUIRED; Location for data transfer. For locations check: https://management.azure.com/subscriptions/SUBSCRIPTIONID/locations?api-version=2018-01-01
	Location *string `json:"location,omitempty"`

	// REQUIRED; Type of the transfer.
	TransferType *TransferType `json:"transferType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUAvailabilityValidationRequest.
func (s SKUAvailabilityValidationRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ValidationInputRequest.marshalInternal(objectMap, ValidationInputDiscriminatorValidateSKUAvailability)
	populate(objectMap, "country", s.Country)
	populate(objectMap, "deviceType", s.DeviceType)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "transferType", s.TransferType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKUAvailabilityValidationRequest.
func (s *SKUAvailabilityValidationRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "country":
			err = unpopulate(val, &s.Country)
			delete(rawMsg, key)
		case "deviceType":
			err = unpopulate(val, &s.DeviceType)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &s.Location)
			delete(rawMsg, key)
		case "transferType":
			err = unpopulate(val, &s.TransferType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ValidationInputRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SKUAvailabilityValidationResponseProperties - Properties of sku availability validation response.
type SKUAvailabilityValidationResponseProperties struct {
	ValidationInputResponse
	// READ-ONLY; Sku availability validation status.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUAvailabilityValidationResponseProperties.
func (s SKUAvailabilityValidationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ValidationInputResponse.marshalInternal(objectMap, ValidationInputDiscriminatorValidateSKUAvailability)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKUAvailabilityValidationResponseProperties.
func (s *SKUAvailabilityValidationResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ValidationInputResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SKUCapacity - Capacity of the sku.
type SKUCapacity struct {
	// READ-ONLY; Maximum capacity in TB.
	Maximum *string `json:"maximum,omitempty" azure:"ro"`

	// READ-ONLY; Usable capacity in TB.
	Usable *string `json:"usable,omitempty" azure:"ro"`
}

// SKUCost - Describes metadata for retrieving price info.
type SKUCost struct {
	// READ-ONLY; Meter id of the Sku.
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; The type of the meter.
	MeterType *string `json:"meterType,omitempty" azure:"ro"`

	// READ-ONLY; Multiplier specifies the region specific value to be multiplied with 1$ guid. Eg: Our new regions will be using 1$ shipping guid with appropriate
	// multiplier specific to region.
	Multiplier *float64 `json:"multiplier,omitempty" azure:"ro"`
}

// SKUInformation - Information of the sku.
type SKUInformation struct {
	// READ-ONLY; The sku is enabled or not.
	Enabled *bool `json:"enabled,omitempty" azure:"ro"`

	// READ-ONLY; Properties of the sku.
	Properties *SKUProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; The Sku.
	SKU *SKU `json:"sku,omitempty" azure:"ro"`
}

// SKUProperties - Properties of the sku.
type SKUProperties struct {
	// READ-ONLY; Api versions that support this Sku.
	APIVersions []*string `json:"apiVersions,omitempty" azure:"ro"`

	// READ-ONLY; Capacity of the Sku.
	Capacity *SKUCapacity `json:"capacity,omitempty" azure:"ro"`

	// READ-ONLY; Cost of the Sku.
	Costs []*SKUCost `json:"costs,omitempty" azure:"ro"`

	// READ-ONLY; The map of data location to service location.
	DataLocationToServiceLocationMap []*DataLocationToServiceLocationMap `json:"dataLocationToServiceLocationMap,omitempty" azure:"ro"`

	// READ-ONLY; Reason why the Sku is disabled.
	DisabledReason *SKUDisabledReason `json:"disabledReason,omitempty" azure:"ro"`

	// READ-ONLY; Message for why the Sku is disabled.
	DisabledReasonMessage *string `json:"disabledReasonMessage,omitempty" azure:"ro"`

	// READ-ONLY; Required feature to access the sku.
	RequiredFeature *string `json:"requiredFeature,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUProperties.
func (s SKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersions", s.APIVersions)
	populate(objectMap, "capacity", s.Capacity)
	populate(objectMap, "costs", s.Costs)
	populate(objectMap, "dataLocationToServiceLocationMap", s.DataLocationToServiceLocationMap)
	populate(objectMap, "disabledReason", s.DisabledReason)
	populate(objectMap, "disabledReasonMessage", s.DisabledReasonMessage)
	populate(objectMap, "requiredFeature", s.RequiredFeature)
	return json.Marshal(objectMap)
}

// ScheduleAvailabilityRequestClassification provides polymorphic access to related types.
// Call the interface's GetScheduleAvailabilityRequest() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DataBoxScheduleAvailabilityRequest, *DiskScheduleAvailabilityRequest, *HeavyScheduleAvailabilityRequest, *ScheduleAvailabilityRequest
type ScheduleAvailabilityRequestClassification interface {
	// GetScheduleAvailabilityRequest returns the ScheduleAvailabilityRequest content of the underlying type.
	GetScheduleAvailabilityRequest() *ScheduleAvailabilityRequest
}

// ScheduleAvailabilityRequest - Request body to get the availability for scheduling orders.
type ScheduleAvailabilityRequest struct {
	// REQUIRED; Sku Name for which the order is to be scheduled.
	SKUName *SKUName `json:"skuName,omitempty"`

	// REQUIRED; Location for data transfer. For locations check: https://management.azure.com/subscriptions/SUBSCRIPTIONID/locations?api-version=2018-01-01
	StorageLocation *string `json:"storageLocation,omitempty"`

	// Country in which storage location should be supported.
	Country *string `json:"country,omitempty"`
}

// GetScheduleAvailabilityRequest implements the ScheduleAvailabilityRequestClassification interface for type ScheduleAvailabilityRequest.
func (s *ScheduleAvailabilityRequest) GetScheduleAvailabilityRequest() *ScheduleAvailabilityRequest {
	return s
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleAvailabilityRequest.
func (s *ScheduleAvailabilityRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s ScheduleAvailabilityRequest) marshalInternal(objectMap map[string]interface{}, discValue SKUName) {
	populate(objectMap, "country", s.Country)
	s.SKUName = &discValue
	objectMap["skuName"] = s.SKUName
	populate(objectMap, "storageLocation", s.StorageLocation)
}

func (s *ScheduleAvailabilityRequest) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "country":
			err = unpopulate(val, &s.Country)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, &s.SKUName)
			delete(rawMsg, key)
		case "storageLocation":
			err = unpopulate(val, &s.StorageLocation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ScheduleAvailabilityResponse - Schedule availability for given sku in a region.
type ScheduleAvailabilityResponse struct {
	// READ-ONLY; List of dates available to schedule
	AvailableDates []*time.Time `json:"availableDates,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleAvailabilityResponse.
func (s ScheduleAvailabilityResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	aux := make([]*timeRFC3339, len(s.AvailableDates), len(s.AvailableDates))
	for i := 0; i < len(s.AvailableDates); i++ {
		aux[i] = (*timeRFC3339)(s.AvailableDates[i])
	}
	populate(objectMap, "availableDates", aux)
	return json.Marshal(objectMap)
}

// ServiceListAvailableSKUsByResourceGroupOptions contains the optional parameters for the Service.ListAvailableSKUsByResourceGroup method.
type ServiceListAvailableSKUsByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ServiceRegionConfigurationByResourceGroupOptions contains the optional parameters for the Service.RegionConfigurationByResourceGroup method.
type ServiceRegionConfigurationByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ServiceRegionConfigurationOptions contains the optional parameters for the Service.RegionConfiguration method.
type ServiceRegionConfigurationOptions struct {
	// placeholder for future optional parameters
}

// ServiceValidateAddressOptions contains the optional parameters for the Service.ValidateAddress method.
type ServiceValidateAddressOptions struct {
	// placeholder for future optional parameters
}

// ServiceValidateInputsByResourceGroupOptions contains the optional parameters for the Service.ValidateInputsByResourceGroup method.
type ServiceValidateInputsByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ServiceValidateInputsOptions contains the optional parameters for the Service.ValidateInputs method.
type ServiceValidateInputsOptions struct {
	// placeholder for future optional parameters
}

// ShareCredentialDetails - Credential details of the shares in account.
type ShareCredentialDetails struct {
	// READ-ONLY; Password for the share.
	Password *string `json:"password,omitempty" azure:"ro"`

	// READ-ONLY; Name of the share.
	ShareName *string `json:"shareName,omitempty" azure:"ro"`

	// READ-ONLY; Type of the share.
	ShareType *ShareDestinationFormatType `json:"shareType,omitempty" azure:"ro"`

	// READ-ONLY; Access protocols supported on the device.
	SupportedAccessProtocols []*AccessProtocol `json:"supportedAccessProtocols,omitempty" azure:"ro"`

	// READ-ONLY; User name for the share.
	UserName *string `json:"userName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ShareCredentialDetails.
func (s ShareCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "password", s.Password)
	populate(objectMap, "shareName", s.ShareName)
	populate(objectMap, "shareType", s.ShareType)
	populate(objectMap, "supportedAccessProtocols", s.SupportedAccessProtocols)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// ShipmentPickUpRequest - Shipment pick up request details.
type ShipmentPickUpRequest struct {
	// REQUIRED; Maximum date before which the pick up should commence, this must be in local time of pick up area.
	EndTime *time.Time `json:"endTime,omitempty"`

	// REQUIRED; Shipment Location in the pickup place. Eg.front desk
	ShipmentLocation *string `json:"shipmentLocation,omitempty"`

	// REQUIRED; Minimum date after which the pick up should commence, this must be in local time of pick up area.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShipmentPickUpRequest.
func (s ShipmentPickUpRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "shipmentLocation", s.ShipmentLocation)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShipmentPickUpRequest.
func (s *ShipmentPickUpRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &s.EndTime)
			delete(rawMsg, key)
		case "shipmentLocation":
			err = unpopulate(val, &s.ShipmentLocation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ShipmentPickUpResponse - Shipment pick up response.
type ShipmentPickUpResponse struct {
	// READ-ONLY; Confirmation number for the pick up request.
	ConfirmationNumber *string `json:"confirmationNumber,omitempty" azure:"ro"`

	// READ-ONLY; Time by which shipment should be ready for pick up, this is in local time of pick up area.
	ReadyByTime *time.Time `json:"readyByTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ShipmentPickUpResponse.
func (s ShipmentPickUpResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "confirmationNumber", s.ConfirmationNumber)
	populateTimeRFC3339(objectMap, "readyByTime", s.ReadyByTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShipmentPickUpResponse.
func (s *ShipmentPickUpResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confirmationNumber":
			err = unpopulate(val, &s.ConfirmationNumber)
			delete(rawMsg, key)
		case "readyByTime":
			err = unpopulateTimeRFC3339(val, &s.ReadyByTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ShippingAddress - Shipping address where customer wishes to receive the device.
type ShippingAddress struct {
	// REQUIRED; Name of the Country.
	Country *string `json:"country,omitempty"`

	// REQUIRED; Street Address line 1.
	StreetAddress1 *string `json:"streetAddress1,omitempty"`

	// Type of address.
	AddressType *AddressType `json:"addressType,omitempty"`

	// Name of the City.
	City *string `json:"city,omitempty"`

	// Name of the company.
	CompanyName *string `json:"companyName,omitempty"`

	// Postal code.
	PostalCode *string `json:"postalCode,omitempty"`

	// Name of the State or Province.
	StateOrProvince *string `json:"stateOrProvince,omitempty"`

	// Street Address line 2.
	StreetAddress2 *string `json:"streetAddress2,omitempty"`

	// Street Address line 3.
	StreetAddress3 *string `json:"streetAddress3,omitempty"`

	// Extended Zip Code.
	ZipExtendedCode *string `json:"zipExtendedCode,omitempty"`
}

// StorageAccountDetails - Details for the storage account.
type StorageAccountDetails struct {
	DataAccountDetails
	// REQUIRED; Storage Account Resource Id.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountDetails.
func (s StorageAccountDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.DataAccountDetails.marshalInternal(objectMap, DataAccountTypeStorageAccount)
	populate(objectMap, "storageAccountId", s.StorageAccountID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageAccountDetails.
func (s *StorageAccountDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storageAccountId":
			err = unpopulate(val, &s.StorageAccountID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.DataAccountDetails.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SubscriptionIsAllowedToCreateJobValidationRequest - Request to validate subscription permission to create jobs.
type SubscriptionIsAllowedToCreateJobValidationRequest struct {
	ValidationInputRequest
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionIsAllowedToCreateJobValidationRequest.
func (s SubscriptionIsAllowedToCreateJobValidationRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ValidationInputRequest.marshalInternal(objectMap, ValidationInputDiscriminatorValidateSubscriptionIsAllowedToCreateJob)
	return json.Marshal(objectMap)
}

// SubscriptionIsAllowedToCreateJobValidationResponseProperties - Properties of subscription permission to create job validation response.
type SubscriptionIsAllowedToCreateJobValidationResponseProperties struct {
	ValidationInputResponse
	// READ-ONLY; Validation status of subscription permission to create job.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionIsAllowedToCreateJobValidationResponseProperties.
func (s SubscriptionIsAllowedToCreateJobValidationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ValidationInputResponse.marshalInternal(objectMap, ValidationInputDiscriminatorValidateSubscriptionIsAllowedToCreateJob)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriptionIsAllowedToCreateJobValidationResponseProperties.
func (s *SubscriptionIsAllowedToCreateJobValidationResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ValidationInputResponse.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SystemData - Provides details about resource creation and update time
type SystemData struct {
	// READ-ONLY; The timestamp of resource creation (UTC)
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; A string identifier for the identity that created the resource
	CreatedBy *string `json:"createdBy,omitempty" azure:"ro"`

	// READ-ONLY; The type of identity that created the resource: user, application, managedIdentity
	CreatedByType *string `json:"createdByType,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty" azure:"ro"`

	// READ-ONLY; A string identifier for the identity that last modified the resource
	LastModifiedBy *string `json:"lastModifiedBy,omitempty" azure:"ro"`

	// READ-ONLY; The type of identity that last modified the resource: user, application, managedIdentity
	LastModifiedByType *string `json:"lastModifiedByType,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TransferAllDetails - Details to transfer all data.
type TransferAllDetails struct {
	// REQUIRED; Type of the account of data
	DataAccountType *DataAccountType `json:"dataAccountType,omitempty"`

	// To indicate if all Azure blobs have to be transferred
	TransferAllBlobs *bool `json:"transferAllBlobs,omitempty"`

	// To indicate if all Azure Files have to be transferred
	TransferAllFiles *bool `json:"transferAllFiles,omitempty"`
}

// TransferConfiguration - Configuration for defining the transfer of data.
type TransferConfiguration struct {
	// REQUIRED; Type of the configuration for transfer.
	TransferConfigurationType *TransferConfigurationType `json:"transferConfigurationType,omitempty"`

	// Map of filter type and the details to transfer all data. This field is required only if the TransferConfigurationType is given as TransferAll
	TransferAllDetails *TransferConfigurationTransferAllDetails `json:"transferAllDetails,omitempty"`

	// Map of filter type and the details to filter. This field is required only if the TransferConfigurationType is given as TransferUsingFilter.
	TransferFilterDetails *TransferConfigurationTransferFilterDetails `json:"transferFilterDetails,omitempty"`
}

// TransferConfigurationTransferAllDetails - Map of filter type and the details to transfer all data. This field is required only if the TransferConfigurationType
// is given as TransferAll
type TransferConfigurationTransferAllDetails struct {
	// Details to transfer all data.
	Include *TransferAllDetails `json:"include,omitempty"`
}

// TransferConfigurationTransferFilterDetails - Map of filter type and the details to filter. This field is required only if the TransferConfigurationType
// is given as TransferUsingFilter.
type TransferConfigurationTransferFilterDetails struct {
	// Details of the filtering the transfer of data.
	Include *TransferFilterDetails `json:"include,omitempty"`
}

// TransferFilterDetails - Details of the filtering the transfer of data.
type TransferFilterDetails struct {
	// REQUIRED; Type of the account of data.
	DataAccountType *DataAccountType `json:"dataAccountType,omitempty"`

	// Filter details to transfer Azure files.
	AzureFileFilterDetails *AzureFileFilterDetails `json:"azureFileFilterDetails,omitempty"`

	// Filter details to transfer blobs.
	BlobFilterDetails *BlobFilterDetails `json:"blobFilterDetails,omitempty"`

	// Details of the filter files to be used for data transfer.
	FilterFileDetails []*FilterFileDetails `json:"filterFileDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TransferFilterDetails.
func (t TransferFilterDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureFileFilterDetails", t.AzureFileFilterDetails)
	populate(objectMap, "blobFilterDetails", t.BlobFilterDetails)
	populate(objectMap, "dataAccountType", t.DataAccountType)
	populate(objectMap, "filterFileDetails", t.FilterFileDetails)
	return json.Marshal(objectMap)
}

// TransportAvailabilityDetails - Transport options availability details for given region.
type TransportAvailabilityDetails struct {
	// READ-ONLY; Transport Shipment Type supported for given region.
	ShipmentType *TransportShipmentTypes `json:"shipmentType,omitempty" azure:"ro"`
}

// TransportAvailabilityRequest - Request body to get the transport availability for given sku.
type TransportAvailabilityRequest struct {
	// Type of the device.
	SKUName *SKUName `json:"skuName,omitempty"`
}

// TransportAvailabilityResponse - Transport options available for given sku in a region.
type TransportAvailabilityResponse struct {
	// READ-ONLY; List of transport availability details for given region
	TransportAvailabilityDetails []*TransportAvailabilityDetails `json:"transportAvailabilityDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TransportAvailabilityResponse.
func (t TransportAvailabilityResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "transportAvailabilityDetails", t.TransportAvailabilityDetails)
	return json.Marshal(objectMap)
}

// TransportPreferences - Preferences related to the shipment logistics of the sku
type TransportPreferences struct {
	// REQUIRED; Indicates Shipment Logistics type that the customer preferred.
	PreferredShipmentType *TransportShipmentTypes `json:"preferredShipmentType,omitempty"`
}

// UnencryptedCredentials - Unencrypted credentials for accessing device.
type UnencryptedCredentials struct {
	// READ-ONLY; Name of the job.
	JobName *string `json:"jobName,omitempty" azure:"ro"`

	// READ-ONLY; Secrets related to this job.
	JobSecrets JobSecretsClassification `json:"jobSecrets,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UnencryptedCredentials.
func (u UnencryptedCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "jobName", u.JobName)
	populate(objectMap, "jobSecrets", u.JobSecrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnencryptedCredentials.
func (u *UnencryptedCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobName":
			err = unpopulate(val, &u.JobName)
			delete(rawMsg, key)
		case "jobSecrets":
			u.JobSecrets, err = unmarshalJobSecretsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UnencryptedCredentialsList - List of unencrypted credentials for accessing device.
type UnencryptedCredentialsList struct {
	// Link for the next set of unencrypted credentials.
	NextLink *string `json:"nextLink,omitempty"`

	// List of unencrypted credentials.
	Value []*UnencryptedCredentials `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UnencryptedCredentialsList.
func (u UnencryptedCredentialsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UpdateJobDetails - Job details for update.
type UpdateJobDetails struct {
	// Contact details for notification and shipping.
	ContactDetails *ContactDetails `json:"contactDetails,omitempty"`

	// Key encryption key for the job.
	KeyEncryptionKey *KeyEncryptionKey `json:"keyEncryptionKey,omitempty"`

	// Return package details of job.
	ReturnToCustomerPackageDetails *PackageCarrierDetails `json:"returnToCustomerPackageDetails,omitempty"`

	// Shipping address of the customer.
	ShippingAddress *ShippingAddress `json:"shippingAddress,omitempty"`
}

// UpdateJobProperties - Job Properties for update
type UpdateJobProperties struct {
	// Details of a job to be updated.
	Details *UpdateJobDetails `json:"details,omitempty"`
}

// UserAssignedIdentity - Class defining User assigned identity details.
type UserAssignedIdentity struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// UserAssignedProperties - User assigned identity properties.
type UserAssignedProperties struct {
	// Arm resource id for user assigned identity to be used to fetch MSI token.
	ResourceID *string `json:"resourceId,omitempty"`
}

// ValidateAddress - The requirements to validate customer address where the device needs to be shipped.
type ValidateAddress struct {
	ValidationInputRequest
	// REQUIRED; Device type to be used for the job.
	DeviceType *SKUName `json:"deviceType,omitempty"`

	// REQUIRED; Shipping address of the customer.
	ShippingAddress *ShippingAddress `json:"shippingAddress,omitempty"`

	// Preferences related to the shipment logistics of the sku.
	TransportPreferences *TransportPreferences `json:"transportPreferences,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateAddress.
func (v ValidateAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ValidationInputRequest.marshalInternal(objectMap, ValidationInputDiscriminatorValidateAddress)
	populate(objectMap, "deviceType", v.DeviceType)
	populate(objectMap, "shippingAddress", v.ShippingAddress)
	populate(objectMap, "transportPreferences", v.TransportPreferences)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateAddress.
func (v *ValidateAddress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceType":
			err = unpopulate(val, &v.DeviceType)
			delete(rawMsg, key)
		case "shippingAddress":
			err = unpopulate(val, &v.ShippingAddress)
			delete(rawMsg, key)
		case "transportPreferences":
			err = unpopulate(val, &v.TransportPreferences)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ValidationInputRequest.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidationInputRequestClassification provides polymorphic access to related types.
// Call the interface's GetValidationInputRequest() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CreateOrderLimitForSubscriptionValidationRequest, *DataTransferDetailsValidationRequest, *PreferencesValidationRequest,
// - *SkuAvailabilityValidationRequest, *SubscriptionIsAllowedToCreateJobValidationRequest, *ValidateAddress, *ValidationInputRequest
type ValidationInputRequestClassification interface {
	// GetValidationInputRequest returns the ValidationInputRequest content of the underlying type.
	GetValidationInputRequest() *ValidationInputRequest
}

// ValidationInputRequest - Minimum fields that must be present in any type of validation request.
type ValidationInputRequest struct {
	// REQUIRED; Identifies the type of validation request.
	ValidationType *ValidationInputDiscriminator `json:"validationType,omitempty"`
}

// GetValidationInputRequest implements the ValidationInputRequestClassification interface for type ValidationInputRequest.
func (v *ValidationInputRequest) GetValidationInputRequest() *ValidationInputRequest { return v }

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationInputRequest.
func (v *ValidationInputRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v ValidationInputRequest) marshalInternal(objectMap map[string]interface{}, discValue ValidationInputDiscriminator) {
	v.ValidationType = &discValue
	objectMap["validationType"] = v.ValidationType
}

func (v *ValidationInputRequest) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "validationType":
			err = unpopulate(val, &v.ValidationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidationInputResponseClassification provides polymorphic access to related types.
// Call the interface's GetValidationInputResponse() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AddressValidationProperties, *CreateOrderLimitForSubscriptionValidationResponseProperties, *DataTransferDetailsValidationResponseProperties,
// - *PreferencesValidationResponseProperties, *SkuAvailabilityValidationResponseProperties, *SubscriptionIsAllowedToCreateJobValidationResponseProperties,
// - *ValidationInputResponse
type ValidationInputResponseClassification interface {
	// GetValidationInputResponse returns the ValidationInputResponse content of the underlying type.
	GetValidationInputResponse() *ValidationInputResponse
}

// ValidationInputResponse - Minimum properties that should be present in each individual validation response.
type ValidationInputResponse struct {
	// REQUIRED; Identifies the type of validation response.
	ValidationType *ValidationInputDiscriminator `json:"validationType,omitempty"`

	// READ-ONLY; Error code and message of validation response.
	Error *CloudError `json:"error,omitempty" azure:"ro"`
}

// GetValidationInputResponse implements the ValidationInputResponseClassification interface for type ValidationInputResponse.
func (v *ValidationInputResponse) GetValidationInputResponse() *ValidationInputResponse { return v }

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationInputResponse.
func (v *ValidationInputResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v ValidationInputResponse) marshalInternal(objectMap map[string]interface{}, discValue ValidationInputDiscriminator) {
	populate(objectMap, "error", v.Error)
	v.ValidationType = &discValue
	objectMap["validationType"] = v.ValidationType
}

func (v *ValidationInputResponse) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &v.Error)
			delete(rawMsg, key)
		case "validationType":
			err = unpopulate(val, &v.ValidationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidationRequestClassification provides polymorphic access to related types.
// Call the interface's GetValidationRequest() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CreateJobValidations, *ValidationRequest
type ValidationRequestClassification interface {
	// GetValidationRequest returns the ValidationRequest content of the underlying type.
	GetValidationRequest() *ValidationRequest
}

// ValidationRequest - Minimum request requirement of any validation category.
type ValidationRequest struct {
	// REQUIRED; List of request details contain validationType and its request as key and value respectively.
	IndividualRequestDetails []ValidationInputRequestClassification `json:"individualRequestDetails,omitempty"`

	// REQUIRED; Identify the nature of validation.
	ValidationCategory *string `json:"validationCategory,omitempty"`
}

// GetValidationRequest implements the ValidationRequestClassification interface for type ValidationRequest.
func (v *ValidationRequest) GetValidationRequest() *ValidationRequest { return v }

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationRequest.
func (v *ValidationRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v ValidationRequest) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "individualRequestDetails", v.IndividualRequestDetails)
	v.ValidationCategory = &discValue
	objectMap["validationCategory"] = v.ValidationCategory
}

func (v *ValidationRequest) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "individualRequestDetails":
			v.IndividualRequestDetails, err = unmarshalValidationInputRequestClassificationArray(val)
			delete(rawMsg, key)
		case "validationCategory":
			err = unpopulate(val, &v.ValidationCategory)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidationResponse - Response of pre job creation validations.
type ValidationResponse struct {
	// READ-ONLY; Properties of pre job creation validation response.
	Properties *ValidationResponseProperties `json:"properties,omitempty" azure:"ro"`
}

// ValidationResponseProperties - Properties of pre job creation validation response.
type ValidationResponseProperties struct {
	// READ-ONLY; List of response details contain validationType and its response as key and value respectively.
	IndividualResponseDetails []ValidationInputResponseClassification `json:"individualResponseDetails,omitempty" azure:"ro"`

	// READ-ONLY; Overall validation status.
	Status *OverallValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidationResponseProperties.
func (v ValidationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "individualResponseDetails", v.IndividualResponseDetails)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationResponseProperties.
func (v *ValidationResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "individualResponseDetails":
			v.IndividualResponseDetails, err = unmarshalValidationInputResponseClassificationArray(val)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &v.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
