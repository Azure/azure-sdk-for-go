//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdataboxedge

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// ARMBaseModel - Represents the base class for all object models.
type ARMBaseModel struct {
	// READ-ONLY; The path ID that uniquely identifies the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The object name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The hierarchical type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ARMBaseModel.
func (a ARMBaseModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ARMBaseModel.
func (a *ARMBaseModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a ARMBaseModel) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "type", a.Type)
}

func (a *ARMBaseModel) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AddonClassification provides polymorphic access to related types.
// Call the interface's GetAddon() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Addon, *ArcAddon, *IoTAddon
type AddonClassification interface {
	// GetAddon returns the Addon content of the underlying type.
	GetAddon() *Addon
}

// Addon - Role Addon
type Addon struct {
	ARMBaseModel
	// REQUIRED; Addon type.
	Kind *AddonType `json:"kind,omitempty"`

	// READ-ONLY; Addon type
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// GetAddon implements the AddonClassification interface for type Addon.
func (a *Addon) GetAddon() *Addon { return a }

// UnmarshalJSON implements the json.Unmarshaller interface for type Addon.
func (a *Addon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a Addon) marshalInternal(objectMap map[string]interface{}, discValue AddonType) {
	a.ARMBaseModel.marshalInternal(objectMap)
	a.Kind = &discValue
	objectMap["kind"] = a.Kind
	populate(objectMap, "systemData", a.SystemData)
}

func (a *Addon) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AddonList - Collection of all the Role addon on the Azure Stack Edge device.
type AddonList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The Value.
	Value []AddonClassification `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AddonList.
func (a AddonList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonList.
func (a *AddonList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &a.NextLink)
			delete(rawMsg, key)
		case "value":
			a.Value, err = unmarshalAddonClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AddonsBeginCreateOrUpdateOptions contains the optional parameters for the Addons.BeginCreateOrUpdate method.
type AddonsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AddonsBeginDeleteOptions contains the optional parameters for the Addons.BeginDelete method.
type AddonsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AddonsGetOptions contains the optional parameters for the Addons.Get method.
type AddonsGetOptions struct {
	// placeholder for future optional parameters
}

// AddonsListByRoleOptions contains the optional parameters for the Addons.ListByRole method.
type AddonsListByRoleOptions struct {
	// placeholder for future optional parameters
}

// Address - The shipping address of the customer.
type Address struct {
	// REQUIRED; The country name.
	Country *string `json:"country,omitempty"`

	// The address line1.
	AddressLine1 *string `json:"addressLine1,omitempty"`

	// The address line2.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// The address line3.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// The city name.
	City *string `json:"city,omitempty"`

	// The postal code.
	PostalCode *string `json:"postalCode,omitempty"`

	// The state name.
	State *string `json:"state,omitempty"`
}

// Alert on the data box edge/gateway device.
type Alert struct {
	ARMBaseModel
	// READ-ONLY; Properties of alert.
	Properties *AlertProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; Alert generated in the resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Alert.
func (a Alert) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Alert.
func (a *Alert) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AlertErrorDetails - Error details for the alert.
type AlertErrorDetails struct {
	// READ-ONLY; Error code.
	ErrorCode *string `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; Error Message.
	ErrorMessage *string `json:"errorMessage,omitempty" azure:"ro"`

	// READ-ONLY; Number of occurrences.
	Occurrences *int32 `json:"occurrences,omitempty" azure:"ro"`
}

// AlertList - Collection of alerts.
type AlertList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The value.
	Value []*Alert `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertList.
func (a AlertList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AlertProperties - Properties of alert.
type AlertProperties struct {
	// READ-ONLY; Alert type.
	AlertType *string `json:"alertType,omitempty" azure:"ro"`

	// READ-ONLY; UTC time when the alert appeared.
	AppearedAtDateTime *time.Time `json:"appearedAtDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Alert details.
	DetailedInformation map[string]*string `json:"detailedInformation,omitempty" azure:"ro"`

	// READ-ONLY; Error details of the alert.
	ErrorDetails *AlertErrorDetails `json:"errorDetails,omitempty" azure:"ro"`

	// READ-ONLY; Alert recommendation.
	Recommendation *string `json:"recommendation,omitempty" azure:"ro"`

	// READ-ONLY; Severity of the alert.
	Severity *AlertSeverity `json:"severity,omitempty" azure:"ro"`

	// READ-ONLY; Alert title.
	Title *string `json:"title,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertProperties.
func (a AlertProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertType", a.AlertType)
	populateTimeRFC3339(objectMap, "appearedAtDateTime", a.AppearedAtDateTime)
	populate(objectMap, "detailedInformation", a.DetailedInformation)
	populate(objectMap, "errorDetails", a.ErrorDetails)
	populate(objectMap, "recommendation", a.Recommendation)
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertProperties.
func (a *AlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertType":
			err = unpopulate(val, &a.AlertType)
			delete(rawMsg, key)
		case "appearedAtDateTime":
			err = unpopulateTimeRFC3339(val, &a.AppearedAtDateTime)
			delete(rawMsg, key)
		case "detailedInformation":
			err = unpopulate(val, &a.DetailedInformation)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, &a.ErrorDetails)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, &a.Recommendation)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &a.Severity)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &a.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AlertsGetOptions contains the optional parameters for the Alerts.Get method.
type AlertsGetOptions struct {
	// placeholder for future optional parameters
}

// AlertsListByDataBoxEdgeDeviceOptions contains the optional parameters for the Alerts.ListByDataBoxEdgeDevice method.
type AlertsListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// ArcAddon - Arc Addon.
type ArcAddon struct {
	Addon
	// REQUIRED; Properties specific to Arc addon.
	Properties *ArcAddonProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArcAddon.
func (a ArcAddon) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Addon.marshalInternal(objectMap, AddonTypeArcForKubernetes)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcAddon.
func (a *ArcAddon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Addon.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ArcAddonProperties - Arc addon properties.
type ArcAddonProperties struct {
	// REQUIRED; Arc resource group name
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// REQUIRED; Arc resource location
	ResourceLocation *string `json:"resourceLocation,omitempty"`

	// REQUIRED; Arc resource Name
	ResourceName *string `json:"resourceName,omitempty"`

	// REQUIRED; Arc resource subscription Id
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// READ-ONLY; Host OS supported by the Arc addon.
	HostPlatform *PlatformType `json:"hostPlatform,omitempty" azure:"ro"`

	// READ-ONLY; Platform where the runtime is hosted.
	HostPlatformType *HostPlatformType `json:"hostPlatformType,omitempty" azure:"ro"`

	// READ-ONLY; Addon Provisioning State
	ProvisioningState *AddonState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Arc resource version
	Version *string `json:"version,omitempty" azure:"ro"`
}

// AsymmetricEncryptedSecret - Represent the secrets intended for encryption with asymmetric key pair.
type AsymmetricEncryptedSecret struct {
	// REQUIRED; The algorithm used to encrypt "Value".
	EncryptionAlgorithm *EncryptionAlgorithm `json:"encryptionAlgorithm,omitempty"`

	// REQUIRED; The value of the secret.
	Value *string `json:"value,omitempty"`

	// Thumbprint certificate used to encrypt \"Value\". If the value is unencrypted, it will be null.
	EncryptionCertThumbprint *string `json:"encryptionCertThumbprint,omitempty"`
}

// Authentication mechanism for IoT devices.
type Authentication struct {
	// Symmetric key for authentication.
	SymmetricKey *SymmetricKey `json:"symmetricKey,omitempty"`
}

// AvailableSKUsListOptions contains the optional parameters for the AvailableSKUs.List method.
type AvailableSKUsListOptions struct {
	// placeholder for future optional parameters
}

// AzureContainerInfo - Azure container mapping of the endpoint.
type AzureContainerInfo struct {
	// REQUIRED; Container name (Based on the data format specified, this represents the name of Azure Files/Page blob/Block blob).
	ContainerName *string `json:"containerName,omitempty"`

	// REQUIRED; Storage format used for the file represented by the share.
	DataFormat *AzureContainerDataFormat `json:"dataFormat,omitempty"`

	// REQUIRED; ID of the storage account credential used to access storage.
	StorageAccountCredentialID *string `json:"storageAccountCredentialId,omitempty"`
}

// BandwidthSchedule - The bandwidth schedule details.
type BandwidthSchedule struct {
	ARMBaseModel
	// REQUIRED; The properties of the bandwidth schedule.
	Properties *BandwidthScheduleProperties `json:"properties,omitempty"`

	// READ-ONLY; Bandwidth object related to ASE resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthSchedule.
func (b BandwidthSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "systemData", b.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BandwidthSchedule.
func (b *BandwidthSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &b.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BandwidthScheduleProperties - The properties of the bandwidth schedule.
type BandwidthScheduleProperties struct {
	// REQUIRED; The days of the week when this schedule is applicable.
	Days []*DayOfWeek `json:"days,omitempty"`

	// REQUIRED; The bandwidth rate in Mbps.
	RateInMbps *int32 `json:"rateInMbps,omitempty"`

	// REQUIRED; The start time of the schedule in UTC.
	Start *string `json:"start,omitempty"`

	// REQUIRED; The stop time of the schedule in UTC.
	Stop *string `json:"stop,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthScheduleProperties.
func (b BandwidthScheduleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "days", b.Days)
	populate(objectMap, "rateInMbps", b.RateInMbps)
	populate(objectMap, "start", b.Start)
	populate(objectMap, "stop", b.Stop)
	return json.Marshal(objectMap)
}

// BandwidthSchedulesBeginCreateOrUpdateOptions contains the optional parameters for the BandwidthSchedules.BeginCreateOrUpdate method.
type BandwidthSchedulesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// BandwidthSchedulesBeginDeleteOptions contains the optional parameters for the BandwidthSchedules.BeginDelete method.
type BandwidthSchedulesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BandwidthSchedulesGetOptions contains the optional parameters for the BandwidthSchedules.Get method.
type BandwidthSchedulesGetOptions struct {
	// placeholder for future optional parameters
}

// BandwidthSchedulesList - The collection of bandwidth schedules.
type BandwidthSchedulesList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of bandwidth schedules.
	Value []*BandwidthSchedule `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthSchedulesList.
func (b BandwidthSchedulesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BandwidthSchedulesListByDataBoxEdgeDeviceOptions contains the optional parameters for the BandwidthSchedules.ListByDataBoxEdgeDevice method.
type BandwidthSchedulesListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// ClientAccessRight - The mapping between a particular client IP and the type of access client has on the NFS share.
type ClientAccessRight struct {
	// REQUIRED; Type of access to be allowed for the client.
	AccessPermission *ClientPermissionType `json:"accessPermission,omitempty"`

	// REQUIRED; IP of the client.
	Client *string `json:"client,omitempty"`
}

// CloudEdgeManagementRole role.
type CloudEdgeManagementRole struct {
	Role
	// Properties specific to CloudEdgeManagementRole role.
	Properties *CloudEdgeManagementRoleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudEdgeManagementRole.
func (c CloudEdgeManagementRole) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Role.marshalInternal(objectMap, RoleTypesCloudEdgeManagement)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudEdgeManagementRole.
func (c *CloudEdgeManagementRole) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.Role.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CloudEdgeManagementRoleProperties - CloudEdgeManagement Role properties.
type CloudEdgeManagementRoleProperties struct {
	// REQUIRED; Role status.
	RoleStatus *RoleStatus `json:"roleStatus,omitempty"`

	// READ-ONLY; Edge Profile of the resource
	EdgeProfile *EdgeProfile `json:"edgeProfile,omitempty" azure:"ro"`

	// READ-ONLY; Local Edge Management Status
	LocalManagementStatus *RoleStatus `json:"localManagementStatus,omitempty" azure:"ro"`
}

// CloudError - An error response from the service.
// Implements the error and azcore.HTTPResponse interfaces.
type CloudError struct {
	raw string
	// The error details.
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
// The contents of the error text are not contractual and subject to change.
func (e CloudError) Error() string {
	return e.raw
}

// CloudErrorBody - An error response from the service.
type CloudErrorBody struct {
	// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A list of additional details about the error.
	Details []*CloudErrorBody `json:"details,omitempty"`

	// A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudErrorBody.
func (c CloudErrorBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", c.Code)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "message", c.Message)
	return json.Marshal(objectMap)
}

// CniConfig - Cni configuration
type CniConfig struct {
	// READ-ONLY; Pod Subnet
	PodSubnet *string `json:"podSubnet,omitempty" azure:"ro"`

	// READ-ONLY; Service subnet
	ServiceSubnet *string `json:"serviceSubnet,omitempty" azure:"ro"`

	// READ-ONLY; Cni type
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; Cni version
	Version *string `json:"version,omitempty" azure:"ro"`
}

// ComputeResource - Compute infrastructure Resource
type ComputeResource struct {
	// REQUIRED; Memory in GB
	MemoryInGB *int64 `json:"memoryInGB,omitempty"`

	// REQUIRED; Processor count
	ProcessorCount *int32 `json:"processorCount,omitempty"`
}

// ContactDetails - Contains all the contact details of the customer.
type ContactDetails struct {
	// REQUIRED; The name of the company.
	CompanyName *string `json:"companyName,omitempty"`

	// REQUIRED; The contact person name.
	ContactPerson *string `json:"contactPerson,omitempty"`

	// REQUIRED; The email list.
	EmailList []*string `json:"emailList,omitempty"`

	// REQUIRED; The phone number.
	Phone *string `json:"phone,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContactDetails.
func (c ContactDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "companyName", c.CompanyName)
	populate(objectMap, "contactPerson", c.ContactPerson)
	populate(objectMap, "emailList", c.EmailList)
	populate(objectMap, "phone", c.Phone)
	return json.Marshal(objectMap)
}

// Container - Represents a container on the Data Box Edge/Gateway device.
type Container struct {
	ARMBaseModel
	// REQUIRED; The container properties.
	Properties *ContainerProperties `json:"properties,omitempty"`

	// READ-ONLY; Container in DataBoxEdge Resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Container.
func (c Container) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Container.
func (c *Container) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &c.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContainerList - Collection of all the containers on the Data Box Edge/Gateway device.
type ContainerList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of containers.
	Value []*Container `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerList.
func (c ContainerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ContainerProperties - The container properties.
type ContainerProperties struct {
	// REQUIRED; DataFormat for Container
	DataFormat *AzureContainerDataFormat `json:"dataFormat,omitempty"`

	// READ-ONLY; Current status of the container.
	ContainerStatus *ContainerStatus `json:"containerStatus,omitempty" azure:"ro"`

	// READ-ONLY; The UTC time when container got created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Details of the refresh job on this container.
	RefreshDetails *RefreshDetails `json:"refreshDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerStatus", c.ContainerStatus)
	populateTimeRFC3339(objectMap, "createdDateTime", c.CreatedDateTime)
	populate(objectMap, "dataFormat", c.DataFormat)
	populate(objectMap, "refreshDetails", c.RefreshDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerProperties.
func (c *ContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerStatus":
			err = unpopulate(val, &c.ContainerStatus)
			delete(rawMsg, key)
		case "createdDateTime":
			err = unpopulateTimeRFC3339(val, &c.CreatedDateTime)
			delete(rawMsg, key)
		case "dataFormat":
			err = unpopulate(val, &c.DataFormat)
			delete(rawMsg, key)
		case "refreshDetails":
			err = unpopulate(val, &c.RefreshDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContainersBeginCreateOrUpdateOptions contains the optional parameters for the Containers.BeginCreateOrUpdate method.
type ContainersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ContainersBeginDeleteOptions contains the optional parameters for the Containers.BeginDelete method.
type ContainersBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ContainersBeginRefreshOptions contains the optional parameters for the Containers.BeginRefresh method.
type ContainersBeginRefreshOptions struct {
	// placeholder for future optional parameters
}

// ContainersGetOptions contains the optional parameters for the Containers.Get method.
type ContainersGetOptions struct {
	// placeholder for future optional parameters
}

// ContainersListByStorageAccountOptions contains the optional parameters for the Containers.ListByStorageAccount method.
type ContainersListByStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// DCAccessCode - DC Access code in the case of Self Managed Shipping.
type DCAccessCode struct {
	// DCAccessCode properties.
	Properties *DCAccessCodeProperties `json:"properties,omitempty"`
}

// DCAccessCodeProperties - DCAccessCode Properties.
type DCAccessCodeProperties struct {
	// DCAccess Code for the Self Managed shipment.
	AuthCode *string `json:"authCode,omitempty"`
}

// DataBoxEdgeDevice - The Data Box Edge/Gateway device.
type DataBoxEdgeDevice struct {
	ARMBaseModel
	// REQUIRED; The location of the device. This is a supported and registered Azure geographical region (for example, West US, East US, or Southeast Asia).
	// The geographical region of a device cannot be changed once
	// it is created, but if an identical geographical region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`

	// The etag for the devices.
	Etag *string `json:"etag,omitempty"`

	// Msi identity of the resource
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// The kind of the device.
	Kind *DataBoxEdgeDeviceKind `json:"kind,omitempty"`

	// The properties of the Data Box Edge/Gateway device.
	Properties *DataBoxEdgeDeviceProperties `json:"properties,omitempty"`

	// The SKU type.
	SKU *SKU `json:"sku,omitempty"`

	// The list of tags that describe the device. These tags can be used to view and group this device (across resource groups).
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; DataBoxEdge Resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeDevice.
func (d DataBoxEdgeDevice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "sku", d.SKU)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxEdgeDevice.
func (d *DataBoxEdgeDevice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &d.Identity)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &d.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxEdgeDeviceExtendedInfo - The extended Info of the Data Box Edge/Gateway device.
type DataBoxEdgeDeviceExtendedInfo struct {
	ARMBaseModel
	// The extended info properties.
	Properties *DataBoxEdgeDeviceExtendedInfoProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeDeviceExtendedInfo.
func (d DataBoxEdgeDeviceExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataBoxEdgeDeviceExtendedInfo.
func (d *DataBoxEdgeDeviceExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataBoxEdgeDeviceExtendedInfoPatch - The Data Box Edge/Gateway device extended info patch.
type DataBoxEdgeDeviceExtendedInfoPatch struct {
	// The name for Channel Integrity Key stored in the Client Key Vault
	ChannelIntegrityKeyName *string `json:"channelIntegrityKeyName,omitempty"`

	// The version of Channel Integrity Key stored in the Client Key Vault
	ChannelIntegrityKeyVersion *string `json:"channelIntegrityKeyVersion,omitempty"`

	// The Key Vault ARM Id for client secrets
	ClientSecretStoreID *string `json:"clientSecretStoreId,omitempty"`

	// The url to access the Client Key Vault
	ClientSecretStoreURL *string `json:"clientSecretStoreUrl,omitempty"`

	// For changing or to initiate the resync to key-vault set the status to KeyVaultSyncPending, rest of the status will not be applicable.
	SyncStatus *KeyVaultSyncStatus `json:"syncStatus,omitempty"`
}

// DataBoxEdgeDeviceExtendedInfoProperties - The properties of the Data Box Edge/Gateway device extended info.
type DataBoxEdgeDeviceExtendedInfoProperties struct {
	// The name of Channel Integrity Key stored in the Client Key Vault
	ChannelIntegrityKeyName *string `json:"channelIntegrityKeyName,omitempty"`

	// The version of Channel Integrity Key stored in the Client Key Vault
	ChannelIntegrityKeyVersion *string `json:"channelIntegrityKeyVersion,omitempty"`

	// The Key Vault ARM Id for client secrets
	ClientSecretStoreID *string `json:"clientSecretStoreId,omitempty"`

	// The url to access the Client Key Vault
	ClientSecretStoreURL *string `json:"clientSecretStoreUrl,omitempty"`

	// The public part of the encryption certificate. Client uses this to encrypt any secret.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// The digital signature of encrypted certificate.
	EncryptionKeyThumbprint *string `json:"encryptionKeyThumbprint,omitempty"`

	// Key vault sync status
	KeyVaultSyncStatus *KeyVaultSyncStatus `json:"keyVaultSyncStatus,omitempty"`

	// READ-ONLY; Device secrets, will be returned only with ODataFilter $expand=deviceSecrets
	DeviceSecrets map[string]*Secret `json:"deviceSecrets,omitempty" azure:"ro"`

	// READ-ONLY; The Resource ID of the Resource.
	ResourceKey *string `json:"resourceKey,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeDeviceExtendedInfoProperties.
func (d DataBoxEdgeDeviceExtendedInfoProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelIntegrityKeyName", d.ChannelIntegrityKeyName)
	populate(objectMap, "channelIntegrityKeyVersion", d.ChannelIntegrityKeyVersion)
	populate(objectMap, "clientSecretStoreId", d.ClientSecretStoreID)
	populate(objectMap, "clientSecretStoreUrl", d.ClientSecretStoreURL)
	populate(objectMap, "deviceSecrets", d.DeviceSecrets)
	populate(objectMap, "encryptionKey", d.EncryptionKey)
	populate(objectMap, "encryptionKeyThumbprint", d.EncryptionKeyThumbprint)
	populate(objectMap, "keyVaultSyncStatus", d.KeyVaultSyncStatus)
	populate(objectMap, "resourceKey", d.ResourceKey)
	return json.Marshal(objectMap)
}

// DataBoxEdgeDeviceList - The collection of Data Box Edge/Gateway devices.
type DataBoxEdgeDeviceList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of Data Box Edge/Gateway devices.
	Value []*DataBoxEdgeDevice `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeDeviceList.
func (d DataBoxEdgeDeviceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataBoxEdgeDevicePatch - The Data Box Edge/Gateway device patch.
type DataBoxEdgeDevicePatch struct {
	// Msi identity of the resource
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// The properties associated with the Data Box Edge/Gateway resource
	Properties *DataBoxEdgeDevicePropertiesPatch `json:"properties,omitempty"`

	// The tags attached to the Data Box Edge/Gateway resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeDevicePatch.
func (d DataBoxEdgeDevicePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DataBoxEdgeDeviceProperties - The properties of the Data Box Edge/Gateway device.
type DataBoxEdgeDeviceProperties struct {
	// The status of the Data Box Edge/Gateway device.
	DataBoxEdgeDeviceStatus *DataBoxEdgeDeviceStatus `json:"dataBoxEdgeDeviceStatus,omitempty"`

	// The details of data-residency related properties for this resource
	DataResidency *DataResidency `json:"dataResidency,omitempty"`

	// READ-ONLY; Type of compute roles configured.
	ConfiguredRoleTypes []*RoleTypes `json:"configuredRoleTypes,omitempty" azure:"ro"`

	// READ-ONLY; The Data Box Edge/Gateway device culture.
	Culture *string `json:"culture,omitempty" azure:"ro"`

	// READ-ONLY; The Description of the Data Box Edge/Gateway device.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The device software version number of the device (eg: 1.2.18105.6).
	DeviceHcsVersion *string `json:"deviceHcsVersion,omitempty" azure:"ro"`

	// READ-ONLY; The Data Box Edge/Gateway device local capacity in MB.
	DeviceLocalCapacity *int64 `json:"deviceLocalCapacity,omitempty" azure:"ro"`

	// READ-ONLY; The Data Box Edge/Gateway device model.
	DeviceModel *string `json:"deviceModel,omitempty" azure:"ro"`

	// READ-ONLY; The Data Box Edge/Gateway device software version.
	DeviceSoftwareVersion *string `json:"deviceSoftwareVersion,omitempty" azure:"ro"`

	// READ-ONLY; The type of the Data Box Edge/Gateway device.
	DeviceType *DeviceType `json:"deviceType,omitempty" azure:"ro"`

	// READ-ONLY; The details of Edge Profile for this resource
	EdgeProfile *EdgeProfile `json:"edgeProfile,omitempty" azure:"ro"`

	// READ-ONLY; The Data Box Edge/Gateway device name.
	FriendlyName *string `json:"friendlyName,omitempty" azure:"ro"`

	// READ-ONLY; The description of the Data Box Edge/Gateway device model.
	ModelDescription *string `json:"modelDescription,omitempty" azure:"ro"`

	// READ-ONLY; The number of nodes in the cluster.
	NodeCount *int32 `json:"nodeCount,omitempty" azure:"ro"`

	// READ-ONLY; The details of the move operation on this resource.
	ResourceMoveDetails *ResourceMoveDetails `json:"resourceMoveDetails,omitempty" azure:"ro"`

	// READ-ONLY; The Serial Number of Data Box Edge/Gateway device.
	SerialNumber *string `json:"serialNumber,omitempty" azure:"ro"`

	// READ-ONLY; DataBoxEdge Device Properties
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The Data Box Edge/Gateway device timezone.
	TimeZone *string `json:"timeZone,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeDeviceProperties.
func (d DataBoxEdgeDeviceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configuredRoleTypes", d.ConfiguredRoleTypes)
	populate(objectMap, "culture", d.Culture)
	populate(objectMap, "dataBoxEdgeDeviceStatus", d.DataBoxEdgeDeviceStatus)
	populate(objectMap, "dataResidency", d.DataResidency)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "deviceHcsVersion", d.DeviceHcsVersion)
	populate(objectMap, "deviceLocalCapacity", d.DeviceLocalCapacity)
	populate(objectMap, "deviceModel", d.DeviceModel)
	populate(objectMap, "deviceSoftwareVersion", d.DeviceSoftwareVersion)
	populate(objectMap, "deviceType", d.DeviceType)
	populate(objectMap, "edgeProfile", d.EdgeProfile)
	populate(objectMap, "friendlyName", d.FriendlyName)
	populate(objectMap, "modelDescription", d.ModelDescription)
	populate(objectMap, "nodeCount", d.NodeCount)
	populate(objectMap, "resourceMoveDetails", d.ResourceMoveDetails)
	populate(objectMap, "serialNumber", d.SerialNumber)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "timeZone", d.TimeZone)
	return json.Marshal(objectMap)
}

// DataBoxEdgeDevicePropertiesPatch - The Data Box Edge/Gateway device properties patch.
type DataBoxEdgeDevicePropertiesPatch struct {
	// Edge Profile property of the Data Box Edge/Gateway device
	EdgeProfile *EdgeProfilePatch `json:"edgeProfile,omitempty"`
}

// DataBoxEdgeMoveRequest - Resource Move details
type DataBoxEdgeMoveRequest struct {
	// REQUIRED; List of resources to be moved
	Resources []*string `json:"resources,omitempty"`

	// REQUIRED; Target resource group ARMId
	TargetResourceGroup *string `json:"targetResourceGroup,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeMoveRequest.
func (d DataBoxEdgeMoveRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "resources", d.Resources)
	populate(objectMap, "targetResourceGroup", d.TargetResourceGroup)
	return json.Marshal(objectMap)
}

// DataBoxEdgeSKU - The Sku information.
type DataBoxEdgeSKU struct {
	// READ-ONLY; The API versions in which Sku is available.
	APIVersions []*string `json:"apiVersions,omitempty" azure:"ro"`

	// READ-ONLY; Links to the next set of results
	Availability *SKUAvailability `json:"availability,omitempty" azure:"ro"`

	// READ-ONLY; The capability info of the SKU.
	Capabilities []*SKUCapability `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; The pricing info of the Sku.
	Costs []*SKUCost `json:"costs,omitempty" azure:"ro"`

	// READ-ONLY; The Sku family.
	Family *string `json:"family,omitempty" azure:"ro"`

	// READ-ONLY; The Sku kind.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; Availability of the Sku for the location/zone/site.
	LocationInfo []*SKULocationInfo `json:"locationInfo,omitempty" azure:"ro"`

	// READ-ONLY; Availability of the Sku for the region.
	Locations []*string `json:"locations,omitempty" azure:"ro"`

	// READ-ONLY; The Sku name.
	Name *SKUName `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; List of Shipment Types supported by this SKU
	ShipmentTypes []*ShipmentType `json:"shipmentTypes,omitempty" azure:"ro"`

	// READ-ONLY; Sku can be signed up by customer or not.
	SignupOption *SKUSignupOption `json:"signupOption,omitempty" azure:"ro"`

	// READ-ONLY; The Sku kind.
	Size *string `json:"size,omitempty" azure:"ro"`

	// READ-ONLY; The Sku tier.
	Tier *SKUTier `json:"tier,omitempty" azure:"ro"`

	// READ-ONLY; Availability of the Sku as preview/stable.
	Version *SKUVersion `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeSKU.
func (d DataBoxEdgeSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersions", d.APIVersions)
	populate(objectMap, "availability", d.Availability)
	populate(objectMap, "capabilities", d.Capabilities)
	populate(objectMap, "costs", d.Costs)
	populate(objectMap, "family", d.Family)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "locationInfo", d.LocationInfo)
	populate(objectMap, "locations", d.Locations)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "resourceType", d.ResourceType)
	populate(objectMap, "shipmentTypes", d.ShipmentTypes)
	populate(objectMap, "signupOption", d.SignupOption)
	populate(objectMap, "size", d.Size)
	populate(objectMap, "tier", d.Tier)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// DataBoxEdgeSKUList - List of SKU Information objects.
type DataBoxEdgeSKUList struct {
	// READ-ONLY; Links to the next set of results
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of ResourceType Sku
	Value []*DataBoxEdgeSKU `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataBoxEdgeSKUList.
func (d DataBoxEdgeSKUList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataResidency - Wraps data-residency related information for edge-resource and this should be used with ARM layer.
type DataResidency struct {
	// DataResidencyType enum
	Type *DataResidencyType `json:"type,omitempty"`
}

// DevicesBeginCreateOrUpdateSecuritySettingsOptions contains the optional parameters for the Devices.BeginCreateOrUpdateSecuritySettings method.
type DevicesBeginCreateOrUpdateSecuritySettingsOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginDeleteOptions contains the optional parameters for the Devices.BeginDelete method.
type DevicesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginDownloadUpdatesOptions contains the optional parameters for the Devices.BeginDownloadUpdates method.
type DevicesBeginDownloadUpdatesOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginInstallUpdatesOptions contains the optional parameters for the Devices.BeginInstallUpdates method.
type DevicesBeginInstallUpdatesOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginScanForUpdatesOptions contains the optional parameters for the Devices.BeginScanForUpdates method.
type DevicesBeginScanForUpdatesOptions struct {
	// placeholder for future optional parameters
}

// DevicesCreateOrUpdateOptions contains the optional parameters for the Devices.CreateOrUpdate method.
type DevicesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DevicesGenerateCertificateOptions contains the optional parameters for the Devices.GenerateCertificate method.
type DevicesGenerateCertificateOptions struct {
	// placeholder for future optional parameters
}

// DevicesGetExtendedInformationOptions contains the optional parameters for the Devices.GetExtendedInformation method.
type DevicesGetExtendedInformationOptions struct {
	// placeholder for future optional parameters
}

// DevicesGetNetworkSettingsOptions contains the optional parameters for the Devices.GetNetworkSettings method.
type DevicesGetNetworkSettingsOptions struct {
	// placeholder for future optional parameters
}

// DevicesGetOptions contains the optional parameters for the Devices.Get method.
type DevicesGetOptions struct {
	// placeholder for future optional parameters
}

// DevicesGetUpdateSummaryOptions contains the optional parameters for the Devices.GetUpdateSummary method.
type DevicesGetUpdateSummaryOptions struct {
	// placeholder for future optional parameters
}

// DevicesListByResourceGroupOptions contains the optional parameters for the Devices.ListByResourceGroup method.
type DevicesListByResourceGroupOptions struct {
	// Specify $expand=details to populate additional fields related to the resource or Specify $skipToken=<token> to populate the next page in the list.
	Expand *string
}

// DevicesListBySubscriptionOptions contains the optional parameters for the Devices.ListBySubscription method.
type DevicesListBySubscriptionOptions struct {
	// Specify $expand=details to populate additional fields related to the resource or Specify $skipToken=<token> to populate the next page in the list.
	Expand *string
}

// DevicesUpdateExtendedInformationOptions contains the optional parameters for the Devices.UpdateExtendedInformation method.
type DevicesUpdateExtendedInformationOptions struct {
	// placeholder for future optional parameters
}

// DevicesUpdateOptions contains the optional parameters for the Devices.Update method.
type DevicesUpdateOptions struct {
	// placeholder for future optional parameters
}

// DevicesUploadCertificateOptions contains the optional parameters for the Devices.UploadCertificate method.
type DevicesUploadCertificateOptions struct {
	// placeholder for future optional parameters
}

// DiagnosticProactiveLogCollectionSettings - The diagnostic proactive log collection settings of a device.
type DiagnosticProactiveLogCollectionSettings struct {
	ARMBaseModel
	// REQUIRED; Properties of the diagnostic proactive log collection settings.
	Properties *ProactiveLogCollectionSettingsProperties `json:"properties,omitempty"`

	// READ-ONLY; DiagnosticProactiveLogCollectionSettings
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticProactiveLogCollectionSettings.
func (d DiagnosticProactiveLogCollectionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiagnosticProactiveLogCollectionSettings.
func (d *DiagnosticProactiveLogCollectionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DiagnosticRemoteSupportSettings - The remote support settings of a device.
type DiagnosticRemoteSupportSettings struct {
	ARMBaseModel
	// REQUIRED; Properties of the remote support settings.
	Properties *DiagnosticRemoteSupportSettingsProperties `json:"properties,omitempty"`

	// READ-ONLY; DiagnosticRemoteSupportSettings
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticRemoteSupportSettings.
func (d DiagnosticRemoteSupportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiagnosticRemoteSupportSettings.
func (d *DiagnosticRemoteSupportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DiagnosticRemoteSupportSettingsProperties - The properties of remote support settings.
type DiagnosticRemoteSupportSettingsProperties struct {
	// Remote support settings list according to the RemoteApplicationType
	RemoteSupportSettingsList []*RemoteSupportSettings `json:"remoteSupportSettingsList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticRemoteSupportSettingsProperties.
func (d DiagnosticRemoteSupportSettingsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "remoteSupportSettingsList", d.RemoteSupportSettingsList)
	return json.Marshal(objectMap)
}

// DiagnosticSettingsBeginUpdateDiagnosticProactiveLogCollectionSettingsOptions contains the optional parameters for the DiagnosticSettings.BeginUpdateDiagnosticProactiveLogCollectionSettings
// method.
type DiagnosticSettingsBeginUpdateDiagnosticProactiveLogCollectionSettingsOptions struct {
	// placeholder for future optional parameters
}

// DiagnosticSettingsBeginUpdateDiagnosticRemoteSupportSettingsOptions contains the optional parameters for the DiagnosticSettings.BeginUpdateDiagnosticRemoteSupportSettings
// method.
type DiagnosticSettingsBeginUpdateDiagnosticRemoteSupportSettingsOptions struct {
	// placeholder for future optional parameters
}

// DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsOptions contains the optional parameters for the DiagnosticSettings.GetDiagnosticProactiveLogCollectionSettings
// method.
type DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsOptions struct {
	// placeholder for future optional parameters
}

// DiagnosticSettingsGetDiagnosticRemoteSupportSettingsOptions contains the optional parameters for the DiagnosticSettings.GetDiagnosticRemoteSupportSettings
// method.
type DiagnosticSettingsGetDiagnosticRemoteSupportSettingsOptions struct {
	// placeholder for future optional parameters
}

// EdgeProfile - Details about Edge Profile for the resource
type EdgeProfile struct {
	// Edge Profile Subscription
	Subscription *EdgeProfileSubscription `json:"subscription,omitempty"`
}

// EdgeProfilePatch - The Data Box Edge/Gateway Edge Profile patch.
type EdgeProfilePatch struct {
	// The Data Box Edge/Gateway Edge Profile Subscription patch
	Subscription *EdgeProfileSubscriptionPatch `json:"subscription,omitempty"`
}

// EdgeProfileSubscription - Subscription details for the Edge Profile
type EdgeProfileSubscription struct {
	// ARM ID of the subscription
	ID               *string                 `json:"id,omitempty"`
	Properties       *SubscriptionProperties `json:"properties,omitempty"`
	RegistrationDate *string                 `json:"registrationDate,omitempty"`

	// Edge Subscription Registration ID
	RegistrationID *string            `json:"registrationId,omitempty"`
	State          *SubscriptionState `json:"state,omitempty"`
	SubscriptionID *string            `json:"subscriptionId,omitempty"`
}

// EdgeProfileSubscriptionPatch - The Data Box Edge/Gateway Edge Profile Subscription patch.
type EdgeProfileSubscriptionPatch struct {
	// The path ID that uniquely identifies the subscription of the edge profile.
	ID *string `json:"id,omitempty"`
}

// EtcdInfo - Etcd configuration
type EtcdInfo struct {
	// READ-ONLY; Etcd type
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; Etcd version
	Version *string `json:"version,omitempty" azure:"ro"`
}

// FileEventTrigger - Trigger details.
type FileEventTrigger struct {
	Trigger
	// REQUIRED; File trigger properties.
	Properties *FileTriggerProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileEventTrigger.
func (f FileEventTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.Trigger.marshalInternal(objectMap, TriggerEventTypeFileEvent)
	populate(objectMap, "properties", f.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileEventTrigger.
func (f *FileEventTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := f.Trigger.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// FileSourceInfo - File source details.
type FileSourceInfo struct {
	// REQUIRED; File share ID.
	ShareID *string `json:"shareId,omitempty"`
}

// FileTriggerProperties - File trigger properties.
type FileTriggerProperties struct {
	// REQUIRED; Role sink info.
	SinkInfo *RoleSinkInfo `json:"sinkInfo,omitempty"`

	// REQUIRED; File event source details.
	SourceInfo *FileSourceInfo `json:"sourceInfo,omitempty"`

	// A custom context tag typically used to correlate the trigger against its usage. For example, if a periodic timer trigger is intended for certain specific
	// IoT modules in the device, the tag can be the
	// name or the image URL of the module.
	CustomContextTag *string `json:"customContextTag,omitempty"`
}

// GenerateCertResponse - Used in activation key generation flow.
type GenerateCertResponse struct {
	// Gets or sets expiry time in UTC
	ExpiryTimeInUTC *string `json:"expiryTimeInUTC,omitempty"`

	// Gets or sets base64 encoded private part of the certificate, needed to form the activation key
	PrivateKey *string `json:"privateKey,omitempty"`

	// Gets or sets base64 encoded certificate raw data, this is the public part needed to be uploaded to cert vault
	PublicKey *string `json:"publicKey,omitempty"`
}

// IPv4Config - Details related to the IPv4 address configuration.
type IPv4Config struct {
	// READ-ONLY; The IPv4 gateway of the network adapter.
	Gateway *string `json:"gateway,omitempty" azure:"ro"`

	// READ-ONLY; The IPv4 address of the network adapter.
	IPAddress *string `json:"ipAddress,omitempty" azure:"ro"`

	// READ-ONLY; The IPv4 subnet of the network adapter.
	Subnet *string `json:"subnet,omitempty" azure:"ro"`
}

// IPv6Config - Details related to the IPv6 address configuration.
type IPv6Config struct {
	// READ-ONLY; The IPv6 gateway of the network adapter.
	Gateway *string `json:"gateway,omitempty" azure:"ro"`

	// READ-ONLY; The IPv6 address of the network adapter.
	IPAddress *string `json:"ipAddress,omitempty" azure:"ro"`

	// READ-ONLY; The IPv6 prefix of the network adapter.
	PrefixLength *int32 `json:"prefixLength,omitempty" azure:"ro"`
}

// ImageRepositoryCredential - Image repository credential.
type ImageRepositoryCredential struct {
	// REQUIRED; Image repository url (e.g.: mcr.microsoft.com).
	ImageRepositoryURL *string `json:"imageRepositoryUrl,omitempty"`

	// REQUIRED; Repository user name.
	UserName *string `json:"userName,omitempty"`

	// Repository user password.
	Password *AsymmetricEncryptedSecret `json:"password,omitempty"`
}

// IoTAddon - IoT Addon.
type IoTAddon struct {
	Addon
	// REQUIRED; Properties specific to IOT addon.
	Properties *IoTAddonProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IoTAddon.
func (i IoTAddon) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.Addon.marshalInternal(objectMap, AddonTypeIotEdge)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTAddon.
func (i *IoTAddon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.Addon.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// IoTAddonProperties - IoT addon properties.
type IoTAddonProperties struct {
	// REQUIRED; IoT device metadata to which appliance needs to be connected.
	IoTDeviceDetails *IoTDeviceInfo `json:"ioTDeviceDetails,omitempty"`

	// REQUIRED; IoT edge device to which the IoT Addon needs to be configured.
	IoTEdgeDeviceDetails *IoTDeviceInfo `json:"ioTEdgeDeviceDetails,omitempty"`

	// READ-ONLY; Host OS supported by the IoT addon.
	HostPlatform *PlatformType `json:"hostPlatform,omitempty" azure:"ro"`

	// READ-ONLY; Platform where the runtime is hosted.
	HostPlatformType *HostPlatformType `json:"hostPlatformType,omitempty" azure:"ro"`

	// READ-ONLY; Addon Provisioning State
	ProvisioningState *AddonState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Version of IoT running on the appliance.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// IoTDeviceInfo - Metadata of IoT device/IoT Edge device to be configured.
type IoTDeviceInfo struct {
	// REQUIRED; ID of the IoT device/edge device.
	DeviceID *string `json:"deviceId,omitempty"`

	// REQUIRED; Host name for the IoT hub associated to the device.
	IoTHostHub *string `json:"ioTHostHub,omitempty"`

	// Encrypted IoT device/IoT edge device connection string.
	Authentication *Authentication `json:"authentication,omitempty"`

	// Id for the IoT hub associated to the device.
	IoTHostHubID *string `json:"ioTHostHubId,omitempty"`
}

// IoTEdgeAgentInfo - IoT edge agent details is optional, this will be used for download system Agent module while bootstrapping IoT Role if specified.
type IoTEdgeAgentInfo struct {
	// REQUIRED; Name of the IoT edge agent image.
	ImageName *string `json:"imageName,omitempty"`

	// REQUIRED; Image Tag.
	Tag *string `json:"tag,omitempty"`

	// Image repository details.
	ImageRepository *ImageRepositoryCredential `json:"imageRepository,omitempty"`
}

// IoTRole - Compute role.
type IoTRole struct {
	Role
	// Properties specific to IoT role.
	Properties *IoTRoleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IoTRole.
func (i IoTRole) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.Role.marshalInternal(objectMap, RoleTypesIOT)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTRole.
func (i *IoTRole) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.Role.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// IoTRoleProperties - IoT role properties.
type IoTRoleProperties struct {
	// REQUIRED; Host OS supported by the IoT role.
	HostPlatform *PlatformType `json:"hostPlatform,omitempty"`

	// REQUIRED; IoT device metadata to which data box edge device needs to be connected.
	IoTDeviceDetails *IoTDeviceInfo `json:"ioTDeviceDetails,omitempty"`

	// REQUIRED; IoT edge device to which the IoT role needs to be configured.
	IoTEdgeDeviceDetails *IoTDeviceInfo `json:"ioTEdgeDeviceDetails,omitempty"`

	// REQUIRED; Role status.
	RoleStatus *RoleStatus `json:"roleStatus,omitempty"`

	// Resource allocation
	ComputeResource *ComputeResource `json:"computeResource,omitempty"`

	// Iot edge agent details to download the agent and bootstrap iot runtime.
	IoTEdgeAgentInfo *IoTEdgeAgentInfo `json:"ioTEdgeAgentInfo,omitempty"`

	// Mount points of shares in role(s).
	ShareMappings []*MountPointMap `json:"shareMappings,omitempty"`

	// READ-ONLY; Platform where the Iot runtime is hosted.
	HostPlatformType *HostPlatformType `json:"hostPlatformType,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IoTRoleProperties.
func (i IoTRoleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeResource", i.ComputeResource)
	populate(objectMap, "hostPlatform", i.HostPlatform)
	populate(objectMap, "hostPlatformType", i.HostPlatformType)
	populate(objectMap, "ioTDeviceDetails", i.IoTDeviceDetails)
	populate(objectMap, "ioTEdgeAgentInfo", i.IoTEdgeAgentInfo)
	populate(objectMap, "ioTEdgeDeviceDetails", i.IoTEdgeDeviceDetails)
	populate(objectMap, "roleStatus", i.RoleStatus)
	populate(objectMap, "shareMappings", i.ShareMappings)
	return json.Marshal(objectMap)
}

// Job - A device job.
type Job struct {
	// READ-ONLY; The UTC date and time at which the job completed.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Error *JobErrorDetails `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; The path ID that uniquely identifies the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The percentage of the job that is complete.
	PercentComplete *int32 `json:"percentComplete,omitempty" azure:"ro"`

	// READ-ONLY; The properties of the job.
	Properties *JobProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which the job started.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The current status of the job.
	Status *JobStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; The hierarchical type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "percentComplete", j.PercentComplete)
	populate(objectMap, "properties", j.Properties)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Job.
func (j *Job) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &j.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &j.Name)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, &j.PercentComplete)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobErrorDetails - The job error information containing the list of job errors.
type JobErrorDetails struct {
	// READ-ONLY; The code intended for programmatic access.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	ErrorDetails []*JobErrorItem `json:"errorDetails,omitempty" azure:"ro"`

	// READ-ONLY; The message that describes the error in detail.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobErrorDetails.
func (j JobErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", j.Code)
	populate(objectMap, "errorDetails", j.ErrorDetails)
	populate(objectMap, "message", j.Message)
	return json.Marshal(objectMap)
}

// JobErrorItem - The job error items.
type JobErrorItem struct {
	// READ-ONLY; The code intended for programmatic access.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The message that describes the error in detail.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The recommended actions.
	Recommendations []*string `json:"recommendations,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobErrorItem.
func (j JobErrorItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", j.Code)
	populate(objectMap, "message", j.Message)
	populate(objectMap, "recommendations", j.Recommendations)
	return json.Marshal(objectMap)
}

// JobProperties - The properties for the job.
type JobProperties struct {
	// If only subfolders need to be refreshed, then the subfolder path inside the share or container. (The path is empty if there are no subfolders.)
	Folder *string `json:"folder,omitempty"`

	// READ-ONLY; Current stage of the update operation.
	CurrentStage *UpdateOperationStage `json:"currentStage,omitempty" azure:"ro"`

	// READ-ONLY; The download progress.
	DownloadProgress *UpdateDownloadProgress `json:"downloadProgress,omitempty" azure:"ro"`

	// READ-ONLY; Local share/remote container relative path to the error manifest file of the refresh.
	ErrorManifestFile *string `json:"errorManifestFile,omitempty" azure:"ro"`

	// READ-ONLY; The install progress.
	InstallProgress *UpdateInstallProgress `json:"installProgress,omitempty" azure:"ro"`

	// READ-ONLY; The type of the job.
	JobType *JobType `json:"jobType,omitempty" azure:"ro"`

	// READ-ONLY; ARM ID of the entity that was refreshed.
	RefreshedEntityID *string `json:"refreshedEntityId,omitempty" azure:"ro"`

	// READ-ONLY; Total number of errors encountered during the refresh process.
	TotalRefreshErrors *int32 `json:"totalRefreshErrors,omitempty" azure:"ro"`
}

// JobsGetOptions contains the optional parameters for the Jobs.Get method.
type JobsGetOptions struct {
	// placeholder for future optional parameters
}

// KubernetesClusterInfo - Kubernetes cluster configuration
type KubernetesClusterInfo struct {
	// REQUIRED; Kubernetes cluster version
	Version *string `json:"version,omitempty"`

	// READ-ONLY; Etcd configuration
	EtcdInfo *EtcdInfo `json:"etcdInfo,omitempty" azure:"ro"`

	// READ-ONLY; Kubernetes cluster nodes
	Nodes []*NodeInfo `json:"nodes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesClusterInfo.
func (k KubernetesClusterInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etcdInfo", k.EtcdInfo)
	populate(objectMap, "nodes", k.Nodes)
	populate(objectMap, "version", k.Version)
	return json.Marshal(objectMap)
}

// KubernetesIPConfiguration - Kubernetes node IP configuration
type KubernetesIPConfiguration struct {
	// IP address of the Kubernetes node.
	IPAddress *string `json:"ipAddress,omitempty"`

	// READ-ONLY; Port of the Kubernetes node.
	Port *string `json:"port,omitempty" azure:"ro"`
}

// KubernetesRole - Kubernetes role.
type KubernetesRole struct {
	Role
	// Properties specific to Kubernetes role.
	Properties *KubernetesRoleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesRole.
func (k KubernetesRole) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	k.Role.marshalInternal(objectMap, RoleTypesKubernetes)
	populate(objectMap, "properties", k.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesRole.
func (k *KubernetesRole) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &k.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := k.Role.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// KubernetesRoleCompute - Kubernetes role compute resource
type KubernetesRoleCompute struct {
	// REQUIRED; VM profile
	VMProfile *string `json:"vmProfile,omitempty"`

	// READ-ONLY; Memory in bytes
	MemoryInBytes *int64 `json:"memoryInBytes,omitempty" azure:"ro"`

	// READ-ONLY; Processor count
	ProcessorCount *int32 `json:"processorCount,omitempty" azure:"ro"`
}

// KubernetesRoleNetwork - Kubernetes role network resource
type KubernetesRoleNetwork struct {
	// READ-ONLY; Cni configuration
	CniConfig *CniConfig `json:"cniConfig,omitempty" azure:"ro"`

	// READ-ONLY; Load balancer configuration
	LoadBalancerConfig *LoadBalancerConfig `json:"loadBalancerConfig,omitempty" azure:"ro"`
}

// KubernetesRoleProperties - Kubernetes role properties.
type KubernetesRoleProperties struct {
	// REQUIRED; Host OS supported by the Kubernetes role.
	HostPlatform *PlatformType `json:"hostPlatform,omitempty"`

	// REQUIRED; Kubernetes cluster configuration
	KubernetesClusterInfo *KubernetesClusterInfo `json:"kubernetesClusterInfo,omitempty"`

	// REQUIRED; Kubernetes role resources
	KubernetesRoleResources *KubernetesRoleResources `json:"kubernetesRoleResources,omitempty"`

	// REQUIRED; Role status.
	RoleStatus *RoleStatus `json:"roleStatus,omitempty"`

	// READ-ONLY; Platform where the runtime is hosted.
	HostPlatformType *HostPlatformType `json:"hostPlatformType,omitempty" azure:"ro"`

	// READ-ONLY; State of Kubernetes deployment
	ProvisioningState *KubernetesState `json:"provisioningState,omitempty" azure:"ro"`
}

// KubernetesRoleResources - Kubernetes role resources
type KubernetesRoleResources struct {
	// REQUIRED; Kubernetes role compute resource
	Compute *KubernetesRoleCompute `json:"compute,omitempty"`

	// Kubernetes role storage resource
	Storage *KubernetesRoleStorage `json:"storage,omitempty"`

	// READ-ONLY; Kubernetes role network resource
	Network *KubernetesRoleNetwork `json:"network,omitempty" azure:"ro"`
}

// KubernetesRoleStorage - Kubernetes role storage resource
type KubernetesRoleStorage struct {
	// Mount points of shares in role(s).
	Endpoints []*MountPointMap `json:"endpoints,omitempty"`

	// READ-ONLY; Kubernetes storage class info.
	StorageClasses []*KubernetesRoleStorageClassInfo `json:"storageClasses,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesRoleStorage.
func (k KubernetesRoleStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "endpoints", k.Endpoints)
	populate(objectMap, "storageClasses", k.StorageClasses)
	return json.Marshal(objectMap)
}

// KubernetesRoleStorageClassInfo - Kubernetes storage class info.
type KubernetesRoleStorageClassInfo struct {
	// READ-ONLY; Storage class name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; If provisioned storage is posix compliant.
	PosixCompliant *PosixComplianceStatus `json:"posixCompliant,omitempty" azure:"ro"`

	// READ-ONLY; Storage class type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// LoadBalancerConfig - Load balancer configuration
type LoadBalancerConfig struct {
	// READ-ONLY; Load balancer type
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; Load balancer version
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MECRole - MEC role.
type MECRole struct {
	Role
	// Properties specific to MEC role.
	Properties *MECRoleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MECRole.
func (m MECRole) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.Role.marshalInternal(objectMap, RoleTypesMEC)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MECRole.
func (m *MECRole) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.Role.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MECRoleProperties - MEC role properties.
type MECRoleProperties struct {
	// REQUIRED; Role status.
	RoleStatus *RoleStatus `json:"roleStatus,omitempty"`

	// Activation key of the MEC.
	ConnectionString *AsymmetricEncryptedSecret `json:"connectionString,omitempty"`

	// Controller Endpoint.
	ControllerEndpoint *string `json:"controllerEndpoint,omitempty"`

	// Unique Id of the Resource.
	ResourceUniqueID *string `json:"resourceUniqueId,omitempty"`
}

// MetricConfiguration - Metric configuration.
type MetricConfiguration struct {
	// REQUIRED; Host name for the IoT hub associated to the device.
	CounterSets []*MetricCounterSet `json:"counterSets,omitempty"`

	// REQUIRED; The Resource ID on which the metrics should be pushed.
	ResourceID *string `json:"resourceId,omitempty"`

	// The MDM account to which the counters should be pushed.
	MdmAccount *string `json:"mdmAccount,omitempty"`

	// The MDM namespace to which the counters should be pushed. This is required if MDMAccount is specified
	MetricNameSpace *string `json:"metricNameSpace,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricConfiguration.
func (m MetricConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "counterSets", m.CounterSets)
	populate(objectMap, "mdmAccount", m.MdmAccount)
	populate(objectMap, "metricNameSpace", m.MetricNameSpace)
	populate(objectMap, "resourceId", m.ResourceID)
	return json.Marshal(objectMap)
}

// MetricCounter - The metric counter
type MetricCounter struct {
	// REQUIRED; The counter name.
	Name *string `json:"name,omitempty"`

	// The additional dimensions to be added to metric.
	AdditionalDimensions []*MetricDimension `json:"additionalDimensions,omitempty"`

	// The dimension filter.
	DimensionFilter []*MetricDimension `json:"dimensionFilter,omitempty"`

	// The instance from which counter should be collected.
	Instance *string `json:"instance,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricCounter.
func (m MetricCounter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalDimensions", m.AdditionalDimensions)
	populate(objectMap, "dimensionFilter", m.DimensionFilter)
	populate(objectMap, "instance", m.Instance)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// MetricCounterSet - The metric counter set
type MetricCounterSet struct {
	// REQUIRED; The counters that should be collected in this set.
	Counters []*MetricCounter `json:"counters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricCounterSet.
func (m MetricCounterSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "counters", m.Counters)
	return json.Marshal(objectMap)
}

// MetricDimension - The metric dimension
type MetricDimension struct {
	// REQUIRED; The dimension value.
	SourceName *string `json:"sourceName,omitempty"`

	// REQUIRED; The dimension type.
	SourceType *string `json:"sourceType,omitempty"`
}

// MetricDimensionV1 - Metric Dimension v1.
type MetricDimensionV1 struct {
	// Display name of the metrics dimension.
	DisplayName *string `json:"displayName,omitempty"`

	// Name of the metrics dimension.
	Name *string `json:"name,omitempty"`

	// To be exported to shoe box.
	ToBeExportedForShoebox *bool `json:"toBeExportedForShoebox,omitempty"`
}

// MetricSpecificationV1 - Metric specification version 1.
type MetricSpecificationV1 struct {
	// Metric aggregation type.
	AggregationType *MetricAggregationType `json:"aggregationType,omitempty"`

	// Metric category.
	Category *MetricCategory `json:"category,omitempty"`

	// Metric dimensions, other than default dimension which is resource.
	Dimensions []*MetricDimensionV1 `json:"dimensions,omitempty"`

	// Description of the metric to be displayed.
	DisplayDescription *string `json:"displayDescription,omitempty"`

	// Display name of the metric.
	DisplayName *string `json:"displayName,omitempty"`

	// Set true to fill the gaps with zero.
	FillGapWithZero *bool `json:"fillGapWithZero,omitempty"`

	// Name of the metric.
	Name *string `json:"name,omitempty"`

	// Resource name override.
	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`

	// Support metric aggregation type.
	SupportedAggregationTypes []*MetricAggregationType `json:"supportedAggregationTypes,omitempty"`

	// Support granularity of metrics.
	SupportedTimeGrainTypes []*TimeGrain `json:"supportedTimeGrainTypes,omitempty"`

	// Metric units.
	Unit *MetricUnit `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricSpecificationV1.
func (m MetricSpecificationV1) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", m.AggregationType)
	populate(objectMap, "category", m.Category)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "fillGapWithZero", m.FillGapWithZero)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "resourceIdDimensionNameOverride", m.ResourceIDDimensionNameOverride)
	populate(objectMap, "supportedAggregationTypes", m.SupportedAggregationTypes)
	populate(objectMap, "supportedTimeGrainTypes", m.SupportedTimeGrainTypes)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// MonitoringConfigBeginCreateOrUpdateOptions contains the optional parameters for the MonitoringConfig.BeginCreateOrUpdate method.
type MonitoringConfigBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// MonitoringConfigBeginDeleteOptions contains the optional parameters for the MonitoringConfig.BeginDelete method.
type MonitoringConfigBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// MonitoringConfigGetOptions contains the optional parameters for the MonitoringConfig.Get method.
type MonitoringConfigGetOptions struct {
	// placeholder for future optional parameters
}

// MonitoringConfigListOptions contains the optional parameters for the MonitoringConfig.List method.
type MonitoringConfigListOptions struct {
	// placeholder for future optional parameters
}

// MonitoringMetricConfiguration - The metric setting details for the role
type MonitoringMetricConfiguration struct {
	ARMBaseModel
	// REQUIRED; The metric setting properties.
	Properties *MonitoringMetricConfigurationProperties `json:"properties,omitempty"`

	// READ-ONLY; MonitoringConfiguration on ASE device
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MonitoringMetricConfiguration.
func (m MonitoringMetricConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MonitoringMetricConfiguration.
func (m *MonitoringMetricConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MonitoringMetricConfigurationList - Collection of metric configurations.
type MonitoringMetricConfigurationList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of metric configurations.
	Value []*MonitoringMetricConfiguration `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MonitoringMetricConfigurationList.
func (m MonitoringMetricConfigurationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MonitoringMetricConfigurationProperties - Metrics properties
type MonitoringMetricConfigurationProperties struct {
	// REQUIRED; The metrics configuration details
	MetricConfigurations []*MetricConfiguration `json:"metricConfigurations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MonitoringMetricConfigurationProperties.
func (m MonitoringMetricConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "metricConfigurations", m.MetricConfigurations)
	return json.Marshal(objectMap)
}

// MountPointMap - The share mount point.
type MountPointMap struct {
	// REQUIRED; ID of the share mounted to the role VM.
	ShareID *string `json:"shareId,omitempty"`

	// READ-ONLY; Mount point for the share.
	MountPoint *string `json:"mountPoint,omitempty" azure:"ro"`

	// READ-ONLY; Mounting type.
	MountType *MountType `json:"mountType,omitempty" azure:"ro"`

	// READ-ONLY; ID of the role to which share is mounted.
	RoleID *string `json:"roleId,omitempty" azure:"ro"`

	// READ-ONLY; Role type.
	RoleType *RoleTypes `json:"roleType,omitempty" azure:"ro"`
}

// NetworkAdapter - Represents the networkAdapter on a device.
type NetworkAdapter struct {
	// Value indicating whether this adapter has DHCP enabled.
	DhcpStatus *NetworkAdapterDHCPStatus `json:"dhcpStatus,omitempty"`

	// Value indicating whether this adapter is RDMA capable.
	RdmaStatus *NetworkAdapterRDMAStatus `json:"rdmaStatus,omitempty"`

	// READ-ONLY; Instance ID of network adapter.
	AdapterID *string `json:"adapterId,omitempty" azure:"ro"`

	// READ-ONLY; Hardware position of network adapter.
	AdapterPosition *NetworkAdapterPosition `json:"adapterPosition,omitempty" azure:"ro"`

	// READ-ONLY; The list of DNS Servers of the device.
	DNSServers []*string `json:"dnsServers,omitempty" azure:"ro"`

	// READ-ONLY; The IPv4 configuration of the network adapter.
	IPv4Configuration *IPv4Config `json:"ipv4Configuration,omitempty" azure:"ro"`

	// READ-ONLY; The IPv6 configuration of the network adapter.
	IPv6Configuration *IPv6Config `json:"ipv6Configuration,omitempty" azure:"ro"`

	// READ-ONLY; The IPv6 local address.
	IPv6LinkLocalAddress *string `json:"ipv6LinkLocalAddress,omitempty" azure:"ro"`

	// READ-ONLY; Logical index of the adapter.
	Index *int32 `json:"index,omitempty" azure:"ro"`

	// READ-ONLY; Hardware label for the adapter.
	Label *string `json:"label,omitempty" azure:"ro"`

	// READ-ONLY; Link speed.
	LinkSpeed *int64 `json:"linkSpeed,omitempty" azure:"ro"`

	// READ-ONLY; MAC address.
	MacAddress *string `json:"macAddress,omitempty" azure:"ro"`

	// READ-ONLY; Network adapter name.
	NetworkAdapterName *string `json:"networkAdapterName,omitempty" azure:"ro"`

	// READ-ONLY; Node ID of the network adapter.
	NodeID *string `json:"nodeId,omitempty" azure:"ro"`

	// READ-ONLY; Value indicating whether this adapter is valid.
	Status *NetworkAdapterStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAdapter.
func (n NetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adapterId", n.AdapterID)
	populate(objectMap, "adapterPosition", n.AdapterPosition)
	populate(objectMap, "dnsServers", n.DNSServers)
	populate(objectMap, "dhcpStatus", n.DhcpStatus)
	populate(objectMap, "ipv4Configuration", n.IPv4Configuration)
	populate(objectMap, "ipv6Configuration", n.IPv6Configuration)
	populate(objectMap, "ipv6LinkLocalAddress", n.IPv6LinkLocalAddress)
	populate(objectMap, "index", n.Index)
	populate(objectMap, "label", n.Label)
	populate(objectMap, "linkSpeed", n.LinkSpeed)
	populate(objectMap, "macAddress", n.MacAddress)
	populate(objectMap, "networkAdapterName", n.NetworkAdapterName)
	populate(objectMap, "nodeId", n.NodeID)
	populate(objectMap, "rdmaStatus", n.RdmaStatus)
	populate(objectMap, "status", n.Status)
	return json.Marshal(objectMap)
}

// NetworkAdapterPosition - The network adapter position.
type NetworkAdapterPosition struct {
	// READ-ONLY; The network group.
	NetworkGroup *NetworkGroup `json:"networkGroup,omitempty" azure:"ro"`

	// READ-ONLY; The port.
	Port *int32 `json:"port,omitempty" azure:"ro"`
}

// NetworkSettings - The network settings of a device.
type NetworkSettings struct {
	ARMBaseModel
	// READ-ONLY; The properties of network settings of a device.
	Properties *NetworkSettingsProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; NetworkSettings on ASE device
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSettings.
func (n NetworkSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkSettings.
func (n *NetworkSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &n.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NetworkSettingsProperties - The properties of network settings.
type NetworkSettingsProperties struct {
	// READ-ONLY; The network adapter list on the device.
	NetworkAdapters []*NetworkAdapter `json:"networkAdapters,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSettingsProperties.
func (n NetworkSettingsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "networkAdapters", n.NetworkAdapters)
	return json.Marshal(objectMap)
}

// Node - Represents a single node in a Data box Edge/Gateway device Gateway devices, standalone Edge devices and a single node cluster Edge device will
// all have 1 node Multi-node Edge devices will have more
// than 1 nodes
type Node struct {
	ARMBaseModel
	// READ-ONLY; The properties of the node
	Properties *NodeProperties `json:"properties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Node.
func (n Node) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", n.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Node.
func (n *Node) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &n.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NodeInfo - Kubernetes node info
type NodeInfo struct {
	// IP Configuration of the Kubernetes node.
	IPConfiguration []*KubernetesIPConfiguration `json:"ipConfiguration,omitempty"`

	// READ-ONLY; Node name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Node type - Master/Worker
	Type *KubernetesNodeType `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NodeInfo.
func (n NodeInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ipConfiguration", n.IPConfiguration)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// NodeList - Collection of Nodes.
type NodeList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of Nodes.
	Value []*Node `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NodeList.
func (n NodeList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// NodeProperties - This class represents the nodes in a highly available cluster
type NodeProperties struct {
	// READ-ONLY; Serial number of the Chassis
	NodeChassisSerialNumber *string `json:"nodeChassisSerialNumber,omitempty" azure:"ro"`

	// READ-ONLY; Display Name of the individual node
	NodeDisplayName *string `json:"nodeDisplayName,omitempty" azure:"ro"`

	// READ-ONLY; Friendly software version name that is currently installed on the node
	NodeFriendlySoftwareVersion *string `json:"nodeFriendlySoftwareVersion,omitempty" azure:"ro"`

	// READ-ONLY; HCS version that is currently installed on the node
	NodeHcsVersion *string `json:"nodeHcsVersion,omitempty" azure:"ro"`

	// READ-ONLY; Guid instance id of the node
	NodeInstanceID *string `json:"nodeInstanceId,omitempty" azure:"ro"`

	// READ-ONLY; Serial number of the individual node
	NodeSerialNumber *string `json:"nodeSerialNumber,omitempty" azure:"ro"`

	// READ-ONLY; The current status of the individual node
	NodeStatus *NodeStatus `json:"nodeStatus,omitempty" azure:"ro"`
}

// NodesListByDataBoxEdgeDeviceOptions contains the optional parameters for the Nodes.ListByDataBoxEdgeDevice method.
type NodesListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// Operations.
type Operation struct {
	// Properties displayed for the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// Is data action.
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Name of the operation.
	Name *string `json:"name,omitempty"`

	// Origin of the operation.
	Origin *string `json:"origin,omitempty"`

	// Operation properties.
	Properties *OperationProperties `json:"properties,omitempty"`
}

// OperationDisplay - Operation display properties.
type OperationDisplay struct {
	// Description of the operation to be performed.
	Description *string `json:"description,omitempty"`

	// Operation to be performed on the resource.
	Operation *string `json:"operation,omitempty"`

	// Provider name.
	Provider *string `json:"provider,omitempty"`

	// The type of resource in which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationProperties - Operation properties.
type OperationProperties struct {
	// Service specification.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationsList - The list of operations used for the discovery of available provider operations.
type OperationsList struct {
	// REQUIRED; The value.
	Value []*Operation `json:"value,omitempty"`

	// Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationsList.
func (o OperationsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OperationsStatusGetOptions contains the optional parameters for the OperationsStatus.Get method.
type OperationsStatusGetOptions struct {
	// placeholder for future optional parameters
}

// Order - The order details.
type Order struct {
	ARMBaseModel
	// The order properties.
	Properties *OrderProperties `json:"properties,omitempty"`

	// READ-ONLY; Order configured on ASE resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Order.
func (o Order) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Order.
func (o *Order) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &o.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := o.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// OrderList - List of order entities.
type OrderList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of orders.
	Value []*Order `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OrderList.
func (o OrderList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OrderProperties - Order properties.
type OrderProperties struct {
	// REQUIRED; The contact details.
	ContactInformation *ContactDetails `json:"contactInformation,omitempty"`

	// ShipmentType of the order
	ShipmentType *ShipmentType `json:"shipmentType,omitempty"`

	// The shipping address.
	ShippingAddress *Address `json:"shippingAddress,omitempty"`

	// READ-ONLY; Current status of the order.
	CurrentStatus *OrderStatus `json:"currentStatus,omitempty" azure:"ro"`

	// READ-ONLY; Tracking information for the package delivered to the customer whether it has an original or a replacement device.
	DeliveryTrackingInfo []*TrackingInfo `json:"deliveryTrackingInfo,omitempty" azure:"ro"`

	// READ-ONLY; List of status changes in the order.
	OrderHistory []*OrderStatus `json:"orderHistory,omitempty" azure:"ro"`

	// READ-ONLY; Tracking information for the package returned from the customer whether it has an original or a replacement device.
	ReturnTrackingInfo []*TrackingInfo `json:"returnTrackingInfo,omitempty" azure:"ro"`

	// READ-ONLY; Serial number of the device.
	SerialNumber *string `json:"serialNumber,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OrderProperties.
func (o OrderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contactInformation", o.ContactInformation)
	populate(objectMap, "currentStatus", o.CurrentStatus)
	populate(objectMap, "deliveryTrackingInfo", o.DeliveryTrackingInfo)
	populate(objectMap, "orderHistory", o.OrderHistory)
	populate(objectMap, "returnTrackingInfo", o.ReturnTrackingInfo)
	populate(objectMap, "serialNumber", o.SerialNumber)
	populate(objectMap, "shipmentType", o.ShipmentType)
	populate(objectMap, "shippingAddress", o.ShippingAddress)
	return json.Marshal(objectMap)
}

// OrderStatus - Represents a single status change.
type OrderStatus struct {
	// REQUIRED; Status of the order as per the allowed status types.
	Status *OrderState `json:"status,omitempty"`

	// Comments related to this status change.
	Comments *string `json:"comments,omitempty"`

	// READ-ONLY; Dictionary to hold generic information which is not stored by the already existing properties
	AdditionalOrderDetails map[string]*string `json:"additionalOrderDetails,omitempty" azure:"ro"`

	// READ-ONLY; Tracking information related to the state in the ordering flow
	TrackingInformation *TrackingInfo `json:"trackingInformation,omitempty" azure:"ro"`

	// READ-ONLY; Time of status update.
	UpdateDateTime *time.Time `json:"updateDateTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OrderStatus.
func (o OrderStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalOrderDetails", o.AdditionalOrderDetails)
	populate(objectMap, "comments", o.Comments)
	populate(objectMap, "status", o.Status)
	populate(objectMap, "trackingInformation", o.TrackingInformation)
	populateTimeRFC3339(objectMap, "updateDateTime", o.UpdateDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrderStatus.
func (o *OrderStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalOrderDetails":
			err = unpopulate(val, &o.AdditionalOrderDetails)
			delete(rawMsg, key)
		case "comments":
			err = unpopulate(val, &o.Comments)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &o.Status)
			delete(rawMsg, key)
		case "trackingInformation":
			err = unpopulate(val, &o.TrackingInformation)
			delete(rawMsg, key)
		case "updateDateTime":
			err = unpopulateTimeRFC3339(val, &o.UpdateDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OrdersBeginCreateOrUpdateOptions contains the optional parameters for the Orders.BeginCreateOrUpdate method.
type OrdersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// OrdersBeginDeleteOptions contains the optional parameters for the Orders.BeginDelete method.
type OrdersBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// OrdersGetOptions contains the optional parameters for the Orders.Get method.
type OrdersGetOptions struct {
	// placeholder for future optional parameters
}

// OrdersListByDataBoxEdgeDeviceOptions contains the optional parameters for the Orders.ListByDataBoxEdgeDevice method.
type OrdersListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// OrdersListDCAccessCodeOptions contains the optional parameters for the Orders.ListDCAccessCode method.
type OrdersListDCAccessCodeOptions struct {
	// placeholder for future optional parameters
}

// PeriodicTimerEventTrigger - Trigger details.
type PeriodicTimerEventTrigger struct {
	Trigger
	// REQUIRED; Periodic timer trigger properties.
	Properties *PeriodicTimerProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PeriodicTimerEventTrigger.
func (p PeriodicTimerEventTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Trigger.marshalInternal(objectMap, TriggerEventTypePeriodicTimerEvent)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PeriodicTimerEventTrigger.
func (p *PeriodicTimerEventTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Trigger.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PeriodicTimerProperties - Periodic timer trigger properties.
type PeriodicTimerProperties struct {
	// REQUIRED; Role Sink information.
	SinkInfo *RoleSinkInfo `json:"sinkInfo,omitempty"`

	// REQUIRED; Periodic timer details.
	SourceInfo *PeriodicTimerSourceInfo `json:"sourceInfo,omitempty"`

	// A custom context tag typically used to correlate the trigger against its usage. For example, if a periodic timer trigger is intended for certain specific
	// IoT modules in the device, the tag can be the
	// name or the image URL of the module.
	CustomContextTag *string `json:"customContextTag,omitempty"`
}

// PeriodicTimerSourceInfo - Periodic timer event source.
type PeriodicTimerSourceInfo struct {
	// REQUIRED; Periodic frequency at which timer event needs to be raised. Supports daily, hourly, minutes, and seconds.
	Schedule *string `json:"schedule,omitempty"`

	// REQUIRED; The time of the day that results in a valid trigger. Schedule is computed with reference to the time specified upto seconds. If timezone is
	// not specified the time will considered to be in device
	// timezone. The value will always be returned as UTC time.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Topic where periodic events are published to IoT device.
	Topic *string `json:"topic,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PeriodicTimerSourceInfo.
func (p PeriodicTimerSourceInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "schedule", p.Schedule)
	populateTimeRFC3339(objectMap, "startTime", p.StartTime)
	populate(objectMap, "topic", p.Topic)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PeriodicTimerSourceInfo.
func (p *PeriodicTimerSourceInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schedule":
			err = unpopulate(val, &p.Schedule)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &p.StartTime)
			delete(rawMsg, key)
		case "topic":
			err = unpopulate(val, &p.Topic)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProactiveLogCollectionSettingsProperties - The properties of proactive log collection settings.
type ProactiveLogCollectionSettingsProperties struct {
	// REQUIRED; Proactive diagnostic collection consent flag
	UserConsent *ProactiveDiagnosticsConsent `json:"userConsent,omitempty"`
}

// RawCertificateData - Raw Certificate Data.
type RawCertificateData struct {
	// REQUIRED; The base64 encoded certificate raw data.
	Certificate *string `json:"certificate,omitempty"`

	// The authentication type.
	AuthenticationType *AuthenticationType `json:"authenticationType,omitempty"`
}

// RefreshDetails - Fields for tracking refresh job on the share or container.
type RefreshDetails struct {
	// Indicates the relative path of the error xml for the last refresh job on this particular share or container, if any. This could be a failed job or a
	// successful job.
	ErrorManifestFile *string `json:"errorManifestFile,omitempty"`

	// If a refresh job is currently in progress on this share or container, this field indicates the ARM resource ID of that job. The field is empty if no
	// job is in progress.
	InProgressRefreshJobID *string `json:"inProgressRefreshJobId,omitempty"`

	// Indicates the completed time for the last refresh job on this particular share or container, if any.This could be a failed job or a successful job.
	LastCompletedRefreshJobTimeInUTC *time.Time `json:"lastCompletedRefreshJobTimeInUTC,omitempty"`

	// Indicates the id of the last refresh job on this particular share or container,if any. This could be a failed job or a successful job.
	LastJob *string `json:"lastJob,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RefreshDetails.
func (r RefreshDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorManifestFile", r.ErrorManifestFile)
	populate(objectMap, "inProgressRefreshJobId", r.InProgressRefreshJobID)
	populateTimeRFC3339(objectMap, "lastCompletedRefreshJobTimeInUTC", r.LastCompletedRefreshJobTimeInUTC)
	populate(objectMap, "lastJob", r.LastJob)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RefreshDetails.
func (r *RefreshDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorManifestFile":
			err = unpopulate(val, &r.ErrorManifestFile)
			delete(rawMsg, key)
		case "inProgressRefreshJobId":
			err = unpopulate(val, &r.InProgressRefreshJobID)
			delete(rawMsg, key)
		case "lastCompletedRefreshJobTimeInUTC":
			err = unpopulateTimeRFC3339(val, &r.LastCompletedRefreshJobTimeInUTC)
			delete(rawMsg, key)
		case "lastJob":
			err = unpopulate(val, &r.LastJob)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RemoteSupportSettings - RemoteApplicationType for which remote support settings is being modified
type RemoteSupportSettings struct {
	// Access level allowed for this remote application type
	AccessLevel *AccessLevel `json:"accessLevel,omitempty"`

	// Expiration time stamp
	ExpirationTimeStampInUTC *time.Time `json:"expirationTimeStampInUTC,omitempty"`

	// Remote application type
	RemoteApplicationType *RemoteApplicationType `json:"remoteApplicationType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportSettings.
func (r RemoteSupportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessLevel", r.AccessLevel)
	populateTimeRFC3339(objectMap, "expirationTimeStampInUTC", r.ExpirationTimeStampInUTC)
	populate(objectMap, "remoteApplicationType", r.RemoteApplicationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportSettings.
func (r *RemoteSupportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, &r.AccessLevel)
			delete(rawMsg, key)
		case "expirationTimeStampInUTC":
			err = unpopulateTimeRFC3339(val, &r.ExpirationTimeStampInUTC)
			delete(rawMsg, key)
		case "remoteApplicationType":
			err = unpopulate(val, &r.RemoteApplicationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceIdentity - Msi identity details of the resource
type ResourceIdentity struct {
	// Identity type
	Type *MsiIdentityType `json:"type,omitempty"`

	// READ-ONLY; Service Principal Id backing the Msi
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; Home Tenant Id
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// ResourceMoveDetails - Fields for tracking resource move
type ResourceMoveDetails struct {
	// Denotes whether move operation is in progress
	OperationInProgress *ResourceMoveStatus `json:"operationInProgress,omitempty"`

	// Denotes the timeout of the operation to finish
	OperationInProgressLockTimeoutInUTC *time.Time `json:"operationInProgressLockTimeoutInUTC,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceMoveDetails.
func (r ResourceMoveDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operationInProgress", r.OperationInProgress)
	populateTimeRFC3339(objectMap, "operationInProgressLockTimeoutInUTC", r.OperationInProgressLockTimeoutInUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceMoveDetails.
func (r *ResourceMoveDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "operationInProgress":
			err = unpopulate(val, &r.OperationInProgress)
			delete(rawMsg, key)
		case "operationInProgressLockTimeoutInUTC":
			err = unpopulateTimeRFC3339(val, &r.OperationInProgressLockTimeoutInUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceTypeSKU - Resource type Sku object
type ResourceTypeSKU struct {
	// READ-ONLY; The resource type.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; The skus.
	SKUs []*SKUInformation `json:"skus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceTypeSKU.
func (r ResourceTypeSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "resourceType", r.ResourceType)
	populate(objectMap, "skus", r.SKUs)
	return json.Marshal(objectMap)
}

// RoleClassification provides polymorphic access to related types.
// Call the interface's GetRole() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CloudEdgeManagementRole, *IoTRole, *KubernetesRole, *MECRole, *Role
type RoleClassification interface {
	// GetRole returns the Role content of the underlying type.
	GetRole() *Role
}

// Role - Compute role.
type Role struct {
	ARMBaseModel
	// REQUIRED; Role type.
	Kind *RoleTypes `json:"kind,omitempty"`

	// READ-ONLY; Role configured on ASE resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// GetRole implements the RoleClassification interface for type Role.
func (r *Role) GetRole() *Role { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type Role.
func (r *Role) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Role) marshalInternal(objectMap map[string]interface{}, discValue RoleTypes) {
	r.ARMBaseModel.marshalInternal(objectMap)
	r.Kind = &discValue
	objectMap["kind"] = r.Kind
	populate(objectMap, "systemData", r.SystemData)
}

func (r *Role) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &r.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoleList - Collection of all the roles on the Data Box Edge device.
type RoleList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The Value.
	Value []RoleClassification `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleList.
func (r RoleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleList.
func (r *RoleList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &r.NextLink)
			delete(rawMsg, key)
		case "value":
			r.Value, err = unmarshalRoleClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleSinkInfo - Compute role against which events will be raised.
type RoleSinkInfo struct {
	// REQUIRED; Compute role ID.
	RoleID *string `json:"roleId,omitempty"`
}

// RolesBeginCreateOrUpdateOptions contains the optional parameters for the Roles.BeginCreateOrUpdate method.
type RolesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RolesBeginDeleteOptions contains the optional parameters for the Roles.BeginDelete method.
type RolesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RolesGetOptions contains the optional parameters for the Roles.Get method.
type RolesGetOptions struct {
	// placeholder for future optional parameters
}

// RolesListByDataBoxEdgeDeviceOptions contains the optional parameters for the Roles.ListByDataBoxEdgeDevice method.
type RolesListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// SKU - The SKU type.
type SKU struct {
	// SKU name.
	Name *SKUName `json:"name,omitempty"`

	// The SKU tier. This is based on the SKU name.
	Tier *SKUTier `json:"tier,omitempty"`
}

// SKUCapability - The metadata to describe the capability.
type SKUCapability struct {
	// READ-ONLY; An invariant to describe the feature.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; An invariant if the feature is measured by quantity.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// SKUCost - The metadata for retrieving price info.
type SKUCost struct {
	// READ-ONLY; The extended unit.
	ExtendedUnit *string `json:"extendedUnit,omitempty" azure:"ro"`

	// READ-ONLY; Used for querying price from commerce.
	MeterID *string `json:"meterId,omitempty" azure:"ro"`

	// READ-ONLY; The cost quantity.
	Quantity *int64 `json:"quantity,omitempty" azure:"ro"`
}

// SKUInformation - Sku information
type SKUInformation struct {
	// READ-ONLY; The pricing info of the Sku.
	Costs []*SKUCost `json:"costs,omitempty" azure:"ro"`

	// READ-ONLY; The Sku family.
	Family *string `json:"family,omitempty" azure:"ro"`

	// READ-ONLY; The sku kind.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The locations where Sku is available with zones and sites info
	LocationInfo []*SKULocationInfo `json:"locationInfo,omitempty" azure:"ro"`

	// READ-ONLY; The locations where Sku is available.
	Locations []*string `json:"locations,omitempty" azure:"ro"`

	// READ-ONLY; The sku name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The required features for the sku to be available.
	RequiredFeatures []*string `json:"requiredFeatures,omitempty" azure:"ro"`

	// READ-ONLY; The required quotaIds for the sku to be available.
	RequiredQuotaIDs []*string `json:"requiredQuotaIds,omitempty" azure:"ro"`

	// READ-ONLY; The sku tier.
	Tier *string `json:"tier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUInformation.
func (s SKUInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costs", s.Costs)
	populate(objectMap, "family", s.Family)
	populate(objectMap, "kind", s.Kind)
	populate(objectMap, "locationInfo", s.LocationInfo)
	populate(objectMap, "locations", s.Locations)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "requiredFeatures", s.RequiredFeatures)
	populate(objectMap, "requiredQuotaIds", s.RequiredQuotaIDs)
	populate(objectMap, "tier", s.Tier)
	return json.Marshal(objectMap)
}

// SKUInformationList - List of SKU Information objects
type SKUInformationList struct {
	// READ-ONLY; Links to the next set of results
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of ResourceTypeSku objects
	Value []*ResourceTypeSKU `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUInformationList.
func (s SKUInformationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SKULocationInfo - The location info.
type SKULocationInfo struct {
	// READ-ONLY; The location.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The sites.
	Sites []*string `json:"sites,omitempty" azure:"ro"`

	// READ-ONLY; The zones.
	Zones []*string `json:"zones,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKULocationInfo.
func (s SKULocationInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", s.Location)
	populate(objectMap, "sites", s.Sites)
	populate(objectMap, "zones", s.Zones)
	return json.Marshal(objectMap)
}

// Secret - Holds device secret either as a KeyVault reference or as an encrypted value.
type Secret struct {
	// Encrypted (using device public key) secret value.
	EncryptedSecret *AsymmetricEncryptedSecret `json:"encryptedSecret,omitempty"`

	// Id of the Key-Vault where secret is stored (ex: secrets/AuthClientSecret/82ef4346187a4033a10d629cde07d740).
	KeyVaultID *string `json:"keyVaultId,omitempty"`
}

// SecuritySettings - The security settings of a device.
type SecuritySettings struct {
	ARMBaseModel
	// REQUIRED; Properties of the security settings.
	Properties *SecuritySettingsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecuritySettings.
func (s SecuritySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecuritySettings.
func (s *SecuritySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SecuritySettingsProperties - The properties of security settings.
type SecuritySettingsProperties struct {
	// REQUIRED; Device administrator password as an encrypted string (encrypted using RSA PKCS #1) is used to sign into the local web UI of the device. The
	// Actual password should have at least 8 characters that are a
	// combination of uppercase, lowercase, numeric, and special characters.
	DeviceAdminPassword *AsymmetricEncryptedSecret `json:"deviceAdminPassword,omitempty"`
}

// ServiceSpecification - Service specification.
type ServiceSpecification struct {
	// Metric specification as defined by shoebox.
	MetricSpecifications []*MetricSpecificationV1 `json:"metricSpecifications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSpecification.
func (s ServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "metricSpecifications", s.MetricSpecifications)
	return json.Marshal(objectMap)
}

// Share - Represents a share on the Data Box Edge/Gateway device.
type Share struct {
	ARMBaseModel
	// REQUIRED; The share properties.
	Properties *ShareProperties `json:"properties,omitempty"`

	// READ-ONLY; Share on ASE device
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Share.
func (s Share) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Share.
func (s *Share) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ShareAccessRight - Specifies the mapping between this particular user and the type of access he has on shares on this device.
type ShareAccessRight struct {
	// REQUIRED; Type of access to be allowed on the share for this user.
	AccessType *ShareAccessType `json:"accessType,omitempty"`

	// REQUIRED; The share ID.
	ShareID *string `json:"shareId,omitempty"`
}

// ShareList - Collection of all the shares on the Data Box Edge/Gateway device.
type ShareList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of shares.
	Value []*Share `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ShareList.
func (s ShareList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ShareProperties - The share properties.
type ShareProperties struct {
	// REQUIRED; Access protocol to be used by the share.
	AccessProtocol *ShareAccessProtocol `json:"accessProtocol,omitempty"`

	// REQUIRED; Current monitoring status of the share.
	MonitoringStatus *MonitoringStatus `json:"monitoringStatus,omitempty"`

	// REQUIRED; Current status of the share.
	ShareStatus *ShareStatus `json:"shareStatus,omitempty"`

	// Azure container mapping for the share.
	AzureContainerInfo *AzureContainerInfo `json:"azureContainerInfo,omitempty"`

	// List of IP addresses and corresponding access rights on the share(required for NFS protocol).
	ClientAccessRights []*ClientAccessRight `json:"clientAccessRights,omitempty"`

	// Data policy of the share.
	DataPolicy *DataPolicy `json:"dataPolicy,omitempty"`

	// Description for the share.
	Description *string `json:"description,omitempty"`

	// Details of the refresh job on this share.
	RefreshDetails *RefreshDetails `json:"refreshDetails,omitempty"`

	// Mapping of users and corresponding access rights on the share (required for SMB protocol).
	UserAccessRights []*UserAccessRight `json:"userAccessRights,omitempty"`

	// READ-ONLY; Share mount point to the role.
	ShareMappings []*MountPointMap `json:"shareMappings,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ShareProperties.
func (s ShareProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessProtocol", s.AccessProtocol)
	populate(objectMap, "azureContainerInfo", s.AzureContainerInfo)
	populate(objectMap, "clientAccessRights", s.ClientAccessRights)
	populate(objectMap, "dataPolicy", s.DataPolicy)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "monitoringStatus", s.MonitoringStatus)
	populate(objectMap, "refreshDetails", s.RefreshDetails)
	populate(objectMap, "shareMappings", s.ShareMappings)
	populate(objectMap, "shareStatus", s.ShareStatus)
	populate(objectMap, "userAccessRights", s.UserAccessRights)
	return json.Marshal(objectMap)
}

// SharesBeginCreateOrUpdateOptions contains the optional parameters for the Shares.BeginCreateOrUpdate method.
type SharesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SharesBeginDeleteOptions contains the optional parameters for the Shares.BeginDelete method.
type SharesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SharesBeginRefreshOptions contains the optional parameters for the Shares.BeginRefresh method.
type SharesBeginRefreshOptions struct {
	// placeholder for future optional parameters
}

// SharesGetOptions contains the optional parameters for the Shares.Get method.
type SharesGetOptions struct {
	// placeholder for future optional parameters
}

// SharesListByDataBoxEdgeDeviceOptions contains the optional parameters for the Shares.ListByDataBoxEdgeDevice method.
type SharesListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// StorageAccount - Represents a Storage Account on the Data Box Edge/Gateway device.
type StorageAccount struct {
	ARMBaseModel
	// REQUIRED; The Storage Account properties.
	Properties *StorageAccountProperties `json:"properties,omitempty"`

	// READ-ONLY; StorageAccount object on ASE device
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccount.
func (s StorageAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageAccount.
func (s *StorageAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StorageAccountCredential - The storage account credential.
type StorageAccountCredential struct {
	ARMBaseModel
	// REQUIRED; The storage account credential properties.
	Properties *StorageAccountCredentialProperties `json:"properties,omitempty"`

	// READ-ONLY; StorageAccountCredential object
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountCredential.
func (s StorageAccountCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageAccountCredential.
func (s *StorageAccountCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StorageAccountCredentialList - The collection of storage account credentials.
type StorageAccountCredentialList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The value.
	Value []*StorageAccountCredential `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountCredentialList.
func (s StorageAccountCredentialList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageAccountCredentialProperties - The storage account credential properties.
type StorageAccountCredentialProperties struct {
	// REQUIRED; Type of storage accessed on the storage account.
	AccountType *AccountType `json:"accountType,omitempty"`

	// REQUIRED; Alias for the storage account.
	Alias *string `json:"alias,omitempty"`

	// REQUIRED; Signifies whether SSL needs to be enabled or not.
	SSLStatus *SSLStatus `json:"sslStatus,omitempty"`

	// Encrypted storage key.
	AccountKey *AsymmetricEncryptedSecret `json:"accountKey,omitempty"`

	// Blob end point for private clouds.
	BlobDomainName *string `json:"blobDomainName,omitempty"`

	// Connection string for the storage account. Use this string if username and account key are not specified.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`

	// Username for the storage account.
	UserName *string `json:"userName,omitempty"`
}

// StorageAccountCredentialsBeginCreateOrUpdateOptions contains the optional parameters for the StorageAccountCredentials.BeginCreateOrUpdate method.
type StorageAccountCredentialsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountCredentialsBeginDeleteOptions contains the optional parameters for the StorageAccountCredentials.BeginDelete method.
type StorageAccountCredentialsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountCredentialsGetOptions contains the optional parameters for the StorageAccountCredentials.Get method.
type StorageAccountCredentialsGetOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountCredentialsListByDataBoxEdgeDeviceOptions contains the optional parameters for the StorageAccountCredentials.ListByDataBoxEdgeDevice method.
type StorageAccountCredentialsListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountList - Collection of all the Storage Accounts on the Data Box Edge/Gateway device.
type StorageAccountList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of storageAccounts.
	Value []*StorageAccount `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountList.
func (s StorageAccountList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageAccountProperties - The storage account properties.
type StorageAccountProperties struct {
	// REQUIRED; Data policy of the storage Account.
	DataPolicy *DataPolicy `json:"dataPolicy,omitempty"`

	// Description for the storage Account.
	Description *string `json:"description,omitempty"`

	// Storage Account Credential Id
	StorageAccountCredentialID *string `json:"storageAccountCredentialId,omitempty"`

	// Current status of the storage account
	StorageAccountStatus *StorageAccountStatus `json:"storageAccountStatus,omitempty"`

	// READ-ONLY; BlobEndpoint of Storage Account
	BlobEndpoint *string `json:"blobEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; The Container Count. Present only for Storage Accounts with DataPolicy set to Cloud.
	ContainerCount *int32 `json:"containerCount,omitempty" azure:"ro"`
}

// StorageAccountsBeginCreateOrUpdateOptions contains the optional parameters for the StorageAccounts.BeginCreateOrUpdate method.
type StorageAccountsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsBeginDeleteOptions contains the optional parameters for the StorageAccounts.BeginDelete method.
type StorageAccountsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsGetOptions contains the optional parameters for the StorageAccounts.Get method.
type StorageAccountsGetOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsListByDataBoxEdgeDeviceOptions contains the optional parameters for the StorageAccounts.ListByDataBoxEdgeDevice method.
type StorageAccountsListByDataBoxEdgeDeviceOptions struct {
	// placeholder for future optional parameters
}

type SubscriptionProperties struct {
	LocationPlacementID *string                           `json:"locationPlacementId,omitempty"`
	QuotaID             *string                           `json:"quotaId,omitempty"`
	RegisteredFeatures  []*SubscriptionRegisteredFeatures `json:"registeredFeatures,omitempty"`
	SerializedDetails   *string                           `json:"serializedDetails,omitempty"`
	TenantID            *string                           `json:"tenantId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionProperties.
func (s SubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "locationPlacementId", s.LocationPlacementID)
	populate(objectMap, "quotaId", s.QuotaID)
	populate(objectMap, "registeredFeatures", s.RegisteredFeatures)
	populate(objectMap, "serializedDetails", s.SerializedDetails)
	populate(objectMap, "tenantId", s.TenantID)
	return json.Marshal(objectMap)
}

type SubscriptionRegisteredFeatures struct {
	Name  *string `json:"name,omitempty"`
	State *string `json:"state,omitempty"`
}

// SupportPackageRequestProperties - The share properties.
type SupportPackageRequestProperties struct {
	// Type of files, which need to be included in the logs This will contain the type of logs (Default/DefaultWithDumps/None/All/DefaultWithArchived) or a
	// comma separated list of log types that are required
	Include *string `json:"include,omitempty"`

	// MaximumTimeStamp until where logs need to be collected
	MaximumTimeStamp *time.Time `json:"maximumTimeStamp,omitempty"`

	// Start of the timespan of the log collection
	MinimumTimeStamp *time.Time `json:"minimumTimeStamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SupportPackageRequestProperties.
func (s SupportPackageRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "include", s.Include)
	populateTimeRFC3339(objectMap, "maximumTimeStamp", s.MaximumTimeStamp)
	populateTimeRFC3339(objectMap, "minimumTimeStamp", s.MinimumTimeStamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SupportPackageRequestProperties.
func (s *SupportPackageRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "include":
			err = unpopulate(val, &s.Include)
			delete(rawMsg, key)
		case "maximumTimeStamp":
			err = unpopulateTimeRFC3339(val, &s.MaximumTimeStamp)
			delete(rawMsg, key)
		case "minimumTimeStamp":
			err = unpopulateTimeRFC3339(val, &s.MinimumTimeStamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SupportPackagesBeginTriggerSupportPackageOptions contains the optional parameters for the SupportPackages.BeginTriggerSupportPackage method.
type SupportPackagesBeginTriggerSupportPackageOptions struct {
	// placeholder for future optional parameters
}

// SymmetricKey - Symmetric key for authentication.
type SymmetricKey struct {
	// Connection string based on the symmetric key.
	ConnectionString *AsymmetricEncryptedSecret `json:"connectionString,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TrackingInfo - Tracking courier information.
type TrackingInfo struct {
	// Name of the carrier used in the delivery.
	CarrierName *string `json:"carrierName,omitempty"`

	// Serial number of the device being tracked.
	SerialNumber *string `json:"serialNumber,omitempty"`

	// Tracking ID of the shipment.
	TrackingID *string `json:"trackingId,omitempty"`

	// Tracking URL of the shipment.
	TrackingURL *string `json:"trackingUrl,omitempty"`
}

// TriggerClassification provides polymorphic access to related types.
// Call the interface's GetTrigger() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FileEventTrigger, *PeriodicTimerEventTrigger, *Trigger
type TriggerClassification interface {
	// GetTrigger returns the Trigger content of the underlying type.
	GetTrigger() *Trigger
}

// Trigger details.
type Trigger struct {
	ARMBaseModel
	// REQUIRED; Trigger Kind.
	Kind *TriggerEventType `json:"kind,omitempty"`

	// READ-ONLY; Trigger in DataBoxEdge Resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// GetTrigger implements the TriggerClassification interface for type Trigger.
func (t *Trigger) GetTrigger() *Trigger { return t }

// UnmarshalJSON implements the json.Unmarshaller interface for type Trigger.
func (t *Trigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t Trigger) marshalInternal(objectMap map[string]interface{}, discValue TriggerEventType) {
	t.ARMBaseModel.marshalInternal(objectMap)
	t.Kind = &discValue
	objectMap["kind"] = t.Kind
	populate(objectMap, "systemData", t.SystemData)
}

func (t *Trigger) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TriggerList - Collection of all trigger on the data box edge device.
type TriggerList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of triggers.
	Value []TriggerClassification `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerList.
func (t TriggerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerList.
func (t *TriggerList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &t.NextLink)
			delete(rawMsg, key)
		case "value":
			t.Value, err = unmarshalTriggerClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerSupportPackageRequest - The request object for trigger support package.
type TriggerSupportPackageRequest struct {
	ARMBaseModel
	// REQUIRED; The TriggerSupportPackageRequest properties.
	Properties *SupportPackageRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerSupportPackageRequest.
func (t TriggerSupportPackageRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerSupportPackageRequest.
func (t *TriggerSupportPackageRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TriggersBeginCreateOrUpdateOptions contains the optional parameters for the Triggers.BeginCreateOrUpdate method.
type TriggersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TriggersBeginDeleteOptions contains the optional parameters for the Triggers.BeginDelete method.
type TriggersBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// TriggersGetOptions contains the optional parameters for the Triggers.Get method.
type TriggersGetOptions struct {
	// placeholder for future optional parameters
}

// TriggersListByDataBoxEdgeDeviceOptions contains the optional parameters for the Triggers.ListByDataBoxEdgeDevice method.
type TriggersListByDataBoxEdgeDeviceOptions struct {
	// Specify $filter='CustomContextTag eq <tag>' to filter on custom context tag property
	Filter *string
}

// UpdateDetails - Update Specific attributes
type UpdateDetails struct {
	// Estimated Install Time for the update
	EstimatedInstallTimeInMins *int32 `json:"estimatedInstallTimeInMins,omitempty"`

	// Friendly Version Number
	FriendlyVersionNumber *string `json:"friendlyVersionNumber,omitempty"`

	// Impact of Installing an updateType
	InstallationImpact *InstallationImpact `json:"installationImpact,omitempty"`

	// Indicates if updates are available and at least one of the updates needs a reboot.
	RebootBehavior *InstallRebootBehavior `json:"rebootBehavior,omitempty"`

	// Status of the update.
	Status *UpdateStatus `json:"status,omitempty"`

	// Target Version number
	TargetVersion *string `json:"targetVersion,omitempty"`

	// Size of the update(In Bytes)
	UpdateSize *float64 `json:"updateSize,omitempty"`

	// Title of the Update
	UpdateTitle *string `json:"updateTitle,omitempty"`

	// Type of the Update
	UpdateType *UpdateType `json:"updateType,omitempty"`
}

// UpdateDownloadProgress - Details about the download progress of update.
type UpdateDownloadProgress struct {
	// READ-ONLY; The download phase.
	DownloadPhase *DownloadPhase `json:"downloadPhase,omitempty" azure:"ro"`

	// READ-ONLY; Number of updates downloaded.
	NumberOfUpdatesDownloaded *int32 `json:"numberOfUpdatesDownloaded,omitempty" azure:"ro"`

	// READ-ONLY; Number of updates to download.
	NumberOfUpdatesToDownload *int32 `json:"numberOfUpdatesToDownload,omitempty" azure:"ro"`

	// READ-ONLY; Percentage of completion.
	PercentComplete *int32 `json:"percentComplete,omitempty" azure:"ro"`

	// READ-ONLY; Total bytes downloaded.
	TotalBytesDownloaded *float64 `json:"totalBytesDownloaded,omitempty" azure:"ro"`

	// READ-ONLY; Total bytes to download.
	TotalBytesToDownload *float64 `json:"totalBytesToDownload,omitempty" azure:"ro"`
}

// UpdateInstallProgress - Progress details during installation of updates.
type UpdateInstallProgress struct {
	// READ-ONLY; Number of updates installed.
	NumberOfUpdatesInstalled *int32 `json:"numberOfUpdatesInstalled,omitempty" azure:"ro"`

	// READ-ONLY; Number of updates to install.
	NumberOfUpdatesToInstall *int32 `json:"numberOfUpdatesToInstall,omitempty" azure:"ro"`

	// READ-ONLY; Percentage completed.
	PercentComplete *int32 `json:"percentComplete,omitempty" azure:"ro"`
}

// UpdateSummary - Details about ongoing updates and availability of updates on the device.
type UpdateSummary struct {
	ARMBaseModel
	// The device update information summary.
	Properties *UpdateSummaryProperties `json:"properties,omitempty"`

	// READ-ONLY; UpdateSummary Result
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateSummary.
func (u UpdateSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateSummary.
func (u *UpdateSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &u.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UpdateSummaryProperties - The device update information summary.
type UpdateSummaryProperties struct {
	// The last time when a scan was done on the device.
	DeviceLastScannedDateTime *time.Time `json:"deviceLastScannedDateTime,omitempty"`

	// The current version of the device in format: 1.2.17312.13.",
	DeviceVersionNumber *string `json:"deviceVersionNumber,omitempty"`

	// The current version of the device in text format.
	FriendlyDeviceVersionName *string `json:"friendlyDeviceVersionName,omitempty"`

	// The time when the last scan job was completed (success/cancelled/failed) on the appliance.
	LastCompletedScanJobDateTime *time.Time `json:"lastCompletedScanJobDateTime,omitempty"`

	// The time when the Last Install job was completed successfully on the appliance
	LastSuccessfulInstallJobDateTime *time.Time `json:"lastSuccessfulInstallJobDateTime,omitempty"`

	// Time when the last scan job is successfully completed.
	LastSuccessfulScanJobTime *time.Time `json:"lastSuccessfulScanJobTime,omitempty"`

	// READ-ONLY; The job ID of the download job in progress.
	InProgressDownloadJobID *string `json:"inProgressDownloadJobId,omitempty" azure:"ro"`

	// READ-ONLY; The time when the currently running download (if any) started.
	InProgressDownloadJobStartedDateTime *time.Time `json:"inProgressDownloadJobStartedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; The job ID of the install job in progress.
	InProgressInstallJobID *string `json:"inProgressInstallJobId,omitempty" azure:"ro"`

	// READ-ONLY; The time when the currently running install (if any) started.
	InProgressInstallJobStartedDateTime *time.Time `json:"inProgressInstallJobStartedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; The time when the last Download job was completed (success/cancelled/failed) on the appliance.
	LastCompletedDownloadJobDateTime *time.Time `json:"lastCompletedDownloadJobDateTime,omitempty" azure:"ro"`

	// READ-ONLY; JobId of the last ran download job.(Can be success/cancelled/failed)
	LastCompletedDownloadJobID *string `json:"lastCompletedDownloadJobId,omitempty" azure:"ro"`

	// READ-ONLY; The time when the last Install job was completed (success/cancelled/failed) on the appliance.
	LastCompletedInstallJobDateTime *time.Time `json:"lastCompletedInstallJobDateTime,omitempty" azure:"ro"`

	// READ-ONLY; JobId of the last ran install job.(Can be success/cancelled/failed)
	LastCompletedInstallJobID *string `json:"lastCompletedInstallJobId,omitempty" azure:"ro"`

	// READ-ONLY; JobStatus of the last ran download job.
	LastDownloadJobStatus *JobStatus `json:"lastDownloadJobStatus,omitempty" azure:"ro"`

	// READ-ONLY; JobStatus of the last ran install job.
	LastInstallJobStatus *JobStatus `json:"lastInstallJobStatus,omitempty" azure:"ro"`

	// READ-ONLY; The current update operation.
	OngoingUpdateOperation *UpdateOperation `json:"ongoingUpdateOperation,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if updates are available and at least one of the updates needs a reboot.
	RebootBehavior *InstallRebootBehavior `json:"rebootBehavior,omitempty" azure:"ro"`

	// READ-ONLY; The number of updates available for the current device version as per the last device scan.
	TotalNumberOfUpdatesAvailable *int32 `json:"totalNumberOfUpdatesAvailable,omitempty" azure:"ro"`

	// READ-ONLY; The total number of items pending download.
	TotalNumberOfUpdatesPendingDownload *int32 `json:"totalNumberOfUpdatesPendingDownload,omitempty" azure:"ro"`

	// READ-ONLY; The total number of items pending install.
	TotalNumberOfUpdatesPendingInstall *int32 `json:"totalNumberOfUpdatesPendingInstall,omitempty" azure:"ro"`

	// READ-ONLY; The total time in Minutes
	TotalTimeInMinutes *int32 `json:"totalTimeInMinutes,omitempty" azure:"ro"`

	// READ-ONLY; The total size of updates available for download in bytes.
	TotalUpdateSizeInBytes *float64 `json:"totalUpdateSizeInBytes,omitempty" azure:"ro"`

	// READ-ONLY; The list of updates available for install.
	UpdateTitles []*string `json:"updateTitles,omitempty" azure:"ro"`

	// READ-ONLY; The list of updates available for install.
	Updates []*UpdateDetails `json:"updates,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateSummaryProperties.
func (u UpdateSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "deviceLastScannedDateTime", u.DeviceLastScannedDateTime)
	populate(objectMap, "deviceVersionNumber", u.DeviceVersionNumber)
	populate(objectMap, "friendlyDeviceVersionName", u.FriendlyDeviceVersionName)
	populate(objectMap, "inProgressDownloadJobId", u.InProgressDownloadJobID)
	populateTimeRFC3339(objectMap, "inProgressDownloadJobStartedDateTime", u.InProgressDownloadJobStartedDateTime)
	populate(objectMap, "inProgressInstallJobId", u.InProgressInstallJobID)
	populateTimeRFC3339(objectMap, "inProgressInstallJobStartedDateTime", u.InProgressInstallJobStartedDateTime)
	populateTimeRFC3339(objectMap, "lastCompletedDownloadJobDateTime", u.LastCompletedDownloadJobDateTime)
	populate(objectMap, "lastCompletedDownloadJobId", u.LastCompletedDownloadJobID)
	populateTimeRFC3339(objectMap, "lastCompletedInstallJobDateTime", u.LastCompletedInstallJobDateTime)
	populate(objectMap, "lastCompletedInstallJobId", u.LastCompletedInstallJobID)
	populateTimeRFC3339(objectMap, "lastCompletedScanJobDateTime", u.LastCompletedScanJobDateTime)
	populate(objectMap, "lastDownloadJobStatus", u.LastDownloadJobStatus)
	populate(objectMap, "lastInstallJobStatus", u.LastInstallJobStatus)
	populateTimeRFC3339(objectMap, "lastSuccessfulInstallJobDateTime", u.LastSuccessfulInstallJobDateTime)
	populateTimeRFC3339(objectMap, "lastSuccessfulScanJobTime", u.LastSuccessfulScanJobTime)
	populate(objectMap, "ongoingUpdateOperation", u.OngoingUpdateOperation)
	populate(objectMap, "rebootBehavior", u.RebootBehavior)
	populate(objectMap, "totalNumberOfUpdatesAvailable", u.TotalNumberOfUpdatesAvailable)
	populate(objectMap, "totalNumberOfUpdatesPendingDownload", u.TotalNumberOfUpdatesPendingDownload)
	populate(objectMap, "totalNumberOfUpdatesPendingInstall", u.TotalNumberOfUpdatesPendingInstall)
	populate(objectMap, "totalTimeInMinutes", u.TotalTimeInMinutes)
	populate(objectMap, "totalUpdateSizeInBytes", u.TotalUpdateSizeInBytes)
	populate(objectMap, "updateTitles", u.UpdateTitles)
	populate(objectMap, "updates", u.Updates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateSummaryProperties.
func (u *UpdateSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceLastScannedDateTime":
			err = unpopulateTimeRFC3339(val, &u.DeviceLastScannedDateTime)
			delete(rawMsg, key)
		case "deviceVersionNumber":
			err = unpopulate(val, &u.DeviceVersionNumber)
			delete(rawMsg, key)
		case "friendlyDeviceVersionName":
			err = unpopulate(val, &u.FriendlyDeviceVersionName)
			delete(rawMsg, key)
		case "inProgressDownloadJobId":
			err = unpopulate(val, &u.InProgressDownloadJobID)
			delete(rawMsg, key)
		case "inProgressDownloadJobStartedDateTime":
			err = unpopulateTimeRFC3339(val, &u.InProgressDownloadJobStartedDateTime)
			delete(rawMsg, key)
		case "inProgressInstallJobId":
			err = unpopulate(val, &u.InProgressInstallJobID)
			delete(rawMsg, key)
		case "inProgressInstallJobStartedDateTime":
			err = unpopulateTimeRFC3339(val, &u.InProgressInstallJobStartedDateTime)
			delete(rawMsg, key)
		case "lastCompletedDownloadJobDateTime":
			err = unpopulateTimeRFC3339(val, &u.LastCompletedDownloadJobDateTime)
			delete(rawMsg, key)
		case "lastCompletedDownloadJobId":
			err = unpopulate(val, &u.LastCompletedDownloadJobID)
			delete(rawMsg, key)
		case "lastCompletedInstallJobDateTime":
			err = unpopulateTimeRFC3339(val, &u.LastCompletedInstallJobDateTime)
			delete(rawMsg, key)
		case "lastCompletedInstallJobId":
			err = unpopulate(val, &u.LastCompletedInstallJobID)
			delete(rawMsg, key)
		case "lastCompletedScanJobDateTime":
			err = unpopulateTimeRFC3339(val, &u.LastCompletedScanJobDateTime)
			delete(rawMsg, key)
		case "lastDownloadJobStatus":
			err = unpopulate(val, &u.LastDownloadJobStatus)
			delete(rawMsg, key)
		case "lastInstallJobStatus":
			err = unpopulate(val, &u.LastInstallJobStatus)
			delete(rawMsg, key)
		case "lastSuccessfulInstallJobDateTime":
			err = unpopulateTimeRFC3339(val, &u.LastSuccessfulInstallJobDateTime)
			delete(rawMsg, key)
		case "lastSuccessfulScanJobTime":
			err = unpopulateTimeRFC3339(val, &u.LastSuccessfulScanJobTime)
			delete(rawMsg, key)
		case "ongoingUpdateOperation":
			err = unpopulate(val, &u.OngoingUpdateOperation)
			delete(rawMsg, key)
		case "rebootBehavior":
			err = unpopulate(val, &u.RebootBehavior)
			delete(rawMsg, key)
		case "totalNumberOfUpdatesAvailable":
			err = unpopulate(val, &u.TotalNumberOfUpdatesAvailable)
			delete(rawMsg, key)
		case "totalNumberOfUpdatesPendingDownload":
			err = unpopulate(val, &u.TotalNumberOfUpdatesPendingDownload)
			delete(rawMsg, key)
		case "totalNumberOfUpdatesPendingInstall":
			err = unpopulate(val, &u.TotalNumberOfUpdatesPendingInstall)
			delete(rawMsg, key)
		case "totalTimeInMinutes":
			err = unpopulate(val, &u.TotalTimeInMinutes)
			delete(rawMsg, key)
		case "totalUpdateSizeInBytes":
			err = unpopulate(val, &u.TotalUpdateSizeInBytes)
			delete(rawMsg, key)
		case "updateTitles":
			err = unpopulate(val, &u.UpdateTitles)
			delete(rawMsg, key)
		case "updates":
			err = unpopulate(val, &u.Updates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UploadCertificateRequest - The upload certificate request.
type UploadCertificateRequest struct {
	// REQUIRED; The Base 64 encoded certificate raw data.
	Properties *RawCertificateData `json:"properties,omitempty"`
}

// UploadCertificateResponse - The upload registration certificate response.
type UploadCertificateResponse struct {
	// Specifies authentication type.
	AuthType *AuthenticationType `json:"authType,omitempty"`

	// READ-ONLY; Identifier of the target resource that is the recipient of the requested token.
	AADAudience *string `json:"aadAudience,omitempty" azure:"ro"`

	// READ-ONLY; Azure Active Directory tenant authority.
	AADAuthority *string `json:"aadAuthority,omitempty" azure:"ro"`

	// READ-ONLY; Azure Active Directory tenant ID.
	AADTenantID *string `json:"aadTenantId,omitempty" azure:"ro"`

	// READ-ONLY; The azure management endpoint audience.
	AzureManagementEndpointAudience *string `json:"azureManagementEndpointAudience,omitempty" azure:"ro"`

	// READ-ONLY; The resource ID of the Data Box Edge/Gateway device.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; Azure Active Directory service principal client ID.
	ServicePrincipalClientID *string `json:"servicePrincipalClientId,omitempty" azure:"ro"`

	// READ-ONLY; Azure Active Directory service principal object ID.
	ServicePrincipalObjectID *string `json:"servicePrincipalObjectId,omitempty" azure:"ro"`
}

// User - Represents a user who has access to one or more shares on the Data Box Edge/Gateway device.
type User struct {
	ARMBaseModel
	// REQUIRED; The storage account credential properties.
	Properties *UserProperties `json:"properties,omitempty"`

	// READ-ONLY; User in DataBoxEdge Resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type User.
func (u User) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.ARMBaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type User.
func (u *User) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &u.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.ARMBaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UserAccessRight - The mapping between a particular user and the access type on the SMB share.
type UserAccessRight struct {
	// REQUIRED; Type of access to be allowed for the user.
	AccessType *ShareAccessType `json:"accessType,omitempty"`

	// REQUIRED; User ID (already existing in the device).
	UserID *string `json:"userId,omitempty"`
}

// UserList - Collection of users.
type UserList struct {
	// READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of users.
	Value []*User `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UserList.
func (u UserList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UserProperties - The user properties.
type UserProperties struct {
	// REQUIRED; Type of the user.
	UserType *UserType `json:"userType,omitempty"`

	// The password details.
	EncryptedPassword *AsymmetricEncryptedSecret `json:"encryptedPassword,omitempty"`

	// READ-ONLY; List of shares that the user has rights on. This field should not be specified during user creation.
	ShareAccessRights []*ShareAccessRight `json:"shareAccessRights,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UserProperties.
func (u UserProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedPassword", u.EncryptedPassword)
	populate(objectMap, "shareAccessRights", u.ShareAccessRights)
	populate(objectMap, "userType", u.UserType)
	return json.Marshal(objectMap)
}

// UsersBeginCreateOrUpdateOptions contains the optional parameters for the Users.BeginCreateOrUpdate method.
type UsersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// UsersBeginDeleteOptions contains the optional parameters for the Users.BeginDelete method.
type UsersBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// UsersGetOptions contains the optional parameters for the Users.Get method.
type UsersGetOptions struct {
	// placeholder for future optional parameters
}

// UsersListByDataBoxEdgeDeviceOptions contains the optional parameters for the Users.ListByDataBoxEdgeDevice method.
type UsersListByDataBoxEdgeDeviceOptions struct {
	// Specify $filter='Type eq <type>' to filter on user type property
	Filter *string
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
