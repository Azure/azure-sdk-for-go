//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdataboxedge

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AddonsListByRolePager provides operations for iterating over paged responses.
type AddonsListByRolePager struct {
	client    *AddonsClient
	current   AddonsListByRoleResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AddonsListByRoleResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AddonsListByRolePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AddonsListByRolePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AddonList.NextLink == nil || len(*p.current.AddonList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRoleHandleError(resp)
		return false
	}
	result, err := p.client.listByRoleHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AddonsListByRoleResponse page.
func (p *AddonsListByRolePager) PageResponse() AddonsListByRoleResponse {
	return p.current
}

// AlertsListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type AlertsListByDataBoxEdgeDevicePager struct {
	client    *AlertsClient
	current   AlertsListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsListByDataBoxEdgeDeviceResponse page.
func (p *AlertsListByDataBoxEdgeDevicePager) PageResponse() AlertsListByDataBoxEdgeDeviceResponse {
	return p.current
}

// AvailableSKUsListPager provides operations for iterating over paged responses.
type AvailableSKUsListPager struct {
	client    *AvailableSKUsClient
	current   AvailableSKUsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableSKUsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableSKUsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableSKUsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataBoxEdgeSKUList.NextLink == nil || len(*p.current.DataBoxEdgeSKUList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableSKUsListResponse page.
func (p *AvailableSKUsListPager) PageResponse() AvailableSKUsListResponse {
	return p.current
}

// BandwidthSchedulesListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type BandwidthSchedulesListByDataBoxEdgeDevicePager struct {
	client    *BandwidthSchedulesClient
	current   BandwidthSchedulesListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BandwidthSchedulesListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BandwidthSchedulesListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BandwidthSchedulesListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BandwidthSchedulesList.NextLink == nil || len(*p.current.BandwidthSchedulesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BandwidthSchedulesListByDataBoxEdgeDeviceResponse page.
func (p *BandwidthSchedulesListByDataBoxEdgeDevicePager) PageResponse() BandwidthSchedulesListByDataBoxEdgeDeviceResponse {
	return p.current
}

// ContainersListByStorageAccountPager provides operations for iterating over paged responses.
type ContainersListByStorageAccountPager struct {
	client    *ContainersClient
	current   ContainersListByStorageAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainersListByStorageAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContainersListByStorageAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContainersListByStorageAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerList.NextLink == nil || len(*p.current.ContainerList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByStorageAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByStorageAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContainersListByStorageAccountResponse page.
func (p *ContainersListByStorageAccountPager) PageResponse() ContainersListByStorageAccountResponse {
	return p.current
}

// DevicesListByResourceGroupPager provides operations for iterating over paged responses.
type DevicesListByResourceGroupPager struct {
	client    *DevicesClient
	current   DevicesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DevicesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DevicesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DevicesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataBoxEdgeDeviceList.NextLink == nil || len(*p.current.DataBoxEdgeDeviceList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DevicesListByResourceGroupResponse page.
func (p *DevicesListByResourceGroupPager) PageResponse() DevicesListByResourceGroupResponse {
	return p.current
}

// DevicesListBySubscriptionPager provides operations for iterating over paged responses.
type DevicesListBySubscriptionPager struct {
	client    *DevicesClient
	current   DevicesListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DevicesListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DevicesListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DevicesListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataBoxEdgeDeviceList.NextLink == nil || len(*p.current.DataBoxEdgeDeviceList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DevicesListBySubscriptionResponse page.
func (p *DevicesListBySubscriptionPager) PageResponse() DevicesListBySubscriptionResponse {
	return p.current
}

// MonitoringConfigListPager provides operations for iterating over paged responses.
type MonitoringConfigListPager struct {
	client    *MonitoringConfigClient
	current   MonitoringConfigListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, MonitoringConfigListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *MonitoringConfigListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *MonitoringConfigListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.MonitoringMetricConfigurationList.NextLink == nil || len(*p.current.MonitoringMetricConfigurationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current MonitoringConfigListResponse page.
func (p *MonitoringConfigListPager) PageResponse() MonitoringConfigListResponse {
	return p.current
}

// NodesListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type NodesListByDataBoxEdgeDevicePager struct {
	client    *NodesClient
	current   NodesListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NodesListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NodesListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NodesListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NodeList.NextLink == nil || len(*p.current.NodeList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NodesListByDataBoxEdgeDeviceResponse page.
func (p *NodesListByDataBoxEdgeDevicePager) PageResponse() NodesListByDataBoxEdgeDeviceResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationsList.NextLink == nil || len(*p.current.OperationsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// OrdersListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type OrdersListByDataBoxEdgeDevicePager struct {
	client    *OrdersClient
	current   OrdersListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OrdersListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OrdersListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OrdersListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OrderList.NextLink == nil || len(*p.current.OrderList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OrdersListByDataBoxEdgeDeviceResponse page.
func (p *OrdersListByDataBoxEdgeDevicePager) PageResponse() OrdersListByDataBoxEdgeDeviceResponse {
	return p.current
}

// RolesListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type RolesListByDataBoxEdgeDevicePager struct {
	client    *RolesClient
	current   RolesListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RolesListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RolesListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RolesListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleList.NextLink == nil || len(*p.current.RoleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RolesListByDataBoxEdgeDeviceResponse page.
func (p *RolesListByDataBoxEdgeDevicePager) PageResponse() RolesListByDataBoxEdgeDeviceResponse {
	return p.current
}

// SharesListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type SharesListByDataBoxEdgeDevicePager struct {
	client    *SharesClient
	current   SharesListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharesListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharesListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareList.NextLink == nil || len(*p.current.ShareList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharesListByDataBoxEdgeDeviceResponse page.
func (p *SharesListByDataBoxEdgeDevicePager) PageResponse() SharesListByDataBoxEdgeDeviceResponse {
	return p.current
}

// StorageAccountCredentialsListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type StorageAccountCredentialsListByDataBoxEdgeDevicePager struct {
	client    *StorageAccountCredentialsClient
	current   StorageAccountCredentialsListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StorageAccountCredentialsListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StorageAccountCredentialsListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StorageAccountCredentialsListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StorageAccountCredentialList.NextLink == nil || len(*p.current.StorageAccountCredentialList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StorageAccountCredentialsListByDataBoxEdgeDeviceResponse page.
func (p *StorageAccountCredentialsListByDataBoxEdgeDevicePager) PageResponse() StorageAccountCredentialsListByDataBoxEdgeDeviceResponse {
	return p.current
}

// StorageAccountsListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type StorageAccountsListByDataBoxEdgeDevicePager struct {
	client    *StorageAccountsClient
	current   StorageAccountsListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StorageAccountsListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StorageAccountsListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StorageAccountsListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StorageAccountList.NextLink == nil || len(*p.current.StorageAccountList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StorageAccountsListByDataBoxEdgeDeviceResponse page.
func (p *StorageAccountsListByDataBoxEdgeDevicePager) PageResponse() StorageAccountsListByDataBoxEdgeDeviceResponse {
	return p.current
}

// TriggersListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type TriggersListByDataBoxEdgeDevicePager struct {
	client    *TriggersClient
	current   TriggersListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TriggersListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TriggersListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TriggersListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggerList.NextLink == nil || len(*p.current.TriggerList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TriggersListByDataBoxEdgeDeviceResponse page.
func (p *TriggersListByDataBoxEdgeDevicePager) PageResponse() TriggersListByDataBoxEdgeDeviceResponse {
	return p.current
}

// UsersListByDataBoxEdgeDevicePager provides operations for iterating over paged responses.
type UsersListByDataBoxEdgeDevicePager struct {
	client    *UsersClient
	current   UsersListByDataBoxEdgeDeviceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsersListByDataBoxEdgeDeviceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsersListByDataBoxEdgeDevicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsersListByDataBoxEdgeDevicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserList.NextLink == nil || len(*p.current.UserList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataBoxEdgeDeviceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataBoxEdgeDeviceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsersListByDataBoxEdgeDeviceResponse page.
func (p *UsersListByDataBoxEdgeDevicePager) PageResponse() UsersListByDataBoxEdgeDeviceResponse {
	return p.current
}
