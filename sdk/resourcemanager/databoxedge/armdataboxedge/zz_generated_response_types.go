//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdataboxedge

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AddonsClientCreateOrUpdatePollerResponse contains the response from method AddonsClient.CreateOrUpdate.
type AddonsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AddonsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AddonsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsClientCreateOrUpdateResponse, error) {
	respType := AddonsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AddonsClientCreateOrUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AddonsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AddonsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AddonsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AddonsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AddonsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AddonsClientCreateOrUpdateResponse contains the response from method AddonsClient.CreateOrUpdate.
type AddonsClientCreateOrUpdateResponse struct {
	AddonsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsClientCreateOrUpdateResult contains the result from method AddonsClient.CreateOrUpdate.
type AddonsClientCreateOrUpdateResult struct {
	AddonClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonsClientCreateOrUpdateResult.
func (a *AddonsClientCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalAddonClassification(data)
	if err != nil {
		return err
	}
	a.AddonClassification = res
	return nil
}

// AddonsClientDeletePollerResponse contains the response from method AddonsClient.Delete.
type AddonsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AddonsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AddonsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsClientDeleteResponse, error) {
	respType := AddonsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AddonsClientDeletePollerResponse from the provided client and resume token.
func (l *AddonsClientDeletePollerResponse) Resume(ctx context.Context, client *AddonsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AddonsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AddonsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AddonsClientDeleteResponse contains the response from method AddonsClient.Delete.
type AddonsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsClientGetResponse contains the response from method AddonsClient.Get.
type AddonsClientGetResponse struct {
	AddonsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsClientGetResult contains the result from method AddonsClient.Get.
type AddonsClientGetResult struct {
	AddonClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonsClientGetResult.
func (a *AddonsClientGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalAddonClassification(data)
	if err != nil {
		return err
	}
	a.AddonClassification = res
	return nil
}

// AddonsClientListByRoleResponse contains the response from method AddonsClient.ListByRole.
type AddonsClientListByRoleResponse struct {
	AddonsClientListByRoleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsClientListByRoleResult contains the result from method AddonsClient.ListByRole.
type AddonsClientListByRoleResult struct {
	AddonList
}

// AlertsClientGetResponse contains the response from method AlertsClient.Get.
type AlertsClientGetResponse struct {
	AlertsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AlertsClientGetResult contains the result from method AlertsClient.Get.
type AlertsClientGetResult struct {
	Alert
}

// AlertsClientListByDataBoxEdgeDeviceResponse contains the response from method AlertsClient.ListByDataBoxEdgeDevice.
type AlertsClientListByDataBoxEdgeDeviceResponse struct {
	AlertsClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AlertsClientListByDataBoxEdgeDeviceResult contains the result from method AlertsClient.ListByDataBoxEdgeDevice.
type AlertsClientListByDataBoxEdgeDeviceResult struct {
	AlertList
}

// AvailableSKUsClientListResponse contains the response from method AvailableSKUsClient.List.
type AvailableSKUsClientListResponse struct {
	AvailableSKUsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableSKUsClientListResult contains the result from method AvailableSKUsClient.List.
type AvailableSKUsClientListResult struct {
	SKUList
}

// BandwidthSchedulesClientCreateOrUpdatePollerResponse contains the response from method BandwidthSchedulesClient.CreateOrUpdate.
type BandwidthSchedulesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BandwidthSchedulesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BandwidthSchedulesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BandwidthSchedulesClientCreateOrUpdateResponse, error) {
	respType := BandwidthSchedulesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BandwidthSchedule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BandwidthSchedulesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BandwidthSchedulesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BandwidthSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BandwidthSchedulesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BandwidthSchedulesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BandwidthSchedulesClientCreateOrUpdateResponse contains the response from method BandwidthSchedulesClient.CreateOrUpdate.
type BandwidthSchedulesClientCreateOrUpdateResponse struct {
	BandwidthSchedulesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesClientCreateOrUpdateResult contains the result from method BandwidthSchedulesClient.CreateOrUpdate.
type BandwidthSchedulesClientCreateOrUpdateResult struct {
	BandwidthSchedule
}

// BandwidthSchedulesClientDeletePollerResponse contains the response from method BandwidthSchedulesClient.Delete.
type BandwidthSchedulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BandwidthSchedulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BandwidthSchedulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BandwidthSchedulesClientDeleteResponse, error) {
	respType := BandwidthSchedulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BandwidthSchedulesClientDeletePollerResponse from the provided client and resume token.
func (l *BandwidthSchedulesClientDeletePollerResponse) Resume(ctx context.Context, client *BandwidthSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BandwidthSchedulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BandwidthSchedulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BandwidthSchedulesClientDeleteResponse contains the response from method BandwidthSchedulesClient.Delete.
type BandwidthSchedulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesClientGetResponse contains the response from method BandwidthSchedulesClient.Get.
type BandwidthSchedulesClientGetResponse struct {
	BandwidthSchedulesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesClientGetResult contains the result from method BandwidthSchedulesClient.Get.
type BandwidthSchedulesClientGetResult struct {
	BandwidthSchedule
}

// BandwidthSchedulesClientListByDataBoxEdgeDeviceResponse contains the response from method BandwidthSchedulesClient.ListByDataBoxEdgeDevice.
type BandwidthSchedulesClientListByDataBoxEdgeDeviceResponse struct {
	BandwidthSchedulesClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesClientListByDataBoxEdgeDeviceResult contains the result from method BandwidthSchedulesClient.ListByDataBoxEdgeDevice.
type BandwidthSchedulesClientListByDataBoxEdgeDeviceResult struct {
	BandwidthSchedulesList
}

// ContainersClientCreateOrUpdatePollerResponse contains the response from method ContainersClient.CreateOrUpdate.
type ContainersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersClientCreateOrUpdateResponse, error) {
	respType := ContainersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Container)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ContainersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ContainersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainersClientCreateOrUpdateResponse contains the response from method ContainersClient.CreateOrUpdate.
type ContainersClientCreateOrUpdateResponse struct {
	ContainersClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersClientCreateOrUpdateResult contains the result from method ContainersClient.CreateOrUpdate.
type ContainersClientCreateOrUpdateResult struct {
	Container
}

// ContainersClientDeletePollerResponse contains the response from method ContainersClient.Delete.
type ContainersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersClientDeleteResponse, error) {
	respType := ContainersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainersClientDeletePollerResponse from the provided client and resume token.
func (l *ContainersClientDeletePollerResponse) Resume(ctx context.Context, client *ContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ContainersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainersClientDeleteResponse contains the response from method ContainersClient.Delete.
type ContainersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersClientGetResponse contains the response from method ContainersClient.Get.
type ContainersClientGetResponse struct {
	ContainersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersClientGetResult contains the result from method ContainersClient.Get.
type ContainersClientGetResult struct {
	Container
}

// ContainersClientListByStorageAccountResponse contains the response from method ContainersClient.ListByStorageAccount.
type ContainersClientListByStorageAccountResponse struct {
	ContainersClientListByStorageAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersClientListByStorageAccountResult contains the result from method ContainersClient.ListByStorageAccount.
type ContainersClientListByStorageAccountResult struct {
	ContainerList
}

// ContainersClientRefreshPollerResponse contains the response from method ContainersClient.Refresh.
type ContainersClientRefreshPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainersClientRefreshPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainersClientRefreshPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersClientRefreshResponse, error) {
	respType := ContainersClientRefreshResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainersClientRefreshPollerResponse from the provided client and resume token.
func (l *ContainersClientRefreshPollerResponse) Resume(ctx context.Context, client *ContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainersClient.Refresh", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ContainersClientRefreshPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainersClientRefreshResponse contains the response from method ContainersClient.Refresh.
type ContainersClientRefreshResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientCreateOrUpdateResponse contains the response from method DevicesClient.CreateOrUpdate.
type DevicesClientCreateOrUpdateResponse struct {
	DevicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientCreateOrUpdateResult contains the result from method DevicesClient.CreateOrUpdate.
type DevicesClientCreateOrUpdateResult struct {
	Device
}

// DevicesClientCreateOrUpdateSecuritySettingsPollerResponse contains the response from method DevicesClient.CreateOrUpdateSecuritySettings.
type DevicesClientCreateOrUpdateSecuritySettingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesClientCreateOrUpdateSecuritySettingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesClientCreateOrUpdateSecuritySettingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientCreateOrUpdateSecuritySettingsResponse, error) {
	respType := DevicesClientCreateOrUpdateSecuritySettingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesClientCreateOrUpdateSecuritySettingsPollerResponse from the provided client and resume token.
func (l *DevicesClientCreateOrUpdateSecuritySettingsPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.CreateOrUpdateSecuritySettings", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DevicesClientCreateOrUpdateSecuritySettingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesClientCreateOrUpdateSecuritySettingsResponse contains the response from method DevicesClient.CreateOrUpdateSecuritySettings.
type DevicesClientCreateOrUpdateSecuritySettingsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientDeletePollerResponse contains the response from method DevicesClient.Delete.
type DevicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientDeleteResponse, error) {
	respType := DevicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesClientDeletePollerResponse from the provided client and resume token.
func (l *DevicesClientDeletePollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DevicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesClientDeleteResponse contains the response from method DevicesClient.Delete.
type DevicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientDownloadUpdatesPollerResponse contains the response from method DevicesClient.DownloadUpdates.
type DevicesClientDownloadUpdatesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesClientDownloadUpdatesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesClientDownloadUpdatesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientDownloadUpdatesResponse, error) {
	respType := DevicesClientDownloadUpdatesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesClientDownloadUpdatesPollerResponse from the provided client and resume token.
func (l *DevicesClientDownloadUpdatesPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.DownloadUpdates", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DevicesClientDownloadUpdatesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesClientDownloadUpdatesResponse contains the response from method DevicesClient.DownloadUpdates.
type DevicesClientDownloadUpdatesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientGenerateCertificateResponse contains the response from method DevicesClient.GenerateCertificate.
type DevicesClientGenerateCertificateResponse struct {
	DevicesClientGenerateCertificateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientGenerateCertificateResult contains the result from method DevicesClient.GenerateCertificate.
type DevicesClientGenerateCertificateResult struct {
	GenerateCertResponse
}

// DevicesClientGetExtendedInformationResponse contains the response from method DevicesClient.GetExtendedInformation.
type DevicesClientGetExtendedInformationResponse struct {
	DevicesClientGetExtendedInformationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientGetExtendedInformationResult contains the result from method DevicesClient.GetExtendedInformation.
type DevicesClientGetExtendedInformationResult struct {
	DeviceExtendedInfo
}

// DevicesClientGetNetworkSettingsResponse contains the response from method DevicesClient.GetNetworkSettings.
type DevicesClientGetNetworkSettingsResponse struct {
	DevicesClientGetNetworkSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientGetNetworkSettingsResult contains the result from method DevicesClient.GetNetworkSettings.
type DevicesClientGetNetworkSettingsResult struct {
	NetworkSettings
}

// DevicesClientGetResponse contains the response from method DevicesClient.Get.
type DevicesClientGetResponse struct {
	DevicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientGetResult contains the result from method DevicesClient.Get.
type DevicesClientGetResult struct {
	Device
}

// DevicesClientGetUpdateSummaryResponse contains the response from method DevicesClient.GetUpdateSummary.
type DevicesClientGetUpdateSummaryResponse struct {
	DevicesClientGetUpdateSummaryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientGetUpdateSummaryResult contains the result from method DevicesClient.GetUpdateSummary.
type DevicesClientGetUpdateSummaryResult struct {
	UpdateSummary
}

// DevicesClientInstallUpdatesPollerResponse contains the response from method DevicesClient.InstallUpdates.
type DevicesClientInstallUpdatesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesClientInstallUpdatesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesClientInstallUpdatesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientInstallUpdatesResponse, error) {
	respType := DevicesClientInstallUpdatesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesClientInstallUpdatesPollerResponse from the provided client and resume token.
func (l *DevicesClientInstallUpdatesPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.InstallUpdates", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DevicesClientInstallUpdatesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesClientInstallUpdatesResponse contains the response from method DevicesClient.InstallUpdates.
type DevicesClientInstallUpdatesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientListByResourceGroupResponse contains the response from method DevicesClient.ListByResourceGroup.
type DevicesClientListByResourceGroupResponse struct {
	DevicesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientListByResourceGroupResult contains the result from method DevicesClient.ListByResourceGroup.
type DevicesClientListByResourceGroupResult struct {
	DeviceList
}

// DevicesClientListBySubscriptionResponse contains the response from method DevicesClient.ListBySubscription.
type DevicesClientListBySubscriptionResponse struct {
	DevicesClientListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientListBySubscriptionResult contains the result from method DevicesClient.ListBySubscription.
type DevicesClientListBySubscriptionResult struct {
	DeviceList
}

// DevicesClientScanForUpdatesPollerResponse contains the response from method DevicesClient.ScanForUpdates.
type DevicesClientScanForUpdatesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesClientScanForUpdatesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesClientScanForUpdatesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientScanForUpdatesResponse, error) {
	respType := DevicesClientScanForUpdatesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesClientScanForUpdatesPollerResponse from the provided client and resume token.
func (l *DevicesClientScanForUpdatesPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.ScanForUpdates", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DevicesClientScanForUpdatesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesClientScanForUpdatesResponse contains the response from method DevicesClient.ScanForUpdates.
type DevicesClientScanForUpdatesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientUpdateExtendedInformationResponse contains the response from method DevicesClient.UpdateExtendedInformation.
type DevicesClientUpdateExtendedInformationResponse struct {
	DevicesClientUpdateExtendedInformationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientUpdateExtendedInformationResult contains the result from method DevicesClient.UpdateExtendedInformation.
type DevicesClientUpdateExtendedInformationResult struct {
	DeviceExtendedInfo
}

// DevicesClientUpdateResponse contains the response from method DevicesClient.Update.
type DevicesClientUpdateResponse struct {
	DevicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientUpdateResult contains the result from method DevicesClient.Update.
type DevicesClientUpdateResult struct {
	Device
}

// DevicesClientUploadCertificateResponse contains the response from method DevicesClient.UploadCertificate.
type DevicesClientUploadCertificateResponse struct {
	DevicesClientUploadCertificateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesClientUploadCertificateResult contains the result from method DevicesClient.UploadCertificate.
type DevicesClientUploadCertificateResult struct {
	UploadCertificateResponse
}

// DiagnosticSettingsClientGetDiagnosticProactiveLogCollectionSettingsResponse contains the response from method DiagnosticSettingsClient.GetDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsClientGetDiagnosticProactiveLogCollectionSettingsResponse struct {
	DiagnosticSettingsClientGetDiagnosticProactiveLogCollectionSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsClientGetDiagnosticProactiveLogCollectionSettingsResult contains the result from method DiagnosticSettingsClient.GetDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsClientGetDiagnosticProactiveLogCollectionSettingsResult struct {
	DiagnosticProactiveLogCollectionSettings
}

// DiagnosticSettingsClientGetDiagnosticRemoteSupportSettingsResponse contains the response from method DiagnosticSettingsClient.GetDiagnosticRemoteSupportSettings.
type DiagnosticSettingsClientGetDiagnosticRemoteSupportSettingsResponse struct {
	DiagnosticSettingsClientGetDiagnosticRemoteSupportSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsClientGetDiagnosticRemoteSupportSettingsResult contains the result from method DiagnosticSettingsClient.GetDiagnosticRemoteSupportSettings.
type DiagnosticSettingsClientGetDiagnosticRemoteSupportSettingsResult struct {
	DiagnosticRemoteSupportSettings
}

// DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse contains the response from method
// DiagnosticSettingsClient.UpdateDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse, error) {
	respType := DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiagnosticProactiveLogCollectionSettings)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse from the provided
// client and resume token.
func (l *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse) Resume(ctx context.Context, client *DiagnosticSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiagnosticSettingsClient.UpdateDiagnosticProactiveLogCollectionSettings", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse contains the response from method DiagnosticSettingsClient.UpdateDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse struct {
	DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResult contains the result from method DiagnosticSettingsClient.UpdateDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResult struct {
	DiagnosticProactiveLogCollectionSettings
}

// DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPollerResponse contains the response from method DiagnosticSettingsClient.UpdateDiagnosticRemoteSupportSettings.
type DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse, error) {
	respType := DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiagnosticRemoteSupportSettings)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPollerResponse from the provided client
// and resume token.
func (l *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPollerResponse) Resume(ctx context.Context, client *DiagnosticSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiagnosticSettingsClient.UpdateDiagnosticRemoteSupportSettings", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse contains the response from method DiagnosticSettingsClient.UpdateDiagnosticRemoteSupportSettings.
type DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse struct {
	DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResult contains the result from method DiagnosticSettingsClient.UpdateDiagnosticRemoteSupportSettings.
type DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResult struct {
	DiagnosticRemoteSupportSettings
}

// JobsClientGetResponse contains the response from method JobsClient.Get.
type JobsClientGetResponse struct {
	JobsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobsClientGetResult contains the result from method JobsClient.Get.
type JobsClientGetResult struct {
	Job
}

// MonitoringConfigClientCreateOrUpdatePollerResponse contains the response from method MonitoringConfigClient.CreateOrUpdate.
type MonitoringConfigClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringConfigClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitoringConfigClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringConfigClientCreateOrUpdateResponse, error) {
	respType := MonitoringConfigClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitoringMetricConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringConfigClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *MonitoringConfigClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *MonitoringConfigClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringConfigClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &MonitoringConfigClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringConfigClientCreateOrUpdateResponse contains the response from method MonitoringConfigClient.CreateOrUpdate.
type MonitoringConfigClientCreateOrUpdateResponse struct {
	MonitoringConfigClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigClientCreateOrUpdateResult contains the result from method MonitoringConfigClient.CreateOrUpdate.
type MonitoringConfigClientCreateOrUpdateResult struct {
	MonitoringMetricConfiguration
}

// MonitoringConfigClientDeletePollerResponse contains the response from method MonitoringConfigClient.Delete.
type MonitoringConfigClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringConfigClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitoringConfigClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringConfigClientDeleteResponse, error) {
	respType := MonitoringConfigClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringConfigClientDeletePollerResponse from the provided client and resume token.
func (l *MonitoringConfigClientDeletePollerResponse) Resume(ctx context.Context, client *MonitoringConfigClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringConfigClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &MonitoringConfigClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringConfigClientDeleteResponse contains the response from method MonitoringConfigClient.Delete.
type MonitoringConfigClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigClientGetResponse contains the response from method MonitoringConfigClient.Get.
type MonitoringConfigClientGetResponse struct {
	MonitoringConfigClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigClientGetResult contains the result from method MonitoringConfigClient.Get.
type MonitoringConfigClientGetResult struct {
	MonitoringMetricConfiguration
}

// MonitoringConfigClientListResponse contains the response from method MonitoringConfigClient.List.
type MonitoringConfigClientListResponse struct {
	MonitoringConfigClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigClientListResult contains the result from method MonitoringConfigClient.List.
type MonitoringConfigClientListResult struct {
	MonitoringMetricConfigurationList
}

// NodesClientListByDataBoxEdgeDeviceResponse contains the response from method NodesClient.ListByDataBoxEdgeDevice.
type NodesClientListByDataBoxEdgeDeviceResponse struct {
	NodesClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NodesClientListByDataBoxEdgeDeviceResult contains the result from method NodesClient.ListByDataBoxEdgeDevice.
type NodesClientListByDataBoxEdgeDeviceResult struct {
	NodeList
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationsList
}

// OperationsStatusClientGetResponse contains the response from method OperationsStatusClient.Get.
type OperationsStatusClientGetResponse struct {
	OperationsStatusClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsStatusClientGetResult contains the result from method OperationsStatusClient.Get.
type OperationsStatusClientGetResult struct {
	Job
}

// OrdersClientCreateOrUpdatePollerResponse contains the response from method OrdersClient.CreateOrUpdate.
type OrdersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OrdersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OrdersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OrdersClientCreateOrUpdateResponse, error) {
	respType := OrdersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Order)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OrdersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *OrdersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *OrdersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OrdersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OrdersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OrdersClientCreateOrUpdateResponse contains the response from method OrdersClient.CreateOrUpdate.
type OrdersClientCreateOrUpdateResponse struct {
	OrdersClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersClientCreateOrUpdateResult contains the result from method OrdersClient.CreateOrUpdate.
type OrdersClientCreateOrUpdateResult struct {
	Order
}

// OrdersClientDeletePollerResponse contains the response from method OrdersClient.Delete.
type OrdersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OrdersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OrdersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OrdersClientDeleteResponse, error) {
	respType := OrdersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OrdersClientDeletePollerResponse from the provided client and resume token.
func (l *OrdersClientDeletePollerResponse) Resume(ctx context.Context, client *OrdersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OrdersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &OrdersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OrdersClientDeleteResponse contains the response from method OrdersClient.Delete.
type OrdersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersClientGetResponse contains the response from method OrdersClient.Get.
type OrdersClientGetResponse struct {
	OrdersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersClientGetResult contains the result from method OrdersClient.Get.
type OrdersClientGetResult struct {
	Order
}

// OrdersClientListByDataBoxEdgeDeviceResponse contains the response from method OrdersClient.ListByDataBoxEdgeDevice.
type OrdersClientListByDataBoxEdgeDeviceResponse struct {
	OrdersClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersClientListByDataBoxEdgeDeviceResult contains the result from method OrdersClient.ListByDataBoxEdgeDevice.
type OrdersClientListByDataBoxEdgeDeviceResult struct {
	OrderList
}

// OrdersClientListDCAccessCodeResponse contains the response from method OrdersClient.ListDCAccessCode.
type OrdersClientListDCAccessCodeResponse struct {
	OrdersClientListDCAccessCodeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersClientListDCAccessCodeResult contains the result from method OrdersClient.ListDCAccessCode.
type OrdersClientListDCAccessCodeResult struct {
	DCAccessCode
}

// RolesClientCreateOrUpdatePollerResponse contains the response from method RolesClient.CreateOrUpdate.
type RolesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RolesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RolesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RolesClientCreateOrUpdateResponse, error) {
	respType := RolesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RolesClientCreateOrUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RolesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RolesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RolesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RolesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RolesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RolesClientCreateOrUpdateResponse contains the response from method RolesClient.CreateOrUpdate.
type RolesClientCreateOrUpdateResponse struct {
	RolesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesClientCreateOrUpdateResult contains the result from method RolesClient.CreateOrUpdate.
type RolesClientCreateOrUpdateResult struct {
	RoleClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RolesClientCreateOrUpdateResult.
func (r *RolesClientCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalRoleClassification(data)
	if err != nil {
		return err
	}
	r.RoleClassification = res
	return nil
}

// RolesClientDeletePollerResponse contains the response from method RolesClient.Delete.
type RolesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RolesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RolesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RolesClientDeleteResponse, error) {
	respType := RolesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RolesClientDeletePollerResponse from the provided client and resume token.
func (l *RolesClientDeletePollerResponse) Resume(ctx context.Context, client *RolesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RolesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RolesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RolesClientDeleteResponse contains the response from method RolesClient.Delete.
type RolesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesClientGetResponse contains the response from method RolesClient.Get.
type RolesClientGetResponse struct {
	RolesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesClientGetResult contains the result from method RolesClient.Get.
type RolesClientGetResult struct {
	RoleClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RolesClientGetResult.
func (r *RolesClientGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalRoleClassification(data)
	if err != nil {
		return err
	}
	r.RoleClassification = res
	return nil
}

// RolesClientListByDataBoxEdgeDeviceResponse contains the response from method RolesClient.ListByDataBoxEdgeDevice.
type RolesClientListByDataBoxEdgeDeviceResponse struct {
	RolesClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesClientListByDataBoxEdgeDeviceResult contains the result from method RolesClient.ListByDataBoxEdgeDevice.
type RolesClientListByDataBoxEdgeDeviceResult struct {
	RoleList
}

// SharesClientCreateOrUpdatePollerResponse contains the response from method SharesClient.CreateOrUpdate.
type SharesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SharesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SharesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SharesClientCreateOrUpdateResponse, error) {
	respType := SharesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Share)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SharesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SharesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SharesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SharesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SharesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SharesClientCreateOrUpdateResponse contains the response from method SharesClient.CreateOrUpdate.
type SharesClientCreateOrUpdateResponse struct {
	SharesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesClientCreateOrUpdateResult contains the result from method SharesClient.CreateOrUpdate.
type SharesClientCreateOrUpdateResult struct {
	Share
}

// SharesClientDeletePollerResponse contains the response from method SharesClient.Delete.
type SharesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SharesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SharesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SharesClientDeleteResponse, error) {
	respType := SharesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SharesClientDeletePollerResponse from the provided client and resume token.
func (l *SharesClientDeletePollerResponse) Resume(ctx context.Context, client *SharesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SharesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SharesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SharesClientDeleteResponse contains the response from method SharesClient.Delete.
type SharesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesClientGetResponse contains the response from method SharesClient.Get.
type SharesClientGetResponse struct {
	SharesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesClientGetResult contains the result from method SharesClient.Get.
type SharesClientGetResult struct {
	Share
}

// SharesClientListByDataBoxEdgeDeviceResponse contains the response from method SharesClient.ListByDataBoxEdgeDevice.
type SharesClientListByDataBoxEdgeDeviceResponse struct {
	SharesClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesClientListByDataBoxEdgeDeviceResult contains the result from method SharesClient.ListByDataBoxEdgeDevice.
type SharesClientListByDataBoxEdgeDeviceResult struct {
	ShareList
}

// SharesClientRefreshPollerResponse contains the response from method SharesClient.Refresh.
type SharesClientRefreshPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SharesClientRefreshPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SharesClientRefreshPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SharesClientRefreshResponse, error) {
	respType := SharesClientRefreshResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SharesClientRefreshPollerResponse from the provided client and resume token.
func (l *SharesClientRefreshPollerResponse) Resume(ctx context.Context, client *SharesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SharesClient.Refresh", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SharesClientRefreshPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SharesClientRefreshResponse contains the response from method SharesClient.Refresh.
type SharesClientRefreshResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsClientCreateOrUpdatePollerResponse contains the response from method StorageAccountCredentialsClient.CreateOrUpdate.
type StorageAccountCredentialsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountCredentialsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountCredentialsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountCredentialsClientCreateOrUpdateResponse, error) {
	respType := StorageAccountCredentialsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageAccountCredential)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountCredentialsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *StorageAccountCredentialsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *StorageAccountCredentialsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountCredentialsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageAccountCredentialsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountCredentialsClientCreateOrUpdateResponse contains the response from method StorageAccountCredentialsClient.CreateOrUpdate.
type StorageAccountCredentialsClientCreateOrUpdateResponse struct {
	StorageAccountCredentialsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsClientCreateOrUpdateResult contains the result from method StorageAccountCredentialsClient.CreateOrUpdate.
type StorageAccountCredentialsClientCreateOrUpdateResult struct {
	StorageAccountCredential
}

// StorageAccountCredentialsClientDeletePollerResponse contains the response from method StorageAccountCredentialsClient.Delete.
type StorageAccountCredentialsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountCredentialsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountCredentialsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountCredentialsClientDeleteResponse, error) {
	respType := StorageAccountCredentialsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountCredentialsClientDeletePollerResponse from the provided client and resume token.
func (l *StorageAccountCredentialsClientDeletePollerResponse) Resume(ctx context.Context, client *StorageAccountCredentialsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountCredentialsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageAccountCredentialsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountCredentialsClientDeleteResponse contains the response from method StorageAccountCredentialsClient.Delete.
type StorageAccountCredentialsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsClientGetResponse contains the response from method StorageAccountCredentialsClient.Get.
type StorageAccountCredentialsClientGetResponse struct {
	StorageAccountCredentialsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsClientGetResult contains the result from method StorageAccountCredentialsClient.Get.
type StorageAccountCredentialsClientGetResult struct {
	StorageAccountCredential
}

// StorageAccountCredentialsClientListByDataBoxEdgeDeviceResponse contains the response from method StorageAccountCredentialsClient.ListByDataBoxEdgeDevice.
type StorageAccountCredentialsClientListByDataBoxEdgeDeviceResponse struct {
	StorageAccountCredentialsClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsClientListByDataBoxEdgeDeviceResult contains the result from method StorageAccountCredentialsClient.ListByDataBoxEdgeDevice.
type StorageAccountCredentialsClientListByDataBoxEdgeDeviceResult struct {
	StorageAccountCredentialList
}

// StorageAccountsClientCreateOrUpdatePollerResponse contains the response from method StorageAccountsClient.CreateOrUpdate.
type StorageAccountsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountsClientCreateOrUpdateResponse, error) {
	respType := StorageAccountsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageAccount)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *StorageAccountsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *StorageAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageAccountsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountsClientCreateOrUpdateResponse contains the response from method StorageAccountsClient.CreateOrUpdate.
type StorageAccountsClientCreateOrUpdateResponse struct {
	StorageAccountsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsClientCreateOrUpdateResult contains the result from method StorageAccountsClient.CreateOrUpdate.
type StorageAccountsClientCreateOrUpdateResult struct {
	StorageAccount
}

// StorageAccountsClientDeletePollerResponse contains the response from method StorageAccountsClient.Delete.
type StorageAccountsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountsClientDeleteResponse, error) {
	respType := StorageAccountsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountsClientDeletePollerResponse from the provided client and resume token.
func (l *StorageAccountsClientDeletePollerResponse) Resume(ctx context.Context, client *StorageAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageAccountsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountsClientDeleteResponse contains the response from method StorageAccountsClient.Delete.
type StorageAccountsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsClientGetResponse contains the response from method StorageAccountsClient.Get.
type StorageAccountsClientGetResponse struct {
	StorageAccountsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsClientGetResult contains the result from method StorageAccountsClient.Get.
type StorageAccountsClientGetResult struct {
	StorageAccount
}

// StorageAccountsClientListByDataBoxEdgeDeviceResponse contains the response from method StorageAccountsClient.ListByDataBoxEdgeDevice.
type StorageAccountsClientListByDataBoxEdgeDeviceResponse struct {
	StorageAccountsClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsClientListByDataBoxEdgeDeviceResult contains the result from method StorageAccountsClient.ListByDataBoxEdgeDevice.
type StorageAccountsClientListByDataBoxEdgeDeviceResult struct {
	StorageAccountList
}

// SupportPackagesClientTriggerSupportPackagePollerResponse contains the response from method SupportPackagesClient.TriggerSupportPackage.
type SupportPackagesClientTriggerSupportPackagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SupportPackagesClientTriggerSupportPackagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SupportPackagesClientTriggerSupportPackagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SupportPackagesClientTriggerSupportPackageResponse, error) {
	respType := SupportPackagesClientTriggerSupportPackageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SupportPackagesClientTriggerSupportPackagePollerResponse from the provided client and resume token.
func (l *SupportPackagesClientTriggerSupportPackagePollerResponse) Resume(ctx context.Context, client *SupportPackagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SupportPackagesClient.TriggerSupportPackage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SupportPackagesClientTriggerSupportPackagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SupportPackagesClientTriggerSupportPackageResponse contains the response from method SupportPackagesClient.TriggerSupportPackage.
type SupportPackagesClientTriggerSupportPackageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersClientCreateOrUpdatePollerResponse contains the response from method TriggersClient.CreateOrUpdate.
type TriggersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TriggersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggersClientCreateOrUpdateResponse, error) {
	respType := TriggersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggersClientCreateOrUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *TriggersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *TriggersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TriggersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &TriggersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggersClientCreateOrUpdateResponse contains the response from method TriggersClient.CreateOrUpdate.
type TriggersClientCreateOrUpdateResponse struct {
	TriggersClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersClientCreateOrUpdateResult contains the result from method TriggersClient.CreateOrUpdate.
type TriggersClientCreateOrUpdateResult struct {
	TriggerClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggersClientCreateOrUpdateResult.
func (t *TriggersClientCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalTriggerClassification(data)
	if err != nil {
		return err
	}
	t.TriggerClassification = res
	return nil
}

// TriggersClientDeletePollerResponse contains the response from method TriggersClient.Delete.
type TriggersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TriggersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggersClientDeleteResponse, error) {
	respType := TriggersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggersClientDeletePollerResponse from the provided client and resume token.
func (l *TriggersClientDeletePollerResponse) Resume(ctx context.Context, client *TriggersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TriggersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &TriggersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggersClientDeleteResponse contains the response from method TriggersClient.Delete.
type TriggersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersClientGetResponse contains the response from method TriggersClient.Get.
type TriggersClientGetResponse struct {
	TriggersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersClientGetResult contains the result from method TriggersClient.Get.
type TriggersClientGetResult struct {
	TriggerClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggersClientGetResult.
func (t *TriggersClientGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalTriggerClassification(data)
	if err != nil {
		return err
	}
	t.TriggerClassification = res
	return nil
}

// TriggersClientListByDataBoxEdgeDeviceResponse contains the response from method TriggersClient.ListByDataBoxEdgeDevice.
type TriggersClientListByDataBoxEdgeDeviceResponse struct {
	TriggersClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersClientListByDataBoxEdgeDeviceResult contains the result from method TriggersClient.ListByDataBoxEdgeDevice.
type TriggersClientListByDataBoxEdgeDeviceResult struct {
	TriggerList
}

// UsersClientCreateOrUpdatePollerResponse contains the response from method UsersClient.CreateOrUpdate.
type UsersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersClientCreateOrUpdateResponse, error) {
	respType := UsersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.User)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *UsersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &UsersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersClientCreateOrUpdateResponse contains the response from method UsersClient.CreateOrUpdate.
type UsersClientCreateOrUpdateResponse struct {
	UsersClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersClientCreateOrUpdateResult contains the result from method UsersClient.CreateOrUpdate.
type UsersClientCreateOrUpdateResult struct {
	User
}

// UsersClientDeletePollerResponse contains the response from method UsersClient.Delete.
type UsersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersClientDeleteResponse, error) {
	respType := UsersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersClientDeletePollerResponse from the provided client and resume token.
func (l *UsersClientDeletePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &UsersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersClientDeleteResponse contains the response from method UsersClient.Delete.
type UsersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersClientGetResponse contains the response from method UsersClient.Get.
type UsersClientGetResponse struct {
	UsersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersClientGetResult contains the result from method UsersClient.Get.
type UsersClientGetResult struct {
	User
}

// UsersClientListByDataBoxEdgeDeviceResponse contains the response from method UsersClient.ListByDataBoxEdgeDevice.
type UsersClientListByDataBoxEdgeDeviceResponse struct {
	UsersClientListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersClientListByDataBoxEdgeDeviceResult contains the result from method UsersClient.ListByDataBoxEdgeDevice.
type UsersClientListByDataBoxEdgeDeviceResult struct {
	UserList
}
