//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdataboxedge

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AddonsCreateOrUpdatePollerResponse contains the response from method Addons.CreateOrUpdate.
type AddonsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AddonsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AddonsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsCreateOrUpdateResponse, error) {
	respType := AddonsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AddonClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AddonsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AddonsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AddonsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AddonsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AddonsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AddonsCreateOrUpdateResponse contains the response from method Addons.CreateOrUpdate.
type AddonsCreateOrUpdateResponse struct {
	AddonsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsCreateOrUpdateResult contains the result from method Addons.CreateOrUpdate.
type AddonsCreateOrUpdateResult struct {
	AddonClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonsCreateOrUpdateResult.
func (a *AddonsCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalAddonClassification(data)
	if err != nil {
		return err
	}
	a.AddonClassification = res
	return nil
}

// AddonsDeletePollerResponse contains the response from method Addons.Delete.
type AddonsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AddonsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AddonsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsDeleteResponse, error) {
	respType := AddonsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AddonsDeletePollerResponse from the provided client and resume token.
func (l *AddonsDeletePollerResponse) Resume(ctx context.Context, client *AddonsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AddonsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AddonsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AddonsDeleteResponse contains the response from method Addons.Delete.
type AddonsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsGetResponse contains the response from method Addons.Get.
type AddonsGetResponse struct {
	AddonsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsGetResult contains the result from method Addons.Get.
type AddonsGetResult struct {
	AddonClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonsGetResult.
func (a *AddonsGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalAddonClassification(data)
	if err != nil {
		return err
	}
	a.AddonClassification = res
	return nil
}

// AddonsListByRoleResponse contains the response from method Addons.ListByRole.
type AddonsListByRoleResponse struct {
	AddonsListByRoleResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsListByRoleResult contains the result from method Addons.ListByRole.
type AddonsListByRoleResult struct {
	AddonList
}

// AlertsGetResponse contains the response from method Alerts.Get.
type AlertsGetResponse struct {
	AlertsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AlertsGetResult contains the result from method Alerts.Get.
type AlertsGetResult struct {
	Alert
}

// AlertsListByDataBoxEdgeDeviceResponse contains the response from method Alerts.ListByDataBoxEdgeDevice.
type AlertsListByDataBoxEdgeDeviceResponse struct {
	AlertsListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AlertsListByDataBoxEdgeDeviceResult contains the result from method Alerts.ListByDataBoxEdgeDevice.
type AlertsListByDataBoxEdgeDeviceResult struct {
	AlertList
}

// AvailableSKUsListResponse contains the response from method AvailableSKUs.List.
type AvailableSKUsListResponse struct {
	AvailableSKUsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableSKUsListResult contains the result from method AvailableSKUs.List.
type AvailableSKUsListResult struct {
	DataBoxEdgeSKUList
}

// BandwidthSchedulesCreateOrUpdatePollerResponse contains the response from method BandwidthSchedules.CreateOrUpdate.
type BandwidthSchedulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BandwidthSchedulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BandwidthSchedulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BandwidthSchedulesCreateOrUpdateResponse, error) {
	respType := BandwidthSchedulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BandwidthSchedule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BandwidthSchedulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BandwidthSchedulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BandwidthSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BandwidthSchedulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &BandwidthSchedulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BandwidthSchedulesCreateOrUpdateResponse contains the response from method BandwidthSchedules.CreateOrUpdate.
type BandwidthSchedulesCreateOrUpdateResponse struct {
	BandwidthSchedulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesCreateOrUpdateResult contains the result from method BandwidthSchedules.CreateOrUpdate.
type BandwidthSchedulesCreateOrUpdateResult struct {
	BandwidthSchedule
}

// BandwidthSchedulesDeletePollerResponse contains the response from method BandwidthSchedules.Delete.
type BandwidthSchedulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BandwidthSchedulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BandwidthSchedulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BandwidthSchedulesDeleteResponse, error) {
	respType := BandwidthSchedulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BandwidthSchedulesDeletePollerResponse from the provided client and resume token.
func (l *BandwidthSchedulesDeletePollerResponse) Resume(ctx context.Context, client *BandwidthSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BandwidthSchedulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &BandwidthSchedulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BandwidthSchedulesDeleteResponse contains the response from method BandwidthSchedules.Delete.
type BandwidthSchedulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesGetResponse contains the response from method BandwidthSchedules.Get.
type BandwidthSchedulesGetResponse struct {
	BandwidthSchedulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesGetResult contains the result from method BandwidthSchedules.Get.
type BandwidthSchedulesGetResult struct {
	BandwidthSchedule
}

// BandwidthSchedulesListByDataBoxEdgeDeviceResponse contains the response from method BandwidthSchedules.ListByDataBoxEdgeDevice.
type BandwidthSchedulesListByDataBoxEdgeDeviceResponse struct {
	BandwidthSchedulesListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BandwidthSchedulesListByDataBoxEdgeDeviceResult contains the result from method BandwidthSchedules.ListByDataBoxEdgeDevice.
type BandwidthSchedulesListByDataBoxEdgeDeviceResult struct {
	BandwidthSchedulesList
}

// ContainersCreateOrUpdatePollerResponse contains the response from method Containers.CreateOrUpdate.
type ContainersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersCreateOrUpdateResponse, error) {
	respType := ContainersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Container)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ContainersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ContainersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainersCreateOrUpdateResponse contains the response from method Containers.CreateOrUpdate.
type ContainersCreateOrUpdateResponse struct {
	ContainersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersCreateOrUpdateResult contains the result from method Containers.CreateOrUpdate.
type ContainersCreateOrUpdateResult struct {
	Container
}

// ContainersDeletePollerResponse contains the response from method Containers.Delete.
type ContainersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersDeleteResponse, error) {
	respType := ContainersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainersDeletePollerResponse from the provided client and resume token.
func (l *ContainersDeletePollerResponse) Resume(ctx context.Context, client *ContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ContainersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainersDeleteResponse contains the response from method Containers.Delete.
type ContainersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersGetResponse contains the response from method Containers.Get.
type ContainersGetResponse struct {
	ContainersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersGetResult contains the result from method Containers.Get.
type ContainersGetResult struct {
	Container
}

// ContainersListByStorageAccountResponse contains the response from method Containers.ListByStorageAccount.
type ContainersListByStorageAccountResponse struct {
	ContainersListByStorageAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainersListByStorageAccountResult contains the result from method Containers.ListByStorageAccount.
type ContainersListByStorageAccountResult struct {
	ContainerList
}

// ContainersRefreshPollerResponse contains the response from method Containers.Refresh.
type ContainersRefreshPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainersRefreshPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainersRefreshPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersRefreshResponse, error) {
	respType := ContainersRefreshResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainersRefreshPollerResponse from the provided client and resume token.
func (l *ContainersRefreshPollerResponse) Resume(ctx context.Context, client *ContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainersClient.Refresh", token, client.pl, client.refreshHandleError)
	if err != nil {
		return err
	}
	poller := &ContainersRefreshPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainersRefreshResponse contains the response from method Containers.Refresh.
type ContainersRefreshResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesCreateOrUpdateResponse contains the response from method Devices.CreateOrUpdate.
type DevicesCreateOrUpdateResponse struct {
	DevicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesCreateOrUpdateResult contains the result from method Devices.CreateOrUpdate.
type DevicesCreateOrUpdateResult struct {
	DataBoxEdgeDevice
}

// DevicesCreateOrUpdateSecuritySettingsPollerResponse contains the response from method Devices.CreateOrUpdateSecuritySettings.
type DevicesCreateOrUpdateSecuritySettingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesCreateOrUpdateSecuritySettingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesCreateOrUpdateSecuritySettingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesCreateOrUpdateSecuritySettingsResponse, error) {
	respType := DevicesCreateOrUpdateSecuritySettingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesCreateOrUpdateSecuritySettingsPollerResponse from the provided client and resume token.
func (l *DevicesCreateOrUpdateSecuritySettingsPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.CreateOrUpdateSecuritySettings", token, client.pl, client.createOrUpdateSecuritySettingsHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesCreateOrUpdateSecuritySettingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesCreateOrUpdateSecuritySettingsResponse contains the response from method Devices.CreateOrUpdateSecuritySettings.
type DevicesCreateOrUpdateSecuritySettingsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesDeletePollerResponse contains the response from method Devices.Delete.
type DevicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesDeleteResponse, error) {
	respType := DevicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesDeletePollerResponse from the provided client and resume token.
func (l *DevicesDeletePollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesDeleteResponse contains the response from method Devices.Delete.
type DevicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesDownloadUpdatesPollerResponse contains the response from method Devices.DownloadUpdates.
type DevicesDownloadUpdatesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesDownloadUpdatesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesDownloadUpdatesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesDownloadUpdatesResponse, error) {
	respType := DevicesDownloadUpdatesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesDownloadUpdatesPollerResponse from the provided client and resume token.
func (l *DevicesDownloadUpdatesPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.DownloadUpdates", token, client.pl, client.downloadUpdatesHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesDownloadUpdatesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesDownloadUpdatesResponse contains the response from method Devices.DownloadUpdates.
type DevicesDownloadUpdatesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGenerateCertificateResponse contains the response from method Devices.GenerateCertificate.
type DevicesGenerateCertificateResponse struct {
	DevicesGenerateCertificateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGenerateCertificateResult contains the result from method Devices.GenerateCertificate.
type DevicesGenerateCertificateResult struct {
	GenerateCertResponse
}

// DevicesGetExtendedInformationResponse contains the response from method Devices.GetExtendedInformation.
type DevicesGetExtendedInformationResponse struct {
	DevicesGetExtendedInformationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGetExtendedInformationResult contains the result from method Devices.GetExtendedInformation.
type DevicesGetExtendedInformationResult struct {
	DataBoxEdgeDeviceExtendedInfo
}

// DevicesGetNetworkSettingsResponse contains the response from method Devices.GetNetworkSettings.
type DevicesGetNetworkSettingsResponse struct {
	DevicesGetNetworkSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGetNetworkSettingsResult contains the result from method Devices.GetNetworkSettings.
type DevicesGetNetworkSettingsResult struct {
	NetworkSettings
}

// DevicesGetResponse contains the response from method Devices.Get.
type DevicesGetResponse struct {
	DevicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGetResult contains the result from method Devices.Get.
type DevicesGetResult struct {
	DataBoxEdgeDevice
}

// DevicesGetUpdateSummaryResponse contains the response from method Devices.GetUpdateSummary.
type DevicesGetUpdateSummaryResponse struct {
	DevicesGetUpdateSummaryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGetUpdateSummaryResult contains the result from method Devices.GetUpdateSummary.
type DevicesGetUpdateSummaryResult struct {
	UpdateSummary
}

// DevicesInstallUpdatesPollerResponse contains the response from method Devices.InstallUpdates.
type DevicesInstallUpdatesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesInstallUpdatesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesInstallUpdatesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesInstallUpdatesResponse, error) {
	respType := DevicesInstallUpdatesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesInstallUpdatesPollerResponse from the provided client and resume token.
func (l *DevicesInstallUpdatesPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.InstallUpdates", token, client.pl, client.installUpdatesHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesInstallUpdatesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesInstallUpdatesResponse contains the response from method Devices.InstallUpdates.
type DevicesInstallUpdatesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesListByResourceGroupResponse contains the response from method Devices.ListByResourceGroup.
type DevicesListByResourceGroupResponse struct {
	DevicesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesListByResourceGroupResult contains the result from method Devices.ListByResourceGroup.
type DevicesListByResourceGroupResult struct {
	DataBoxEdgeDeviceList
}

// DevicesListBySubscriptionResponse contains the response from method Devices.ListBySubscription.
type DevicesListBySubscriptionResponse struct {
	DevicesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesListBySubscriptionResult contains the result from method Devices.ListBySubscription.
type DevicesListBySubscriptionResult struct {
	DataBoxEdgeDeviceList
}

// DevicesScanForUpdatesPollerResponse contains the response from method Devices.ScanForUpdates.
type DevicesScanForUpdatesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesScanForUpdatesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesScanForUpdatesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesScanForUpdatesResponse, error) {
	respType := DevicesScanForUpdatesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesScanForUpdatesPollerResponse from the provided client and resume token.
func (l *DevicesScanForUpdatesPollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.ScanForUpdates", token, client.pl, client.scanForUpdatesHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesScanForUpdatesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesScanForUpdatesResponse contains the response from method Devices.ScanForUpdates.
type DevicesScanForUpdatesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesUpdateExtendedInformationResponse contains the response from method Devices.UpdateExtendedInformation.
type DevicesUpdateExtendedInformationResponse struct {
	DevicesUpdateExtendedInformationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesUpdateExtendedInformationResult contains the result from method Devices.UpdateExtendedInformation.
type DevicesUpdateExtendedInformationResult struct {
	DataBoxEdgeDeviceExtendedInfo
}

// DevicesUpdateResponse contains the response from method Devices.Update.
type DevicesUpdateResponse struct {
	DevicesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesUpdateResult contains the result from method Devices.Update.
type DevicesUpdateResult struct {
	DataBoxEdgeDevice
}

// DevicesUploadCertificateResponse contains the response from method Devices.UploadCertificate.
type DevicesUploadCertificateResponse struct {
	DevicesUploadCertificateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesUploadCertificateResult contains the result from method Devices.UploadCertificate.
type DevicesUploadCertificateResult struct {
	UploadCertificateResponse
}

// DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsResponse contains the response from method DiagnosticSettings.GetDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsResponse struct {
	DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsResult contains the result from method DiagnosticSettings.GetDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsGetDiagnosticProactiveLogCollectionSettingsResult struct {
	DiagnosticProactiveLogCollectionSettings
}

// DiagnosticSettingsGetDiagnosticRemoteSupportSettingsResponse contains the response from method DiagnosticSettings.GetDiagnosticRemoteSupportSettings.
type DiagnosticSettingsGetDiagnosticRemoteSupportSettingsResponse struct {
	DiagnosticSettingsGetDiagnosticRemoteSupportSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsGetDiagnosticRemoteSupportSettingsResult contains the result from method DiagnosticSettings.GetDiagnosticRemoteSupportSettings.
type DiagnosticSettingsGetDiagnosticRemoteSupportSettingsResult struct {
	DiagnosticRemoteSupportSettings
}

// DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse contains the response from method DiagnosticSettings.UpdateDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResponse, error) {
	respType := DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiagnosticProactiveLogCollectionSettings)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse from the provided client and resume token.
func (l *DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPollerResponse) Resume(ctx context.Context, client *DiagnosticSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiagnosticSettingsClient.UpdateDiagnosticProactiveLogCollectionSettings", token, client.pl, client.updateDiagnosticProactiveLogCollectionSettingsHandleError)
	if err != nil {
		return err
	}
	poller := &DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResponse contains the response from method DiagnosticSettings.UpdateDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResponse struct {
	DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResult contains the result from method DiagnosticSettings.UpdateDiagnosticProactiveLogCollectionSettings.
type DiagnosticSettingsUpdateDiagnosticProactiveLogCollectionSettingsResult struct {
	DiagnosticProactiveLogCollectionSettings
}

// DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPollerResponse contains the response from method DiagnosticSettings.UpdateDiagnosticRemoteSupportSettings.
type DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResponse, error) {
	respType := DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiagnosticRemoteSupportSettings)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPollerResponse from the provided client and resume token.
func (l *DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPollerResponse) Resume(ctx context.Context, client *DiagnosticSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiagnosticSettingsClient.UpdateDiagnosticRemoteSupportSettings", token, client.pl, client.updateDiagnosticRemoteSupportSettingsHandleError)
	if err != nil {
		return err
	}
	poller := &DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResponse contains the response from method DiagnosticSettings.UpdateDiagnosticRemoteSupportSettings.
type DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResponse struct {
	DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResult contains the result from method DiagnosticSettings.UpdateDiagnosticRemoteSupportSettings.
type DiagnosticSettingsUpdateDiagnosticRemoteSupportSettingsResult struct {
	DiagnosticRemoteSupportSettings
}

// JobsGetResponse contains the response from method Jobs.Get.
type JobsGetResponse struct {
	JobsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobsGetResult contains the result from method Jobs.Get.
type JobsGetResult struct {
	Job
}

// MonitoringConfigCreateOrUpdatePollerResponse contains the response from method MonitoringConfig.CreateOrUpdate.
type MonitoringConfigCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringConfigCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitoringConfigCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringConfigCreateOrUpdateResponse, error) {
	respType := MonitoringConfigCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitoringMetricConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringConfigCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *MonitoringConfigCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *MonitoringConfigClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringConfigClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &MonitoringConfigCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringConfigCreateOrUpdateResponse contains the response from method MonitoringConfig.CreateOrUpdate.
type MonitoringConfigCreateOrUpdateResponse struct {
	MonitoringConfigCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigCreateOrUpdateResult contains the result from method MonitoringConfig.CreateOrUpdate.
type MonitoringConfigCreateOrUpdateResult struct {
	MonitoringMetricConfiguration
}

// MonitoringConfigDeletePollerResponse contains the response from method MonitoringConfig.Delete.
type MonitoringConfigDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringConfigDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitoringConfigDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringConfigDeleteResponse, error) {
	respType := MonitoringConfigDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringConfigDeletePollerResponse from the provided client and resume token.
func (l *MonitoringConfigDeletePollerResponse) Resume(ctx context.Context, client *MonitoringConfigClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringConfigClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &MonitoringConfigDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringConfigDeleteResponse contains the response from method MonitoringConfig.Delete.
type MonitoringConfigDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigGetResponse contains the response from method MonitoringConfig.Get.
type MonitoringConfigGetResponse struct {
	MonitoringConfigGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigGetResult contains the result from method MonitoringConfig.Get.
type MonitoringConfigGetResult struct {
	MonitoringMetricConfiguration
}

// MonitoringConfigListResponse contains the response from method MonitoringConfig.List.
type MonitoringConfigListResponse struct {
	MonitoringConfigListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringConfigListResult contains the result from method MonitoringConfig.List.
type MonitoringConfigListResult struct {
	MonitoringMetricConfigurationList
}

// NodesListByDataBoxEdgeDeviceResponse contains the response from method Nodes.ListByDataBoxEdgeDevice.
type NodesListByDataBoxEdgeDeviceResponse struct {
	NodesListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NodesListByDataBoxEdgeDeviceResult contains the result from method Nodes.ListByDataBoxEdgeDevice.
type NodesListByDataBoxEdgeDeviceResult struct {
	NodeList
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationsList
}

// OperationsStatusGetResponse contains the response from method OperationsStatus.Get.
type OperationsStatusGetResponse struct {
	OperationsStatusGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsStatusGetResult contains the result from method OperationsStatus.Get.
type OperationsStatusGetResult struct {
	Job
}

// OrdersCreateOrUpdatePollerResponse contains the response from method Orders.CreateOrUpdate.
type OrdersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OrdersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OrdersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OrdersCreateOrUpdateResponse, error) {
	respType := OrdersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Order)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OrdersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *OrdersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *OrdersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OrdersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &OrdersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OrdersCreateOrUpdateResponse contains the response from method Orders.CreateOrUpdate.
type OrdersCreateOrUpdateResponse struct {
	OrdersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersCreateOrUpdateResult contains the result from method Orders.CreateOrUpdate.
type OrdersCreateOrUpdateResult struct {
	Order
}

// OrdersDeletePollerResponse contains the response from method Orders.Delete.
type OrdersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OrdersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OrdersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OrdersDeleteResponse, error) {
	respType := OrdersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OrdersDeletePollerResponse from the provided client and resume token.
func (l *OrdersDeletePollerResponse) Resume(ctx context.Context, client *OrdersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OrdersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &OrdersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OrdersDeleteResponse contains the response from method Orders.Delete.
type OrdersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersGetResponse contains the response from method Orders.Get.
type OrdersGetResponse struct {
	OrdersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersGetResult contains the result from method Orders.Get.
type OrdersGetResult struct {
	Order
}

// OrdersListByDataBoxEdgeDeviceResponse contains the response from method Orders.ListByDataBoxEdgeDevice.
type OrdersListByDataBoxEdgeDeviceResponse struct {
	OrdersListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersListByDataBoxEdgeDeviceResult contains the result from method Orders.ListByDataBoxEdgeDevice.
type OrdersListByDataBoxEdgeDeviceResult struct {
	OrderList
}

// OrdersListDCAccessCodeResponse contains the response from method Orders.ListDCAccessCode.
type OrdersListDCAccessCodeResponse struct {
	OrdersListDCAccessCodeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OrdersListDCAccessCodeResult contains the result from method Orders.ListDCAccessCode.
type OrdersListDCAccessCodeResult struct {
	DCAccessCode
}

// RolesCreateOrUpdatePollerResponse contains the response from method Roles.CreateOrUpdate.
type RolesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RolesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RolesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RolesCreateOrUpdateResponse, error) {
	respType := RolesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RoleClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RolesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RolesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RolesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RolesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RolesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RolesCreateOrUpdateResponse contains the response from method Roles.CreateOrUpdate.
type RolesCreateOrUpdateResponse struct {
	RolesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesCreateOrUpdateResult contains the result from method Roles.CreateOrUpdate.
type RolesCreateOrUpdateResult struct {
	RoleClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RolesCreateOrUpdateResult.
func (r *RolesCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalRoleClassification(data)
	if err != nil {
		return err
	}
	r.RoleClassification = res
	return nil
}

// RolesDeletePollerResponse contains the response from method Roles.Delete.
type RolesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RolesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RolesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RolesDeleteResponse, error) {
	respType := RolesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RolesDeletePollerResponse from the provided client and resume token.
func (l *RolesDeletePollerResponse) Resume(ctx context.Context, client *RolesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RolesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RolesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RolesDeleteResponse contains the response from method Roles.Delete.
type RolesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesGetResponse contains the response from method Roles.Get.
type RolesGetResponse struct {
	RolesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesGetResult contains the result from method Roles.Get.
type RolesGetResult struct {
	RoleClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RolesGetResult.
func (r *RolesGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalRoleClassification(data)
	if err != nil {
		return err
	}
	r.RoleClassification = res
	return nil
}

// RolesListByDataBoxEdgeDeviceResponse contains the response from method Roles.ListByDataBoxEdgeDevice.
type RolesListByDataBoxEdgeDeviceResponse struct {
	RolesListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesListByDataBoxEdgeDeviceResult contains the result from method Roles.ListByDataBoxEdgeDevice.
type RolesListByDataBoxEdgeDeviceResult struct {
	RoleList
}

// SharesCreateOrUpdatePollerResponse contains the response from method Shares.CreateOrUpdate.
type SharesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SharesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SharesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SharesCreateOrUpdateResponse, error) {
	respType := SharesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Share)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SharesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SharesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SharesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SharesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SharesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SharesCreateOrUpdateResponse contains the response from method Shares.CreateOrUpdate.
type SharesCreateOrUpdateResponse struct {
	SharesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesCreateOrUpdateResult contains the result from method Shares.CreateOrUpdate.
type SharesCreateOrUpdateResult struct {
	Share
}

// SharesDeletePollerResponse contains the response from method Shares.Delete.
type SharesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SharesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SharesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SharesDeleteResponse, error) {
	respType := SharesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SharesDeletePollerResponse from the provided client and resume token.
func (l *SharesDeletePollerResponse) Resume(ctx context.Context, client *SharesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SharesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SharesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SharesDeleteResponse contains the response from method Shares.Delete.
type SharesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesGetResponse contains the response from method Shares.Get.
type SharesGetResponse struct {
	SharesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesGetResult contains the result from method Shares.Get.
type SharesGetResult struct {
	Share
}

// SharesListByDataBoxEdgeDeviceResponse contains the response from method Shares.ListByDataBoxEdgeDevice.
type SharesListByDataBoxEdgeDeviceResponse struct {
	SharesListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SharesListByDataBoxEdgeDeviceResult contains the result from method Shares.ListByDataBoxEdgeDevice.
type SharesListByDataBoxEdgeDeviceResult struct {
	ShareList
}

// SharesRefreshPollerResponse contains the response from method Shares.Refresh.
type SharesRefreshPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SharesRefreshPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SharesRefreshPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SharesRefreshResponse, error) {
	respType := SharesRefreshResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SharesRefreshPollerResponse from the provided client and resume token.
func (l *SharesRefreshPollerResponse) Resume(ctx context.Context, client *SharesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SharesClient.Refresh", token, client.pl, client.refreshHandleError)
	if err != nil {
		return err
	}
	poller := &SharesRefreshPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SharesRefreshResponse contains the response from method Shares.Refresh.
type SharesRefreshResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsCreateOrUpdatePollerResponse contains the response from method StorageAccountCredentials.CreateOrUpdate.
type StorageAccountCredentialsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountCredentialsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountCredentialsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountCredentialsCreateOrUpdateResponse, error) {
	respType := StorageAccountCredentialsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageAccountCredential)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountCredentialsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *StorageAccountCredentialsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *StorageAccountCredentialsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountCredentialsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &StorageAccountCredentialsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountCredentialsCreateOrUpdateResponse contains the response from method StorageAccountCredentials.CreateOrUpdate.
type StorageAccountCredentialsCreateOrUpdateResponse struct {
	StorageAccountCredentialsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsCreateOrUpdateResult contains the result from method StorageAccountCredentials.CreateOrUpdate.
type StorageAccountCredentialsCreateOrUpdateResult struct {
	StorageAccountCredential
}

// StorageAccountCredentialsDeletePollerResponse contains the response from method StorageAccountCredentials.Delete.
type StorageAccountCredentialsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountCredentialsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountCredentialsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountCredentialsDeleteResponse, error) {
	respType := StorageAccountCredentialsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountCredentialsDeletePollerResponse from the provided client and resume token.
func (l *StorageAccountCredentialsDeletePollerResponse) Resume(ctx context.Context, client *StorageAccountCredentialsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountCredentialsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &StorageAccountCredentialsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountCredentialsDeleteResponse contains the response from method StorageAccountCredentials.Delete.
type StorageAccountCredentialsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsGetResponse contains the response from method StorageAccountCredentials.Get.
type StorageAccountCredentialsGetResponse struct {
	StorageAccountCredentialsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsGetResult contains the result from method StorageAccountCredentials.Get.
type StorageAccountCredentialsGetResult struct {
	StorageAccountCredential
}

// StorageAccountCredentialsListByDataBoxEdgeDeviceResponse contains the response from method StorageAccountCredentials.ListByDataBoxEdgeDevice.
type StorageAccountCredentialsListByDataBoxEdgeDeviceResponse struct {
	StorageAccountCredentialsListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountCredentialsListByDataBoxEdgeDeviceResult contains the result from method StorageAccountCredentials.ListByDataBoxEdgeDevice.
type StorageAccountCredentialsListByDataBoxEdgeDeviceResult struct {
	StorageAccountCredentialList
}

// StorageAccountsCreateOrUpdatePollerResponse contains the response from method StorageAccounts.CreateOrUpdate.
type StorageAccountsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountsCreateOrUpdateResponse, error) {
	respType := StorageAccountsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageAccount)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *StorageAccountsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *StorageAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &StorageAccountsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountsCreateOrUpdateResponse contains the response from method StorageAccounts.CreateOrUpdate.
type StorageAccountsCreateOrUpdateResponse struct {
	StorageAccountsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsCreateOrUpdateResult contains the result from method StorageAccounts.CreateOrUpdate.
type StorageAccountsCreateOrUpdateResult struct {
	StorageAccount
}

// StorageAccountsDeletePollerResponse contains the response from method StorageAccounts.Delete.
type StorageAccountsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageAccountsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageAccountsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountsDeleteResponse, error) {
	respType := StorageAccountsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageAccountsDeletePollerResponse from the provided client and resume token.
func (l *StorageAccountsDeletePollerResponse) Resume(ctx context.Context, client *StorageAccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageAccountsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &StorageAccountsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageAccountsDeleteResponse contains the response from method StorageAccounts.Delete.
type StorageAccountsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsGetResponse contains the response from method StorageAccounts.Get.
type StorageAccountsGetResponse struct {
	StorageAccountsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsGetResult contains the result from method StorageAccounts.Get.
type StorageAccountsGetResult struct {
	StorageAccount
}

// StorageAccountsListByDataBoxEdgeDeviceResponse contains the response from method StorageAccounts.ListByDataBoxEdgeDevice.
type StorageAccountsListByDataBoxEdgeDeviceResponse struct {
	StorageAccountsListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageAccountsListByDataBoxEdgeDeviceResult contains the result from method StorageAccounts.ListByDataBoxEdgeDevice.
type StorageAccountsListByDataBoxEdgeDeviceResult struct {
	StorageAccountList
}

// SupportPackagesTriggerSupportPackagePollerResponse contains the response from method SupportPackages.TriggerSupportPackage.
type SupportPackagesTriggerSupportPackagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SupportPackagesTriggerSupportPackagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SupportPackagesTriggerSupportPackagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SupportPackagesTriggerSupportPackageResponse, error) {
	respType := SupportPackagesTriggerSupportPackageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SupportPackagesTriggerSupportPackagePollerResponse from the provided client and resume token.
func (l *SupportPackagesTriggerSupportPackagePollerResponse) Resume(ctx context.Context, client *SupportPackagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SupportPackagesClient.TriggerSupportPackage", token, client.pl, client.triggerSupportPackageHandleError)
	if err != nil {
		return err
	}
	poller := &SupportPackagesTriggerSupportPackagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SupportPackagesTriggerSupportPackageResponse contains the response from method SupportPackages.TriggerSupportPackage.
type SupportPackagesTriggerSupportPackageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersCreateOrUpdatePollerResponse contains the response from method Triggers.CreateOrUpdate.
type TriggersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TriggersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggersCreateOrUpdateResponse, error) {
	respType := TriggersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *TriggersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *TriggersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TriggersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &TriggersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggersCreateOrUpdateResponse contains the response from method Triggers.CreateOrUpdate.
type TriggersCreateOrUpdateResponse struct {
	TriggersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersCreateOrUpdateResult contains the result from method Triggers.CreateOrUpdate.
type TriggersCreateOrUpdateResult struct {
	TriggerClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggersCreateOrUpdateResult.
func (t *TriggersCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalTriggerClassification(data)
	if err != nil {
		return err
	}
	t.TriggerClassification = res
	return nil
}

// TriggersDeletePollerResponse contains the response from method Triggers.Delete.
type TriggersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TriggersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggersDeleteResponse, error) {
	respType := TriggersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggersDeletePollerResponse from the provided client and resume token.
func (l *TriggersDeletePollerResponse) Resume(ctx context.Context, client *TriggersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TriggersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &TriggersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggersDeleteResponse contains the response from method Triggers.Delete.
type TriggersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersGetResponse contains the response from method Triggers.Get.
type TriggersGetResponse struct {
	TriggersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersGetResult contains the result from method Triggers.Get.
type TriggersGetResult struct {
	TriggerClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggersGetResult.
func (t *TriggersGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalTriggerClassification(data)
	if err != nil {
		return err
	}
	t.TriggerClassification = res
	return nil
}

// TriggersListByDataBoxEdgeDeviceResponse contains the response from method Triggers.ListByDataBoxEdgeDevice.
type TriggersListByDataBoxEdgeDeviceResponse struct {
	TriggersListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggersListByDataBoxEdgeDeviceResult contains the result from method Triggers.ListByDataBoxEdgeDevice.
type TriggersListByDataBoxEdgeDeviceResult struct {
	TriggerList
}

// UsersCreateOrUpdatePollerResponse contains the response from method Users.CreateOrUpdate.
type UsersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersCreateOrUpdateResponse, error) {
	respType := UsersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.User)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *UsersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &UsersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersCreateOrUpdateResponse contains the response from method Users.CreateOrUpdate.
type UsersCreateOrUpdateResponse struct {
	UsersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersCreateOrUpdateResult contains the result from method Users.CreateOrUpdate.
type UsersCreateOrUpdateResult struct {
	User
}

// UsersDeletePollerResponse contains the response from method Users.Delete.
type UsersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersDeleteResponse, error) {
	respType := UsersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersDeletePollerResponse from the provided client and resume token.
func (l *UsersDeletePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &UsersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersDeleteResponse contains the response from method Users.Delete.
type UsersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersGetResponse contains the response from method Users.Get.
type UsersGetResponse struct {
	UsersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersGetResult contains the result from method Users.Get.
type UsersGetResult struct {
	User
}

// UsersListByDataBoxEdgeDeviceResponse contains the response from method Users.ListByDataBoxEdgeDevice.
type UsersListByDataBoxEdgeDeviceResponse struct {
	UsersListByDataBoxEdgeDeviceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersListByDataBoxEdgeDeviceResult contains the result from method Users.ListByDataBoxEdgeDevice.
type UsersListByDataBoxEdgeDeviceResult struct {
	UserList
}
