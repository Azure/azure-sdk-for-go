//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatafactory

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AccessPolicyResponse.
func (a AccessPolicyResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", a.AccessToken)
	populate(objectMap, "dataPlaneUrl", a.DataPlaneURL)
	populate(objectMap, "policy", a.Policy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessPolicyResponse.
func (a *AccessPolicyResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			err = unpopulate(val, "AccessToken", &a.AccessToken)
			delete(rawMsg, key)
		case "dataPlaneUrl":
			err = unpopulate(val, "DataPlaneURL", &a.DataPlaneURL)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &a.Policy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Activity.
func (a Activity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "state", a.State)
	objectMap["type"] = a.Type
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Activity.
func (a *Activity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActivityDependency.
func (a ActivityDependency) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activity", a.Activity)
	populate(objectMap, "dependencyConditions", a.DependencyConditions)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityDependency.
func (a *ActivityDependency) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activity":
			err = unpopulate(val, "Activity", &a.Activity)
			delete(rawMsg, key)
		case "dependencyConditions":
			err = unpopulate(val, "DependencyConditions", &a.DependencyConditions)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActivityPolicy.
func (a ActivityPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "retry", a.Retry)
	populate(objectMap, "retryIntervalInSeconds", a.RetryIntervalInSeconds)
	populate(objectMap, "secureInput", a.SecureInput)
	populate(objectMap, "secureOutput", a.SecureOutput)
	populateAny(objectMap, "timeout", a.Timeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityPolicy.
func (a *ActivityPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retry":
			err = unpopulate(val, "Retry", &a.Retry)
			delete(rawMsg, key)
		case "retryIntervalInSeconds":
			err = unpopulate(val, "RetryIntervalInSeconds", &a.RetryIntervalInSeconds)
			delete(rawMsg, key)
		case "secureInput":
			err = unpopulate(val, "SecureInput", &a.SecureInput)
			delete(rawMsg, key)
		case "secureOutput":
			err = unpopulate(val, "SecureOutput", &a.SecureOutput)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &a.Timeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActivityRun.
func (a ActivityRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityName", a.ActivityName)
	populateDateTimeRFC3339(objectMap, "activityRunEnd", a.ActivityRunEnd)
	populate(objectMap, "activityRunId", a.ActivityRunID)
	populateDateTimeRFC3339(objectMap, "activityRunStart", a.ActivityRunStart)
	populate(objectMap, "activityType", a.ActivityType)
	populate(objectMap, "durationInMs", a.DurationInMs)
	populateAny(objectMap, "error", a.Error)
	populateAny(objectMap, "input", a.Input)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populateAny(objectMap, "output", a.Output)
	populate(objectMap, "pipelineName", a.PipelineName)
	populate(objectMap, "pipelineRunId", a.PipelineRunID)
	populate(objectMap, "status", a.Status)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityRun.
func (a *ActivityRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityName":
			err = unpopulate(val, "ActivityName", &a.ActivityName)
			delete(rawMsg, key)
		case "activityRunEnd":
			err = unpopulateDateTimeRFC3339(val, "ActivityRunEnd", &a.ActivityRunEnd)
			delete(rawMsg, key)
		case "activityRunId":
			err = unpopulate(val, "ActivityRunID", &a.ActivityRunID)
			delete(rawMsg, key)
		case "activityRunStart":
			err = unpopulateDateTimeRFC3339(val, "ActivityRunStart", &a.ActivityRunStart)
			delete(rawMsg, key)
		case "activityType":
			err = unpopulate(val, "ActivityType", &a.ActivityType)
			delete(rawMsg, key)
		case "durationInMs":
			err = unpopulate(val, "DurationInMs", &a.DurationInMs)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &a.Error)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, "Input", &a.Input)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, "Output", &a.Output)
			delete(rawMsg, key)
		case "pipelineName":
			err = unpopulate(val, "PipelineName", &a.PipelineName)
			delete(rawMsg, key)
		case "pipelineRunId":
			err = unpopulate(val, "PipelineRunID", &a.PipelineRunID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActivityRunsQueryResponse.
func (a ActivityRunsQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", a.ContinuationToken)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityRunsQueryResponse.
func (a *ActivityRunsQueryResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &a.ContinuationToken)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddDataFlowToDebugSessionResponse.
func (a AddDataFlowToDebugSessionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobVersion", a.JobVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddDataFlowToDebugSessionResponse.
func (a *AddDataFlowToDebugSessionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobVersion":
			err = unpopulate(val, "JobVersion", &a.JobVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSLinkedService.
func (a AmazonMWSLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonMWS"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSLinkedService.
func (a *AmazonMWSLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSLinkedServiceTypeProperties.
func (a AmazonMWSLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accessKeyId", a.AccessKeyID)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "endpoint", a.Endpoint)
	populateAny(objectMap, "marketplaceID", a.MarketplaceID)
	populate(objectMap, "mwsAuthToken", a.MwsAuthToken)
	populate(objectMap, "secretKey", a.SecretKey)
	populateAny(objectMap, "sellerID", a.SellerID)
	populateAny(objectMap, "useEncryptedEndpoints", a.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", a.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", a.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSLinkedServiceTypeProperties.
func (a *AmazonMWSLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, "AccessKeyID", &a.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "marketplaceID":
			err = unpopulate(val, "MarketplaceID", &a.MarketplaceID)
			delete(rawMsg, key)
		case "mwsAuthToken":
			a.MwsAuthToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "secretKey":
			a.SecretKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sellerID":
			err = unpopulate(val, "SellerID", &a.SellerID)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &a.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &a.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &a.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSObjectDataset.
func (a AmazonMWSObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonMWSObject"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSObjectDataset.
func (a *AmazonMWSObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSSource.
func (a AmazonMWSSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AmazonMWSSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSSource.
func (a *AmazonMWSSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForLinkedServiceTypeProperties.
func (a AmazonRdsForLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForLinkedServiceTypeProperties.
func (a *AmazonRdsForLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleLinkedService.
func (a AmazonRdsForOracleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonRdsForOracle"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleLinkedService.
func (a *AmazonRdsForOracleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOraclePartitionSettings.
func (a AmazonRdsForOraclePartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "partitionColumnName", a.PartitionColumnName)
	populateAny(objectMap, "partitionLowerBound", a.PartitionLowerBound)
	populateAny(objectMap, "partitionNames", a.PartitionNames)
	populateAny(objectMap, "partitionUpperBound", a.PartitionUpperBound)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOraclePartitionSettings.
func (a *AmazonRdsForOraclePartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &a.PartitionColumnName)
			delete(rawMsg, key)
		case "partitionLowerBound":
			err = unpopulate(val, "PartitionLowerBound", &a.PartitionLowerBound)
			delete(rawMsg, key)
		case "partitionNames":
			err = unpopulate(val, "PartitionNames", &a.PartitionNames)
			delete(rawMsg, key)
		case "partitionUpperBound":
			err = unpopulate(val, "PartitionUpperBound", &a.PartitionUpperBound)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleSource.
func (a AmazonRdsForOracleSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "oracleReaderQuery", a.OracleReaderQuery)
	populateAny(objectMap, "partitionOption", a.PartitionOption)
	populate(objectMap, "partitionSettings", a.PartitionSettings)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AmazonRdsForOracleSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleSource.
func (a *AmazonRdsForOracleSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "oracleReaderQuery":
			err = unpopulate(val, "OracleReaderQuery", &a.OracleReaderQuery)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &a.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &a.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleTableDataset.
func (a AmazonRdsForOracleTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonRdsForOracleTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleTableDataset.
func (a *AmazonRdsForOracleTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleTableDatasetTypeProperties.
func (a AmazonRdsForOracleTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleTableDatasetTypeProperties.
func (a *AmazonRdsForOracleTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerLinkedService.
func (a AmazonRdsForSQLServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonRdsForSqlServer"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerLinkedService.
func (a *AmazonRdsForSQLServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerLinkedServiceTypeProperties.
func (a AmazonRdsForSQLServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alwaysEncryptedSettings", a.AlwaysEncryptedSettings)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populateAny(objectMap, "userName", a.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerLinkedServiceTypeProperties.
func (a *AmazonRdsForSQLServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, "AlwaysEncryptedSettings", &a.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &a.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerSource.
func (a AmazonRdsForSQLServerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "isolationLevel", a.IsolationLevel)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", a.PartitionOption)
	populate(objectMap, "partitionSettings", a.PartitionSettings)
	populateAny(objectMap, "produceAdditionalTypes", a.ProduceAdditionalTypes)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sqlReaderQuery", a.SQLReaderQuery)
	populateAny(objectMap, "sqlReaderStoredProcedureName", a.SQLReaderStoredProcedureName)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populateAny(objectMap, "storedProcedureParameters", a.StoredProcedureParameters)
	objectMap["type"] = "AmazonRdsForSqlServerSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerSource.
func (a *AmazonRdsForSQLServerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, "IsolationLevel", &a.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &a.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &a.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, "ProduceAdditionalTypes", &a.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, "SQLReaderQuery", &a.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, "SQLReaderStoredProcedureName", &a.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &a.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerTableDataset.
func (a AmazonRdsForSQLServerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonRdsForSqlServerTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerTableDataset.
func (a *AmazonRdsForSQLServerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerTableDatasetTypeProperties.
func (a AmazonRdsForSQLServerTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerTableDatasetTypeProperties.
func (a *AmazonRdsForSQLServerTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftLinkedService.
func (a AmazonRedshiftLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonRedshift"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedService.
func (a *AmazonRedshiftLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftLinkedServiceTypeProperties.
func (a AmazonRedshiftLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "database", a.Database)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populateAny(objectMap, "port", a.Port)
	populateAny(objectMap, "server", a.Server)
	populateAny(objectMap, "username", a.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedServiceTypeProperties.
func (a *AmazonRedshiftLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			err = unpopulate(val, "Database", &a.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &a.Port)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &a.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &a.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftSource.
func (a AmazonRedshiftSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "redshiftUnloadSettings", a.RedshiftUnloadSettings)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AmazonRedshiftSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftSource.
func (a *AmazonRedshiftSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "redshiftUnloadSettings":
			err = unpopulate(val, "RedshiftUnloadSettings", &a.RedshiftUnloadSettings)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftTableDataset.
func (a AmazonRedshiftTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonRedshiftTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftTableDataset.
func (a *AmazonRedshiftTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftTableDatasetTypeProperties.
func (a AmazonRedshiftTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftTableDatasetTypeProperties.
func (a *AmazonRedshiftTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleLinkedService.
func (a AmazonS3CompatibleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonS3Compatible"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleLinkedService.
func (a *AmazonS3CompatibleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleLinkedServiceTypeProperties.
func (a AmazonS3CompatibleLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accessKeyId", a.AccessKeyID)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "forcePathStyle", a.ForcePathStyle)
	populate(objectMap, "secretAccessKey", a.SecretAccessKey)
	populateAny(objectMap, "serviceUrl", a.ServiceURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleLinkedServiceTypeProperties.
func (a *AmazonS3CompatibleLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, "AccessKeyID", &a.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "forcePathStyle":
			err = unpopulate(val, "ForcePathStyle", &a.ForcePathStyle)
			delete(rawMsg, key)
		case "secretAccessKey":
			a.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, "ServiceURL", &a.ServiceURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleLocation.
func (a AmazonS3CompatibleLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "bucketName", a.BucketName)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AmazonS3CompatibleLocation"
	populateAny(objectMap, "version", a.Version)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleLocation.
func (a *AmazonS3CompatibleLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, "BucketName", &a.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleReadSettings.
func (a AmazonS3CompatibleReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", a.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", a.PartitionRootPath)
	populateAny(objectMap, "prefix", a.Prefix)
	populateAny(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AmazonS3CompatibleReadSettings"
	populateAny(objectMap, "wildcardFileName", a.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleReadSettings.
func (a *AmazonS3CompatibleReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3Dataset.
func (a AmazonS3Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonS3Object"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3Dataset.
func (a *AmazonS3Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3DatasetTypeProperties.
func (a AmazonS3DatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "bucketName", a.BucketName)
	populate(objectMap, "compression", a.Compression)
	populate(objectMap, "format", a.Format)
	populateAny(objectMap, "key", a.Key)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "prefix", a.Prefix)
	populateAny(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3DatasetTypeProperties.
func (a *AmazonS3DatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, "BucketName", &a.BucketName)
			delete(rawMsg, key)
		case "compression":
			err = unpopulate(val, "Compression", &a.Compression)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, "Key", &a.Key)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &a.Prefix)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3LinkedService.
func (a AmazonS3LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonS3"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedService.
func (a *AmazonS3LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3LinkedServiceTypeProperties.
func (a AmazonS3LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accessKeyId", a.AccessKeyID)
	populateAny(objectMap, "authenticationType", a.AuthenticationType)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "secretAccessKey", a.SecretAccessKey)
	populateAny(objectMap, "serviceUrl", a.ServiceURL)
	populate(objectMap, "sessionToken", a.SessionToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedServiceTypeProperties.
func (a *AmazonS3LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, "AccessKeyID", &a.AccessKeyID)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &a.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "secretAccessKey":
			a.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, "ServiceURL", &a.ServiceURL)
			delete(rawMsg, key)
		case "sessionToken":
			a.SessionToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3Location.
func (a AmazonS3Location) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "bucketName", a.BucketName)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AmazonS3Location"
	populateAny(objectMap, "version", a.Version)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3Location.
func (a *AmazonS3Location) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, "BucketName", &a.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3ReadSettings.
func (a AmazonS3ReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", a.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", a.PartitionRootPath)
	populateAny(objectMap, "prefix", a.Prefix)
	populateAny(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AmazonS3ReadSettings"
	populateAny(objectMap, "wildcardFileName", a.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3ReadSettings.
func (a *AmazonS3ReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppFiguresLinkedService.
func (a AppFiguresLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AppFigures"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppFiguresLinkedService.
func (a *AppFiguresLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppFiguresLinkedServiceTypeProperties.
func (a AppFiguresLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientKey", a.ClientKey)
	populate(objectMap, "password", a.Password)
	populateAny(objectMap, "userName", a.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppFiguresLinkedServiceTypeProperties.
func (a *AppFiguresLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientKey":
			a.ClientKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &a.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppendVariableActivity.
func (a AppendVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "state", a.State)
	objectMap["type"] = "AppendVariable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppendVariableActivity.
func (a *AppendVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppendVariableActivityTypeProperties.
func (a AppendVariableActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "value", a.Value)
	populate(objectMap, "variableName", a.VariableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppendVariableActivityTypeProperties.
func (a *AppendVariableActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		case "variableName":
			err = unpopulate(val, "VariableName", &a.VariableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArmIDWrapper.
func (a ArmIDWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArmIDWrapper.
func (a *ArmIDWrapper) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AsanaLinkedService.
func (a AsanaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "Asana"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AsanaLinkedService.
func (a *AsanaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AsanaLinkedServiceTypeProperties.
func (a AsanaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiToken", a.APIToken)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AsanaLinkedServiceTypeProperties.
func (a *AsanaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiToken":
			a.APIToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvroDataset.
func (a AvroDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "Avro"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDataset.
func (a *AvroDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvroDatasetTypeProperties.
func (a AvroDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "avroCompressionCodec", a.AvroCompressionCodec)
	populate(objectMap, "avroCompressionLevel", a.AvroCompressionLevel)
	populate(objectMap, "location", a.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDatasetTypeProperties.
func (a *AvroDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avroCompressionCodec":
			err = unpopulate(val, "AvroCompressionCodec", &a.AvroCompressionCodec)
			delete(rawMsg, key)
		case "avroCompressionLevel":
			err = unpopulate(val, "AvroCompressionLevel", &a.AvroCompressionLevel)
			delete(rawMsg, key)
		case "location":
			a.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvroFormat.
func (a AvroFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deserializer", a.Deserializer)
	populateAny(objectMap, "serializer", a.Serializer)
	objectMap["type"] = "AvroFormat"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroFormat.
func (a *AvroFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, "Deserializer", &a.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, "Serializer", &a.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvroSink.
func (a AvroSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "formatSettings", a.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	populate(objectMap, "storeSettings", a.StoreSettings)
	objectMap["type"] = "AvroSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSink.
func (a *AvroSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &a.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			a.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvroSource.
func (a AvroSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populate(objectMap, "storeSettings", a.StoreSettings)
	objectMap["type"] = "AvroSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSource.
func (a *AvroSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			a.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvroWriteSettings.
func (a AvroWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileNamePrefix", a.FileNamePrefix)
	populateAny(objectMap, "maxRowsPerFile", a.MaxRowsPerFile)
	populate(objectMap, "recordName", a.RecordName)
	populate(objectMap, "recordNamespace", a.RecordNamespace)
	objectMap["type"] = "AvroWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroWriteSettings.
func (a *AvroWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileNamePrefix":
			err = unpopulate(val, "FileNamePrefix", &a.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, "MaxRowsPerFile", &a.MaxRowsPerFile)
			delete(rawMsg, key)
		case "recordName":
			err = unpopulate(val, "RecordName", &a.RecordName)
			delete(rawMsg, key)
		case "recordNamespace":
			err = unpopulate(val, "RecordNamespace", &a.RecordNamespace)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzPowerShellSetup.
func (a AzPowerShellSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = "AzPowerShellSetup"
	populate(objectMap, "typeProperties", a.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzPowerShellSetup.
func (a *AzPowerShellSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzPowerShellSetupTypeProperties.
func (a AzPowerShellSetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzPowerShellSetupTypeProperties.
func (a *AzPowerShellSetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBatchLinkedService.
func (a AzureBatchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureBatch"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedService.
func (a *AzureBatchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBatchLinkedServiceTypeProperties.
func (a AzureBatchLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessKey", a.AccessKey)
	populateAny(objectMap, "accountName", a.AccountName)
	populateAny(objectMap, "batchUri", a.BatchURI)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populateAny(objectMap, "poolName", a.PoolName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedServiceTypeProperties.
func (a *AzureBatchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKey":
			a.AccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "batchUri":
			err = unpopulate(val, "BatchURI", &a.BatchURI)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "poolName":
			err = unpopulate(val, "PoolName", &a.PoolName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobDataset.
func (a AzureBlobDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureBlob"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobDataset.
func (a *AzureBlobDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobDatasetTypeProperties.
func (a AzureBlobDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", a.Compression)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "format", a.Format)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "tableRootLocation", a.TableRootLocation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobDatasetTypeProperties.
func (a *AzureBlobDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &a.Compression)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "tableRootLocation":
			err = unpopulate(val, "TableRootLocation", &a.TableRootLocation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSDataset.
func (a AzureBlobFSDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureBlobFSFile"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSDataset.
func (a *AzureBlobFSDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSDatasetTypeProperties.
func (a AzureBlobFSDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", a.Compression)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "format", a.Format)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSDatasetTypeProperties.
func (a *AzureBlobFSDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &a.Compression)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSLinkedService.
func (a AzureBlobFSLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureBlobFS"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSLinkedService.
func (a *AzureBlobFSLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSLinkedServiceTypeProperties.
func (a AzureBlobFSLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accountKey", a.AccountKey)
	populateAny(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "sasToken", a.SasToken)
	populateAny(objectMap, "sasUri", a.SasURI)
	populate(objectMap, "servicePrincipalCredential", a.ServicePrincipalCredential)
	populateAny(objectMap, "servicePrincipalCredentialType", a.ServicePrincipalCredentialType)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	populateAny(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSLinkedServiceTypeProperties.
func (a *AzureBlobFSLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &a.AzureCloudType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "sasToken":
			a.SasToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sasUri":
			err = unpopulate(val, "SasURI", &a.SasURI)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			a.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, "ServicePrincipalCredentialType", &a.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSLocation.
func (a AzureBlobFSLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "fileSystem", a.FileSystem)
	populateAny(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureBlobFSLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSLocation.
func (a *AzureBlobFSLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "fileSystem":
			err = unpopulate(val, "FileSystem", &a.FileSystem)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSReadSettings.
func (a AzureBlobFSReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", a.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", a.PartitionRootPath)
	populateAny(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureBlobFSReadSettings"
	populateAny(objectMap, "wildcardFileName", a.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSReadSettings.
func (a *AzureBlobFSReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &a.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSSink.
func (a AzureBlobFSSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", a.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "metadata", a.Metadata)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureBlobFSSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSSink.
func (a *AzureBlobFSSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &a.Metadata)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSSource.
func (a AzureBlobFSSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "recursive", a.Recursive)
	populateAny(objectMap, "skipHeaderLineCount", a.SkipHeaderLineCount)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populateAny(objectMap, "treatEmptyAsNull", a.TreatEmptyAsNull)
	objectMap["type"] = "AzureBlobFSSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSSource.
func (a *AzureBlobFSSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "skipHeaderLineCount":
			err = unpopulate(val, "SkipHeaderLineCount", &a.SkipHeaderLineCount)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			err = unpopulate(val, "TreatEmptyAsNull", &a.TreatEmptyAsNull)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSWriteSettings.
func (a AzureBlobFSWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "blockSizeInMB", a.BlockSizeInMB)
	populateAny(objectMap, "copyBehavior", a.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureBlobFSWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSWriteSettings.
func (a *AzureBlobFSWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blockSizeInMB":
			err = unpopulate(val, "BlockSizeInMB", &a.BlockSizeInMB)
			delete(rawMsg, key)
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLinkedService.
func (a AzureBlobStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureBlobStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedService.
func (a *AzureBlobStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLinkedServiceTypeProperties.
func (a AzureBlobStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populateAny(objectMap, "accountKind", a.AccountKind)
	populate(objectMap, "authenticationType", a.AuthenticationType)
	populateAny(objectMap, "azureCloudType", a.AzureCloudType)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populateAny(objectMap, "containerUri", a.ContainerURI)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "sasToken", a.SasToken)
	populateAny(objectMap, "sasUri", a.SasURI)
	populateAny(objectMap, "serviceEndpoint", a.ServiceEndpoint)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedServiceTypeProperties.
func (a *AzureBlobStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "accountKind":
			err = unpopulate(val, "AccountKind", &a.AccountKind)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &a.AuthenticationType)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "containerUri":
			err = unpopulate(val, "ContainerURI", &a.ContainerURI)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, "SasToken", &a.SasToken)
			delete(rawMsg, key)
		case "sasUri":
			err = unpopulate(val, "SasURI", &a.SasURI)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &a.ServiceEndpoint)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLocation.
func (a AzureBlobStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "container", a.Container)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureBlobStorageLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLocation.
func (a *AzureBlobStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "container":
			err = unpopulate(val, "Container", &a.Container)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageReadSettings.
func (a AzureBlobStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", a.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", a.PartitionRootPath)
	populateAny(objectMap, "prefix", a.Prefix)
	populateAny(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureBlobStorageReadSettings"
	populateAny(objectMap, "wildcardFileName", a.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageReadSettings.
func (a *AzureBlobStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageWriteSettings.
func (a AzureBlobStorageWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "blockSizeInMB", a.BlockSizeInMB)
	populateAny(objectMap, "copyBehavior", a.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureBlobStorageWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageWriteSettings.
func (a *AzureBlobStorageWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blockSizeInMB":
			err = unpopulate(val, "BlockSizeInMB", &a.BlockSizeInMB)
			delete(rawMsg, key)
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerCommandActivity.
func (a AzureDataExplorerCommandActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "policy", a.Policy)
	populate(objectMap, "state", a.State)
	objectMap["type"] = "AzureDataExplorerCommand"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerCommandActivity.
func (a *AzureDataExplorerCommandActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &a.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerCommandActivityTypeProperties.
func (a AzureDataExplorerCommandActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "command", a.Command)
	populateAny(objectMap, "commandTimeout", a.CommandTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerCommandActivityTypeProperties.
func (a *AzureDataExplorerCommandActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "command":
			err = unpopulate(val, "Command", &a.Command)
			delete(rawMsg, key)
		case "commandTimeout":
			err = unpopulate(val, "CommandTimeout", &a.CommandTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerDatasetTypeProperties.
func (a AzureDataExplorerDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "table", a.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerDatasetTypeProperties.
func (a *AzureDataExplorerDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerLinkedService.
func (a AzureDataExplorerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDataExplorer"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedService.
func (a *AzureDataExplorerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerLinkedServiceTypeProperties.
func (a AzureDataExplorerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "credential", a.Credential)
	populateAny(objectMap, "database", a.Database)
	populateAny(objectMap, "endpoint", a.Endpoint)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedServiceTypeProperties.
func (a *AzureDataExplorerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &a.Database)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerSink.
func (a AzureDataExplorerSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "flushImmediately", a.FlushImmediately)
	populateAny(objectMap, "ingestionMappingAsJson", a.IngestionMappingAsJSON)
	populateAny(objectMap, "ingestionMappingName", a.IngestionMappingName)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureDataExplorerSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerSink.
func (a *AzureDataExplorerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "flushImmediately":
			err = unpopulate(val, "FlushImmediately", &a.FlushImmediately)
			delete(rawMsg, key)
		case "ingestionMappingAsJson":
			err = unpopulate(val, "IngestionMappingAsJSON", &a.IngestionMappingAsJSON)
			delete(rawMsg, key)
		case "ingestionMappingName":
			err = unpopulate(val, "IngestionMappingName", &a.IngestionMappingName)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerSource.
func (a AzureDataExplorerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "noTruncation", a.NoTruncation)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureDataExplorerSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerSource.
func (a *AzureDataExplorerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "noTruncation":
			err = unpopulate(val, "NoTruncation", &a.NoTruncation)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerTableDataset.
func (a AzureDataExplorerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureDataExplorerTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerTableDataset.
func (a *AzureDataExplorerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a AzureDataLakeAnalyticsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDataLakeAnalytics"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a *AzureDataLakeAnalyticsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeAnalyticsLinkedServiceTypeProperties.
func (a AzureDataLakeAnalyticsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accountName", a.AccountName)
	populateAny(objectMap, "dataLakeAnalyticsUri", a.DataLakeAnalyticsURI)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "resourceGroupName", a.ResourceGroupName)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "subscriptionId", a.SubscriptionID)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedServiceTypeProperties.
func (a *AzureDataLakeAnalyticsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "dataLakeAnalyticsUri":
			err = unpopulate(val, "DataLakeAnalyticsURI", &a.DataLakeAnalyticsURI)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, "ResourceGroupName", &a.ResourceGroupName)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &a.SubscriptionID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreDataset.
func (a AzureDataLakeStoreDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureDataLakeStoreFile"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreDataset.
func (a *AzureDataLakeStoreDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreDatasetTypeProperties.
func (a AzureDataLakeStoreDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", a.Compression)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "format", a.Format)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreDatasetTypeProperties.
func (a *AzureDataLakeStoreDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &a.Compression)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLinkedService.
func (a AzureDataLakeStoreLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDataLakeStore"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedService.
func (a *AzureDataLakeStoreLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLinkedServiceTypeProperties.
func (a AzureDataLakeStoreLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accountName", a.AccountName)
	populateAny(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "credential", a.Credential)
	populateAny(objectMap, "dataLakeStoreUri", a.DataLakeStoreURI)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "resourceGroupName", a.ResourceGroupName)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "subscriptionId", a.SubscriptionID)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedServiceTypeProperties.
func (a *AzureDataLakeStoreLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &a.AzureCloudType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "dataLakeStoreUri":
			err = unpopulate(val, "DataLakeStoreURI", &a.DataLakeStoreURI)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, "ResourceGroupName", &a.ResourceGroupName)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &a.SubscriptionID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLocation.
func (a AzureDataLakeStoreLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureDataLakeStoreLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLocation.
func (a *AzureDataLakeStoreLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreReadSettings.
func (a AzureDataLakeStoreReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", a.FileListPath)
	populateAny(objectMap, "listAfter", a.ListAfter)
	populateAny(objectMap, "listBefore", a.ListBefore)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", a.PartitionRootPath)
	populateAny(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureDataLakeStoreReadSettings"
	populateAny(objectMap, "wildcardFileName", a.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreReadSettings.
func (a *AzureDataLakeStoreReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &a.FileListPath)
			delete(rawMsg, key)
		case "listAfter":
			err = unpopulate(val, "ListAfter", &a.ListAfter)
			delete(rawMsg, key)
		case "listBefore":
			err = unpopulate(val, "ListBefore", &a.ListBefore)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &a.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreSink.
func (a AzureDataLakeStoreSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", a.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enableAdlsSingleFileParallel", a.EnableAdlsSingleFileParallel)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureDataLakeStoreSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreSink.
func (a *AzureDataLakeStoreSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enableAdlsSingleFileParallel":
			err = unpopulate(val, "EnableAdlsSingleFileParallel", &a.EnableAdlsSingleFileParallel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreSource.
func (a AzureDataLakeStoreSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "recursive", a.Recursive)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureDataLakeStoreSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreSource.
func (a *AzureDataLakeStoreSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreWriteSettings.
func (a AzureDataLakeStoreWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", a.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "expiryDateTime", a.ExpiryDateTime)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureDataLakeStoreWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreWriteSettings.
func (a *AzureDataLakeStoreWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "expiryDateTime":
			err = unpopulate(val, "ExpiryDateTime", &a.ExpiryDateTime)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeDataset.
func (a AzureDatabricksDeltaLakeDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureDatabricksDeltaLakeDataset"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeDataset.
func (a *AzureDatabricksDeltaLakeDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeDatasetTypeProperties.
func (a AzureDatabricksDeltaLakeDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "database", a.Database)
	populateAny(objectMap, "table", a.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeDatasetTypeProperties.
func (a *AzureDatabricksDeltaLakeDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			err = unpopulate(val, "Database", &a.Database)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeExportCommand.
func (a AzureDatabricksDeltaLakeExportCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "dateFormat", a.DateFormat)
	populateAny(objectMap, "timestampFormat", a.TimestampFormat)
	objectMap["type"] = "AzureDatabricksDeltaLakeExportCommand"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeExportCommand.
func (a *AzureDatabricksDeltaLakeExportCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateFormat":
			err = unpopulate(val, "DateFormat", &a.DateFormat)
			delete(rawMsg, key)
		case "timestampFormat":
			err = unpopulate(val, "TimestampFormat", &a.TimestampFormat)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeImportCommand.
func (a AzureDatabricksDeltaLakeImportCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "dateFormat", a.DateFormat)
	populateAny(objectMap, "timestampFormat", a.TimestampFormat)
	objectMap["type"] = "AzureDatabricksDeltaLakeImportCommand"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeImportCommand.
func (a *AzureDatabricksDeltaLakeImportCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateFormat":
			err = unpopulate(val, "DateFormat", &a.DateFormat)
			delete(rawMsg, key)
		case "timestampFormat":
			err = unpopulate(val, "TimestampFormat", &a.TimestampFormat)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeLinkedService.
func (a AzureDatabricksDeltaLakeLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDatabricksDeltaLake"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeLinkedService.
func (a *AzureDatabricksDeltaLakeLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeSink.
func (a AzureDatabricksDeltaLakeSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "importSettings", a.ImportSettings)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", a.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureDatabricksDeltaLakeSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeSink.
func (a *AzureDatabricksDeltaLakeSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "importSettings":
			err = unpopulate(val, "ImportSettings", &a.ImportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &a.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeSource.
func (a AzureDatabricksDeltaLakeSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "exportSettings", a.ExportSettings)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureDatabricksDeltaLakeSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeSource.
func (a *AzureDatabricksDeltaLakeSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "exportSettings":
			err = unpopulate(val, "ExportSettings", &a.ExportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDetltaLakeLinkedServiceTypeProperties.
func (a AzureDatabricksDetltaLakeLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", a.AccessToken)
	populateAny(objectMap, "clusterId", a.ClusterID)
	populate(objectMap, "credential", a.Credential)
	populateAny(objectMap, "domain", a.Domain)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "workspaceResourceId", a.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDetltaLakeLinkedServiceTypeProperties.
func (a *AzureDatabricksDetltaLakeLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			a.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clusterId":
			err = unpopulate(val, "ClusterID", &a.ClusterID)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "Domain", &a.Domain)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "workspaceResourceId":
			err = unpopulate(val, "WorkspaceResourceID", &a.WorkspaceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksLinkedService.
func (a AzureDatabricksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDatabricks"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedService.
func (a *AzureDatabricksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksLinkedServiceTypeProperties.
func (a AzureDatabricksLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", a.AccessToken)
	populateAny(objectMap, "authentication", a.Authentication)
	populate(objectMap, "credential", a.Credential)
	populateAny(objectMap, "domain", a.Domain)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "existingClusterId", a.ExistingClusterID)
	populateAny(objectMap, "instancePoolId", a.InstancePoolID)
	populate(objectMap, "newClusterCustomTags", a.NewClusterCustomTags)
	populateAny(objectMap, "newClusterDriverNodeType", a.NewClusterDriverNodeType)
	populateAny(objectMap, "newClusterEnableElasticDisk", a.NewClusterEnableElasticDisk)
	populateAny(objectMap, "newClusterInitScripts", a.NewClusterInitScripts)
	populateAny(objectMap, "newClusterLogDestination", a.NewClusterLogDestination)
	populateAny(objectMap, "newClusterNodeType", a.NewClusterNodeType)
	populateAny(objectMap, "newClusterNumOfWorker", a.NewClusterNumOfWorker)
	populate(objectMap, "newClusterSparkConf", a.NewClusterSparkConf)
	populate(objectMap, "newClusterSparkEnvVars", a.NewClusterSparkEnvVars)
	populateAny(objectMap, "newClusterVersion", a.NewClusterVersion)
	populateAny(objectMap, "policyId", a.PolicyID)
	populateAny(objectMap, "workspaceResourceId", a.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedServiceTypeProperties.
func (a *AzureDatabricksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			a.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, "Authentication", &a.Authentication)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "Domain", &a.Domain)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "existingClusterId":
			err = unpopulate(val, "ExistingClusterID", &a.ExistingClusterID)
			delete(rawMsg, key)
		case "instancePoolId":
			err = unpopulate(val, "InstancePoolID", &a.InstancePoolID)
			delete(rawMsg, key)
		case "newClusterCustomTags":
			err = unpopulate(val, "NewClusterCustomTags", &a.NewClusterCustomTags)
			delete(rawMsg, key)
		case "newClusterDriverNodeType":
			err = unpopulate(val, "NewClusterDriverNodeType", &a.NewClusterDriverNodeType)
			delete(rawMsg, key)
		case "newClusterEnableElasticDisk":
			err = unpopulate(val, "NewClusterEnableElasticDisk", &a.NewClusterEnableElasticDisk)
			delete(rawMsg, key)
		case "newClusterInitScripts":
			err = unpopulate(val, "NewClusterInitScripts", &a.NewClusterInitScripts)
			delete(rawMsg, key)
		case "newClusterLogDestination":
			err = unpopulate(val, "NewClusterLogDestination", &a.NewClusterLogDestination)
			delete(rawMsg, key)
		case "newClusterNodeType":
			err = unpopulate(val, "NewClusterNodeType", &a.NewClusterNodeType)
			delete(rawMsg, key)
		case "newClusterNumOfWorker":
			err = unpopulate(val, "NewClusterNumOfWorker", &a.NewClusterNumOfWorker)
			delete(rawMsg, key)
		case "newClusterSparkConf":
			err = unpopulate(val, "NewClusterSparkConf", &a.NewClusterSparkConf)
			delete(rawMsg, key)
		case "newClusterSparkEnvVars":
			err = unpopulate(val, "NewClusterSparkEnvVars", &a.NewClusterSparkEnvVars)
			delete(rawMsg, key)
		case "newClusterVersion":
			err = unpopulate(val, "NewClusterVersion", &a.NewClusterVersion)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "workspaceResourceId":
			err = unpopulate(val, "WorkspaceResourceID", &a.WorkspaceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLinkedService.
func (a AzureFileStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureFileStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedService.
func (a *AzureFileStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLinkedServiceTypeProperties.
func (a AzureFileStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "fileShare", a.FileShare)
	populateAny(objectMap, "host", a.Host)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "sasToken", a.SasToken)
	populateAny(objectMap, "sasUri", a.SasURI)
	populateAny(objectMap, "snapshot", a.Snapshot)
	populateAny(objectMap, "userId", a.UserID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedServiceTypeProperties.
func (a *AzureFileStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "fileShare":
			err = unpopulate(val, "FileShare", &a.FileShare)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &a.Host)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, "SasToken", &a.SasToken)
			delete(rawMsg, key)
		case "sasUri":
			err = unpopulate(val, "SasURI", &a.SasURI)
			delete(rawMsg, key)
		case "snapshot":
			err = unpopulate(val, "Snapshot", &a.Snapshot)
			delete(rawMsg, key)
		case "userId":
			err = unpopulate(val, "UserID", &a.UserID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLocation.
func (a AzureFileStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", a.FileName)
	populateAny(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureFileStorageLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLocation.
func (a *AzureFileStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageReadSettings.
func (a AzureFileStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", a.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", a.PartitionRootPath)
	populateAny(objectMap, "prefix", a.Prefix)
	populateAny(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureFileStorageReadSettings"
	populateAny(objectMap, "wildcardFileName", a.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageReadSettings.
func (a *AzureFileStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageWriteSettings.
func (a AzureFileStorageWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", a.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureFileStorageWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageWriteSettings.
func (a *AzureFileStorageWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionActivity.
func (a AzureFunctionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "policy", a.Policy)
	populate(objectMap, "state", a.State)
	objectMap["type"] = "AzureFunctionActivity"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionActivity.
func (a *AzureFunctionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &a.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionActivityTypeProperties.
func (a AzureFunctionActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "body", a.Body)
	populateAny(objectMap, "functionName", a.FunctionName)
	populateAny(objectMap, "headers", a.Headers)
	populate(objectMap, "method", a.Method)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionActivityTypeProperties.
func (a *AzureFunctionActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "body":
			err = unpopulate(val, "Body", &a.Body)
			delete(rawMsg, key)
		case "functionName":
			err = unpopulate(val, "FunctionName", &a.FunctionName)
			delete(rawMsg, key)
		case "headers":
			err = unpopulate(val, "Headers", &a.Headers)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &a.Method)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionLinkedService.
func (a AzureFunctionLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureFunction"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedService.
func (a *AzureFunctionLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionLinkedServiceTypeProperties.
func (a AzureFunctionLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authentication", a.Authentication)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "functionAppUrl", a.FunctionAppURL)
	populate(objectMap, "functionKey", a.FunctionKey)
	populateAny(objectMap, "resourceId", a.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedServiceTypeProperties.
func (a *AzureFunctionLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &a.Authentication)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "functionAppUrl":
			err = unpopulate(val, "FunctionAppURL", &a.FunctionAppURL)
			delete(rawMsg, key)
		case "functionKey":
			a.FunctionKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &a.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultLinkedService.
func (a AzureKeyVaultLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureKeyVault"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultLinkedService.
func (a *AzureKeyVaultLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultLinkedServiceTypeProperties.
func (a AzureKeyVaultLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "baseUrl", a.BaseURL)
	populate(objectMap, "credential", a.Credential)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultLinkedServiceTypeProperties.
func (a *AzureKeyVaultLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUrl":
			err = unpopulate(val, "BaseURL", &a.BaseURL)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultSecretReference.
func (a AzureKeyVaultSecretReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "secretName", a.SecretName)
	populateAny(objectMap, "secretVersion", a.SecretVersion)
	populate(objectMap, "store", a.Store)
	objectMap["type"] = "AzureKeyVaultSecret"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultSecretReference.
func (a *AzureKeyVaultSecretReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretName":
			err = unpopulate(val, "SecretName", &a.SecretName)
			delete(rawMsg, key)
		case "secretVersion":
			err = unpopulate(val, "SecretVersion", &a.SecretVersion)
			delete(rawMsg, key)
		case "store":
			err = unpopulate(val, "Store", &a.Store)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLBatchExecutionActivity.
func (a AzureMLBatchExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "policy", a.Policy)
	populate(objectMap, "state", a.State)
	objectMap["type"] = "AzureMLBatchExecution"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLBatchExecutionActivity.
func (a *AzureMLBatchExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &a.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLBatchExecutionActivityTypeProperties.
func (a AzureMLBatchExecutionActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "globalParameters", a.GlobalParameters)
	populate(objectMap, "webServiceInputs", a.WebServiceInputs)
	populate(objectMap, "webServiceOutputs", a.WebServiceOutputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLBatchExecutionActivityTypeProperties.
func (a *AzureMLBatchExecutionActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "globalParameters":
			err = unpopulate(val, "GlobalParameters", &a.GlobalParameters)
			delete(rawMsg, key)
		case "webServiceInputs":
			err = unpopulate(val, "WebServiceInputs", &a.WebServiceInputs)
			delete(rawMsg, key)
		case "webServiceOutputs":
			err = unpopulate(val, "WebServiceOutputs", &a.WebServiceOutputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLExecutePipelineActivity.
func (a AzureMLExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "policy", a.Policy)
	populate(objectMap, "state", a.State)
	objectMap["type"] = "AzureMLExecutePipeline"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLExecutePipelineActivity.
func (a *AzureMLExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &a.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLExecutePipelineActivityTypeProperties.
func (a AzureMLExecutePipelineActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "continueOnStepFailure", a.ContinueOnStepFailure)
	populateAny(objectMap, "dataPathAssignments", a.DataPathAssignments)
	populateAny(objectMap, "experimentName", a.ExperimentName)
	populateAny(objectMap, "mlParentRunId", a.MlParentRunID)
	populateAny(objectMap, "mlPipelineEndpointId", a.MlPipelineEndpointID)
	populateAny(objectMap, "mlPipelineId", a.MlPipelineID)
	populateAny(objectMap, "mlPipelineParameters", a.MlPipelineParameters)
	populateAny(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLExecutePipelineActivityTypeProperties.
func (a *AzureMLExecutePipelineActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continueOnStepFailure":
			err = unpopulate(val, "ContinueOnStepFailure", &a.ContinueOnStepFailure)
			delete(rawMsg, key)
		case "dataPathAssignments":
			err = unpopulate(val, "DataPathAssignments", &a.DataPathAssignments)
			delete(rawMsg, key)
		case "experimentName":
			err = unpopulate(val, "ExperimentName", &a.ExperimentName)
			delete(rawMsg, key)
		case "mlParentRunId":
			err = unpopulate(val, "MlParentRunID", &a.MlParentRunID)
			delete(rawMsg, key)
		case "mlPipelineEndpointId":
			err = unpopulate(val, "MlPipelineEndpointID", &a.MlPipelineEndpointID)
			delete(rawMsg, key)
		case "mlPipelineId":
			err = unpopulate(val, "MlPipelineID", &a.MlPipelineID)
			delete(rawMsg, key)
		case "mlPipelineParameters":
			err = unpopulate(val, "MlPipelineParameters", &a.MlPipelineParameters)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLLinkedService.
func (a AzureMLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureML"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLLinkedService.
func (a *AzureMLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLLinkedServiceTypeProperties.
func (a AzureMLLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiKey", a.APIKey)
	populateAny(objectMap, "authentication", a.Authentication)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "mlEndpoint", a.MlEndpoint)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	populateAny(objectMap, "updateResourceEndpoint", a.UpdateResourceEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLLinkedServiceTypeProperties.
func (a *AzureMLLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiKey":
			a.APIKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, "Authentication", &a.Authentication)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "mlEndpoint":
			err = unpopulate(val, "MlEndpoint", &a.MlEndpoint)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		case "updateResourceEndpoint":
			err = unpopulate(val, "UpdateResourceEndpoint", &a.UpdateResourceEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLServiceLinkedService.
func (a AzureMLServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureMLService"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLServiceLinkedService.
func (a *AzureMLServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLServiceLinkedServiceTypeProperties.
func (a AzureMLServiceLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authentication", a.Authentication)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populateAny(objectMap, "mlWorkspaceName", a.MlWorkspaceName)
	populateAny(objectMap, "resourceGroupName", a.ResourceGroupName)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "subscriptionId", a.SubscriptionID)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLServiceLinkedServiceTypeProperties.
func (a *AzureMLServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &a.Authentication)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "mlWorkspaceName":
			err = unpopulate(val, "MlWorkspaceName", &a.MlWorkspaceName)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, "ResourceGroupName", &a.ResourceGroupName)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &a.SubscriptionID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLUpdateResourceActivity.
func (a AzureMLUpdateResourceActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "onInactiveMarkAs", a.OnInactiveMarkAs)
	populate(objectMap, "policy", a.Policy)
	populate(objectMap, "state", a.State)
	objectMap["type"] = "AzureMLUpdateResource"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLUpdateResourceActivity.
func (a *AzureMLUpdateResourceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &a.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &a.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLUpdateResourceActivityTypeProperties.
func (a AzureMLUpdateResourceActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "trainedModelFilePath", a.TrainedModelFilePath)
	populate(objectMap, "trainedModelLinkedServiceName", a.TrainedModelLinkedServiceName)
	populateAny(objectMap, "trainedModelName", a.TrainedModelName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLUpdateResourceActivityTypeProperties.
func (a *AzureMLUpdateResourceActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "trainedModelFilePath":
			err = unpopulate(val, "TrainedModelFilePath", &a.TrainedModelFilePath)
			delete(rawMsg, key)
		case "trainedModelLinkedServiceName":
			err = unpopulate(val, "TrainedModelLinkedServiceName", &a.TrainedModelLinkedServiceName)
			delete(rawMsg, key)
		case "trainedModelName":
			err = unpopulate(val, "TrainedModelName", &a.TrainedModelName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLWebServiceFile.
func (a AzureMLWebServiceFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "filePath", a.FilePath)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLWebServiceFile.
func (a *AzureMLWebServiceFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filePath":
			err = unpopulate(val, "FilePath", &a.FilePath)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBLinkedService.
func (a AzureMariaDBLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureMariaDB"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBLinkedService.
func (a *AzureMariaDBLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBLinkedServiceTypeProperties.
func (a AzureMariaDBLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "pwd", a.Pwd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBLinkedServiceTypeProperties.
func (a *AzureMariaDBLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "pwd":
			err = unpopulate(val, "Pwd", &a.Pwd)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBSource.
func (a AzureMariaDBSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureMariaDBSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBSource.
func (a *AzureMariaDBSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBTableDataset.
func (a AzureMariaDBTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureMariaDBTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBTableDataset.
func (a *AzureMariaDBTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLLinkedService.
func (a AzureMySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureMySql"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLLinkedService.
func (a *AzureMySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLLinkedServiceTypeProperties.
func (a AzureMySQLLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLLinkedServiceTypeProperties.
func (a *AzureMySQLLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &a.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLSink.
func (a AzureMySQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", a.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureMySqlSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLSink.
func (a *AzureMySQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &a.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLSource.
func (a AzureMySQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureMySqlSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLSource.
func (a *AzureMySQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLTableDataset.
func (a AzureMySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureMySqlTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLTableDataset.
func (a *AzureMySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLTableDatasetTypeProperties.
func (a AzureMySQLTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "table", a.Table)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLTableDatasetTypeProperties.
func (a *AzureMySQLTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLLinkedService.
func (a AzurePostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzurePostgreSql"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLLinkedService.
func (a *AzurePostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLLinkedServiceTypeProperties.
func (a AzurePostgreSQLLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLLinkedServiceTypeProperties.
func (a *AzurePostgreSQLLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &a.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLSink.
func (a AzurePostgreSQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", a.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzurePostgreSqlSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLSink.
func (a *AzurePostgreSQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &a.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLSource.
func (a AzurePostgreSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "query", a.Query)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzurePostgreSqlSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLSource.
func (a *AzurePostgreSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLTableDataset.
func (a AzurePostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzurePostgreSqlTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLTableDataset.
func (a *AzurePostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLTableDatasetTypeProperties.
func (a AzurePostgreSQLTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLTableDatasetTypeProperties.
func (a *AzurePostgreSQLTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureQueueSink.
func (a AzureQueueSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureQueueSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureQueueSink.
func (a *AzureQueueSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWLinkedService.
func (a AzureSQLDWLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSqlDW"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWLinkedService.
func (a *AzureSQLDWLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWLinkedServiceTypeProperties.
func (a AzureSQLDWLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "azureCloudType", a.AzureCloudType)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWLinkedServiceTypeProperties.
func (a *AzureSQLDWLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &a.Password)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWTableDataset.
func (a AzureSQLDWTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSqlDWTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWTableDataset.
func (a *AzureSQLDWTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWTableDatasetTypeProperties.
func (a AzureSQLDWTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWTableDatasetTypeProperties.
func (a *AzureSQLDWTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseLinkedService.
func (a AzureSQLDatabaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSqlDatabase"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedService.
func (a *AzureSQLDatabaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseLinkedServiceTypeProperties.
func (a AzureSQLDatabaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alwaysEncryptedSettings", a.AlwaysEncryptedSettings)
	populateAny(objectMap, "azureCloudType", a.AzureCloudType)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedServiceTypeProperties.
func (a *AzureSQLDatabaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, "AlwaysEncryptedSettings", &a.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &a.Password)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMILinkedService.
func (a AzureSQLMILinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSqlMI"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMILinkedService.
func (a *AzureSQLMILinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMILinkedServiceTypeProperties.
func (a AzureSQLMILinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alwaysEncryptedSettings", a.AlwaysEncryptedSettings)
	populateAny(objectMap, "azureCloudType", a.AzureCloudType)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populateAny(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populateAny(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMILinkedServiceTypeProperties.
func (a *AzureSQLMILinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, "AlwaysEncryptedSettings", &a.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &a.Password)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMITableDataset.
func (a AzureSQLMITableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSqlMITable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMITableDataset.
func (a *AzureSQLMITableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMITableDatasetTypeProperties.
func (a AzureSQLMITableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMITableDatasetTypeProperties.
func (a *AzureSQLMITableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSink.
func (a AzureSQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", a.PreCopyScript)
	populateAny(objectMap, "sqlWriterStoredProcedureName", a.SQLWriterStoredProcedureName)
	populateAny(objectMap, "sqlWriterTableType", a.SQLWriterTableType)
	populateAny(objectMap, "sqlWriterUseTableLock", a.SQLWriterUseTableLock)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	populateAny(objectMap, "storedProcedureParameters", a.StoredProcedureParameters)
	populateAny(objectMap, "storedProcedureTableTypeParameterName", a.StoredProcedureTableTypeParameterName)
	populateAny(objectMap, "tableOption", a.TableOption)
	objectMap["type"] = "AzureSqlSink"
	populate(objectMap, "upsertSettings", a.UpsertSettings)
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", a.WriteBehavior)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSink.
func (a *AzureSQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &a.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, "SQLWriterStoredProcedureName", &a.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, "SQLWriterTableType", &a.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, "SQLWriterUseTableLock", &a.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &a.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, "StoredProcedureTableTypeParameterName", &a.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, "TableOption", &a.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, "UpsertSettings", &a.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &a.WriteBehavior)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSource.
func (a AzureSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "isolationLevel", a.IsolationLevel)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", a.PartitionOption)
	populate(objectMap, "partitionSettings", a.PartitionSettings)
	populateAny(objectMap, "produceAdditionalTypes", a.ProduceAdditionalTypes)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sqlReaderQuery", a.SQLReaderQuery)
	populateAny(objectMap, "sqlReaderStoredProcedureName", a.SQLReaderStoredProcedureName)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populateAny(objectMap, "storedProcedureParameters", a.StoredProcedureParameters)
	objectMap["type"] = "AzureSqlSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSource.
func (a *AzureSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, "IsolationLevel", &a.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &a.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &a.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, "ProduceAdditionalTypes", &a.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, "SQLReaderQuery", &a.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, "SQLReaderStoredProcedureName", &a.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &a.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLTableDataset.
func (a AzureSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSqlTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLTableDataset.
func (a *AzureSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLTableDatasetTypeProperties.
func (a AzureSQLTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "table", a.Table)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLTableDatasetTypeProperties.
func (a *AzureSQLTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &a.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexDataset.
func (a AzureSearchIndexDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSearchIndex"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexDataset.
func (a *AzureSearchIndexDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexDatasetTypeProperties.
func (a AzureSearchIndexDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "indexName", a.IndexName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexDatasetTypeProperties.
func (a *AzureSearchIndexDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "indexName":
			err = unpopulate(val, "IndexName", &a.IndexName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexSink.
func (a AzureSearchIndexSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureSearchIndexSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", a.WriteBehavior)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexSink.
func (a *AzureSearchIndexSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &a.WriteBehavior)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchLinkedService.
func (a AzureSearchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSearch"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedService.
func (a *AzureSearchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchLinkedServiceTypeProperties.
func (a AzureSearchLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "key", a.Key)
	populateAny(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedServiceTypeProperties.
func (a *AzureSearchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "key":
			a.Key, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageLinkedService.
func (a AzureStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageLinkedService.
func (a *AzureStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageLinkedServiceTypeProperties.
func (a AzureStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populateAny(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "sasToken", a.SasToken)
	populateAny(objectMap, "sasUri", a.SasURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageLinkedServiceTypeProperties.
func (a *AzureStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &a.EncryptedCredential)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, "SasToken", &a.SasToken)
			delete(rawMsg, key)
		case "sasUri":
			err = unpopulate(val, "SasURI", &a.SasURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSynapseArtifactsLinkedService.
func (a AzureSynapseArtifactsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSynapseArtifacts"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSynapseArtifactsLinkedService.
func (a *AzureSynapseArtifactsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSynapseArtifactsLinkedServiceTypeProperties.
func (a AzureSynapseArtifactsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authentication", a.Authentication)
	populateAny(objectMap, "endpoint", a.Endpoint)
	populateAny(objectMap, "workspaceResourceId", a.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSynapseArtifactsLinkedServiceTypeProperties.
func (a *AzureSynapseArtifactsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &a.Authentication)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "workspaceResourceId":
			err = unpopulate(val, "WorkspaceResourceID", &a.WorkspaceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableDataset.
func (a AzureTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populateAny(objectMap, "schema", a.Schema)
	populateAny(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableDataset.
func (a *AzureTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableDatasetTypeProperties.
func (a AzureTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", a.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableDatasetTypeProperties.
func (a *AzureTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &a.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableSink.
func (a AzureTableSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "azureTableDefaultPartitionKeyValue", a.AzureTableDefaultPartitionKeyValue)
	populateAny(objectMap, "azureTableInsertType", a.AzureTableInsertType)
	populateAny(objectMap, "azureTablePartitionKeyName", a.AzureTablePartitionKeyName)
	populateAny(objectMap, "azureTableRowKeyName", a.AzureTableRowKeyName)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureTableSink"
	populateAny(objectMap, "writeBatchSize", a.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableSink.
func (a *AzureTableSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureTableDefaultPartitionKeyValue":
			err = unpopulate(val, "AzureTableDefaultPartitionKeyValue", &a.AzureTableDefaultPartitionKeyValue)
			delete(rawMsg, key)
		case "azureTableInsertType":
			err = unpopulate(val, "AzureTableInsertType", &a.AzureTableInsertType)
			delete(rawMsg, key)
		case "azureTablePartitionKeyName":
			err = unpopulate(val, "AzureTablePartitionKeyName", &a.AzureTablePartitionKeyName)
			delete(rawMsg, key)
		case "azureTableRowKeyName":
			err = unpopulate(val, "AzureTableRowKeyName", &a.AzureTableRowKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableSource.
func (a AzureTableSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", a.AdditionalColumns)
	populateAny(objectMap, "azureTableSourceIgnoreTableNotFound", a.AzureTableSourceIgnoreTableNotFound)
	populateAny(objectMap, "azureTableSourceQuery", a.AzureTableSourceQuery)
	populateAny(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populateAny(objectMap, "queryTimeout", a.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureTableSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableSource.
func (a *AzureTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &a.AdditionalColumns)
			delete(rawMsg, key)
		case "azureTableSourceIgnoreTableNotFound":
			err = unpopulate(val, "AzureTableSourceIgnoreTableNotFound", &a.AzureTableSourceIgnoreTableNotFound)
			delete(rawMsg, key)
		case "azureTableSourceQuery":
			err = unpopulate(val, "AzureTableSourceQuery", &a.AzureTableSourceQuery)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableStorageLinkedService.
func (a AzureTableStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureTableStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableStorageLinkedService.
func (a *AzureTableStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BigDataPoolParametrizationReference.
func (b BigDataPoolParametrizationReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "referenceName", b.ReferenceName)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BigDataPoolParametrizationReference.
func (b *BigDataPoolParametrizationReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &b.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BinaryDataset.
func (b BinaryDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", b.Annotations)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "folder", b.Folder)
	populate(objectMap, "linkedServiceName", b.LinkedServiceName)
	populate(objectMap, "parameters", b.Parameters)
	populateAny(objectMap, "schema", b.Schema)
	populateAny(objectMap, "structure", b.Structure)
	objectMap["type"] = "Binary"
	populate(objectMap, "typeProperties", b.TypeProperties)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDataset.
func (b *BinaryDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &b.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &b.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &b.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &b.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &b.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &b.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &b.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &b.TypeProperties)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BinaryDatasetTypeProperties.
func (b BinaryDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", b.Compression)
	populate(objectMap, "location", b.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDatasetTypeProperties.
func (b *BinaryDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &b.Compression)
			delete(rawMsg, key)
		case "location":
			b.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BinaryReadSettings.
func (b BinaryReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compressionProperties", b.CompressionProperties)
	objectMap["type"] = "BinaryReadSettings"
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryReadSettings.
func (b *BinaryReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			b.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BinarySink.
func (b BinarySink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", b.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", b.SinkRetryWait)
	populate(objectMap, "storeSettings", b.StoreSettings)
	objectMap["type"] = "BinarySink"
	populateAny(objectMap, "writeBatchSize", b.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", b.WriteBatchTimeout)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinarySink.
func (b *BinarySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &b.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &b.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			b.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &b.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &b.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BinarySource.
func (b BinarySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populate(objectMap, "formatSettings", b.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", b.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", b.SourceRetryWait)
	populate(objectMap, "storeSettings", b.StoreSettings)
	objectMap["type"] = "BinarySource"
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinarySource.
func (b *BinarySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &b.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &b.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &b.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			b.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobEventsTrigger.
func (b BlobEventsTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", b.Annotations)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "pipelines", b.Pipelines)
	populate(objectMap, "runtimeState", b.RuntimeState)
	objectMap["type"] = "BlobEventsTrigger"
	populate(objectMap, "typeProperties", b.TypeProperties)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobEventsTrigger.
func (b *BlobEventsTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &b.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &b.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, "Pipelines", &b.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &b.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &b.TypeProperties)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobEventsTriggerTypeProperties.
func (b BlobEventsTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobPathBeginsWith", b.BlobPathBeginsWith)
	populate(objectMap, "blobPathEndsWith", b.BlobPathEndsWith)
	populate(objectMap, "events", b.Events)
	populate(objectMap, "ignoreEmptyBlobs", b.IgnoreEmptyBlobs)
	populate(objectMap, "scope", b.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobEventsTriggerTypeProperties.
func (b *BlobEventsTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobPathBeginsWith":
			err = unpopulate(val, "BlobPathBeginsWith", &b.BlobPathBeginsWith)
			delete(rawMsg, key)
		case "blobPathEndsWith":
			err = unpopulate(val, "BlobPathEndsWith", &b.BlobPathEndsWith)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, "Events", &b.Events)
			delete(rawMsg, key)
		case "ignoreEmptyBlobs":
			err = unpopulate(val, "IgnoreEmptyBlobs", &b.IgnoreEmptyBlobs)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &b.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobSink.
func (b BlobSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "blobWriterAddHeader", b.BlobWriterAddHeader)
	populateAny(objectMap, "blobWriterDateTimeFormat", b.BlobWriterDateTimeFormat)
	populateAny(objectMap, "blobWriterOverwriteFiles", b.BlobWriterOverwriteFiles)
	populateAny(objectMap, "copyBehavior", b.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populate(objectMap, "metadata", b.Metadata)
	populateAny(objectMap, "sinkRetryCount", b.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", b.SinkRetryWait)
	objectMap["type"] = "BlobSink"
	populateAny(objectMap, "writeBatchSize", b.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", b.WriteBatchTimeout)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobSink.
func (b *BlobSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobWriterAddHeader":
			err = unpopulate(val, "BlobWriterAddHeader", &b.BlobWriterAddHeader)
			delete(rawMsg, key)
		case "blobWriterDateTimeFormat":
			err = unpopulate(val, "BlobWriterDateTimeFormat", &b.BlobWriterDateTimeFormat)
			delete(rawMsg, key)
		case "blobWriterOverwriteFiles":
			err = unpopulate(val, "BlobWriterOverwriteFiles", &b.BlobWriterOverwriteFiles)
			delete(rawMsg, key)
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &b.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &b.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &b.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &b.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &b.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobSource.
func (b BlobSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populateAny(objectMap, "recursive", b.Recursive)
	populateAny(objectMap, "skipHeaderLineCount", b.SkipHeaderLineCount)
	populateAny(objectMap, "sourceRetryCount", b.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", b.SourceRetryWait)
	populateAny(objectMap, "treatEmptyAsNull", b.TreatEmptyAsNull)
	objectMap["type"] = "BlobSource"
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobSource.
func (b *BlobSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &b.Recursive)
			delete(rawMsg, key)
		case "skipHeaderLineCount":
			err = unpopulate(val, "SkipHeaderLineCount", &b.SkipHeaderLineCount)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &b.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &b.SourceRetryWait)
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			err = unpopulate(val, "TreatEmptyAsNull", &b.TreatEmptyAsNull)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobTrigger.
func (b BlobTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", b.Annotations)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "pipelines", b.Pipelines)
	populate(objectMap, "runtimeState", b.RuntimeState)
	objectMap["type"] = "BlobTrigger"
	populate(objectMap, "typeProperties", b.TypeProperties)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobTrigger.
func (b *BlobTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &b.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &b.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, "Pipelines", &b.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &b.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &b.TypeProperties)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobTriggerTypeProperties.
func (b BlobTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "folderPath", b.FolderPath)
	populate(objectMap, "linkedService", b.LinkedService)
	populate(objectMap, "maxConcurrency", b.MaxConcurrency)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobTriggerTypeProperties.
func (b *BlobTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "folderPath":
			err = unpopulate(val, "FolderPath", &b.FolderPath)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &b.LinkedService)
			delete(rawMsg, key)
		case "maxConcurrency":
			err = unpopulate(val, "MaxConcurrency", &b.MaxConcurrency)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CMKIdentityDefinition.
func (c CMKIdentityDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "userAssignedIdentity", c.UserAssignedIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CMKIdentityDefinition.
func (c *CMKIdentityDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "userAssignedIdentity":
			err = unpopulate(val, "UserAssignedIdentity", &c.UserAssignedIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CassandraLinkedService.
func (c CassandraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "Cassandra"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedService.
func (c *CassandraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CassandraLinkedServiceTypeProperties.
func (c CassandraLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", c.AuthenticationType)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populateAny(objectMap, "host", c.Host)
	populate(objectMap, "password", c.Password)
	populateAny(objectMap, "port", c.Port)
	populateAny(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedServiceTypeProperties.
func (c *CassandraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &c.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &c.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &c.Host)
			delete(rawMsg, key)
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &c.Port)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CassandraSource.
func (c CassandraSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "consistencyLevel", c.ConsistencyLevel)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "query", c.Query)
	populateAny(objectMap, "queryTimeout", c.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CassandraSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraSource.
func (c *CassandraSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &c.AdditionalColumns)
			delete(rawMsg, key)
		case "consistencyLevel":
			err = unpopulate(val, "ConsistencyLevel", &c.ConsistencyLevel)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &c.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CassandraTableDataset.
func (c CassandraTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "CassandraTable"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraTableDataset.
func (c *CassandraTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CassandraTableDatasetTypeProperties.
func (c CassandraTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "keyspace", c.Keyspace)
	populateAny(objectMap, "tableName", c.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraTableDatasetTypeProperties.
func (c *CassandraTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyspace":
			err = unpopulate(val, "Keyspace", &c.Keyspace)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &c.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChainingTrigger.
func (c ChainingTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "pipeline", c.Pipeline)
	populate(objectMap, "runtimeState", c.RuntimeState)
	objectMap["type"] = "ChainingTrigger"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChainingTrigger.
func (c *ChainingTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "pipeline":
			err = unpopulate(val, "Pipeline", &c.Pipeline)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &c.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChainingTriggerTypeProperties.
func (c ChainingTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "runDimension", c.RunDimension)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChainingTriggerTypeProperties.
func (c *ChainingTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &c.DependsOn)
			delete(rawMsg, key)
		case "runDimension":
			err = unpopulate(val, "RunDimension", &c.RunDimension)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChangeDataCapture.
func (c ChangeDataCapture) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowVNetOverride", c.AllowVNetOverride)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "policy", c.Policy)
	populate(objectMap, "sourceConnectionsInfo", c.SourceConnectionsInfo)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "targetConnectionsInfo", c.TargetConnectionsInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChangeDataCapture.
func (c *ChangeDataCapture) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowVNetOverride":
			err = unpopulate(val, "AllowVNetOverride", &c.AllowVNetOverride)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &c.Policy)
			delete(rawMsg, key)
		case "sourceConnectionsInfo":
			err = unpopulate(val, "SourceConnectionsInfo", &c.SourceConnectionsInfo)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "targetConnectionsInfo":
			err = unpopulate(val, "TargetConnectionsInfo", &c.TargetConnectionsInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChangeDataCaptureFolder.
func (c ChangeDataCaptureFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", c.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChangeDataCaptureFolder.
func (c *ChangeDataCaptureFolder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChangeDataCaptureListResponse.
func (c ChangeDataCaptureListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChangeDataCaptureListResponse.
func (c *ChangeDataCaptureListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChangeDataCaptureResource.
func (c ChangeDataCaptureResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "type", c.Type)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChangeDataCaptureResource.
func (c *ChangeDataCaptureResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &c.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CmdkeySetup.
func (c CmdkeySetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = "CmdkeySetup"
	populate(objectMap, "typeProperties", c.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CmdkeySetup.
func (c *CmdkeySetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CmdkeySetupTypeProperties.
func (c CmdkeySetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "password", c.Password)
	populateAny(objectMap, "targetName", c.TargetName)
	populateAny(objectMap, "userName", c.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CmdkeySetupTypeProperties.
func (c *CmdkeySetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "targetName":
			err = unpopulate(val, "TargetName", &c.TargetName)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &c.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c CommonDataServiceForAppsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "CommonDataServiceForAppsEntity"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c *CommonDataServiceForAppsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsEntityDatasetTypeProperties.
func (c CommonDataServiceForAppsEntityDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "entityName", c.EntityName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsEntityDatasetTypeProperties.
func (c *CommonDataServiceForAppsEntityDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entityName":
			err = unpopulate(val, "EntityName", &c.EntityName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsLinkedService.
func (c CommonDataServiceForAppsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CommonDataServiceForApps"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedService.
func (c *CommonDataServiceForAppsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsLinkedServiceTypeProperties.
func (c CommonDataServiceForAppsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", c.AuthenticationType)
	populateAny(objectMap, "deploymentType", c.DeploymentType)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populateAny(objectMap, "hostName", c.HostName)
	populateAny(objectMap, "organizationName", c.OrganizationName)
	populate(objectMap, "password", c.Password)
	populateAny(objectMap, "port", c.Port)
	populate(objectMap, "servicePrincipalCredential", c.ServicePrincipalCredential)
	populateAny(objectMap, "servicePrincipalCredentialType", c.ServicePrincipalCredentialType)
	populateAny(objectMap, "servicePrincipalId", c.ServicePrincipalID)
	populateAny(objectMap, "serviceUri", c.ServiceURI)
	populateAny(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedServiceTypeProperties.
func (c *CommonDataServiceForAppsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &c.AuthenticationType)
			delete(rawMsg, key)
		case "deploymentType":
			err = unpopulate(val, "DeploymentType", &c.DeploymentType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &c.EncryptedCredential)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &c.HostName)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, "OrganizationName", &c.OrganizationName)
			delete(rawMsg, key)
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &c.Port)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			c.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, "ServicePrincipalCredentialType", &c.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &c.ServicePrincipalID)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, "ServiceURI", &c.ServiceURI)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsSink.
func (c CommonDataServiceForAppsSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "alternateKeyName", c.AlternateKeyName)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "ignoreNullValues", c.IgnoreNullValues)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = "CommonDataServiceForAppsSink"
	populateAny(objectMap, "writeBatchSize", c.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", c.WriteBehavior)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsSink.
func (c *CommonDataServiceForAppsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			err = unpopulate(val, "AlternateKeyName", &c.AlternateKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, "IgnoreNullValues", &c.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &c.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &c.WriteBehavior)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsSource.
func (c CommonDataServiceForAppsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", c.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "query", c.Query)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CommonDataServiceForAppsSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsSource.
func (c *CommonDataServiceForAppsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &c.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &c.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComponentSetup.
func (c ComponentSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = "ComponentSetup"
	populate(objectMap, "typeProperties", c.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComponentSetup.
func (c *ComponentSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CompressionReadSettings.
func (c CompressionReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompressionReadSettings.
func (c *CompressionReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConcurLinkedService.
func (c ConcurLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "Concur"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedService.
func (c *ConcurLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConcurLinkedServiceTypeProperties.
func (c ConcurLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", c.ClientID)
	populateAny(objectMap, "connectionProperties", c.ConnectionProperties)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populate(objectMap, "password", c.Password)
	populateAny(objectMap, "useEncryptedEndpoints", c.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", c.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", c.UsePeerVerification)
	populateAny(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedServiceTypeProperties.
func (c *ConcurLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &c.ClientID)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &c.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &c.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &c.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &c.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &c.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConcurObjectDataset.
func (c ConcurObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "ConcurObject"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurObjectDataset.
func (c *ConcurObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConcurSource.
func (c ConcurSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", c.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "query", c.Query)
	populateAny(objectMap, "queryTimeout", c.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "ConcurSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurSource.
func (c *ConcurSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &c.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &c.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionStateProperties.
func (c ConnectionStateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", c.ActionsRequired)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionStateProperties.
func (c *ConnectionStateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &c.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ControlActivity.
func (c ControlActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "onInactiveMarkAs", c.OnInactiveMarkAs)
	populate(objectMap, "state", c.State)
	objectMap["type"] = "Container"
	populate(objectMap, "userProperties", c.UserProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ControlActivity.
func (c *ControlActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &c.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &c.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &c.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &c.UserProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivity.
func (c CopyActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "inputs", c.Inputs)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "onInactiveMarkAs", c.OnInactiveMarkAs)
	populate(objectMap, "outputs", c.Outputs)
	populate(objectMap, "policy", c.Policy)
	populate(objectMap, "state", c.State)
	objectMap["type"] = "Copy"
	populate(objectMap, "typeProperties", c.TypeProperties)
	populate(objectMap, "userProperties", c.UserProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivity.
func (c *CopyActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &c.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, "Inputs", &c.Inputs)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &c.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, "Outputs", &c.Outputs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &c.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &c.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &c.UserProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivityLogSettings.
func (c CopyActivityLogSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "enableReliableLogging", c.EnableReliableLogging)
	populateAny(objectMap, "logLevel", c.LogLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivityLogSettings.
func (c *CopyActivityLogSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableReliableLogging":
			err = unpopulate(val, "EnableReliableLogging", &c.EnableReliableLogging)
			delete(rawMsg, key)
		case "logLevel":
			err = unpopulate(val, "LogLevel", &c.LogLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivityTypeProperties.
func (c CopyActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "dataIntegrationUnits", c.DataIntegrationUnits)
	populateAny(objectMap, "enableSkipIncompatibleRow", c.EnableSkipIncompatibleRow)
	populateAny(objectMap, "enableStaging", c.EnableStaging)
	populate(objectMap, "logSettings", c.LogSettings)
	populate(objectMap, "logStorageSettings", c.LogStorageSettings)
	populateAny(objectMap, "parallelCopies", c.ParallelCopies)
	populate(objectMap, "preserve", c.Preserve)
	populate(objectMap, "preserveRules", c.PreserveRules)
	populate(objectMap, "redirectIncompatibleRowSettings", c.RedirectIncompatibleRowSettings)
	populate(objectMap, "sink", c.Sink)
	populate(objectMap, "skipErrorFile", c.SkipErrorFile)
	populate(objectMap, "source", c.Source)
	populate(objectMap, "stagingSettings", c.StagingSettings)
	populateAny(objectMap, "translator", c.Translator)
	populateAny(objectMap, "validateDataConsistency", c.ValidateDataConsistency)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivityTypeProperties.
func (c *CopyActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrationUnits":
			err = unpopulate(val, "DataIntegrationUnits", &c.DataIntegrationUnits)
			delete(rawMsg, key)
		case "enableSkipIncompatibleRow":
			err = unpopulate(val, "EnableSkipIncompatibleRow", &c.EnableSkipIncompatibleRow)
			delete(rawMsg, key)
		case "enableStaging":
			err = unpopulate(val, "EnableStaging", &c.EnableStaging)
			delete(rawMsg, key)
		case "logSettings":
			err = unpopulate(val, "LogSettings", &c.LogSettings)
			delete(rawMsg, key)
		case "logStorageSettings":
			err = unpopulate(val, "LogStorageSettings", &c.LogStorageSettings)
			delete(rawMsg, key)
		case "parallelCopies":
			err = unpopulate(val, "ParallelCopies", &c.ParallelCopies)
			delete(rawMsg, key)
		case "preserve":
			err = unpopulate(val, "Preserve", &c.Preserve)
			delete(rawMsg, key)
		case "preserveRules":
			err = unpopulate(val, "PreserveRules", &c.PreserveRules)
			delete(rawMsg, key)
		case "redirectIncompatibleRowSettings":
			err = unpopulate(val, "RedirectIncompatibleRowSettings", &c.RedirectIncompatibleRowSettings)
			delete(rawMsg, key)
		case "sink":
			c.Sink, err = unmarshalCopySinkClassification(val)
			delete(rawMsg, key)
		case "skipErrorFile":
			err = unpopulate(val, "SkipErrorFile", &c.SkipErrorFile)
			delete(rawMsg, key)
		case "source":
			c.Source, err = unmarshalCopySourceClassification(val)
			delete(rawMsg, key)
		case "stagingSettings":
			err = unpopulate(val, "StagingSettings", &c.StagingSettings)
			delete(rawMsg, key)
		case "translator":
			err = unpopulate(val, "Translator", &c.Translator)
			delete(rawMsg, key)
		case "validateDataConsistency":
			err = unpopulate(val, "ValidateDataConsistency", &c.ValidateDataConsistency)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyComputeScaleProperties.
func (c CopyComputeScaleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataIntegrationUnit", c.DataIntegrationUnit)
	populate(objectMap, "timeToLive", c.TimeToLive)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyComputeScaleProperties.
func (c *CopyComputeScaleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrationUnit":
			err = unpopulate(val, "DataIntegrationUnit", &c.DataIntegrationUnit)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, "TimeToLive", &c.TimeToLive)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopySink.
func (c CopySink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = c.Type
	populateAny(objectMap, "writeBatchSize", c.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySink.
func (c *CopySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &c.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopySource.
func (c CopySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySource.
func (c *CopySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbLinkedService.
func (c CosmosDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CosmosDb"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedService.
func (c *CosmosDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbLinkedServiceTypeProperties.
func (c CosmosDbLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accountEndpoint", c.AccountEndpoint)
	populate(objectMap, "accountKey", c.AccountKey)
	populateAny(objectMap, "azureCloudType", c.AzureCloudType)
	populate(objectMap, "connectionMode", c.ConnectionMode)
	populateAny(objectMap, "connectionString", c.ConnectionString)
	populate(objectMap, "credential", c.Credential)
	populateAny(objectMap, "database", c.Database)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populate(objectMap, "servicePrincipalCredential", c.ServicePrincipalCredential)
	populateAny(objectMap, "servicePrincipalCredentialType", c.ServicePrincipalCredentialType)
	populateAny(objectMap, "servicePrincipalId", c.ServicePrincipalID)
	populateAny(objectMap, "tenant", c.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedServiceTypeProperties.
func (c *CosmosDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountEndpoint":
			err = unpopulate(val, "AccountEndpoint", &c.AccountEndpoint)
			delete(rawMsg, key)
		case "accountKey":
			c.AccountKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &c.AzureCloudType)
			delete(rawMsg, key)
		case "connectionMode":
			err = unpopulate(val, "ConnectionMode", &c.ConnectionMode)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &c.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &c.Credential)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &c.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &c.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			c.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, "ServicePrincipalCredentialType", &c.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &c.ServicePrincipalID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &c.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c CosmosDbMongoDbAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "CosmosDbMongoDbApiCollection"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c *CosmosDbMongoDbAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPICollectionDatasetTypeProperties.
func (c CosmosDbMongoDbAPICollectionDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "collection", c.Collection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPICollectionDatasetTypeProperties.
func (c *CosmosDbMongoDbAPICollectionDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collection":
			err = unpopulate(val, "Collection", &c.Collection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c CosmosDbMongoDbAPILinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CosmosDbMongoDbApi"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c *CosmosDbMongoDbAPILinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPILinkedServiceTypeProperties.
func (c CosmosDbMongoDbAPILinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", c.ConnectionString)
	populateAny(objectMap, "database", c.Database)
	populateAny(objectMap, "isServerVersionAbove32", c.IsServerVersionAbove32)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPILinkedServiceTypeProperties.
func (c *CosmosDbMongoDbAPILinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &c.ConnectionString)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &c.Database)
			delete(rawMsg, key)
		case "isServerVersionAbove32":
			err = unpopulate(val, "IsServerVersionAbove32", &c.IsServerVersionAbove32)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPISink.
func (c CosmosDbMongoDbAPISink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = "CosmosDbMongoDbApiSink"
	populateAny(objectMap, "writeBatchSize", c.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", c.WriteBehavior)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPISink.
func (c *CosmosDbMongoDbAPISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &c.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &c.WriteBehavior)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPISource.
func (c CosmosDbMongoDbAPISource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", c.AdditionalColumns)
	populateAny(objectMap, "batchSize", c.BatchSize)
	populate(objectMap, "cursorMethods", c.CursorMethods)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "filter", c.Filter)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "queryTimeout", c.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CosmosDbMongoDbApiSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPISource.
func (c *CosmosDbMongoDbAPISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &c.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, "BatchSize", &c.BatchSize)
			delete(rawMsg, key)
		case "cursorMethods":
			err = unpopulate(val, "CursorMethods", &c.CursorMethods)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &c.Filter)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c CosmosDbSQLAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "CosmosDbSqlApiCollection"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c *CosmosDbSQLAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPICollectionDatasetTypeProperties.
func (c CosmosDbSQLAPICollectionDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "collectionName", c.CollectionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPICollectionDatasetTypeProperties.
func (c *CosmosDbSQLAPICollectionDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collectionName":
			err = unpopulate(val, "CollectionName", &c.CollectionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPISink.
func (c CosmosDbSQLAPISink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = "CosmosDbSqlApiSink"
	populateAny(objectMap, "writeBatchSize", c.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", c.WriteBehavior)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPISink.
func (c *CosmosDbSQLAPISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &c.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &c.WriteBehavior)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPISource.
func (c CosmosDbSQLAPISource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", c.AdditionalColumns)
	populateAny(objectMap, "detectDatetime", c.DetectDatetime)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "pageSize", c.PageSize)
	populateAny(objectMap, "preferredRegions", c.PreferredRegions)
	populateAny(objectMap, "query", c.Query)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CosmosDbSqlApiSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPISource.
func (c *CosmosDbSQLAPISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &c.AdditionalColumns)
			delete(rawMsg, key)
		case "detectDatetime":
			err = unpopulate(val, "DetectDatetime", &c.DetectDatetime)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "pageSize":
			err = unpopulate(val, "PageSize", &c.PageSize)
			delete(rawMsg, key)
		case "preferredRegions":
			err = unpopulate(val, "PreferredRegions", &c.PreferredRegions)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &c.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseLinkedService.
func (c CouchbaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "Couchbase"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseLinkedService.
func (c *CouchbaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseLinkedServiceTypeProperties.
func (c CouchbaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", c.ConnectionString)
	populate(objectMap, "credString", c.CredString)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseLinkedServiceTypeProperties.
func (c *CouchbaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &c.ConnectionString)
			delete(rawMsg, key)
		case "credString":
			err = unpopulate(val, "CredString", &c.CredString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &c.EncryptedCredential)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseSource.
func (c CouchbaseSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", c.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populateAny(objectMap, "query", c.Query)
	populateAny(objectMap, "queryTimeout", c.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CouchbaseSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseSource.
func (c *CouchbaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &c.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &c.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseTableDataset.
func (c CouchbaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "CouchbaseTable"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseTableDataset.
func (c *CouchbaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateDataFlowDebugSessionRequest.
func (c CreateDataFlowDebugSessionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeType", c.ComputeType)
	populate(objectMap, "coreCount", c.CoreCount)
	populate(objectMap, "integrationRuntime", c.IntegrationRuntime)
	populate(objectMap, "timeToLive", c.TimeToLive)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateDataFlowDebugSessionRequest.
func (c *CreateDataFlowDebugSessionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			err = unpopulate(val, "ComputeType", &c.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, "CoreCount", &c.CoreCount)
			delete(rawMsg, key)
		case "integrationRuntime":
			err = unpopulate(val, "IntegrationRuntime", &c.IntegrationRuntime)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, "TimeToLive", &c.TimeToLive)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateDataFlowDebugSessionResponse.
func (c CreateDataFlowDebugSessionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sessionId", c.SessionID)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateDataFlowDebugSessionResponse.
func (c *CreateDataFlowDebugSessionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sessionId":
			err = unpopulate(val, "SessionID", &c.SessionID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateLinkedIntegrationRuntimeRequest.
func (c CreateLinkedIntegrationRuntimeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataFactoryLocation", c.DataFactoryLocation)
	populate(objectMap, "dataFactoryName", c.DataFactoryName)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "subscriptionId", c.SubscriptionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateLinkedIntegrationRuntimeRequest.
func (c *CreateLinkedIntegrationRuntimeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryLocation":
			err = unpopulate(val, "DataFactoryLocation", &c.DataFactoryLocation)
			delete(rawMsg, key)
		case "dataFactoryName":
			err = unpopulate(val, "DataFactoryName", &c.DataFactoryName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &c.SubscriptionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateRunResponse.
func (c CreateRunResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "runId", c.RunID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateRunResponse.
func (c *CreateRunResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "runId":
			err = unpopulate(val, "RunID", &c.RunID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Credential.
func (c Credential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Credential.
func (c *Credential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CredentialListResponse.
func (c CredentialListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialListResponse.
func (c *CredentialListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CredentialReference.
func (c CredentialReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "referenceName", c.ReferenceName)
	populate(objectMap, "type", c.Type)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialReference.
func (c *CredentialReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &c.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivity.
func (c CustomActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "onInactiveMarkAs", c.OnInactiveMarkAs)
	populate(objectMap, "policy", c.Policy)
	populate(objectMap, "state", c.State)
	objectMap["type"] = "Custom"
	populate(objectMap, "typeProperties", c.TypeProperties)
	populate(objectMap, "userProperties", c.UserProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomActivity.
func (c *CustomActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &c.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &c.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &c.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &c.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &c.UserProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivityReferenceObject.
func (c CustomActivityReferenceObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "datasets", c.Datasets)
	populate(objectMap, "linkedServices", c.LinkedServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomActivityReferenceObject.
func (c *CustomActivityReferenceObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasets":
			err = unpopulate(val, "Datasets", &c.Datasets)
			delete(rawMsg, key)
		case "linkedServices":
			err = unpopulate(val, "LinkedServices", &c.LinkedServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivityTypeProperties.
func (c CustomActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "autoUserSpecification", c.AutoUserSpecification)
	populateAny(objectMap, "command", c.Command)
	populate(objectMap, "extendedProperties", c.ExtendedProperties)
	populateAny(objectMap, "folderPath", c.FolderPath)
	populate(objectMap, "referenceObjects", c.ReferenceObjects)
	populate(objectMap, "resourceLinkedService", c.ResourceLinkedService)
	populateAny(objectMap, "retentionTimeInDays", c.RetentionTimeInDays)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomActivityTypeProperties.
func (c *CustomActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUserSpecification":
			err = unpopulate(val, "AutoUserSpecification", &c.AutoUserSpecification)
			delete(rawMsg, key)
		case "command":
			err = unpopulate(val, "Command", &c.Command)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, "ExtendedProperties", &c.ExtendedProperties)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &c.FolderPath)
			delete(rawMsg, key)
		case "referenceObjects":
			err = unpopulate(val, "ReferenceObjects", &c.ReferenceObjects)
			delete(rawMsg, key)
		case "resourceLinkedService":
			err = unpopulate(val, "ResourceLinkedService", &c.ResourceLinkedService)
			delete(rawMsg, key)
		case "retentionTimeInDays":
			err = unpopulate(val, "RetentionTimeInDays", &c.RetentionTimeInDays)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataSourceLinkedService.
func (c CustomDataSourceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CustomDataSource"
	populateAny(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataSourceLinkedService.
func (c *CustomDataSourceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataset.
func (c CustomDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populateAny(objectMap, "schema", c.Schema)
	populateAny(objectMap, "structure", c.Structure)
	objectMap["type"] = "CustomDataset"
	populateAny(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataset.
func (c *CustomDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomEventsTrigger.
func (c CustomEventsTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "pipelines", c.Pipelines)
	populate(objectMap, "runtimeState", c.RuntimeState)
	objectMap["type"] = "CustomEventsTrigger"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomEventsTrigger.
func (c *CustomEventsTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, "Pipelines", &c.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &c.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomEventsTriggerTypeProperties.
func (c CustomEventsTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "events", c.Events)
	populate(objectMap, "scope", c.Scope)
	populate(objectMap, "subjectBeginsWith", c.SubjectBeginsWith)
	populate(objectMap, "subjectEndsWith", c.SubjectEndsWith)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomEventsTriggerTypeProperties.
func (c *CustomEventsTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "events":
			err = unpopulate(val, "Events", &c.Events)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &c.Scope)
			delete(rawMsg, key)
		case "subjectBeginsWith":
			err = unpopulate(val, "SubjectBeginsWith", &c.SubjectBeginsWith)
			delete(rawMsg, key)
		case "subjectEndsWith":
			err = unpopulate(val, "SubjectEndsWith", &c.SubjectEndsWith)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomSetupBase.
func (c CustomSetupBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = c.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomSetupBase.
func (c *CustomSetupBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DWCopyCommandDefaultValue.
func (d DWCopyCommandDefaultValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "columnName", d.ColumnName)
	populateAny(objectMap, "defaultValue", d.DefaultValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DWCopyCommandDefaultValue.
func (d *DWCopyCommandDefaultValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnName":
			err = unpopulate(val, "ColumnName", &d.ColumnName)
			delete(rawMsg, key)
		case "defaultValue":
			err = unpopulate(val, "DefaultValue", &d.DefaultValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DWCopyCommandSettings.
func (d DWCopyCommandSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalOptions", d.AdditionalOptions)
	populate(objectMap, "defaultValues", d.DefaultValues)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DWCopyCommandSettings.
func (d *DWCopyCommandSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalOptions":
			err = unpopulate(val, "AdditionalOptions", &d.AdditionalOptions)
			delete(rawMsg, key)
		case "defaultValues":
			err = unpopulate(val, "DefaultValues", &d.DefaultValues)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlow.
func (d DataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	objectMap["type"] = d.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlow.
func (d *DataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugCommandPayload.
func (d DataFlowDebugCommandPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "columns", d.Columns)
	populate(objectMap, "expression", d.Expression)
	populate(objectMap, "rowLimits", d.RowLimits)
	populate(objectMap, "streamName", d.StreamName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugCommandPayload.
func (d *DataFlowDebugCommandPayload) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columns":
			err = unpopulate(val, "Columns", &d.Columns)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, "Expression", &d.Expression)
			delete(rawMsg, key)
		case "rowLimits":
			err = unpopulate(val, "RowLimits", &d.RowLimits)
			delete(rawMsg, key)
		case "streamName":
			err = unpopulate(val, "StreamName", &d.StreamName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugCommandRequest.
func (d DataFlowDebugCommandRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "command", d.Command)
	populate(objectMap, "commandPayload", d.CommandPayload)
	populate(objectMap, "sessionId", d.SessionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugCommandRequest.
func (d *DataFlowDebugCommandRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "command":
			err = unpopulate(val, "Command", &d.Command)
			delete(rawMsg, key)
		case "commandPayload":
			err = unpopulate(val, "CommandPayload", &d.CommandPayload)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, "SessionID", &d.SessionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugCommandResponse.
func (d DataFlowDebugCommandResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "data", d.Data)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugCommandResponse.
func (d *DataFlowDebugCommandResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
			err = unpopulate(val, "Data", &d.Data)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugPackage.
func (d DataFlowDebugPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataFlow", d.DataFlow)
	populate(objectMap, "dataFlows", d.DataFlows)
	populate(objectMap, "datasets", d.Datasets)
	populate(objectMap, "debugSettings", d.DebugSettings)
	populate(objectMap, "linkedServices", d.LinkedServices)
	populate(objectMap, "sessionId", d.SessionID)
	populate(objectMap, "staging", d.Staging)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugPackage.
func (d *DataFlowDebugPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlow":
			err = unpopulate(val, "DataFlow", &d.DataFlow)
			delete(rawMsg, key)
		case "dataFlows":
			err = unpopulate(val, "DataFlows", &d.DataFlows)
			delete(rawMsg, key)
		case "datasets":
			err = unpopulate(val, "Datasets", &d.Datasets)
			delete(rawMsg, key)
		case "debugSettings":
			err = unpopulate(val, "DebugSettings", &d.DebugSettings)
			delete(rawMsg, key)
		case "linkedServices":
			err = unpopulate(val, "LinkedServices", &d.LinkedServices)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, "SessionID", &d.SessionID)
			delete(rawMsg, key)
		case "staging":
			err = unpopulate(val, "Staging", &d.Staging)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugPackageDebugSettings.
func (d DataFlowDebugPackageDebugSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "datasetParameters", d.DatasetParameters)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "sourceSettings", d.SourceSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugPackageDebugSettings.
func (d *DataFlowDebugPackageDebugSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasetParameters":
			err = unpopulate(val, "DatasetParameters", &d.DatasetParameters)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "sourceSettings":
			err = unpopulate(val, "SourceSettings", &d.SourceSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugResource.
func (d DataFlowDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugResource.
func (d *DataFlowDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDataFlowClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugSessionInfo.
func (d DataFlowDebugSessionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeType", d.ComputeType)
	populate(objectMap, "coreCount", d.CoreCount)
	populate(objectMap, "dataFlowName", d.DataFlowName)
	populate(objectMap, "integrationRuntimeName", d.IntegrationRuntimeName)
	populate(objectMap, "lastActivityTime", d.LastActivityTime)
	populate(objectMap, "nodeCount", d.NodeCount)
	populate(objectMap, "sessionId", d.SessionID)
	populate(objectMap, "startTime", d.StartTime)
	populate(objectMap, "timeToLiveInMinutes", d.TimeToLiveInMinutes)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugSessionInfo.
func (d *DataFlowDebugSessionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			err = unpopulate(val, "ComputeType", &d.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, "CoreCount", &d.CoreCount)
			delete(rawMsg, key)
		case "dataFlowName":
			err = unpopulate(val, "DataFlowName", &d.DataFlowName)
			delete(rawMsg, key)
		case "integrationRuntimeName":
			err = unpopulate(val, "IntegrationRuntimeName", &d.IntegrationRuntimeName)
			delete(rawMsg, key)
		case "lastActivityTime":
			err = unpopulate(val, "LastActivityTime", &d.LastActivityTime)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &d.NodeCount)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, "SessionID", &d.SessionID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &d.StartTime)
			delete(rawMsg, key)
		case "timeToLiveInMinutes":
			err = unpopulate(val, "TimeToLiveInMinutes", &d.TimeToLiveInMinutes)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowFolder.
func (d DataFlowFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowFolder.
func (d *DataFlowFolder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowListResponse.
func (d DataFlowListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowListResponse.
func (d *DataFlowListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowReference.
func (d DataFlowReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "datasetParameters", d.DatasetParameters)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "referenceName", d.ReferenceName)
	populate(objectMap, "type", d.Type)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowReference.
func (d *DataFlowReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasetParameters":
			err = unpopulate(val, "DatasetParameters", &d.DatasetParameters)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &d.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowResource.
func (d DataFlowResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowResource.
func (d *DataFlowResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &d.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDataFlowClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowSink.
func (d DataFlowSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", d.Dataset)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "flowlet", d.Flowlet)
	populate(objectMap, "linkedService", d.LinkedService)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "rejectedDataLinkedService", d.RejectedDataLinkedService)
	populate(objectMap, "schemaLinkedService", d.SchemaLinkedService)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowSink.
func (d *DataFlowSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &d.Dataset)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "flowlet":
			err = unpopulate(val, "Flowlet", &d.Flowlet)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &d.LinkedService)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "rejectedDataLinkedService":
			err = unpopulate(val, "RejectedDataLinkedService", &d.RejectedDataLinkedService)
			delete(rawMsg, key)
		case "schemaLinkedService":
			err = unpopulate(val, "SchemaLinkedService", &d.SchemaLinkedService)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowSource.
func (d DataFlowSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", d.Dataset)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "flowlet", d.Flowlet)
	populate(objectMap, "linkedService", d.LinkedService)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "schemaLinkedService", d.SchemaLinkedService)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowSource.
func (d *DataFlowSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &d.Dataset)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "flowlet":
			err = unpopulate(val, "Flowlet", &d.Flowlet)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &d.LinkedService)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "schemaLinkedService":
			err = unpopulate(val, "SchemaLinkedService", &d.SchemaLinkedService)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowSourceSetting.
func (d DataFlowSourceSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "rowLimit", d.RowLimit)
	populate(objectMap, "sourceName", d.SourceName)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowSourceSetting.
func (d *DataFlowSourceSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rowLimit":
			err = unpopulate(val, "RowLimit", &d.RowLimit)
			delete(rawMsg, key)
		case "sourceName":
			err = unpopulate(val, "SourceName", &d.SourceName)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowStagingInfo.
func (d DataFlowStagingInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "folderPath", d.FolderPath)
	populate(objectMap, "linkedService", d.LinkedService)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowStagingInfo.
func (d *DataFlowStagingInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "folderPath":
			err = unpopulate(val, "FolderPath", &d.FolderPath)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &d.LinkedService)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsUSQLActivity.
func (d DataLakeAnalyticsUSQLActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "onInactiveMarkAs", d.OnInactiveMarkAs)
	populate(objectMap, "policy", d.Policy)
	populate(objectMap, "state", d.State)
	objectMap["type"] = "DataLakeAnalyticsU-SQL"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsUSQLActivity.
func (d *DataLakeAnalyticsUSQLActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &d.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &d.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &d.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsUSQLActivityTypeProperties.
func (d DataLakeAnalyticsUSQLActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "compilationMode", d.CompilationMode)
	populateAny(objectMap, "degreeOfParallelism", d.DegreeOfParallelism)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "priority", d.Priority)
	populateAny(objectMap, "runtimeVersion", d.RuntimeVersion)
	populate(objectMap, "scriptLinkedService", d.ScriptLinkedService)
	populateAny(objectMap, "scriptPath", d.ScriptPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsUSQLActivityTypeProperties.
func (d *DataLakeAnalyticsUSQLActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compilationMode":
			err = unpopulate(val, "CompilationMode", &d.CompilationMode)
			delete(rawMsg, key)
		case "degreeOfParallelism":
			err = unpopulate(val, "DegreeOfParallelism", &d.DegreeOfParallelism)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &d.Priority)
			delete(rawMsg, key)
		case "runtimeVersion":
			err = unpopulate(val, "RuntimeVersion", &d.RuntimeVersion)
			delete(rawMsg, key)
		case "scriptLinkedService":
			err = unpopulate(val, "ScriptLinkedService", &d.ScriptLinkedService)
			delete(rawMsg, key)
		case "scriptPath":
			err = unpopulate(val, "ScriptPath", &d.ScriptPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataMapperMapping.
func (d DataMapperMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attributeMappingInfo", d.AttributeMappingInfo)
	populate(objectMap, "sourceConnectionReference", d.SourceConnectionReference)
	populateAny(objectMap, "sourceDenormalizeInfo", d.SourceDenormalizeInfo)
	populate(objectMap, "sourceEntityName", d.SourceEntityName)
	populate(objectMap, "targetEntityName", d.TargetEntityName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataMapperMapping.
func (d *DataMapperMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributeMappingInfo":
			err = unpopulate(val, "AttributeMappingInfo", &d.AttributeMappingInfo)
			delete(rawMsg, key)
		case "sourceConnectionReference":
			err = unpopulate(val, "SourceConnectionReference", &d.SourceConnectionReference)
			delete(rawMsg, key)
		case "sourceDenormalizeInfo":
			err = unpopulate(val, "SourceDenormalizeInfo", &d.SourceDenormalizeInfo)
			delete(rawMsg, key)
		case "sourceEntityName":
			err = unpopulate(val, "SourceEntityName", &d.SourceEntityName)
			delete(rawMsg, key)
		case "targetEntityName":
			err = unpopulate(val, "TargetEntityName", &d.TargetEntityName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksNotebookActivity.
func (d DatabricksNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "onInactiveMarkAs", d.OnInactiveMarkAs)
	populate(objectMap, "policy", d.Policy)
	populate(objectMap, "state", d.State)
	objectMap["type"] = "DatabricksNotebook"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksNotebookActivity.
func (d *DatabricksNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &d.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &d.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &d.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksNotebookActivityTypeProperties.
func (d DatabricksNotebookActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseParameters", d.BaseParameters)
	populate(objectMap, "libraries", d.Libraries)
	populateAny(objectMap, "notebookPath", d.NotebookPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksNotebookActivityTypeProperties.
func (d *DatabricksNotebookActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseParameters":
			err = unpopulate(val, "BaseParameters", &d.BaseParameters)
			delete(rawMsg, key)
		case "libraries":
			err = unpopulate(val, "Libraries", &d.Libraries)
			delete(rawMsg, key)
		case "notebookPath":
			err = unpopulate(val, "NotebookPath", &d.NotebookPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkJarActivity.
func (d DatabricksSparkJarActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "onInactiveMarkAs", d.OnInactiveMarkAs)
	populate(objectMap, "policy", d.Policy)
	populate(objectMap, "state", d.State)
	objectMap["type"] = "DatabricksSparkJar"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkJarActivity.
func (d *DatabricksSparkJarActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &d.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &d.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &d.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkJarActivityTypeProperties.
func (d DatabricksSparkJarActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "libraries", d.Libraries)
	populateAny(objectMap, "mainClassName", d.MainClassName)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkJarActivityTypeProperties.
func (d *DatabricksSparkJarActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "libraries":
			err = unpopulate(val, "Libraries", &d.Libraries)
			delete(rawMsg, key)
		case "mainClassName":
			err = unpopulate(val, "MainClassName", &d.MainClassName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkPythonActivity.
func (d DatabricksSparkPythonActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "onInactiveMarkAs", d.OnInactiveMarkAs)
	populate(objectMap, "policy", d.Policy)
	populate(objectMap, "state", d.State)
	objectMap["type"] = "DatabricksSparkPython"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkPythonActivity.
func (d *DatabricksSparkPythonActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &d.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &d.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &d.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkPythonActivityTypeProperties.
func (d DatabricksSparkPythonActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "libraries", d.Libraries)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "pythonFile", d.PythonFile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkPythonActivityTypeProperties.
func (d *DatabricksSparkPythonActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "libraries":
			err = unpopulate(val, "Libraries", &d.Libraries)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "pythonFile":
			err = unpopulate(val, "PythonFile", &d.PythonFile)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Dataset.
func (d Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Dataset.
func (d *Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetCompression.
func (d DatasetCompression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "level", d.Level)
	populateAny(objectMap, "type", d.Type)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetCompression.
func (d *DatasetCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			err = unpopulate(val, "Level", &d.Level)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetDebugResource.
func (d DatasetDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetDebugResource.
func (d *DatasetDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDatasetClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetFolder.
func (d DatasetFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetFolder.
func (d *DatasetFolder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetListResponse.
func (d DatasetListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetListResponse.
func (d *DatasetListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetLocation.
func (d DatasetLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", d.FileName)
	populateAny(objectMap, "folderPath", d.FolderPath)
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetLocation.
func (d *DatasetLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &d.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &d.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetReference.
func (d DatasetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "referenceName", d.ReferenceName)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetReference.
func (d *DatasetReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &d.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetResource.
func (d DatasetResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetResource.
func (d *DatasetResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &d.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDatasetClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetStorageFormat.
func (d DatasetStorageFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deserializer", d.Deserializer)
	populateAny(objectMap, "serializer", d.Serializer)
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetStorageFormat.
func (d *DatasetStorageFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, "Deserializer", &d.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, "Serializer", &d.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataworldLinkedService.
func (d DataworldLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Dataworld"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataworldLinkedService.
func (d *DataworldLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataworldLinkedServiceTypeProperties.
func (d DataworldLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiToken", d.APIToken)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataworldLinkedServiceTypeProperties.
func (d *DataworldLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiToken":
			d.APIToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &d.EncryptedCredential)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Db2LinkedService.
func (d Db2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Db2"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedService.
func (d *Db2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Db2LinkedServiceTypeProperties.
func (d Db2LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", d.AuthenticationType)
	populateAny(objectMap, "certificateCommonName", d.CertificateCommonName)
	populateAny(objectMap, "connectionString", d.ConnectionString)
	populateAny(objectMap, "database", d.Database)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populateAny(objectMap, "packageCollection", d.PackageCollection)
	populate(objectMap, "password", d.Password)
	populateAny(objectMap, "server", d.Server)
	populateAny(objectMap, "username", d.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedServiceTypeProperties.
func (d *Db2LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &d.AuthenticationType)
			delete(rawMsg, key)
		case "certificateCommonName":
			err = unpopulate(val, "CertificateCommonName", &d.CertificateCommonName)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &d.ConnectionString)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &d.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &d.EncryptedCredential)
			delete(rawMsg, key)
		case "packageCollection":
			err = unpopulate(val, "PackageCollection", &d.PackageCollection)
			delete(rawMsg, key)
		case "password":
			d.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &d.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &d.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Db2Source.
func (d Db2Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "query", d.Query)
	populateAny(objectMap, "queryTimeout", d.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "Db2Source"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2Source.
func (d *Db2Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Db2TableDataset.
func (d Db2TableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "Db2Table"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2TableDataset.
func (d *Db2TableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Db2TableDatasetTypeProperties.
func (d Db2TableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "table", d.Table)
	populateAny(objectMap, "tableName", d.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2TableDatasetTypeProperties.
func (d *Db2TableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &d.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &d.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeleteActivity.
func (d DeleteActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "onInactiveMarkAs", d.OnInactiveMarkAs)
	populate(objectMap, "policy", d.Policy)
	populate(objectMap, "state", d.State)
	objectMap["type"] = "Delete"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteActivity.
func (d *DeleteActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &d.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &d.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &d.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeleteActivityTypeProperties.
func (d DeleteActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", d.Dataset)
	populateAny(objectMap, "enableLogging", d.EnableLogging)
	populate(objectMap, "logStorageSettings", d.LogStorageSettings)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "recursive", d.Recursive)
	populate(objectMap, "storeSettings", d.StoreSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteActivityTypeProperties.
func (d *DeleteActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &d.Dataset)
			delete(rawMsg, key)
		case "enableLogging":
			err = unpopulate(val, "EnableLogging", &d.EnableLogging)
			delete(rawMsg, key)
		case "logStorageSettings":
			err = unpopulate(val, "LogStorageSettings", &d.LogStorageSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &d.Recursive)
			delete(rawMsg, key)
		case "storeSettings":
			d.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeleteDataFlowDebugSessionRequest.
func (d DeleteDataFlowDebugSessionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sessionId", d.SessionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteDataFlowDebugSessionRequest.
func (d *DeleteDataFlowDebugSessionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sessionId":
			err = unpopulate(val, "SessionID", &d.SessionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextDataset.
func (d DelimitedTextDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "DelimitedText"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDataset.
func (d *DelimitedTextDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextDatasetTypeProperties.
func (d DelimitedTextDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "columnDelimiter", d.ColumnDelimiter)
	populateAny(objectMap, "compressionCodec", d.CompressionCodec)
	populateAny(objectMap, "compressionLevel", d.CompressionLevel)
	populateAny(objectMap, "encodingName", d.EncodingName)
	populateAny(objectMap, "escapeChar", d.EscapeChar)
	populateAny(objectMap, "firstRowAsHeader", d.FirstRowAsHeader)
	populate(objectMap, "location", d.Location)
	populateAny(objectMap, "nullValue", d.NullValue)
	populateAny(objectMap, "quoteChar", d.QuoteChar)
	populateAny(objectMap, "rowDelimiter", d.RowDelimiter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDatasetTypeProperties.
func (d *DelimitedTextDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			err = unpopulate(val, "ColumnDelimiter", &d.ColumnDelimiter)
			delete(rawMsg, key)
		case "compressionCodec":
			err = unpopulate(val, "CompressionCodec", &d.CompressionCodec)
			delete(rawMsg, key)
		case "compressionLevel":
			err = unpopulate(val, "CompressionLevel", &d.CompressionLevel)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, "EncodingName", &d.EncodingName)
			delete(rawMsg, key)
		case "escapeChar":
			err = unpopulate(val, "EscapeChar", &d.EscapeChar)
			delete(rawMsg, key)
		case "firstRowAsHeader":
			err = unpopulate(val, "FirstRowAsHeader", &d.FirstRowAsHeader)
			delete(rawMsg, key)
		case "location":
			d.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, "NullValue", &d.NullValue)
			delete(rawMsg, key)
		case "quoteChar":
			err = unpopulate(val, "QuoteChar", &d.QuoteChar)
			delete(rawMsg, key)
		case "rowDelimiter":
			err = unpopulate(val, "RowDelimiter", &d.RowDelimiter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextReadSettings.
func (d DelimitedTextReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compressionProperties", d.CompressionProperties)
	populateAny(objectMap, "skipLineCount", d.SkipLineCount)
	objectMap["type"] = "DelimitedTextReadSettings"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextReadSettings.
func (d *DelimitedTextReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			d.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "skipLineCount":
			err = unpopulate(val, "SkipLineCount", &d.SkipLineCount)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextSink.
func (d DelimitedTextSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "formatSettings", d.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", d.SinkRetryWait)
	populate(objectMap, "storeSettings", d.StoreSettings)
	objectMap["type"] = "DelimitedTextSink"
	populateAny(objectMap, "writeBatchSize", d.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextSink.
func (d *DelimitedTextSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &d.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &d.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			d.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &d.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextSource.
func (d DelimitedTextSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "formatSettings", d.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	populate(objectMap, "storeSettings", d.StoreSettings)
	objectMap["type"] = "DelimitedTextSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextSource.
func (d *DelimitedTextSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &d.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			d.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextWriteSettings.
func (d DelimitedTextWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileExtension", d.FileExtension)
	populateAny(objectMap, "fileNamePrefix", d.FileNamePrefix)
	populateAny(objectMap, "maxRowsPerFile", d.MaxRowsPerFile)
	populateAny(objectMap, "quoteAllText", d.QuoteAllText)
	objectMap["type"] = "DelimitedTextWriteSettings"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextWriteSettings.
func (d *DelimitedTextWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileExtension":
			err = unpopulate(val, "FileExtension", &d.FileExtension)
			delete(rawMsg, key)
		case "fileNamePrefix":
			err = unpopulate(val, "FileNamePrefix", &d.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, "MaxRowsPerFile", &d.MaxRowsPerFile)
			delete(rawMsg, key)
		case "quoteAllText":
			err = unpopulate(val, "QuoteAllText", &d.QuoteAllText)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DependencyReference.
func (d DependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = d.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DependencyReference.
func (d *DependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistcpSettings.
func (d DistcpSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "distcpOptions", d.DistcpOptions)
	populateAny(objectMap, "resourceManagerEndpoint", d.ResourceManagerEndpoint)
	populateAny(objectMap, "tempScriptPath", d.TempScriptPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistcpSettings.
func (d *DistcpSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distcpOptions":
			err = unpopulate(val, "DistcpOptions", &d.DistcpOptions)
			delete(rawMsg, key)
		case "resourceManagerEndpoint":
			err = unpopulate(val, "ResourceManagerEndpoint", &d.ResourceManagerEndpoint)
			delete(rawMsg, key)
		case "tempScriptPath":
			err = unpopulate(val, "TempScriptPath", &d.TempScriptPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionDataset.
func (d DocumentDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "DocumentDbCollection"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionDataset.
func (d *DocumentDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionDatasetTypeProperties.
func (d DocumentDbCollectionDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "collectionName", d.CollectionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionDatasetTypeProperties.
func (d *DocumentDbCollectionDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collectionName":
			err = unpopulate(val, "CollectionName", &d.CollectionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionSink.
func (d DocumentDbCollectionSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "nestingSeparator", d.NestingSeparator)
	populateAny(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", d.SinkRetryWait)
	objectMap["type"] = "DocumentDbCollectionSink"
	populateAny(objectMap, "writeBatchSize", d.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", d.WriteBehavior)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionSink.
func (d *DocumentDbCollectionSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "nestingSeparator":
			err = unpopulate(val, "NestingSeparator", &d.NestingSeparator)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &d.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &d.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &d.WriteBehavior)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionSource.
func (d DocumentDbCollectionSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "nestingSeparator", d.NestingSeparator)
	populateAny(objectMap, "query", d.Query)
	populateAny(objectMap, "queryTimeout", d.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DocumentDbCollectionSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionSource.
func (d *DocumentDbCollectionSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "nestingSeparator":
			err = unpopulate(val, "NestingSeparator", &d.NestingSeparator)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DrillDatasetTypeProperties.
func (d DrillDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "table", d.Table)
	populateAny(objectMap, "tableName", d.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillDatasetTypeProperties.
func (d *DrillDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &d.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &d.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DrillLinkedService.
func (d DrillLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Drill"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillLinkedService.
func (d *DrillLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DrillLinkedServiceTypeProperties.
func (d DrillLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", d.ConnectionString)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populate(objectMap, "pwd", d.Pwd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillLinkedServiceTypeProperties.
func (d *DrillLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &d.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &d.EncryptedCredential)
			delete(rawMsg, key)
		case "pwd":
			err = unpopulate(val, "Pwd", &d.Pwd)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DrillSource.
func (d DrillSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "query", d.Query)
	populateAny(objectMap, "queryTimeout", d.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DrillSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillSource.
func (d *DrillSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DrillTableDataset.
func (d DrillTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "DrillTable"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillTableDataset.
func (d *DrillTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXLinkedService.
func (d DynamicsAXLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "DynamicsAX"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXLinkedService.
func (d *DynamicsAXLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXLinkedServiceTypeProperties.
func (d DynamicsAXLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "aadResourceId", d.AADResourceID)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populateAny(objectMap, "servicePrincipalId", d.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", d.ServicePrincipalKey)
	populateAny(objectMap, "tenant", d.Tenant)
	populateAny(objectMap, "url", d.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXLinkedServiceTypeProperties.
func (d *DynamicsAXLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			err = unpopulate(val, "AADResourceID", &d.AADResourceID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &d.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &d.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			d.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &d.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &d.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXResourceDataset.
func (d DynamicsAXResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "DynamicsAXResource"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXResourceDataset.
func (d *DynamicsAXResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXResourceDatasetTypeProperties.
func (d DynamicsAXResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "path", d.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXResourceDatasetTypeProperties.
func (d *DynamicsAXResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &d.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXSource.
func (d DynamicsAXSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", d.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "query", d.Query)
	populateAny(objectMap, "queryTimeout", d.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DynamicsAXSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXSource.
func (d *DynamicsAXSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &d.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmEntityDataset.
func (d DynamicsCrmEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "DynamicsCrmEntity"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmEntityDataset.
func (d *DynamicsCrmEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmEntityDatasetTypeProperties.
func (d DynamicsCrmEntityDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "entityName", d.EntityName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmEntityDatasetTypeProperties.
func (d *DynamicsCrmEntityDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entityName":
			err = unpopulate(val, "EntityName", &d.EntityName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmLinkedService.
func (d DynamicsCrmLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "DynamicsCrm"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedService.
func (d *DynamicsCrmLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmLinkedServiceTypeProperties.
func (d DynamicsCrmLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", d.AuthenticationType)
	populateAny(objectMap, "deploymentType", d.DeploymentType)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populateAny(objectMap, "hostName", d.HostName)
	populateAny(objectMap, "organizationName", d.OrganizationName)
	populate(objectMap, "password", d.Password)
	populateAny(objectMap, "port", d.Port)
	populate(objectMap, "servicePrincipalCredential", d.ServicePrincipalCredential)
	populateAny(objectMap, "servicePrincipalCredentialType", d.ServicePrincipalCredentialType)
	populateAny(objectMap, "servicePrincipalId", d.ServicePrincipalID)
	populateAny(objectMap, "serviceUri", d.ServiceURI)
	populateAny(objectMap, "username", d.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedServiceTypeProperties.
func (d *DynamicsCrmLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &d.AuthenticationType)
			delete(rawMsg, key)
		case "deploymentType":
			err = unpopulate(val, "DeploymentType", &d.DeploymentType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &d.EncryptedCredential)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &d.HostName)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, "OrganizationName", &d.OrganizationName)
			delete(rawMsg, key)
		case "password":
			d.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &d.Port)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, "ServicePrincipalCredentialType", &d.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &d.ServicePrincipalID)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, "ServiceURI", &d.ServiceURI)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &d.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmSink.
func (d DynamicsCrmSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "alternateKeyName", d.AlternateKeyName)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "ignoreNullValues", d.IgnoreNullValues)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", d.SinkRetryWait)
	objectMap["type"] = "DynamicsCrmSink"
	populateAny(objectMap, "writeBatchSize", d.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", d.WriteBehavior)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmSink.
func (d *DynamicsCrmSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			err = unpopulate(val, "AlternateKeyName", &d.AlternateKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, "IgnoreNullValues", &d.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &d.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &d.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &d.WriteBehavior)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmSource.
func (d DynamicsCrmSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "query", d.Query)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DynamicsCrmSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmSource.
func (d *DynamicsCrmSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &d.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsEntityDataset.
func (d DynamicsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populateAny(objectMap, "schema", d.Schema)
	populateAny(objectMap, "structure", d.Structure)
	objectMap["type"] = "DynamicsEntity"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsEntityDataset.
func (d *DynamicsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsEntityDatasetTypeProperties.
func (d DynamicsEntityDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "entityName", d.EntityName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsEntityDatasetTypeProperties.
func (d *DynamicsEntityDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entityName":
			err = unpopulate(val, "EntityName", &d.EntityName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsLinkedService.
func (d DynamicsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Dynamics"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedService.
func (d *DynamicsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsLinkedServiceTypeProperties.
func (d DynamicsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", d.AuthenticationType)
	populate(objectMap, "credential", d.Credential)
	populateAny(objectMap, "deploymentType", d.DeploymentType)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populateAny(objectMap, "hostName", d.HostName)
	populateAny(objectMap, "organizationName", d.OrganizationName)
	populate(objectMap, "password", d.Password)
	populateAny(objectMap, "port", d.Port)
	populate(objectMap, "servicePrincipalCredential", d.ServicePrincipalCredential)
	populateAny(objectMap, "servicePrincipalCredentialType", d.ServicePrincipalCredentialType)
	populateAny(objectMap, "servicePrincipalId", d.ServicePrincipalID)
	populateAny(objectMap, "serviceUri", d.ServiceURI)
	populateAny(objectMap, "username", d.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedServiceTypeProperties.
func (d *DynamicsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &d.AuthenticationType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &d.Credential)
			delete(rawMsg, key)
		case "deploymentType":
			err = unpopulate(val, "DeploymentType", &d.DeploymentType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &d.EncryptedCredential)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &d.HostName)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, "OrganizationName", &d.OrganizationName)
			delete(rawMsg, key)
		case "password":
			d.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &d.Port)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, "ServicePrincipalCredentialType", &d.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &d.ServicePrincipalID)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, "ServiceURI", &d.ServiceURI)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &d.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsSink.
func (d DynamicsSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "alternateKeyName", d.AlternateKeyName)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "ignoreNullValues", d.IgnoreNullValues)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", d.SinkRetryWait)
	objectMap["type"] = "DynamicsSink"
	populateAny(objectMap, "writeBatchSize", d.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", d.WriteBehavior)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsSink.
func (d *DynamicsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			err = unpopulate(val, "AlternateKeyName", &d.AlternateKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, "IgnoreNullValues", &d.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &d.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &d.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &d.WriteBehavior)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsSource.
func (d DynamicsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", d.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populateAny(objectMap, "query", d.Query)
	populateAny(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DynamicsSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsSource.
func (d *DynamicsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &d.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EloquaLinkedService.
func (e EloquaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", e.Annotations)
	populate(objectMap, "connectVia", e.ConnectVia)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "parameters", e.Parameters)
	objectMap["type"] = "Eloqua"
	populate(objectMap, "typeProperties", e.TypeProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedService.
func (e *EloquaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &e.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &e.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &e.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EloquaLinkedServiceTypeProperties.
func (e EloquaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", e.EncryptedCredential)
	populateAny(objectMap, "endpoint", e.Endpoint)
	populate(objectMap, "password", e.Password)
	populateAny(objectMap, "useEncryptedEndpoints", e.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", e.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", e.UsePeerVerification)
	populateAny(objectMap, "username", e.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedServiceTypeProperties.
func (e *EloquaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &e.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &e.Endpoint)
			delete(rawMsg, key)
		case "password":
			e.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &e.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &e.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &e.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &e.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EloquaObjectDataset.
func (e EloquaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", e.Annotations)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "folder", e.Folder)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "parameters", e.Parameters)
	populateAny(objectMap, "schema", e.Schema)
	populateAny(objectMap, "structure", e.Structure)
	objectMap["type"] = "EloquaObject"
	populate(objectMap, "typeProperties", e.TypeProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaObjectDataset.
func (e *EloquaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &e.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &e.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &e.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &e.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &e.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &e.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EloquaSource.
func (e EloquaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", e.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", e.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", e.MaxConcurrentConnections)
	populateAny(objectMap, "query", e.Query)
	populateAny(objectMap, "queryTimeout", e.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", e.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", e.SourceRetryWait)
	objectMap["type"] = "EloquaSource"
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaSource.
func (e *EloquaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &e.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &e.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &e.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &e.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &e.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &e.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &e.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionConfiguration.
func (e EncryptionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", e.Identity)
	populate(objectMap, "keyName", e.KeyName)
	populate(objectMap, "keyVersion", e.KeyVersion)
	populate(objectMap, "vaultBaseUrl", e.VaultBaseURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionConfiguration.
func (e *EncryptionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &e.Identity)
			delete(rawMsg, key)
		case "keyName":
			err = unpopulate(val, "KeyName", &e.KeyName)
			delete(rawMsg, key)
		case "keyVersion":
			err = unpopulate(val, "KeyVersion", &e.KeyVersion)
			delete(rawMsg, key)
		case "vaultBaseUrl":
			err = unpopulate(val, "VaultBaseURL", &e.VaultBaseURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityReference.
func (e EntityReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "referenceName", e.ReferenceName)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityReference.
func (e *EntityReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &e.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableSetup.
func (e EnvironmentVariableSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = "EnvironmentVariableSetup"
	populate(objectMap, "typeProperties", e.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableSetup.
func (e *EnvironmentVariableSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableSetupTypeProperties.
func (e EnvironmentVariableSetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "variableName", e.VariableName)
	populate(objectMap, "variableValue", e.VariableValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableSetupTypeProperties.
func (e *EnvironmentVariableSetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "variableName":
			err = unpopulate(val, "VariableName", &e.VariableName)
			delete(rawMsg, key)
		case "variableValue":
			err = unpopulate(val, "VariableValue", &e.VariableValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExcelDataset.
func (e ExcelDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", e.Annotations)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "folder", e.Folder)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "parameters", e.Parameters)
	populateAny(objectMap, "schema", e.Schema)
	populateAny(objectMap, "structure", e.Structure)
	objectMap["type"] = "Excel"
	populate(objectMap, "typeProperties", e.TypeProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExcelDataset.
func (e *ExcelDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &e.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &e.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &e.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &e.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &e.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &e.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExcelDatasetTypeProperties.
func (e ExcelDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", e.Compression)
	populateAny(objectMap, "firstRowAsHeader", e.FirstRowAsHeader)
	populate(objectMap, "location", e.Location)
	populateAny(objectMap, "nullValue", e.NullValue)
	populateAny(objectMap, "range", e.Range)
	populateAny(objectMap, "sheetIndex", e.SheetIndex)
	populateAny(objectMap, "sheetName", e.SheetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExcelDatasetTypeProperties.
func (e *ExcelDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &e.Compression)
			delete(rawMsg, key)
		case "firstRowAsHeader":
			err = unpopulate(val, "FirstRowAsHeader", &e.FirstRowAsHeader)
			delete(rawMsg, key)
		case "location":
			e.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, "NullValue", &e.NullValue)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, "Range", &e.Range)
			delete(rawMsg, key)
		case "sheetIndex":
			err = unpopulate(val, "SheetIndex", &e.SheetIndex)
			delete(rawMsg, key)
		case "sheetName":
			err = unpopulate(val, "SheetName", &e.SheetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExcelSource.
func (e ExcelSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", e.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", e.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", e.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", e.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", e.SourceRetryWait)
	populate(objectMap, "storeSettings", e.StoreSettings)
	objectMap["type"] = "ExcelSource"
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExcelSource.
func (e *ExcelSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &e.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &e.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &e.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &e.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &e.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			e.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteDataFlowActivity.
func (e ExecuteDataFlowActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "onInactiveMarkAs", e.OnInactiveMarkAs)
	populate(objectMap, "policy", e.Policy)
	populate(objectMap, "state", e.State)
	objectMap["type"] = "ExecuteDataFlow"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteDataFlowActivity.
func (e *ExecuteDataFlowActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &e.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &e.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &e.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteDataFlowActivityTypeProperties.
func (e ExecuteDataFlowActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compute", e.Compute)
	populateAny(objectMap, "continueOnError", e.ContinueOnError)
	populate(objectMap, "dataFlow", e.DataFlow)
	populate(objectMap, "integrationRuntime", e.IntegrationRuntime)
	populateAny(objectMap, "runConcurrently", e.RunConcurrently)
	populateAny(objectMap, "sourceStagingConcurrency", e.SourceStagingConcurrency)
	populate(objectMap, "staging", e.Staging)
	populateAny(objectMap, "traceLevel", e.TraceLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteDataFlowActivityTypeProperties.
func (e *ExecuteDataFlowActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
			err = unpopulate(val, "Compute", &e.Compute)
			delete(rawMsg, key)
		case "continueOnError":
			err = unpopulate(val, "ContinueOnError", &e.ContinueOnError)
			delete(rawMsg, key)
		case "dataFlow":
			err = unpopulate(val, "DataFlow", &e.DataFlow)
			delete(rawMsg, key)
		case "integrationRuntime":
			err = unpopulate(val, "IntegrationRuntime", &e.IntegrationRuntime)
			delete(rawMsg, key)
		case "runConcurrently":
			err = unpopulate(val, "RunConcurrently", &e.RunConcurrently)
			delete(rawMsg, key)
		case "sourceStagingConcurrency":
			err = unpopulate(val, "SourceStagingConcurrency", &e.SourceStagingConcurrency)
			delete(rawMsg, key)
		case "staging":
			err = unpopulate(val, "Staging", &e.Staging)
			delete(rawMsg, key)
		case "traceLevel":
			err = unpopulate(val, "TraceLevel", &e.TraceLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteDataFlowActivityTypePropertiesCompute.
func (e ExecuteDataFlowActivityTypePropertiesCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "computeType", e.ComputeType)
	populateAny(objectMap, "coreCount", e.CoreCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteDataFlowActivityTypePropertiesCompute.
func (e *ExecuteDataFlowActivityTypePropertiesCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			err = unpopulate(val, "ComputeType", &e.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, "CoreCount", &e.CoreCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivity.
func (e ExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "onInactiveMarkAs", e.OnInactiveMarkAs)
	populate(objectMap, "policy", e.Policy)
	populate(objectMap, "state", e.State)
	objectMap["type"] = "ExecutePipeline"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePipelineActivity.
func (e *ExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &e.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &e.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivityPolicy.
func (e ExecutePipelineActivityPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secureInput", e.SecureInput)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePipelineActivityPolicy.
func (e *ExecutePipelineActivityPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secureInput":
			err = unpopulate(val, "SecureInput", &e.SecureInput)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivityTypeProperties.
func (e ExecutePipelineActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", e.Parameters)
	populate(objectMap, "pipeline", e.Pipeline)
	populate(objectMap, "waitOnCompletion", e.WaitOnCompletion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePipelineActivityTypeProperties.
func (e *ExecutePipelineActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &e.Parameters)
			delete(rawMsg, key)
		case "pipeline":
			err = unpopulate(val, "Pipeline", &e.Pipeline)
			delete(rawMsg, key)
		case "waitOnCompletion":
			err = unpopulate(val, "WaitOnCompletion", &e.WaitOnCompletion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePowerQueryActivityTypeProperties.
func (e ExecutePowerQueryActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compute", e.Compute)
	populateAny(objectMap, "continueOnError", e.ContinueOnError)
	populate(objectMap, "dataFlow", e.DataFlow)
	populate(objectMap, "integrationRuntime", e.IntegrationRuntime)
	populate(objectMap, "queries", e.Queries)
	populateAny(objectMap, "runConcurrently", e.RunConcurrently)
	populate(objectMap, "sinks", e.Sinks)
	populateAny(objectMap, "sourceStagingConcurrency", e.SourceStagingConcurrency)
	populate(objectMap, "staging", e.Staging)
	populateAny(objectMap, "traceLevel", e.TraceLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePowerQueryActivityTypeProperties.
func (e *ExecutePowerQueryActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
			err = unpopulate(val, "Compute", &e.Compute)
			delete(rawMsg, key)
		case "continueOnError":
			err = unpopulate(val, "ContinueOnError", &e.ContinueOnError)
			delete(rawMsg, key)
		case "dataFlow":
			err = unpopulate(val, "DataFlow", &e.DataFlow)
			delete(rawMsg, key)
		case "integrationRuntime":
			err = unpopulate(val, "IntegrationRuntime", &e.IntegrationRuntime)
			delete(rawMsg, key)
		case "queries":
			err = unpopulate(val, "Queries", &e.Queries)
			delete(rawMsg, key)
		case "runConcurrently":
			err = unpopulate(val, "RunConcurrently", &e.RunConcurrently)
			delete(rawMsg, key)
		case "sinks":
			err = unpopulate(val, "Sinks", &e.Sinks)
			delete(rawMsg, key)
		case "sourceStagingConcurrency":
			err = unpopulate(val, "SourceStagingConcurrency", &e.SourceStagingConcurrency)
			delete(rawMsg, key)
		case "staging":
			err = unpopulate(val, "Staging", &e.Staging)
			delete(rawMsg, key)
		case "traceLevel":
			err = unpopulate(val, "TraceLevel", &e.TraceLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteSSISPackageActivity.
func (e ExecuteSSISPackageActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "onInactiveMarkAs", e.OnInactiveMarkAs)
	populate(objectMap, "policy", e.Policy)
	populate(objectMap, "state", e.State)
	objectMap["type"] = "ExecuteSSISPackage"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteSSISPackageActivity.
func (e *ExecuteSSISPackageActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &e.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &e.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &e.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteSSISPackageActivityTypeProperties.
func (e ExecuteSSISPackageActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectVia", e.ConnectVia)
	populateAny(objectMap, "environmentPath", e.EnvironmentPath)
	populate(objectMap, "executionCredential", e.ExecutionCredential)
	populate(objectMap, "logLocation", e.LogLocation)
	populateAny(objectMap, "loggingLevel", e.LoggingLevel)
	populate(objectMap, "packageConnectionManagers", e.PackageConnectionManagers)
	populate(objectMap, "packageLocation", e.PackageLocation)
	populate(objectMap, "packageParameters", e.PackageParameters)
	populate(objectMap, "projectConnectionManagers", e.ProjectConnectionManagers)
	populate(objectMap, "projectParameters", e.ProjectParameters)
	populate(objectMap, "propertyOverrides", e.PropertyOverrides)
	populateAny(objectMap, "runtime", e.Runtime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteSSISPackageActivityTypeProperties.
func (e *ExecuteSSISPackageActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &e.ConnectVia)
			delete(rawMsg, key)
		case "environmentPath":
			err = unpopulate(val, "EnvironmentPath", &e.EnvironmentPath)
			delete(rawMsg, key)
		case "executionCredential":
			err = unpopulate(val, "ExecutionCredential", &e.ExecutionCredential)
			delete(rawMsg, key)
		case "logLocation":
			err = unpopulate(val, "LogLocation", &e.LogLocation)
			delete(rawMsg, key)
		case "loggingLevel":
			err = unpopulate(val, "LoggingLevel", &e.LoggingLevel)
			delete(rawMsg, key)
		case "packageConnectionManagers":
			err = unpopulate(val, "PackageConnectionManagers", &e.PackageConnectionManagers)
			delete(rawMsg, key)
		case "packageLocation":
			err = unpopulate(val, "PackageLocation", &e.PackageLocation)
			delete(rawMsg, key)
		case "packageParameters":
			err = unpopulate(val, "PackageParameters", &e.PackageParameters)
			delete(rawMsg, key)
		case "projectConnectionManagers":
			err = unpopulate(val, "ProjectConnectionManagers", &e.ProjectConnectionManagers)
			delete(rawMsg, key)
		case "projectParameters":
			err = unpopulate(val, "ProjectParameters", &e.ProjectParameters)
			delete(rawMsg, key)
		case "propertyOverrides":
			err = unpopulate(val, "PropertyOverrides", &e.PropertyOverrides)
			delete(rawMsg, key)
		case "runtime":
			err = unpopulate(val, "Runtime", &e.Runtime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteWranglingDataflowActivity.
func (e ExecuteWranglingDataflowActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "onInactiveMarkAs", e.OnInactiveMarkAs)
	populate(objectMap, "policy", e.Policy)
	populate(objectMap, "state", e.State)
	objectMap["type"] = "ExecuteWranglingDataflow"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteWranglingDataflowActivity.
func (e *ExecuteWranglingDataflowActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &e.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &e.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecutionActivity.
func (e ExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "onInactiveMarkAs", e.OnInactiveMarkAs)
	populate(objectMap, "policy", e.Policy)
	populate(objectMap, "state", e.State)
	objectMap["type"] = "Execution"
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutionActivity.
func (e *ExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &e.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &e.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &e.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExportSettings.
func (e ExportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = e.Type
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportSettings.
func (e *ExportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExposureControlBatchRequest.
func (e ExposureControlBatchRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exposureControlRequests", e.ExposureControlRequests)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExposureControlBatchRequest.
func (e *ExposureControlBatchRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exposureControlRequests":
			err = unpopulate(val, "ExposureControlRequests", &e.ExposureControlRequests)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExposureControlBatchResponse.
func (e ExposureControlBatchResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exposureControlResponses", e.ExposureControlResponses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExposureControlBatchResponse.
func (e *ExposureControlBatchResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exposureControlResponses":
			err = unpopulate(val, "ExposureControlResponses", &e.ExposureControlResponses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExposureControlRequest.
func (e ExposureControlRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "featureName", e.FeatureName)
	populate(objectMap, "featureType", e.FeatureType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExposureControlRequest.
func (e *ExposureControlRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "featureName":
			err = unpopulate(val, "FeatureName", &e.FeatureName)
			delete(rawMsg, key)
		case "featureType":
			err = unpopulate(val, "FeatureType", &e.FeatureType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExposureControlResponse.
func (e ExposureControlResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "featureName", e.FeatureName)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExposureControlResponse.
func (e *ExposureControlResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "featureName":
			err = unpopulate(val, "FeatureName", &e.FeatureName)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Expression.
func (e Expression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", e.Type)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Expression.
func (e *Expression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Factory.
func (f Factory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", f.ETag)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "identity", f.Identity)
	populate(objectMap, "location", f.Location)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "tags", f.Tags)
	populate(objectMap, "type", f.Type)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Factory.
func (f *Factory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &f.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &f.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &f.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &f.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryGitHubConfiguration.
func (f FactoryGitHubConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountName", f.AccountName)
	populate(objectMap, "clientId", f.ClientID)
	populate(objectMap, "clientSecret", f.ClientSecret)
	populate(objectMap, "collaborationBranch", f.CollaborationBranch)
	populate(objectMap, "disablePublish", f.DisablePublish)
	populate(objectMap, "hostName", f.HostName)
	populate(objectMap, "lastCommitId", f.LastCommitID)
	populate(objectMap, "repositoryName", f.RepositoryName)
	populate(objectMap, "rootFolder", f.RootFolder)
	objectMap["type"] = "FactoryGitHubConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryGitHubConfiguration.
func (f *FactoryGitHubConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &f.AccountName)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &f.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			err = unpopulate(val, "ClientSecret", &f.ClientSecret)
			delete(rawMsg, key)
		case "collaborationBranch":
			err = unpopulate(val, "CollaborationBranch", &f.CollaborationBranch)
			delete(rawMsg, key)
		case "disablePublish":
			err = unpopulate(val, "DisablePublish", &f.DisablePublish)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &f.HostName)
			delete(rawMsg, key)
		case "lastCommitId":
			err = unpopulate(val, "LastCommitID", &f.LastCommitID)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &f.RepositoryName)
			delete(rawMsg, key)
		case "rootFolder":
			err = unpopulate(val, "RootFolder", &f.RootFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryIdentity.
func (f FactoryIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", f.PrincipalID)
	populate(objectMap, "tenantId", f.TenantID)
	populate(objectMap, "type", f.Type)
	populate(objectMap, "userAssignedIdentities", f.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryIdentity.
func (f *FactoryIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &f.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &f.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &f.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryListResponse.
func (f FactoryListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryListResponse.
func (f *FactoryListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryProperties.
func (f FactoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createTime", f.CreateTime)
	populate(objectMap, "encryption", f.Encryption)
	populate(objectMap, "globalParameters", f.GlobalParameters)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", f.PublicNetworkAccess)
	populate(objectMap, "purviewConfiguration", f.PurviewConfiguration)
	populate(objectMap, "repoConfiguration", f.RepoConfiguration)
	populate(objectMap, "version", f.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryProperties.
func (f *FactoryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateDateTimeRFC3339(val, "CreateTime", &f.CreateTime)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, "Encryption", &f.Encryption)
			delete(rawMsg, key)
		case "globalParameters":
			err = unpopulate(val, "GlobalParameters", &f.GlobalParameters)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &f.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &f.PublicNetworkAccess)
			delete(rawMsg, key)
		case "purviewConfiguration":
			err = unpopulate(val, "PurviewConfiguration", &f.PurviewConfiguration)
			delete(rawMsg, key)
		case "repoConfiguration":
			f.RepoConfiguration, err = unmarshalFactoryRepoConfigurationClassification(val)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &f.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryRepoConfiguration.
func (f FactoryRepoConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountName", f.AccountName)
	populate(objectMap, "collaborationBranch", f.CollaborationBranch)
	populate(objectMap, "disablePublish", f.DisablePublish)
	populate(objectMap, "lastCommitId", f.LastCommitID)
	populate(objectMap, "repositoryName", f.RepositoryName)
	populate(objectMap, "rootFolder", f.RootFolder)
	objectMap["type"] = f.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryRepoConfiguration.
func (f *FactoryRepoConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &f.AccountName)
			delete(rawMsg, key)
		case "collaborationBranch":
			err = unpopulate(val, "CollaborationBranch", &f.CollaborationBranch)
			delete(rawMsg, key)
		case "disablePublish":
			err = unpopulate(val, "DisablePublish", &f.DisablePublish)
			delete(rawMsg, key)
		case "lastCommitId":
			err = unpopulate(val, "LastCommitID", &f.LastCommitID)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &f.RepositoryName)
			delete(rawMsg, key)
		case "rootFolder":
			err = unpopulate(val, "RootFolder", &f.RootFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryRepoUpdate.
func (f FactoryRepoUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "factoryResourceId", f.FactoryResourceID)
	populate(objectMap, "repoConfiguration", f.RepoConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryRepoUpdate.
func (f *FactoryRepoUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "factoryResourceId":
			err = unpopulate(val, "FactoryResourceID", &f.FactoryResourceID)
			delete(rawMsg, key)
		case "repoConfiguration":
			f.RepoConfiguration, err = unmarshalFactoryRepoConfigurationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryUpdateParameters.
func (f FactoryUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", f.Identity)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "tags", f.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryUpdateParameters.
func (f *FactoryUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &f.Identity)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &f.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryUpdateProperties.
func (f FactoryUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "publicNetworkAccess", f.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryUpdateProperties.
func (f *FactoryUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &f.PublicNetworkAccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FactoryVSTSConfiguration.
func (f FactoryVSTSConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountName", f.AccountName)
	populate(objectMap, "collaborationBranch", f.CollaborationBranch)
	populate(objectMap, "disablePublish", f.DisablePublish)
	populate(objectMap, "lastCommitId", f.LastCommitID)
	populate(objectMap, "projectName", f.ProjectName)
	populate(objectMap, "repositoryName", f.RepositoryName)
	populate(objectMap, "rootFolder", f.RootFolder)
	populate(objectMap, "tenantId", f.TenantID)
	objectMap["type"] = "FactoryVSTSConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryVSTSConfiguration.
func (f *FactoryVSTSConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &f.AccountName)
			delete(rawMsg, key)
		case "collaborationBranch":
			err = unpopulate(val, "CollaborationBranch", &f.CollaborationBranch)
			delete(rawMsg, key)
		case "disablePublish":
			err = unpopulate(val, "DisablePublish", &f.DisablePublish)
			delete(rawMsg, key)
		case "lastCommitId":
			err = unpopulate(val, "LastCommitID", &f.LastCommitID)
			delete(rawMsg, key)
		case "projectName":
			err = unpopulate(val, "ProjectName", &f.ProjectName)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &f.RepositoryName)
			delete(rawMsg, key)
		case "rootFolder":
			err = unpopulate(val, "RootFolder", &f.RootFolder)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &f.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FailActivity.
func (f FailActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", f.DependsOn)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "onInactiveMarkAs", f.OnInactiveMarkAs)
	populate(objectMap, "state", f.State)
	objectMap["type"] = "Fail"
	populate(objectMap, "typeProperties", f.TypeProperties)
	populate(objectMap, "userProperties", f.UserProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FailActivity.
func (f *FailActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &f.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &f.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &f.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &f.UserProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FailActivityTypeProperties.
func (f FailActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "errorCode", f.ErrorCode)
	populateAny(objectMap, "message", f.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FailActivityTypeProperties.
func (f *FailActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &f.ErrorCode)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &f.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLinkedService.
func (f FileServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "connectVia", f.ConnectVia)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "parameters", f.Parameters)
	objectMap["type"] = "FileServer"
	populate(objectMap, "typeProperties", f.TypeProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedService.
func (f *FileServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &f.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &f.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &f.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLinkedServiceTypeProperties.
func (f FileServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", f.EncryptedCredential)
	populateAny(objectMap, "host", f.Host)
	populate(objectMap, "password", f.Password)
	populateAny(objectMap, "userId", f.UserID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedServiceTypeProperties.
func (f *FileServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &f.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &f.Host)
			delete(rawMsg, key)
		case "password":
			f.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userId":
			err = unpopulate(val, "UserID", &f.UserID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLocation.
func (f FileServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", f.FileName)
	populateAny(objectMap, "folderPath", f.FolderPath)
	objectMap["type"] = "FileServerLocation"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLocation.
func (f *FileServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &f.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &f.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileServerReadSettings.
func (f FileServerReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", f.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", f.EnablePartitionDiscovery)
	populateAny(objectMap, "fileFilter", f.FileFilter)
	populateAny(objectMap, "fileListPath", f.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", f.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", f.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", f.PartitionRootPath)
	populateAny(objectMap, "recursive", f.Recursive)
	objectMap["type"] = "FileServerReadSettings"
	populateAny(objectMap, "wildcardFileName", f.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", f.WildcardFolderPath)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerReadSettings.
func (f *FileServerReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &f.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &f.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileFilter":
			err = unpopulate(val, "FileFilter", &f.FileFilter)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &f.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &f.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &f.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &f.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &f.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &f.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &f.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileServerWriteSettings.
func (f FileServerWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", f.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	objectMap["type"] = "FileServerWriteSettings"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerWriteSettings.
func (f *FileServerWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &f.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileShareDataset.
func (f FileShareDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "folder", f.Folder)
	populate(objectMap, "linkedServiceName", f.LinkedServiceName)
	populate(objectMap, "parameters", f.Parameters)
	populateAny(objectMap, "schema", f.Schema)
	populateAny(objectMap, "structure", f.Structure)
	objectMap["type"] = "FileShare"
	populate(objectMap, "typeProperties", f.TypeProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileShareDataset.
func (f *FileShareDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &f.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &f.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &f.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &f.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &f.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &f.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileShareDatasetTypeProperties.
func (f FileShareDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", f.Compression)
	populateAny(objectMap, "fileFilter", f.FileFilter)
	populateAny(objectMap, "fileName", f.FileName)
	populateAny(objectMap, "folderPath", f.FolderPath)
	populate(objectMap, "format", f.Format)
	populateAny(objectMap, "modifiedDatetimeEnd", f.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", f.ModifiedDatetimeStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileShareDatasetTypeProperties.
func (f *FileShareDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &f.Compression)
			delete(rawMsg, key)
		case "fileFilter":
			err = unpopulate(val, "FileFilter", &f.FileFilter)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &f.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &f.FolderPath)
			delete(rawMsg, key)
		case "format":
			f.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &f.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &f.ModifiedDatetimeStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemSink.
func (f FileSystemSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", f.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", f.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", f.SinkRetryWait)
	objectMap["type"] = "FileSystemSink"
	populateAny(objectMap, "writeBatchSize", f.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", f.WriteBatchTimeout)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemSink.
func (f *FileSystemSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &f.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &f.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &f.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &f.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &f.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemSource.
func (f FileSystemSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", f.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populateAny(objectMap, "recursive", f.Recursive)
	populateAny(objectMap, "sourceRetryCount", f.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", f.SourceRetryWait)
	objectMap["type"] = "FileSystemSource"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemSource.
func (f *FileSystemSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &f.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &f.Recursive)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &f.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &f.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FilterActivity.
func (f FilterActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", f.DependsOn)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "onInactiveMarkAs", f.OnInactiveMarkAs)
	populate(objectMap, "state", f.State)
	objectMap["type"] = "Filter"
	populate(objectMap, "typeProperties", f.TypeProperties)
	populate(objectMap, "userProperties", f.UserProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FilterActivity.
func (f *FilterActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &f.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &f.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &f.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &f.UserProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FilterActivityTypeProperties.
func (f FilterActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "condition", f.Condition)
	populate(objectMap, "items", f.Items)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FilterActivityTypeProperties.
func (f *FilterActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "condition":
			err = unpopulate(val, "Condition", &f.Condition)
			delete(rawMsg, key)
		case "items":
			err = unpopulate(val, "Items", &f.Items)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Flowlet.
func (f Flowlet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "folder", f.Folder)
	objectMap["type"] = "Flowlet"
	populate(objectMap, "typeProperties", f.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Flowlet.
func (f *Flowlet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &f.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &f.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlowletTypeProperties.
func (f FlowletTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "script", f.Script)
	populate(objectMap, "scriptLines", f.ScriptLines)
	populate(objectMap, "sinks", f.Sinks)
	populate(objectMap, "sources", f.Sources)
	populate(objectMap, "transformations", f.Transformations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlowletTypeProperties.
func (f *FlowletTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "script":
			err = unpopulate(val, "Script", &f.Script)
			delete(rawMsg, key)
		case "scriptLines":
			err = unpopulate(val, "ScriptLines", &f.ScriptLines)
			delete(rawMsg, key)
		case "sinks":
			err = unpopulate(val, "Sinks", &f.Sinks)
			delete(rawMsg, key)
		case "sources":
			err = unpopulate(val, "Sources", &f.Sources)
			delete(rawMsg, key)
		case "transformations":
			err = unpopulate(val, "Transformations", &f.Transformations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ForEachActivity.
func (f ForEachActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", f.DependsOn)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "onInactiveMarkAs", f.OnInactiveMarkAs)
	populate(objectMap, "state", f.State)
	objectMap["type"] = "ForEach"
	populate(objectMap, "typeProperties", f.TypeProperties)
	populate(objectMap, "userProperties", f.UserProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivity.
func (f *ForEachActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &f.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &f.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &f.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &f.UserProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ForEachActivityTypeProperties.
func (f ForEachActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activities", f.Activities)
	populate(objectMap, "batchCount", f.BatchCount)
	populate(objectMap, "isSequential", f.IsSequential)
	populate(objectMap, "items", f.Items)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivityTypeProperties.
func (f *ForEachActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			f.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "batchCount":
			err = unpopulate(val, "BatchCount", &f.BatchCount)
			delete(rawMsg, key)
		case "isSequential":
			err = unpopulate(val, "IsSequential", &f.IsSequential)
			delete(rawMsg, key)
		case "items":
			err = unpopulate(val, "Items", &f.Items)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FormatReadSettings.
func (f FormatReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = f.Type
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FormatReadSettings.
func (f *FormatReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FormatWriteSettings.
func (f FormatWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = f.Type
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FormatWriteSettings.
func (f *FormatWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FtpReadSettings.
func (f FtpReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", f.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableChunking", f.DisableChunking)
	populateAny(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", f.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", f.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populateAny(objectMap, "partitionRootPath", f.PartitionRootPath)
	populateAny(objectMap, "recursive", f.Recursive)
	objectMap["type"] = "FtpReadSettings"
	populateAny(objectMap, "useBinaryTransfer", f.UseBinaryTransfer)
	populateAny(objectMap, "wildcardFileName", f.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", f.WildcardFolderPath)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpReadSettings.
func (f *FtpReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &f.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableChunking":
			err = unpopulate(val, "DisableChunking", &f.DisableChunking)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &f.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &f.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &f.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &f.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "useBinaryTransfer":
			err = unpopulate(val, "UseBinaryTransfer", &f.UseBinaryTransfer)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &f.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &f.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLinkedService.
func (f FtpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "connectVia", f.ConnectVia)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "parameters", f.Parameters)
	objectMap["type"] = "FtpServer"
	populate(objectMap, "typeProperties", f.TypeProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedService.
func (f *FtpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &f.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &f.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &f.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &f.TypeProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLinkedServiceTypeProperties.
func (f FtpServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", f.AuthenticationType)
	populateAny(objectMap, "enableSsl", f.EnableSSL)
	populateAny(objectMap, "enableServerCertificateValidation", f.EnableServerCertificateValidation)
	populate(objectMap, "encryptedCredential", f.EncryptedCredential)
	populateAny(objectMap, "host", f.Host)
	populate(objectMap, "password", f.Password)
	populateAny(objectMap, "port", f.Port)
	populateAny(objectMap, "userName", f.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedServiceTypeProperties.
func (f *FtpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &f.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &f.EnableSSL)
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			err = unpopulate(val, "EnableServerCertificateValidation", &f.EnableServerCertificateValidation)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &f.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &f.Host)
			delete(rawMsg, key)
		case "password":
			f.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &f.Port)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &f.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLocation.
func (f FtpServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", f.FileName)
	populateAny(objectMap, "folderPath", f.FolderPath)
	objectMap["type"] = "FtpServerLocation"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLocation.
func (f *FtpServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &f.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &f.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenericDatasetTypeProperties.
func (g GenericDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", g.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenericDatasetTypeProperties.
func (g *GenericDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &g.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetMetadataActivity.
func (g GetMetadataActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", g.DependsOn)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "onInactiveMarkAs", g.OnInactiveMarkAs)
	populate(objectMap, "policy", g.Policy)
	populate(objectMap, "state", g.State)
	objectMap["type"] = "GetMetadata"
	populate(objectMap, "typeProperties", g.TypeProperties)
	populate(objectMap, "userProperties", g.UserProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetMetadataActivity.
func (g *GetMetadataActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &g.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &g.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &g.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &g.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &g.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &g.UserProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetMetadataActivityTypeProperties.
func (g GetMetadataActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", g.Dataset)
	populate(objectMap, "fieldList", g.FieldList)
	populate(objectMap, "formatSettings", g.FormatSettings)
	populate(objectMap, "storeSettings", g.StoreSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetMetadataActivityTypeProperties.
func (g *GetMetadataActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &g.Dataset)
			delete(rawMsg, key)
		case "fieldList":
			err = unpopulate(val, "FieldList", &g.FieldList)
			delete(rawMsg, key)
		case "formatSettings":
			g.FormatSettings, err = unmarshalFormatReadSettingsClassification(val)
			delete(rawMsg, key)
		case "storeSettings":
			g.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetSsisObjectMetadataRequest.
func (g GetSsisObjectMetadataRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "metadataPath", g.MetadataPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetSsisObjectMetadataRequest.
func (g *GetSsisObjectMetadataRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadataPath":
			err = unpopulate(val, "MetadataPath", &g.MetadataPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitHubAccessTokenRequest.
func (g GitHubAccessTokenRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gitHubAccessCode", g.GitHubAccessCode)
	populate(objectMap, "gitHubAccessTokenBaseUrl", g.GitHubAccessTokenBaseURL)
	populate(objectMap, "gitHubClientId", g.GitHubClientID)
	populate(objectMap, "gitHubClientSecret", g.GitHubClientSecret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitHubAccessTokenRequest.
func (g *GitHubAccessTokenRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gitHubAccessCode":
			err = unpopulate(val, "GitHubAccessCode", &g.GitHubAccessCode)
			delete(rawMsg, key)
		case "gitHubAccessTokenBaseUrl":
			err = unpopulate(val, "GitHubAccessTokenBaseURL", &g.GitHubAccessTokenBaseURL)
			delete(rawMsg, key)
		case "gitHubClientId":
			err = unpopulate(val, "GitHubClientID", &g.GitHubClientID)
			delete(rawMsg, key)
		case "gitHubClientSecret":
			err = unpopulate(val, "GitHubClientSecret", &g.GitHubClientSecret)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitHubAccessTokenResponse.
func (g GitHubAccessTokenResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gitHubAccessToken", g.GitHubAccessToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitHubAccessTokenResponse.
func (g *GitHubAccessTokenResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gitHubAccessToken":
			err = unpopulate(val, "GitHubAccessToken", &g.GitHubAccessToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitHubClientSecret.
func (g GitHubClientSecret) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "byoaSecretAkvUrl", g.ByoaSecretAkvURL)
	populate(objectMap, "byoaSecretName", g.ByoaSecretName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitHubClientSecret.
func (g *GitHubClientSecret) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "byoaSecretAkvUrl":
			err = unpopulate(val, "ByoaSecretAkvURL", &g.ByoaSecretAkvURL)
			delete(rawMsg, key)
		case "byoaSecretName":
			err = unpopulate(val, "ByoaSecretName", &g.ByoaSecretName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GlobalParameterListResponse.
func (g GlobalParameterListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GlobalParameterListResponse.
func (g *GlobalParameterListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GlobalParameterResource.
func (g GlobalParameterResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", g.Etag)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GlobalParameterResource.
func (g *GlobalParameterResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &g.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GlobalParameterSpecification.
func (g GlobalParameterSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", g.Type)
	populateAny(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GlobalParameterSpecification.
func (g *GlobalParameterSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsLinkedService.
func (g GoogleAdWordsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleAdWords"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedService.
func (g *GoogleAdWordsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsLinkedServiceTypeProperties.
func (g GoogleAdWordsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", g.AuthenticationType)
	populateAny(objectMap, "clientCustomerID", g.ClientCustomerID)
	populateAny(objectMap, "clientId", g.ClientID)
	populate(objectMap, "clientSecret", g.ClientSecret)
	populateAny(objectMap, "connectionProperties", g.ConnectionProperties)
	populate(objectMap, "developerToken", g.DeveloperToken)
	populateAny(objectMap, "email", g.Email)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populateAny(objectMap, "googleAdsApiVersion", g.GoogleAdsAPIVersion)
	populateAny(objectMap, "keyFilePath", g.KeyFilePath)
	populateAny(objectMap, "loginCustomerID", g.LoginCustomerID)
	populate(objectMap, "privateKey", g.PrivateKey)
	populate(objectMap, "refreshToken", g.RefreshToken)
	populateAny(objectMap, "supportLegacyDataTypes", g.SupportLegacyDataTypes)
	populateAny(objectMap, "trustedCertPath", g.TrustedCertPath)
	populateAny(objectMap, "useSystemTrustStore", g.UseSystemTrustStore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedServiceTypeProperties.
func (g *GoogleAdWordsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &g.AuthenticationType)
			delete(rawMsg, key)
		case "clientCustomerID":
			err = unpopulate(val, "ClientCustomerID", &g.ClientCustomerID)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &g.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			g.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &g.ConnectionProperties)
			delete(rawMsg, key)
		case "developerToken":
			g.DeveloperToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "email":
			err = unpopulate(val, "Email", &g.Email)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &g.EncryptedCredential)
			delete(rawMsg, key)
		case "googleAdsApiVersion":
			err = unpopulate(val, "GoogleAdsAPIVersion", &g.GoogleAdsAPIVersion)
			delete(rawMsg, key)
		case "keyFilePath":
			err = unpopulate(val, "KeyFilePath", &g.KeyFilePath)
			delete(rawMsg, key)
		case "loginCustomerID":
			err = unpopulate(val, "LoginCustomerID", &g.LoginCustomerID)
			delete(rawMsg, key)
		case "privateKey":
			g.PrivateKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "refreshToken":
			g.RefreshToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "supportLegacyDataTypes":
			err = unpopulate(val, "SupportLegacyDataTypes", &g.SupportLegacyDataTypes)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &g.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &g.UseSystemTrustStore)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsObjectDataset.
func (g GoogleAdWordsObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "folder", g.Folder)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "parameters", g.Parameters)
	populateAny(objectMap, "schema", g.Schema)
	populateAny(objectMap, "structure", g.Structure)
	objectMap["type"] = "GoogleAdWordsObject"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsObjectDataset.
func (g *GoogleAdWordsObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &g.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &g.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &g.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &g.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsSource.
func (g GoogleAdWordsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", g.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populateAny(objectMap, "query", g.Query)
	populateAny(objectMap, "queryTimeout", g.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", g.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", g.SourceRetryWait)
	objectMap["type"] = "GoogleAdWordsSource"
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsSource.
func (g *GoogleAdWordsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &g.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &g.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &g.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &g.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &g.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryDatasetTypeProperties.
func (g GoogleBigQueryDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "dataset", g.Dataset)
	populateAny(objectMap, "table", g.Table)
	populateAny(objectMap, "tableName", g.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryDatasetTypeProperties.
func (g *GoogleBigQueryDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &g.Dataset)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &g.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &g.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryLinkedService.
func (g GoogleBigQueryLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleBigQuery"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedService.
func (g *GoogleBigQueryLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryLinkedServiceTypeProperties.
func (g GoogleBigQueryLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalProjects", g.AdditionalProjects)
	populate(objectMap, "authenticationType", g.AuthenticationType)
	populateAny(objectMap, "clientId", g.ClientID)
	populate(objectMap, "clientSecret", g.ClientSecret)
	populateAny(objectMap, "email", g.Email)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populateAny(objectMap, "keyFilePath", g.KeyFilePath)
	populateAny(objectMap, "project", g.Project)
	populate(objectMap, "refreshToken", g.RefreshToken)
	populateAny(objectMap, "requestGoogleDriveScope", g.RequestGoogleDriveScope)
	populateAny(objectMap, "trustedCertPath", g.TrustedCertPath)
	populateAny(objectMap, "useSystemTrustStore", g.UseSystemTrustStore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedServiceTypeProperties.
func (g *GoogleBigQueryLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProjects":
			err = unpopulate(val, "AdditionalProjects", &g.AdditionalProjects)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &g.AuthenticationType)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &g.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			g.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "email":
			err = unpopulate(val, "Email", &g.Email)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &g.EncryptedCredential)
			delete(rawMsg, key)
		case "keyFilePath":
			err = unpopulate(val, "KeyFilePath", &g.KeyFilePath)
			delete(rawMsg, key)
		case "project":
			err = unpopulate(val, "Project", &g.Project)
			delete(rawMsg, key)
		case "refreshToken":
			g.RefreshToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "requestGoogleDriveScope":
			err = unpopulate(val, "RequestGoogleDriveScope", &g.RequestGoogleDriveScope)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &g.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &g.UseSystemTrustStore)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryObjectDataset.
func (g GoogleBigQueryObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "folder", g.Folder)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "parameters", g.Parameters)
	populateAny(objectMap, "schema", g.Schema)
	populateAny(objectMap, "structure", g.Structure)
	objectMap["type"] = "GoogleBigQueryObject"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryObjectDataset.
func (g *GoogleBigQueryObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &g.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &g.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &g.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &g.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQuerySource.
func (g GoogleBigQuerySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", g.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populateAny(objectMap, "query", g.Query)
	populateAny(objectMap, "queryTimeout", g.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", g.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", g.SourceRetryWait)
	objectMap["type"] = "GoogleBigQuerySource"
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQuerySource.
func (g *GoogleBigQuerySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &g.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &g.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &g.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &g.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &g.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLinkedService.
func (g GoogleCloudStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleCloudStorage"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedService.
func (g *GoogleCloudStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLinkedServiceTypeProperties.
func (g GoogleCloudStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accessKeyId", g.AccessKeyID)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populate(objectMap, "secretAccessKey", g.SecretAccessKey)
	populateAny(objectMap, "serviceUrl", g.ServiceURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedServiceTypeProperties.
func (g *GoogleCloudStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, "AccessKeyID", &g.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &g.EncryptedCredential)
			delete(rawMsg, key)
		case "secretAccessKey":
			g.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, "ServiceURL", &g.ServiceURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLocation.
func (g GoogleCloudStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "bucketName", g.BucketName)
	populateAny(objectMap, "fileName", g.FileName)
	populateAny(objectMap, "folderPath", g.FolderPath)
	objectMap["type"] = "GoogleCloudStorageLocation"
	populateAny(objectMap, "version", g.Version)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLocation.
func (g *GoogleCloudStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, "BucketName", &g.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &g.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &g.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &g.Version)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageReadSettings.
func (g GoogleCloudStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", g.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", g.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", g.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", g.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", g.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", g.PartitionRootPath)
	populateAny(objectMap, "prefix", g.Prefix)
	populateAny(objectMap, "recursive", g.Recursive)
	objectMap["type"] = "GoogleCloudStorageReadSettings"
	populateAny(objectMap, "wildcardFileName", g.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", g.WildcardFolderPath)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageReadSettings.
func (g *GoogleCloudStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &g.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &g.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &g.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &g.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &g.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &g.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &g.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &g.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &g.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &g.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleSheetsLinkedService.
func (g GoogleSheetsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleSheets"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleSheetsLinkedService.
func (g *GoogleSheetsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleSheetsLinkedServiceTypeProperties.
func (g GoogleSheetsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiToken", g.APIToken)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleSheetsLinkedServiceTypeProperties.
func (g *GoogleSheetsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiToken":
			g.APIToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &g.EncryptedCredential)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumDatasetTypeProperties.
func (g GreenplumDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", g.Schema)
	populateAny(objectMap, "table", g.Table)
	populateAny(objectMap, "tableName", g.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumDatasetTypeProperties.
func (g *GreenplumDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &g.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &g.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &g.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumLinkedService.
func (g GreenplumLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "Greenplum"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumLinkedService.
func (g *GreenplumLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumLinkedServiceTypeProperties.
func (g GreenplumLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", g.ConnectionString)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populate(objectMap, "pwd", g.Pwd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumLinkedServiceTypeProperties.
func (g *GreenplumLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &g.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &g.EncryptedCredential)
			delete(rawMsg, key)
		case "pwd":
			err = unpopulate(val, "Pwd", &g.Pwd)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumSource.
func (g GreenplumSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", g.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populateAny(objectMap, "query", g.Query)
	populateAny(objectMap, "queryTimeout", g.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", g.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", g.SourceRetryWait)
	objectMap["type"] = "GreenplumSource"
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumSource.
func (g *GreenplumSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &g.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &g.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &g.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &g.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &g.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumTableDataset.
func (g GreenplumTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "folder", g.Folder)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "parameters", g.Parameters)
	populateAny(objectMap, "schema", g.Schema)
	populateAny(objectMap, "structure", g.Structure)
	objectMap["type"] = "GreenplumTable"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumTableDataset.
func (g *GreenplumTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &g.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &g.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &g.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &g.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &g.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &g.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HBaseLinkedService.
func (h HBaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HBase"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedService.
func (h *HBaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HBaseLinkedServiceTypeProperties.
func (h HBaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowHostNameCNMismatch", h.AllowHostNameCNMismatch)
	populateAny(objectMap, "allowSelfSignedServerCert", h.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populateAny(objectMap, "enableSsl", h.EnableSSL)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populateAny(objectMap, "httpPath", h.HTTPPath)
	populateAny(objectMap, "host", h.Host)
	populate(objectMap, "password", h.Password)
	populateAny(objectMap, "port", h.Port)
	populateAny(objectMap, "trustedCertPath", h.TrustedCertPath)
	populateAny(objectMap, "username", h.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedServiceTypeProperties.
func (h *HBaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, "AllowHostNameCNMismatch", &h.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &h.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &h.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &h.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, "HTTPPath", &h.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &h.Host)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &h.Port)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &h.TrustedCertPath)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &h.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HBaseObjectDataset.
func (h HBaseObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populateAny(objectMap, "schema", h.Schema)
	populateAny(objectMap, "structure", h.Structure)
	objectMap["type"] = "HBaseObject"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseObjectDataset.
func (h *HBaseObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HBaseSource.
func (h HBaseSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", h.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "query", h.Query)
	populateAny(objectMap, "queryTimeout", h.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HBaseSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseSource.
func (h *HBaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &h.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &h.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &h.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightHiveActivity.
func (h HDInsightHiveActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "onInactiveMarkAs", h.OnInactiveMarkAs)
	populate(objectMap, "policy", h.Policy)
	populate(objectMap, "state", h.State)
	objectMap["type"] = "HDInsightHive"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightHiveActivity.
func (h *HDInsightHiveActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &h.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &h.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &h.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightHiveActivityTypeProperties.
func (h HDInsightHiveActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "queryTimeout", h.QueryTimeout)
	populate(objectMap, "scriptLinkedService", h.ScriptLinkedService)
	populateAny(objectMap, "scriptPath", h.ScriptPath)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	populate(objectMap, "variables", h.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightHiveActivityTypeProperties.
func (h *HDInsightHiveActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &h.Arguments)
			delete(rawMsg, key)
		case "defines":
			err = unpopulate(val, "Defines", &h.Defines)
			delete(rawMsg, key)
		case "getDebugInfo":
			err = unpopulate(val, "GetDebugInfo", &h.GetDebugInfo)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &h.QueryTimeout)
			delete(rawMsg, key)
		case "scriptLinkedService":
			err = unpopulate(val, "ScriptLinkedService", &h.ScriptLinkedService)
			delete(rawMsg, key)
		case "scriptPath":
			err = unpopulate(val, "ScriptPath", &h.ScriptPath)
			delete(rawMsg, key)
		case "storageLinkedServices":
			err = unpopulate(val, "StorageLinkedServices", &h.StorageLinkedServices)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, "Variables", &h.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightLinkedService.
func (h HDInsightLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HDInsight"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightLinkedService.
func (h *HDInsightLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightLinkedServiceTypeProperties.
func (h HDInsightLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clusterUri", h.ClusterURI)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populateAny(objectMap, "fileSystem", h.FileSystem)
	populate(objectMap, "hcatalogLinkedServiceName", h.HcatalogLinkedServiceName)
	populateAny(objectMap, "isEspEnabled", h.IsEspEnabled)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "password", h.Password)
	populateAny(objectMap, "userName", h.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightLinkedServiceTypeProperties.
func (h *HDInsightLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterUri":
			err = unpopulate(val, "ClusterURI", &h.ClusterURI)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "fileSystem":
			err = unpopulate(val, "FileSystem", &h.FileSystem)
			delete(rawMsg, key)
		case "hcatalogLinkedServiceName":
			err = unpopulate(val, "HcatalogLinkedServiceName", &h.HcatalogLinkedServiceName)
			delete(rawMsg, key)
		case "isEspEnabled":
			err = unpopulate(val, "IsEspEnabled", &h.IsEspEnabled)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &h.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightMapReduceActivity.
func (h HDInsightMapReduceActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "onInactiveMarkAs", h.OnInactiveMarkAs)
	populate(objectMap, "policy", h.Policy)
	populate(objectMap, "state", h.State)
	objectMap["type"] = "HDInsightMapReduce"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightMapReduceActivity.
func (h *HDInsightMapReduceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &h.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &h.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &h.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightMapReduceActivityTypeProperties.
func (h HDInsightMapReduceActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", h.Arguments)
	populateAny(objectMap, "className", h.ClassName)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populateAny(objectMap, "jarFilePath", h.JarFilePath)
	populate(objectMap, "jarLibs", h.JarLibs)
	populate(objectMap, "jarLinkedService", h.JarLinkedService)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightMapReduceActivityTypeProperties.
func (h *HDInsightMapReduceActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &h.Arguments)
			delete(rawMsg, key)
		case "className":
			err = unpopulate(val, "ClassName", &h.ClassName)
			delete(rawMsg, key)
		case "defines":
			err = unpopulate(val, "Defines", &h.Defines)
			delete(rawMsg, key)
		case "getDebugInfo":
			err = unpopulate(val, "GetDebugInfo", &h.GetDebugInfo)
			delete(rawMsg, key)
		case "jarFilePath":
			err = unpopulate(val, "JarFilePath", &h.JarFilePath)
			delete(rawMsg, key)
		case "jarLibs":
			err = unpopulate(val, "JarLibs", &h.JarLibs)
			delete(rawMsg, key)
		case "jarLinkedService":
			err = unpopulate(val, "JarLinkedService", &h.JarLinkedService)
			delete(rawMsg, key)
		case "storageLinkedServices":
			err = unpopulate(val, "StorageLinkedServices", &h.StorageLinkedServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightOnDemandLinkedService.
func (h HDInsightOnDemandLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HDInsightOnDemand"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightOnDemandLinkedService.
func (h *HDInsightOnDemandLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightOnDemandLinkedServiceTypeProperties.
func (h HDInsightOnDemandLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalLinkedServiceNames", h.AdditionalLinkedServiceNames)
	populateAny(objectMap, "clusterNamePrefix", h.ClusterNamePrefix)
	populate(objectMap, "clusterPassword", h.ClusterPassword)
	populateAny(objectMap, "clusterResourceGroup", h.ClusterResourceGroup)
	populate(objectMap, "clusterSshPassword", h.ClusterSSHPassword)
	populateAny(objectMap, "clusterSshUserName", h.ClusterSSHUserName)
	populateAny(objectMap, "clusterSize", h.ClusterSize)
	populateAny(objectMap, "clusterType", h.ClusterType)
	populateAny(objectMap, "clusterUserName", h.ClusterUserName)
	populateAny(objectMap, "coreConfiguration", h.CoreConfiguration)
	populate(objectMap, "credential", h.Credential)
	populateAny(objectMap, "dataNodeSize", h.DataNodeSize)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populateAny(objectMap, "hBaseConfiguration", h.HBaseConfiguration)
	populate(objectMap, "hcatalogLinkedServiceName", h.HcatalogLinkedServiceName)
	populateAny(objectMap, "hdfsConfiguration", h.HdfsConfiguration)
	populateAny(objectMap, "headNodeSize", h.HeadNodeSize)
	populateAny(objectMap, "hiveConfiguration", h.HiveConfiguration)
	populateAny(objectMap, "hostSubscriptionId", h.HostSubscriptionID)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populateAny(objectMap, "mapReduceConfiguration", h.MapReduceConfiguration)
	populateAny(objectMap, "oozieConfiguration", h.OozieConfiguration)
	populate(objectMap, "scriptActions", h.ScriptActions)
	populateAny(objectMap, "servicePrincipalId", h.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", h.ServicePrincipalKey)
	populateAny(objectMap, "sparkVersion", h.SparkVersion)
	populateAny(objectMap, "stormConfiguration", h.StormConfiguration)
	populateAny(objectMap, "subnetName", h.SubnetName)
	populateAny(objectMap, "tenant", h.Tenant)
	populateAny(objectMap, "timeToLive", h.TimeToLive)
	populateAny(objectMap, "version", h.Version)
	populateAny(objectMap, "virtualNetworkId", h.VirtualNetworkID)
	populateAny(objectMap, "yarnConfiguration", h.YarnConfiguration)
	populateAny(objectMap, "zookeeperNodeSize", h.ZookeeperNodeSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightOnDemandLinkedServiceTypeProperties.
func (h *HDInsightOnDemandLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalLinkedServiceNames":
			err = unpopulate(val, "AdditionalLinkedServiceNames", &h.AdditionalLinkedServiceNames)
			delete(rawMsg, key)
		case "clusterNamePrefix":
			err = unpopulate(val, "ClusterNamePrefix", &h.ClusterNamePrefix)
			delete(rawMsg, key)
		case "clusterPassword":
			h.ClusterPassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clusterResourceGroup":
			err = unpopulate(val, "ClusterResourceGroup", &h.ClusterResourceGroup)
			delete(rawMsg, key)
		case "clusterSshPassword":
			h.ClusterSSHPassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clusterSshUserName":
			err = unpopulate(val, "ClusterSSHUserName", &h.ClusterSSHUserName)
			delete(rawMsg, key)
		case "clusterSize":
			err = unpopulate(val, "ClusterSize", &h.ClusterSize)
			delete(rawMsg, key)
		case "clusterType":
			err = unpopulate(val, "ClusterType", &h.ClusterType)
			delete(rawMsg, key)
		case "clusterUserName":
			err = unpopulate(val, "ClusterUserName", &h.ClusterUserName)
			delete(rawMsg, key)
		case "coreConfiguration":
			err = unpopulate(val, "CoreConfiguration", &h.CoreConfiguration)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &h.Credential)
			delete(rawMsg, key)
		case "dataNodeSize":
			err = unpopulate(val, "DataNodeSize", &h.DataNodeSize)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "hBaseConfiguration":
			err = unpopulate(val, "HBaseConfiguration", &h.HBaseConfiguration)
			delete(rawMsg, key)
		case "hcatalogLinkedServiceName":
			err = unpopulate(val, "HcatalogLinkedServiceName", &h.HcatalogLinkedServiceName)
			delete(rawMsg, key)
		case "hdfsConfiguration":
			err = unpopulate(val, "HdfsConfiguration", &h.HdfsConfiguration)
			delete(rawMsg, key)
		case "headNodeSize":
			err = unpopulate(val, "HeadNodeSize", &h.HeadNodeSize)
			delete(rawMsg, key)
		case "hiveConfiguration":
			err = unpopulate(val, "HiveConfiguration", &h.HiveConfiguration)
			delete(rawMsg, key)
		case "hostSubscriptionId":
			err = unpopulate(val, "HostSubscriptionID", &h.HostSubscriptionID)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "mapReduceConfiguration":
			err = unpopulate(val, "MapReduceConfiguration", &h.MapReduceConfiguration)
			delete(rawMsg, key)
		case "oozieConfiguration":
			err = unpopulate(val, "OozieConfiguration", &h.OozieConfiguration)
			delete(rawMsg, key)
		case "scriptActions":
			err = unpopulate(val, "ScriptActions", &h.ScriptActions)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &h.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			h.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sparkVersion":
			err = unpopulate(val, "SparkVersion", &h.SparkVersion)
			delete(rawMsg, key)
		case "stormConfiguration":
			err = unpopulate(val, "StormConfiguration", &h.StormConfiguration)
			delete(rawMsg, key)
		case "subnetName":
			err = unpopulate(val, "SubnetName", &h.SubnetName)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &h.Tenant)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, "TimeToLive", &h.TimeToLive)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &h.Version)
			delete(rawMsg, key)
		case "virtualNetworkId":
			err = unpopulate(val, "VirtualNetworkID", &h.VirtualNetworkID)
			delete(rawMsg, key)
		case "yarnConfiguration":
			err = unpopulate(val, "YarnConfiguration", &h.YarnConfiguration)
			delete(rawMsg, key)
		case "zookeeperNodeSize":
			err = unpopulate(val, "ZookeeperNodeSize", &h.ZookeeperNodeSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightPigActivity.
func (h HDInsightPigActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "onInactiveMarkAs", h.OnInactiveMarkAs)
	populate(objectMap, "policy", h.Policy)
	populate(objectMap, "state", h.State)
	objectMap["type"] = "HDInsightPig"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightPigActivity.
func (h *HDInsightPigActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &h.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &h.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &h.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightPigActivityTypeProperties.
func (h HDInsightPigActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "arguments", h.Arguments)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "scriptLinkedService", h.ScriptLinkedService)
	populateAny(objectMap, "scriptPath", h.ScriptPath)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightPigActivityTypeProperties.
func (h *HDInsightPigActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &h.Arguments)
			delete(rawMsg, key)
		case "defines":
			err = unpopulate(val, "Defines", &h.Defines)
			delete(rawMsg, key)
		case "getDebugInfo":
			err = unpopulate(val, "GetDebugInfo", &h.GetDebugInfo)
			delete(rawMsg, key)
		case "scriptLinkedService":
			err = unpopulate(val, "ScriptLinkedService", &h.ScriptLinkedService)
			delete(rawMsg, key)
		case "scriptPath":
			err = unpopulate(val, "ScriptPath", &h.ScriptPath)
			delete(rawMsg, key)
		case "storageLinkedServices":
			err = unpopulate(val, "StorageLinkedServices", &h.StorageLinkedServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightSparkActivity.
func (h HDInsightSparkActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "onInactiveMarkAs", h.OnInactiveMarkAs)
	populate(objectMap, "policy", h.Policy)
	populate(objectMap, "state", h.State)
	objectMap["type"] = "HDInsightSpark"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightSparkActivity.
func (h *HDInsightSparkActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &h.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &h.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &h.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightSparkActivityTypeProperties.
func (h HDInsightSparkActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "className", h.ClassName)
	populateAny(objectMap, "entryFilePath", h.EntryFilePath)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populateAny(objectMap, "proxyUser", h.ProxyUser)
	populateAny(objectMap, "rootPath", h.RootPath)
	populate(objectMap, "sparkConfig", h.SparkConfig)
	populate(objectMap, "sparkJobLinkedService", h.SparkJobLinkedService)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightSparkActivityTypeProperties.
func (h *HDInsightSparkActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &h.Arguments)
			delete(rawMsg, key)
		case "className":
			err = unpopulate(val, "ClassName", &h.ClassName)
			delete(rawMsg, key)
		case "entryFilePath":
			err = unpopulate(val, "EntryFilePath", &h.EntryFilePath)
			delete(rawMsg, key)
		case "getDebugInfo":
			err = unpopulate(val, "GetDebugInfo", &h.GetDebugInfo)
			delete(rawMsg, key)
		case "proxyUser":
			err = unpopulate(val, "ProxyUser", &h.ProxyUser)
			delete(rawMsg, key)
		case "rootPath":
			err = unpopulate(val, "RootPath", &h.RootPath)
			delete(rawMsg, key)
		case "sparkConfig":
			err = unpopulate(val, "SparkConfig", &h.SparkConfig)
			delete(rawMsg, key)
		case "sparkJobLinkedService":
			err = unpopulate(val, "SparkJobLinkedService", &h.SparkJobLinkedService)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightStreamingActivity.
func (h HDInsightStreamingActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "onInactiveMarkAs", h.OnInactiveMarkAs)
	populate(objectMap, "policy", h.Policy)
	populate(objectMap, "state", h.State)
	objectMap["type"] = "HDInsightStreaming"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightStreamingActivity.
func (h *HDInsightStreamingActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &h.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &h.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &h.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightStreamingActivityTypeProperties.
func (h HDInsightStreamingActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", h.Arguments)
	populateAny(objectMap, "combiner", h.Combiner)
	populate(objectMap, "commandEnvironment", h.CommandEnvironment)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "fileLinkedService", h.FileLinkedService)
	populate(objectMap, "filePaths", h.FilePaths)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populateAny(objectMap, "input", h.Input)
	populateAny(objectMap, "mapper", h.Mapper)
	populateAny(objectMap, "output", h.Output)
	populateAny(objectMap, "reducer", h.Reducer)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightStreamingActivityTypeProperties.
func (h *HDInsightStreamingActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &h.Arguments)
			delete(rawMsg, key)
		case "combiner":
			err = unpopulate(val, "Combiner", &h.Combiner)
			delete(rawMsg, key)
		case "commandEnvironment":
			err = unpopulate(val, "CommandEnvironment", &h.CommandEnvironment)
			delete(rawMsg, key)
		case "defines":
			err = unpopulate(val, "Defines", &h.Defines)
			delete(rawMsg, key)
		case "fileLinkedService":
			err = unpopulate(val, "FileLinkedService", &h.FileLinkedService)
			delete(rawMsg, key)
		case "filePaths":
			err = unpopulate(val, "FilePaths", &h.FilePaths)
			delete(rawMsg, key)
		case "getDebugInfo":
			err = unpopulate(val, "GetDebugInfo", &h.GetDebugInfo)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, "Input", &h.Input)
			delete(rawMsg, key)
		case "mapper":
			err = unpopulate(val, "Mapper", &h.Mapper)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, "Output", &h.Output)
			delete(rawMsg, key)
		case "reducer":
			err = unpopulate(val, "Reducer", &h.Reducer)
			delete(rawMsg, key)
		case "storageLinkedServices":
			err = unpopulate(val, "StorageLinkedServices", &h.StorageLinkedServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPDataset.
func (h HTTPDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populateAny(objectMap, "schema", h.Schema)
	populateAny(objectMap, "structure", h.Structure)
	objectMap["type"] = "HttpFile"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPDataset.
func (h *HTTPDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPDatasetTypeProperties.
func (h HTTPDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalHeaders", h.AdditionalHeaders)
	populate(objectMap, "compression", h.Compression)
	populate(objectMap, "format", h.Format)
	populateAny(objectMap, "relativeUrl", h.RelativeURL)
	populateAny(objectMap, "requestBody", h.RequestBody)
	populateAny(objectMap, "requestMethod", h.RequestMethod)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPDatasetTypeProperties.
func (h *HTTPDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			err = unpopulate(val, "AdditionalHeaders", &h.AdditionalHeaders)
			delete(rawMsg, key)
		case "compression":
			err = unpopulate(val, "Compression", &h.Compression)
			delete(rawMsg, key)
		case "format":
			h.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "relativeUrl":
			err = unpopulate(val, "RelativeURL", &h.RelativeURL)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, "RequestBody", &h.RequestBody)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, "RequestMethod", &h.RequestMethod)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPLinkedService.
func (h HTTPLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HttpServer"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedService.
func (h *HTTPLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPLinkedServiceTypeProperties.
func (h HTTPLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authHeaders", h.AuthHeaders)
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populateAny(objectMap, "certThumbprint", h.CertThumbprint)
	populateAny(objectMap, "embeddedCertData", h.EmbeddedCertData)
	populateAny(objectMap, "enableServerCertificateValidation", h.EnableServerCertificateValidation)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "password", h.Password)
	populateAny(objectMap, "url", h.URL)
	populateAny(objectMap, "userName", h.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedServiceTypeProperties.
func (h *HTTPLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authHeaders":
			err = unpopulate(val, "AuthHeaders", &h.AuthHeaders)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &h.AuthenticationType)
			delete(rawMsg, key)
		case "certThumbprint":
			err = unpopulate(val, "CertThumbprint", &h.CertThumbprint)
			delete(rawMsg, key)
		case "embeddedCertData":
			err = unpopulate(val, "EmbeddedCertData", &h.EmbeddedCertData)
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			err = unpopulate(val, "EnableServerCertificateValidation", &h.EnableServerCertificateValidation)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &h.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &h.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPReadSettings.
func (h HTTPReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", h.AdditionalColumns)
	populateAny(objectMap, "additionalHeaders", h.AdditionalHeaders)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "requestBody", h.RequestBody)
	populateAny(objectMap, "requestMethod", h.RequestMethod)
	populateAny(objectMap, "requestTimeout", h.RequestTimeout)
	objectMap["type"] = "HttpReadSettings"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPReadSettings.
func (h *HTTPReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &h.AdditionalColumns)
			delete(rawMsg, key)
		case "additionalHeaders":
			err = unpopulate(val, "AdditionalHeaders", &h.AdditionalHeaders)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, "RequestBody", &h.RequestBody)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, "RequestMethod", &h.RequestMethod)
			delete(rawMsg, key)
		case "requestTimeout":
			err = unpopulate(val, "RequestTimeout", &h.RequestTimeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPServerLocation.
func (h HTTPServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", h.FileName)
	populateAny(objectMap, "folderPath", h.FolderPath)
	populateAny(objectMap, "relativeUrl", h.RelativeURL)
	objectMap["type"] = "HttpServerLocation"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPServerLocation.
func (h *HTTPServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &h.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &h.FolderPath)
			delete(rawMsg, key)
		case "relativeUrl":
			err = unpopulate(val, "RelativeURL", &h.RelativeURL)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPSource.
func (h HTTPSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", h.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HttpSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPSource.
func (h *HTTPSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &h.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLinkedService.
func (h HdfsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "Hdfs"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedService.
func (h *HdfsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLinkedServiceTypeProperties.
func (h HdfsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", h.AuthenticationType)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "password", h.Password)
	populateAny(objectMap, "url", h.URL)
	populateAny(objectMap, "userName", h.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedServiceTypeProperties.
func (h *HdfsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &h.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &h.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &h.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLocation.
func (h HdfsLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", h.FileName)
	populateAny(objectMap, "folderPath", h.FolderPath)
	objectMap["type"] = "HdfsLocation"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLocation.
func (h *HdfsLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &h.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &h.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HdfsReadSettings.
func (h HdfsReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", h.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "distcpSettings", h.DistcpSettings)
	populateAny(objectMap, "enablePartitionDiscovery", h.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", h.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", h.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", h.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", h.PartitionRootPath)
	populateAny(objectMap, "recursive", h.Recursive)
	objectMap["type"] = "HdfsReadSettings"
	populateAny(objectMap, "wildcardFileName", h.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", h.WildcardFolderPath)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsReadSettings.
func (h *HdfsReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &h.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "distcpSettings":
			err = unpopulate(val, "DistcpSettings", &h.DistcpSettings)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &h.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &h.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &h.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &h.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &h.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &h.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &h.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &h.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HdfsSource.
func (h HdfsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "distcpSettings", h.DistcpSettings)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "recursive", h.Recursive)
	populateAny(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HdfsSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsSource.
func (h *HdfsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "distcpSettings":
			err = unpopulate(val, "DistcpSettings", &h.DistcpSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &h.Recursive)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HiveDatasetTypeProperties.
func (h HiveDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", h.Schema)
	populateAny(objectMap, "table", h.Table)
	populateAny(objectMap, "tableName", h.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveDatasetTypeProperties.
func (h *HiveDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &h.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &h.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &h.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HiveLinkedService.
func (h HiveLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "Hive"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedService.
func (h *HiveLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HiveLinkedServiceTypeProperties.
func (h HiveLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowHostNameCNMismatch", h.AllowHostNameCNMismatch)
	populateAny(objectMap, "allowSelfSignedServerCert", h.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populateAny(objectMap, "enableSsl", h.EnableSSL)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populateAny(objectMap, "httpPath", h.HTTPPath)
	populateAny(objectMap, "host", h.Host)
	populate(objectMap, "password", h.Password)
	populateAny(objectMap, "port", h.Port)
	populate(objectMap, "serverType", h.ServerType)
	populateAny(objectMap, "serviceDiscoveryMode", h.ServiceDiscoveryMode)
	populate(objectMap, "thriftTransportProtocol", h.ThriftTransportProtocol)
	populateAny(objectMap, "trustedCertPath", h.TrustedCertPath)
	populateAny(objectMap, "useNativeQuery", h.UseNativeQuery)
	populateAny(objectMap, "useSystemTrustStore", h.UseSystemTrustStore)
	populateAny(objectMap, "username", h.Username)
	populateAny(objectMap, "zooKeeperNameSpace", h.ZooKeeperNameSpace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedServiceTypeProperties.
func (h *HiveLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, "AllowHostNameCNMismatch", &h.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &h.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &h.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &h.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, "HTTPPath", &h.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &h.Host)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &h.Port)
			delete(rawMsg, key)
		case "serverType":
			err = unpopulate(val, "ServerType", &h.ServerType)
			delete(rawMsg, key)
		case "serviceDiscoveryMode":
			err = unpopulate(val, "ServiceDiscoveryMode", &h.ServiceDiscoveryMode)
			delete(rawMsg, key)
		case "thriftTransportProtocol":
			err = unpopulate(val, "ThriftTransportProtocol", &h.ThriftTransportProtocol)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &h.TrustedCertPath)
			delete(rawMsg, key)
		case "useNativeQuery":
			err = unpopulate(val, "UseNativeQuery", &h.UseNativeQuery)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &h.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &h.Username)
			delete(rawMsg, key)
		case "zooKeeperNameSpace":
			err = unpopulate(val, "ZooKeeperNameSpace", &h.ZooKeeperNameSpace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HiveObjectDataset.
func (h HiveObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populateAny(objectMap, "schema", h.Schema)
	populateAny(objectMap, "structure", h.Structure)
	objectMap["type"] = "HiveObject"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveObjectDataset.
func (h *HiveObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HiveSource.
func (h HiveSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", h.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "query", h.Query)
	populateAny(objectMap, "queryTimeout", h.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HiveSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveSource.
func (h *HiveSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &h.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &h.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &h.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HubspotLinkedService.
func (h HubspotLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "Hubspot"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedService.
func (h *HubspotLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HubspotLinkedServiceTypeProperties.
func (h HubspotLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", h.AccessToken)
	populateAny(objectMap, "clientId", h.ClientID)
	populate(objectMap, "clientSecret", h.ClientSecret)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "refreshToken", h.RefreshToken)
	populateAny(objectMap, "useEncryptedEndpoints", h.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", h.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", h.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedServiceTypeProperties.
func (h *HubspotLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			h.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &h.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			h.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &h.EncryptedCredential)
			delete(rawMsg, key)
		case "refreshToken":
			h.RefreshToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &h.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &h.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &h.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HubspotObjectDataset.
func (h HubspotObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populateAny(objectMap, "schema", h.Schema)
	populateAny(objectMap, "structure", h.Structure)
	objectMap["type"] = "HubspotObject"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotObjectDataset.
func (h *HubspotObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HubspotSource.
func (h HubspotSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", h.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populateAny(objectMap, "query", h.Query)
	populateAny(objectMap, "queryTimeout", h.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HubspotSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotSource.
func (h *HubspotSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &h.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &h.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &h.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IfConditionActivity.
func (i IfConditionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", i.DependsOn)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "onInactiveMarkAs", i.OnInactiveMarkAs)
	populate(objectMap, "state", i.State)
	objectMap["type"] = "IfCondition"
	populate(objectMap, "typeProperties", i.TypeProperties)
	populate(objectMap, "userProperties", i.UserProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivity.
func (i *IfConditionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &i.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &i.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &i.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &i.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &i.UserProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IfConditionActivityTypeProperties.
func (i IfConditionActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expression", i.Expression)
	populate(objectMap, "ifFalseActivities", i.IfFalseActivities)
	populate(objectMap, "ifTrueActivities", i.IfTrueActivities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivityTypeProperties.
func (i *IfConditionActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expression":
			err = unpopulate(val, "Expression", &i.Expression)
			delete(rawMsg, key)
		case "ifFalseActivities":
			i.IfFalseActivities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "ifTrueActivities":
			i.IfTrueActivities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaDatasetTypeProperties.
func (i ImpalaDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", i.Schema)
	populateAny(objectMap, "table", i.Table)
	populateAny(objectMap, "tableName", i.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaDatasetTypeProperties.
func (i *ImpalaDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &i.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &i.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &i.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaLinkedService.
func (i ImpalaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "connectVia", i.ConnectVia)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "parameters", i.Parameters)
	objectMap["type"] = "Impala"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedService.
func (i *ImpalaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &i.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &i.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaLinkedServiceTypeProperties.
func (i ImpalaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowHostNameCNMismatch", i.AllowHostNameCNMismatch)
	populateAny(objectMap, "allowSelfSignedServerCert", i.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", i.AuthenticationType)
	populateAny(objectMap, "enableSsl", i.EnableSSL)
	populate(objectMap, "encryptedCredential", i.EncryptedCredential)
	populateAny(objectMap, "host", i.Host)
	populate(objectMap, "password", i.Password)
	populateAny(objectMap, "port", i.Port)
	populateAny(objectMap, "trustedCertPath", i.TrustedCertPath)
	populateAny(objectMap, "useSystemTrustStore", i.UseSystemTrustStore)
	populateAny(objectMap, "username", i.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedServiceTypeProperties.
func (i *ImpalaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, "AllowHostNameCNMismatch", &i.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &i.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &i.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &i.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &i.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &i.Host)
			delete(rawMsg, key)
		case "password":
			i.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &i.Port)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &i.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &i.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &i.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaObjectDataset.
func (i ImpalaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "folder", i.Folder)
	populate(objectMap, "linkedServiceName", i.LinkedServiceName)
	populate(objectMap, "parameters", i.Parameters)
	populateAny(objectMap, "schema", i.Schema)
	populateAny(objectMap, "structure", i.Structure)
	objectMap["type"] = "ImpalaObject"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaObjectDataset.
func (i *ImpalaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &i.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &i.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &i.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &i.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &i.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaSource.
func (i ImpalaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", i.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", i.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", i.MaxConcurrentConnections)
	populateAny(objectMap, "query", i.Query)
	populateAny(objectMap, "queryTimeout", i.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", i.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", i.SourceRetryWait)
	objectMap["type"] = "ImpalaSource"
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaSource.
func (i *ImpalaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &i.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &i.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &i.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &i.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &i.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &i.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &i.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImportSettings.
func (i ImportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImportSettings.
func (i *ImportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformixLinkedService.
func (i InformixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "connectVia", i.ConnectVia)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "parameters", i.Parameters)
	objectMap["type"] = "Informix"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedService.
func (i *InformixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &i.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &i.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformixLinkedServiceTypeProperties.
func (i InformixLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", i.AuthenticationType)
	populateAny(objectMap, "connectionString", i.ConnectionString)
	populate(objectMap, "credential", i.Credential)
	populate(objectMap, "encryptedCredential", i.EncryptedCredential)
	populate(objectMap, "password", i.Password)
	populateAny(objectMap, "userName", i.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedServiceTypeProperties.
func (i *InformixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &i.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &i.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			i.Credential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &i.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			i.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &i.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformixSink.
func (i InformixSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", i.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", i.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", i.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", i.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", i.SinkRetryWait)
	objectMap["type"] = "InformixSink"
	populateAny(objectMap, "writeBatchSize", i.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", i.WriteBatchTimeout)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixSink.
func (i *InformixSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &i.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &i.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &i.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &i.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &i.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &i.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &i.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformixSource.
func (i InformixSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", i.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", i.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", i.MaxConcurrentConnections)
	populateAny(objectMap, "query", i.Query)
	populateAny(objectMap, "queryTimeout", i.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", i.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", i.SourceRetryWait)
	objectMap["type"] = "InformixSource"
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixSource.
func (i *InformixSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &i.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &i.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &i.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &i.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &i.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &i.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &i.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformixTableDataset.
func (i InformixTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "folder", i.Folder)
	populate(objectMap, "linkedServiceName", i.LinkedServiceName)
	populate(objectMap, "parameters", i.Parameters)
	populateAny(objectMap, "schema", i.Schema)
	populateAny(objectMap, "structure", i.Structure)
	objectMap["type"] = "InformixTable"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixTableDataset.
func (i *InformixTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &i.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &i.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &i.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &i.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &i.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformixTableDatasetTypeProperties.
func (i InformixTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", i.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixTableDatasetTypeProperties.
func (i *InformixTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &i.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntime.
func (i IntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", i.Description)
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntime.
func (i *IntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeAuthKeys.
func (i IntegrationRuntimeAuthKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authKey1", i.AuthKey1)
	populate(objectMap, "authKey2", i.AuthKey2)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeAuthKeys.
func (i *IntegrationRuntimeAuthKeys) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authKey1":
			err = unpopulate(val, "AuthKey1", &i.AuthKey1)
			delete(rawMsg, key)
		case "authKey2":
			err = unpopulate(val, "AuthKey2", &i.AuthKey2)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeComputeProperties.
func (i IntegrationRuntimeComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "copyComputeScaleProperties", i.CopyComputeScaleProperties)
	populate(objectMap, "dataFlowProperties", i.DataFlowProperties)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "maxParallelExecutionsPerNode", i.MaxParallelExecutionsPerNode)
	populate(objectMap, "nodeSize", i.NodeSize)
	populate(objectMap, "numberOfNodes", i.NumberOfNodes)
	populate(objectMap, "pipelineExternalComputeScaleProperties", i.PipelineExternalComputeScaleProperties)
	populate(objectMap, "vNetProperties", i.VNetProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeComputeProperties.
func (i *IntegrationRuntimeComputeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyComputeScaleProperties":
			err = unpopulate(val, "CopyComputeScaleProperties", &i.CopyComputeScaleProperties)
			delete(rawMsg, key)
		case "dataFlowProperties":
			err = unpopulate(val, "DataFlowProperties", &i.DataFlowProperties)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "maxParallelExecutionsPerNode":
			err = unpopulate(val, "MaxParallelExecutionsPerNode", &i.MaxParallelExecutionsPerNode)
			delete(rawMsg, key)
		case "nodeSize":
			err = unpopulate(val, "NodeSize", &i.NodeSize)
			delete(rawMsg, key)
		case "numberOfNodes":
			err = unpopulate(val, "NumberOfNodes", &i.NumberOfNodes)
			delete(rawMsg, key)
		case "pipelineExternalComputeScaleProperties":
			err = unpopulate(val, "PipelineExternalComputeScaleProperties", &i.PipelineExternalComputeScaleProperties)
			delete(rawMsg, key)
		case "vNetProperties":
			err = unpopulate(val, "VNetProperties", &i.VNetProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeConnectionInfo.
func (i IntegrationRuntimeConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hostServiceUri", i.HostServiceURI)
	populate(objectMap, "identityCertThumbprint", i.IdentityCertThumbprint)
	populate(objectMap, "isIdentityCertExprired", i.IsIdentityCertExprired)
	populate(objectMap, "publicKey", i.PublicKey)
	populate(objectMap, "serviceToken", i.ServiceToken)
	populate(objectMap, "version", i.Version)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeConnectionInfo.
func (i *IntegrationRuntimeConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostServiceUri":
			err = unpopulate(val, "HostServiceURI", &i.HostServiceURI)
			delete(rawMsg, key)
		case "identityCertThumbprint":
			err = unpopulate(val, "IdentityCertThumbprint", &i.IdentityCertThumbprint)
			delete(rawMsg, key)
		case "isIdentityCertExprired":
			err = unpopulate(val, "IsIdentityCertExprired", &i.IsIdentityCertExprired)
			delete(rawMsg, key)
		case "publicKey":
			err = unpopulate(val, "PublicKey", &i.PublicKey)
			delete(rawMsg, key)
		case "serviceToken":
			err = unpopulate(val, "ServiceToken", &i.ServiceToken)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &i.Version)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeCustomSetupScriptProperties.
func (i IntegrationRuntimeCustomSetupScriptProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobContainerUri", i.BlobContainerURI)
	populate(objectMap, "sasToken", i.SasToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeCustomSetupScriptProperties.
func (i *IntegrationRuntimeCustomSetupScriptProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobContainerUri":
			err = unpopulate(val, "BlobContainerURI", &i.BlobContainerURI)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, "SasToken", &i.SasToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeCustomerVirtualNetwork.
func (i IntegrationRuntimeCustomerVirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "subnetId", i.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeCustomerVirtualNetwork.
func (i *IntegrationRuntimeCustomerVirtualNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "subnetId":
			err = unpopulate(val, "SubnetID", &i.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i IntegrationRuntimeDataFlowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cleanup", i.Cleanup)
	populate(objectMap, "computeType", i.ComputeType)
	populate(objectMap, "coreCount", i.CoreCount)
	populate(objectMap, "customProperties", i.CustomProperties)
	populate(objectMap, "timeToLive", i.TimeToLive)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i *IntegrationRuntimeDataFlowProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cleanup":
			err = unpopulate(val, "Cleanup", &i.Cleanup)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &i.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, "CoreCount", &i.CoreCount)
			delete(rawMsg, key)
		case "customProperties":
			err = unpopulate(val, "CustomProperties", &i.CustomProperties)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, "TimeToLive", &i.TimeToLive)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDataFlowPropertiesCustomPropertiesItem.
func (i IntegrationRuntimeDataFlowPropertiesCustomPropertiesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDataFlowPropertiesCustomPropertiesItem.
func (i *IntegrationRuntimeDataFlowPropertiesCustomPropertiesItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDataProxyProperties.
func (i IntegrationRuntimeDataProxyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectVia", i.ConnectVia)
	populate(objectMap, "path", i.Path)
	populate(objectMap, "stagingLinkedService", i.StagingLinkedService)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDataProxyProperties.
func (i *IntegrationRuntimeDataProxyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &i.ConnectVia)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &i.Path)
			delete(rawMsg, key)
		case "stagingLinkedService":
			err = unpopulate(val, "StagingLinkedService", &i.StagingLinkedService)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDebugResource.
func (i IntegrationRuntimeDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDebugResource.
func (i *IntegrationRuntimeDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeListResponse.
func (i IntegrationRuntimeListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeListResponse.
func (i *IntegrationRuntimeListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeMonitoringData.
func (i IntegrationRuntimeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "nodes", i.Nodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeMonitoringData.
func (i *IntegrationRuntimeMonitoringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, "Nodes", &i.Nodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeNodeIPAddress.
func (i IntegrationRuntimeNodeIPAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddress", i.IPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeNodeIPAddress.
func (i *IntegrationRuntimeNodeIPAddress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &i.IPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeNodeMonitoringData.
func (i IntegrationRuntimeNodeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableMemoryInMB", i.AvailableMemoryInMB)
	populate(objectMap, "cpuUtilization", i.CPUUtilization)
	populate(objectMap, "concurrentJobsLimit", i.ConcurrentJobsLimit)
	populate(objectMap, "concurrentJobsRunning", i.ConcurrentJobsRunning)
	populate(objectMap, "maxConcurrentJobs", i.MaxConcurrentJobs)
	populate(objectMap, "nodeName", i.NodeName)
	populate(objectMap, "receivedBytes", i.ReceivedBytes)
	populate(objectMap, "sentBytes", i.SentBytes)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeNodeMonitoringData.
func (i *IntegrationRuntimeNodeMonitoringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableMemoryInMB":
			err = unpopulate(val, "AvailableMemoryInMB", &i.AvailableMemoryInMB)
			delete(rawMsg, key)
		case "cpuUtilization":
			err = unpopulate(val, "CPUUtilization", &i.CPUUtilization)
			delete(rawMsg, key)
		case "concurrentJobsLimit":
			err = unpopulate(val, "ConcurrentJobsLimit", &i.ConcurrentJobsLimit)
			delete(rawMsg, key)
		case "concurrentJobsRunning":
			err = unpopulate(val, "ConcurrentJobsRunning", &i.ConcurrentJobsRunning)
			delete(rawMsg, key)
		case "maxConcurrentJobs":
			err = unpopulate(val, "MaxConcurrentJobs", &i.MaxConcurrentJobs)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, "NodeName", &i.NodeName)
			delete(rawMsg, key)
		case "receivedBytes":
			err = unpopulate(val, "ReceivedBytes", &i.ReceivedBytes)
			delete(rawMsg, key)
		case "sentBytes":
			err = unpopulate(val, "SentBytes", &i.SentBytes)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint.
func (i IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", i.Category)
	populate(objectMap, "endpoints", i.Endpoints)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint.
func (i *IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &i.Category)
			delete(rawMsg, key)
		case "endpoints":
			err = unpopulate(val, "Endpoints", &i.Endpoints)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpoint.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domainName", i.DomainName)
	populate(objectMap, "endpointDetails", i.EndpointDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpoint.
func (i *IntegrationRuntimeOutboundNetworkDependenciesEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainName":
			err = unpopulate(val, "DomainName", &i.DomainName)
			delete(rawMsg, key)
		case "endpointDetails":
			err = unpopulate(val, "EndpointDetails", &i.EndpointDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "port", i.Port)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails.
func (i *IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "port":
			err = unpopulate(val, "Port", &i.Port)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse.
func (i *IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeReference.
func (i IntegrationRuntimeReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", i.Parameters)
	populate(objectMap, "referenceName", i.ReferenceName)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeReference.
func (i *IntegrationRuntimeReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &i.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeRegenerateKeyParameters.
func (i IntegrationRuntimeRegenerateKeyParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keyName", i.KeyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeRegenerateKeyParameters.
func (i *IntegrationRuntimeRegenerateKeyParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyName":
			err = unpopulate(val, "KeyName", &i.KeyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeResource.
func (i IntegrationRuntimeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", i.Etag)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeResource.
func (i *IntegrationRuntimeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &i.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i IntegrationRuntimeSsisCatalogInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "catalogAdminPassword", i.CatalogAdminPassword)
	populate(objectMap, "catalogAdminUserName", i.CatalogAdminUserName)
	populate(objectMap, "catalogPricingTier", i.CatalogPricingTier)
	populate(objectMap, "catalogServerEndpoint", i.CatalogServerEndpoint)
	populate(objectMap, "dualStandbyPairName", i.DualStandbyPairName)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i *IntegrationRuntimeSsisCatalogInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogAdminPassword":
			err = unpopulate(val, "CatalogAdminPassword", &i.CatalogAdminPassword)
			delete(rawMsg, key)
		case "catalogAdminUserName":
			err = unpopulate(val, "CatalogAdminUserName", &i.CatalogAdminUserName)
			delete(rawMsg, key)
		case "catalogPricingTier":
			err = unpopulate(val, "CatalogPricingTier", &i.CatalogPricingTier)
			delete(rawMsg, key)
		case "catalogServerEndpoint":
			err = unpopulate(val, "CatalogServerEndpoint", &i.CatalogServerEndpoint)
			delete(rawMsg, key)
		case "dualStandbyPairName":
			err = unpopulate(val, "DualStandbyPairName", &i.DualStandbyPairName)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisProperties.
func (i IntegrationRuntimeSsisProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "catalogInfo", i.CatalogInfo)
	populate(objectMap, "credential", i.Credential)
	populate(objectMap, "customSetupScriptProperties", i.CustomSetupScriptProperties)
	populate(objectMap, "dataProxyProperties", i.DataProxyProperties)
	populate(objectMap, "edition", i.Edition)
	populate(objectMap, "expressCustomSetupProperties", i.ExpressCustomSetupProperties)
	populate(objectMap, "licenseType", i.LicenseType)
	populate(objectMap, "packageStores", i.PackageStores)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisProperties.
func (i *IntegrationRuntimeSsisProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogInfo":
			err = unpopulate(val, "CatalogInfo", &i.CatalogInfo)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &i.Credential)
			delete(rawMsg, key)
		case "customSetupScriptProperties":
			err = unpopulate(val, "CustomSetupScriptProperties", &i.CustomSetupScriptProperties)
			delete(rawMsg, key)
		case "dataProxyProperties":
			err = unpopulate(val, "DataProxyProperties", &i.DataProxyProperties)
			delete(rawMsg, key)
		case "edition":
			err = unpopulate(val, "Edition", &i.Edition)
			delete(rawMsg, key)
		case "expressCustomSetupProperties":
			i.ExpressCustomSetupProperties, err = unmarshalCustomSetupBaseClassificationArray(val)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, "LicenseType", &i.LicenseType)
			delete(rawMsg, key)
		case "packageStores":
			err = unpopulate(val, "PackageStores", &i.PackageStores)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeStatus.
func (i IntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataFactoryName", i.DataFactoryName)
	populate(objectMap, "state", i.State)
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeStatus.
func (i *IntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, "DataFactoryName", &i.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &i.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeStatusResponse.
func (i IntegrationRuntimeStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeStatusResponse.
func (i *IntegrationRuntimeStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeStatusClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeVNetProperties.
func (i IntegrationRuntimeVNetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "publicIPs", i.PublicIPs)
	populate(objectMap, "subnet", i.Subnet)
	populate(objectMap, "subnetId", i.SubnetID)
	populate(objectMap, "vNetId", i.VNetID)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeVNetProperties.
func (i *IntegrationRuntimeVNetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "publicIPs":
			err = unpopulate(val, "PublicIPs", &i.PublicIPs)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, "Subnet", &i.Subnet)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &i.SubnetID)
			delete(rawMsg, key)
		case "vNetId":
			err = unpopulate(val, "VNetID", &i.VNetID)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONDataset.
func (j JSONDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", j.Annotations)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "folder", j.Folder)
	populate(objectMap, "linkedServiceName", j.LinkedServiceName)
	populate(objectMap, "parameters", j.Parameters)
	populateAny(objectMap, "schema", j.Schema)
	populateAny(objectMap, "structure", j.Structure)
	objectMap["type"] = "Json"
	populate(objectMap, "typeProperties", j.TypeProperties)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDataset.
func (j *JSONDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &j.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &j.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &j.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &j.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &j.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &j.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &j.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &j.TypeProperties)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONDatasetTypeProperties.
func (j JSONDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", j.Compression)
	populateAny(objectMap, "encodingName", j.EncodingName)
	populate(objectMap, "location", j.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDatasetTypeProperties.
func (j *JSONDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &j.Compression)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, "EncodingName", &j.EncodingName)
			delete(rawMsg, key)
		case "location":
			j.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONFormat.
func (j JSONFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deserializer", j.Deserializer)
	populateAny(objectMap, "encodingName", j.EncodingName)
	populateAny(objectMap, "filePattern", j.FilePattern)
	populateAny(objectMap, "jsonNodeReference", j.JSONNodeReference)
	populateAny(objectMap, "jsonPathDefinition", j.JSONPathDefinition)
	populateAny(objectMap, "nestingSeparator", j.NestingSeparator)
	populateAny(objectMap, "serializer", j.Serializer)
	objectMap["type"] = "JsonFormat"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONFormat.
func (j *JSONFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, "Deserializer", &j.Deserializer)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, "EncodingName", &j.EncodingName)
			delete(rawMsg, key)
		case "filePattern":
			err = unpopulate(val, "FilePattern", &j.FilePattern)
			delete(rawMsg, key)
		case "jsonNodeReference":
			err = unpopulate(val, "JSONNodeReference", &j.JSONNodeReference)
			delete(rawMsg, key)
		case "jsonPathDefinition":
			err = unpopulate(val, "JSONPathDefinition", &j.JSONPathDefinition)
			delete(rawMsg, key)
		case "nestingSeparator":
			err = unpopulate(val, "NestingSeparator", &j.NestingSeparator)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, "Serializer", &j.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONReadSettings.
func (j JSONReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compressionProperties", j.CompressionProperties)
	objectMap["type"] = "JsonReadSettings"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONReadSettings.
func (j *JSONReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			j.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONSink.
func (j JSONSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", j.DisableMetricsCollection)
	populate(objectMap, "formatSettings", j.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", j.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", j.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", j.SinkRetryWait)
	populate(objectMap, "storeSettings", j.StoreSettings)
	objectMap["type"] = "JsonSink"
	populateAny(objectMap, "writeBatchSize", j.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", j.WriteBatchTimeout)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSink.
func (j *JSONSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &j.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &j.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &j.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &j.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &j.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			j.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &j.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &j.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONSource.
func (j JSONSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", j.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", j.DisableMetricsCollection)
	populate(objectMap, "formatSettings", j.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", j.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", j.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", j.SourceRetryWait)
	populate(objectMap, "storeSettings", j.StoreSettings)
	objectMap["type"] = "JsonSource"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSource.
func (j *JSONSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &j.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &j.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &j.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &j.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &j.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &j.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			j.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONWriteSettings.
func (j JSONWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "filePattern", j.FilePattern)
	objectMap["type"] = "JsonWriteSettings"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONWriteSettings.
func (j *JSONWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filePattern":
			err = unpopulate(val, "FilePattern", &j.FilePattern)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JiraLinkedService.
func (j JiraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", j.Annotations)
	populate(objectMap, "connectVia", j.ConnectVia)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "parameters", j.Parameters)
	objectMap["type"] = "Jira"
	populate(objectMap, "typeProperties", j.TypeProperties)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedService.
func (j *JiraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &j.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &j.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &j.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &j.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &j.TypeProperties)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JiraLinkedServiceTypeProperties.
func (j JiraLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", j.EncryptedCredential)
	populateAny(objectMap, "host", j.Host)
	populate(objectMap, "password", j.Password)
	populateAny(objectMap, "port", j.Port)
	populateAny(objectMap, "useEncryptedEndpoints", j.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", j.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", j.UsePeerVerification)
	populateAny(objectMap, "username", j.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedServiceTypeProperties.
func (j *JiraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &j.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &j.Host)
			delete(rawMsg, key)
		case "password":
			j.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &j.Port)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &j.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &j.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &j.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &j.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JiraObjectDataset.
func (j JiraObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", j.Annotations)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "folder", j.Folder)
	populate(objectMap, "linkedServiceName", j.LinkedServiceName)
	populate(objectMap, "parameters", j.Parameters)
	populateAny(objectMap, "schema", j.Schema)
	populateAny(objectMap, "structure", j.Structure)
	objectMap["type"] = "JiraObject"
	populate(objectMap, "typeProperties", j.TypeProperties)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraObjectDataset.
func (j *JiraObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &j.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &j.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &j.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &j.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &j.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &j.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &j.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &j.TypeProperties)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JiraSource.
func (j JiraSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", j.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", j.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", j.MaxConcurrentConnections)
	populateAny(objectMap, "query", j.Query)
	populateAny(objectMap, "queryTimeout", j.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", j.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", j.SourceRetryWait)
	objectMap["type"] = "JiraSource"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraSource.
func (j *JiraSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &j.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &j.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &j.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &j.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &j.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &j.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &j.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseLinkedService.
func (l LakeHouseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", l.Annotations)
	populate(objectMap, "connectVia", l.ConnectVia)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "parameters", l.Parameters)
	objectMap["type"] = "LakeHouse"
	populate(objectMap, "typeProperties", l.TypeProperties)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseLinkedService.
func (l *LakeHouseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &l.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &l.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &l.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &l.TypeProperties)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseLinkedServiceTypeProperties.
func (l LakeHouseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "artifactId", l.ArtifactID)
	populate(objectMap, "encryptedCredential", l.EncryptedCredential)
	populate(objectMap, "servicePrincipalCredential", l.ServicePrincipalCredential)
	populateAny(objectMap, "servicePrincipalCredentialType", l.ServicePrincipalCredentialType)
	populateAny(objectMap, "servicePrincipalId", l.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", l.ServicePrincipalKey)
	populateAny(objectMap, "tenant", l.Tenant)
	populateAny(objectMap, "workspaceId", l.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseLinkedServiceTypeProperties.
func (l *LakeHouseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "artifactId":
			err = unpopulate(val, "ArtifactID", &l.ArtifactID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &l.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			l.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, "ServicePrincipalCredentialType", &l.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &l.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			l.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &l.Tenant)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &l.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseLocation.
func (l LakeHouseLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", l.FileName)
	populateAny(objectMap, "folderPath", l.FolderPath)
	objectMap["type"] = "LakeHouseLocation"
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseLocation.
func (l *LakeHouseLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &l.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &l.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseReadSettings.
func (l LakeHouseReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", l.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", l.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", l.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", l.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", l.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", l.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", l.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", l.PartitionRootPath)
	populateAny(objectMap, "recursive", l.Recursive)
	objectMap["type"] = "LakeHouseReadSettings"
	populateAny(objectMap, "wildcardFileName", l.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", l.WildcardFolderPath)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseReadSettings.
func (l *LakeHouseReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &l.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &l.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &l.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &l.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &l.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &l.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &l.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &l.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &l.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &l.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &l.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseTableDataset.
func (l LakeHouseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", l.Annotations)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "folder", l.Folder)
	populate(objectMap, "linkedServiceName", l.LinkedServiceName)
	populate(objectMap, "parameters", l.Parameters)
	populateAny(objectMap, "schema", l.Schema)
	populateAny(objectMap, "structure", l.Structure)
	objectMap["type"] = "LakeHouseTable"
	populate(objectMap, "typeProperties", l.TypeProperties)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseTableDataset.
func (l *LakeHouseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &l.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &l.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &l.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &l.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &l.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &l.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &l.TypeProperties)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseTableDatasetTypeProperties.
func (l LakeHouseTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "table", l.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseTableDatasetTypeProperties.
func (l *LakeHouseTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "table":
			err = unpopulate(val, "Table", &l.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseTableSink.
func (l LakeHouseTableSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", l.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", l.MaxConcurrentConnections)
	populateAny(objectMap, "partitionNameList", l.PartitionNameList)
	populateAny(objectMap, "partitionOption", l.PartitionOption)
	populateAny(objectMap, "sinkRetryCount", l.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", l.SinkRetryWait)
	populateAny(objectMap, "tableActionOption", l.TableActionOption)
	objectMap["type"] = "LakeHouseTableSink"
	populateAny(objectMap, "writeBatchSize", l.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", l.WriteBatchTimeout)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseTableSink.
func (l *LakeHouseTableSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &l.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &l.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionNameList":
			err = unpopulate(val, "PartitionNameList", &l.PartitionNameList)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &l.PartitionOption)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &l.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &l.SinkRetryWait)
			delete(rawMsg, key)
		case "tableActionOption":
			err = unpopulate(val, "TableActionOption", &l.TableActionOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &l.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &l.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseTableSource.
func (l LakeHouseTableSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", l.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", l.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", l.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", l.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", l.SourceRetryWait)
	populateAny(objectMap, "timestampAsOf", l.TimestampAsOf)
	objectMap["type"] = "LakeHouseTableSource"
	populateAny(objectMap, "versionAsOf", l.VersionAsOf)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseTableSource.
func (l *LakeHouseTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &l.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &l.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &l.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &l.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &l.SourceRetryWait)
			delete(rawMsg, key)
		case "timestampAsOf":
			err = unpopulate(val, "TimestampAsOf", &l.TimestampAsOf)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "versionAsOf":
			err = unpopulate(val, "VersionAsOf", &l.VersionAsOf)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LakeHouseWriteSettings.
func (l LakeHouseWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", l.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", l.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", l.MaxConcurrentConnections)
	objectMap["type"] = "LakeHouseWriteSettings"
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LakeHouseWriteSettings.
func (l *LakeHouseWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &l.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &l.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &l.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LicensedComponentSetupTypeProperties.
func (l LicensedComponentSetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "componentName", l.ComponentName)
	populate(objectMap, "licenseKey", l.LicenseKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LicensedComponentSetupTypeProperties.
func (l *LicensedComponentSetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "componentName":
			err = unpopulate(val, "ComponentName", &l.ComponentName)
			delete(rawMsg, key)
		case "licenseKey":
			l.LicenseKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntime.
func (l LinkedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createTime", l.CreateTime)
	populate(objectMap, "dataFactoryLocation", l.DataFactoryLocation)
	populate(objectMap, "dataFactoryName", l.DataFactoryName)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "subscriptionId", l.SubscriptionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntime.
func (l *LinkedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateDateTimeRFC3339(val, "CreateTime", &l.CreateTime)
			delete(rawMsg, key)
		case "dataFactoryLocation":
			err = unpopulate(val, "DataFactoryLocation", &l.DataFactoryLocation)
			delete(rawMsg, key)
		case "dataFactoryName":
			err = unpopulate(val, "DataFactoryName", &l.DataFactoryName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &l.SubscriptionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l LinkedIntegrationRuntimeKeyAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authorizationType"] = "Key"
	populate(objectMap, "key", l.Key)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l *LinkedIntegrationRuntimeKeyAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			err = unpopulate(val, "AuthorizationType", &l.AuthorizationType)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, "Key", &l.Key)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l LinkedIntegrationRuntimeRbacAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authorizationType"] = "RBAC"
	populate(objectMap, "credential", l.Credential)
	populate(objectMap, "resourceId", l.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l *LinkedIntegrationRuntimeRbacAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			err = unpopulate(val, "AuthorizationType", &l.AuthorizationType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &l.Credential)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &l.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeRequest.
func (l LinkedIntegrationRuntimeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "factoryName", l.LinkedFactoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeRequest.
func (l *LinkedIntegrationRuntimeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "factoryName":
			err = unpopulate(val, "LinkedFactoryName", &l.LinkedFactoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeType.
func (l LinkedIntegrationRuntimeType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authorizationType"] = l.AuthorizationType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeType.
func (l *LinkedIntegrationRuntimeType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			err = unpopulate(val, "AuthorizationType", &l.AuthorizationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedService.
func (l LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", l.Annotations)
	populate(objectMap, "connectVia", l.ConnectVia)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "parameters", l.Parameters)
	objectMap["type"] = l.Type
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedService.
func (l *LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &l.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &l.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &l.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceDebugResource.
func (l LinkedServiceDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceDebugResource.
func (l *LinkedServiceDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "properties":
			l.Properties, err = unmarshalLinkedServiceClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceListResponse.
func (l LinkedServiceListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceListResponse.
func (l *LinkedServiceListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &l.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceReference.
func (l LinkedServiceReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", l.Parameters)
	populate(objectMap, "referenceName", l.ReferenceName)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceReference.
func (l *LinkedServiceReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &l.Parameters)
			delete(rawMsg, key)
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &l.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceResource.
func (l LinkedServiceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceResource.
func (l *LinkedServiceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &l.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &l.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "properties":
			l.Properties, err = unmarshalLinkedServiceClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogLocationSettings.
func (l LogLocationSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "linkedServiceName", l.LinkedServiceName)
	populateAny(objectMap, "path", l.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogLocationSettings.
func (l *LogLocationSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &l.LinkedServiceName)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &l.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogSettings.
func (l LogSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "copyActivityLogSettings", l.CopyActivityLogSettings)
	populateAny(objectMap, "enableCopyActivityLog", l.EnableCopyActivityLog)
	populate(objectMap, "logLocationSettings", l.LogLocationSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogSettings.
func (l *LogSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyActivityLogSettings":
			err = unpopulate(val, "CopyActivityLogSettings", &l.CopyActivityLogSettings)
			delete(rawMsg, key)
		case "enableCopyActivityLog":
			err = unpopulate(val, "EnableCopyActivityLog", &l.EnableCopyActivityLog)
			delete(rawMsg, key)
		case "logLocationSettings":
			err = unpopulate(val, "LogLocationSettings", &l.LogLocationSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogStorageSettings.
func (l LogStorageSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "enableReliableLogging", l.EnableReliableLogging)
	populate(objectMap, "linkedServiceName", l.LinkedServiceName)
	populateAny(objectMap, "logLevel", l.LogLevel)
	populateAny(objectMap, "path", l.Path)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogStorageSettings.
func (l *LogStorageSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableReliableLogging":
			err = unpopulate(val, "EnableReliableLogging", &l.EnableReliableLogging)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &l.LinkedServiceName)
			delete(rawMsg, key)
		case "logLevel":
			err = unpopulate(val, "LogLevel", &l.LogLevel)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &l.Path)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LookupActivity.
func (l LookupActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", l.DependsOn)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "linkedServiceName", l.LinkedServiceName)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "onInactiveMarkAs", l.OnInactiveMarkAs)
	populate(objectMap, "policy", l.Policy)
	populate(objectMap, "state", l.State)
	objectMap["type"] = "Lookup"
	populate(objectMap, "typeProperties", l.TypeProperties)
	populate(objectMap, "userProperties", l.UserProperties)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivity.
func (l *LookupActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &l.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &l.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &l.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &l.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &l.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &l.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &l.UserProperties)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LookupActivityTypeProperties.
func (l LookupActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", l.Dataset)
	populateAny(objectMap, "firstRowOnly", l.FirstRowOnly)
	populate(objectMap, "source", l.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivityTypeProperties.
func (l *LookupActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &l.Dataset)
			delete(rawMsg, key)
		case "firstRowOnly":
			err = unpopulate(val, "FirstRowOnly", &l.FirstRowOnly)
			delete(rawMsg, key)
		case "source":
			l.Source, err = unmarshalCopySourceClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MagentoLinkedService.
func (m MagentoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "Magento"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedService.
func (m *MagentoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MagentoLinkedServiceTypeProperties.
func (m MagentoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", m.AccessToken)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populateAny(objectMap, "host", m.Host)
	populateAny(objectMap, "useEncryptedEndpoints", m.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", m.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", m.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedServiceTypeProperties.
func (m *MagentoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			m.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &m.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &m.Host)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &m.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &m.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &m.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MagentoObjectDataset.
func (m MagentoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MagentoObject"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoObjectDataset.
func (m *MagentoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MagentoSource.
func (m MagentoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "query", m.Query)
	populateAny(objectMap, "queryTimeout", m.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MagentoSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoSource.
func (m *MagentoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentityCredential.
func (m ManagedIdentityCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	objectMap["type"] = "ManagedIdentity"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentityCredential.
func (m *ManagedIdentityCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentityCredentialResource.
func (m ManagedIdentityCredentialResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentityCredentialResource.
func (m *ManagedIdentityCredentialResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentityTypeProperties.
func (m ManagedIdentityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceId", m.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentityTypeProperties.
func (m *ManagedIdentityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
			err = unpopulate(val, "ResourceID", &m.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntime.
func (m ManagedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "managedVirtualNetwork", m.ManagedVirtualNetwork)
	populate(objectMap, "state", m.State)
	objectMap["type"] = IntegrationRuntimeTypeManaged
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntime.
func (m *ManagedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "managedVirtualNetwork":
			err = unpopulate(val, "ManagedVirtualNetwork", &m.ManagedVirtualNetwork)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &m.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeError.
func (m ManagedIntegrationRuntimeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", m.Code)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "parameters", m.Parameters)
	populateDateTimeRFC3339(objectMap, "time", m.Time)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeError.
func (m *ManagedIntegrationRuntimeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &m.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &m.Message)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "time":
			err = unpopulateDateTimeRFC3339(val, "Time", &m.Time)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeNode.
func (m ManagedIntegrationRuntimeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "nodeId", m.NodeID)
	populate(objectMap, "status", m.Status)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeNode.
func (m *ManagedIntegrationRuntimeNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &m.Errors)
			delete(rawMsg, key)
		case "nodeId":
			err = unpopulate(val, "NodeID", &m.NodeID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &m.Status)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeOperationResult.
func (m ManagedIntegrationRuntimeOperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityId", m.ActivityID)
	populate(objectMap, "errorCode", m.ErrorCode)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "result", m.Result)
	populateDateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "type", m.Type)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeOperationResult.
func (m *ManagedIntegrationRuntimeOperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, "ActivityID", &m.ActivityID)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &m.ErrorCode)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &m.Result)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &m.StartTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeStatus.
func (m ManagedIntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataFactoryName", m.DataFactoryName)
	populate(objectMap, "state", m.State)
	objectMap["type"] = IntegrationRuntimeTypeManaged
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeStatus.
func (m *ManagedIntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, "DataFactoryName", &m.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &m.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeStatusTypeProperties.
func (m ManagedIntegrationRuntimeStatusTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createTime", m.CreateTime)
	populate(objectMap, "lastOperation", m.LastOperation)
	populate(objectMap, "nodes", m.Nodes)
	populate(objectMap, "otherErrors", m.OtherErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeStatusTypeProperties.
func (m *ManagedIntegrationRuntimeStatusTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateDateTimeRFC3339(val, "CreateTime", &m.CreateTime)
			delete(rawMsg, key)
		case "lastOperation":
			err = unpopulate(val, "LastOperation", &m.LastOperation)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, "Nodes", &m.Nodes)
			delete(rawMsg, key)
		case "otherErrors":
			err = unpopulate(val, "OtherErrors", &m.OtherErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeTypeProperties.
func (m ManagedIntegrationRuntimeTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeProperties", m.ComputeProperties)
	populate(objectMap, "customerVirtualNetwork", m.CustomerVirtualNetwork)
	populate(objectMap, "ssisProperties", m.SsisProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeTypeProperties.
func (m *ManagedIntegrationRuntimeTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeProperties":
			err = unpopulate(val, "ComputeProperties", &m.ComputeProperties)
			delete(rawMsg, key)
		case "customerVirtualNetwork":
			err = unpopulate(val, "CustomerVirtualNetwork", &m.CustomerVirtualNetwork)
			delete(rawMsg, key)
		case "ssisProperties":
			err = unpopulate(val, "SsisProperties", &m.SsisProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpoint.
func (m ManagedPrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionState", m.ConnectionState)
	populate(objectMap, "fqdns", m.Fqdns)
	populate(objectMap, "groupId", m.GroupID)
	populate(objectMap, "isReserved", m.IsReserved)
	populate(objectMap, "privateLinkResourceId", m.PrivateLinkResourceID)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedPrivateEndpoint.
func (m *ManagedPrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionState":
			err = unpopulate(val, "ConnectionState", &m.ConnectionState)
			delete(rawMsg, key)
		case "fqdns":
			err = unpopulate(val, "Fqdns", &m.Fqdns)
			delete(rawMsg, key)
		case "groupId":
			err = unpopulate(val, "GroupID", &m.GroupID)
			delete(rawMsg, key)
		case "isReserved":
			err = unpopulate(val, "IsReserved", &m.IsReserved)
			delete(rawMsg, key)
		case "privateLinkResourceId":
			err = unpopulate(val, "PrivateLinkResourceID", &m.PrivateLinkResourceID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &m.ProvisioningState)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpointListResponse.
func (m ManagedPrivateEndpointListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedPrivateEndpointListResponse.
func (m *ManagedPrivateEndpointListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpointResource.
func (m ManagedPrivateEndpointResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedPrivateEndpointResource.
func (m *ManagedPrivateEndpointResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetwork.
func (m ManagedVirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alias", m.Alias)
	populate(objectMap, "vNetId", m.VNetID)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVirtualNetwork.
func (m *ManagedVirtualNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
			err = unpopulate(val, "Alias", &m.Alias)
			delete(rawMsg, key)
		case "vNetId":
			err = unpopulate(val, "VNetID", &m.VNetID)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetworkListResponse.
func (m ManagedVirtualNetworkListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVirtualNetworkListResponse.
func (m *ManagedVirtualNetworkListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetworkReference.
func (m ManagedVirtualNetworkReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "referenceName", m.ReferenceName)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVirtualNetworkReference.
func (m *ManagedVirtualNetworkReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &m.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetworkResource.
func (m ManagedVirtualNetworkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVirtualNetworkResource.
func (m *ManagedVirtualNetworkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperAttributeMapping.
func (m MapperAttributeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attributeReference", m.AttributeReference)
	populate(objectMap, "attributeReferences", m.AttributeReferences)
	populate(objectMap, "expression", m.Expression)
	populate(objectMap, "functionName", m.FunctionName)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperAttributeMapping.
func (m *MapperAttributeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributeReference":
			err = unpopulate(val, "AttributeReference", &m.AttributeReference)
			delete(rawMsg, key)
		case "attributeReferences":
			err = unpopulate(val, "AttributeReferences", &m.AttributeReferences)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, "Expression", &m.Expression)
			delete(rawMsg, key)
		case "functionName":
			err = unpopulate(val, "FunctionName", &m.FunctionName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperAttributeMappings.
func (m MapperAttributeMappings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attributeMappings", m.AttributeMappings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperAttributeMappings.
func (m *MapperAttributeMappings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributeMappings":
			err = unpopulate(val, "AttributeMappings", &m.AttributeMappings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperAttributeReference.
func (m MapperAttributeReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "entity", m.Entity)
	populate(objectMap, "entityConnectionReference", m.EntityConnectionReference)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperAttributeReference.
func (m *MapperAttributeReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entity":
			err = unpopulate(val, "Entity", &m.Entity)
			delete(rawMsg, key)
		case "entityConnectionReference":
			err = unpopulate(val, "EntityConnectionReference", &m.EntityConnectionReference)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperConnection.
func (m MapperConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commonDslConnectorProperties", m.CommonDslConnectorProperties)
	populate(objectMap, "isInlineDataset", m.IsInlineDataset)
	populate(objectMap, "linkedService", m.LinkedService)
	populate(objectMap, "linkedServiceType", m.LinkedServiceType)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperConnection.
func (m *MapperConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonDslConnectorProperties":
			err = unpopulate(val, "CommonDslConnectorProperties", &m.CommonDslConnectorProperties)
			delete(rawMsg, key)
		case "isInlineDataset":
			err = unpopulate(val, "IsInlineDataset", &m.IsInlineDataset)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &m.LinkedService)
			delete(rawMsg, key)
		case "linkedServiceType":
			err = unpopulate(val, "LinkedServiceType", &m.LinkedServiceType)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperConnectionReference.
func (m MapperConnectionReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionName", m.ConnectionName)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperConnectionReference.
func (m *MapperConnectionReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionName":
			err = unpopulate(val, "ConnectionName", &m.ConnectionName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperDslConnectorProperties.
func (m MapperDslConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	populateAny(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperDslConnectorProperties.
func (m *MapperDslConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperPolicy.
func (m MapperPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mode", m.Mode)
	populate(objectMap, "recurrence", m.Recurrence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperPolicy.
func (m *MapperPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mode":
			err = unpopulate(val, "Mode", &m.Mode)
			delete(rawMsg, key)
		case "recurrence":
			err = unpopulate(val, "Recurrence", &m.Recurrence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperPolicyRecurrence.
func (m MapperPolicyRecurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "frequency", m.Frequency)
	populate(objectMap, "interval", m.Interval)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperPolicyRecurrence.
func (m *MapperPolicyRecurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "frequency":
			err = unpopulate(val, "Frequency", &m.Frequency)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, "Interval", &m.Interval)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperSourceConnectionsInfo.
func (m MapperSourceConnectionsInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connection", m.Connection)
	populate(objectMap, "sourceEntities", m.SourceEntities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperSourceConnectionsInfo.
func (m *MapperSourceConnectionsInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connection":
			err = unpopulate(val, "Connection", &m.Connection)
			delete(rawMsg, key)
		case "sourceEntities":
			err = unpopulate(val, "SourceEntities", &m.SourceEntities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperTable.
func (m MapperTable) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperTable.
func (m *MapperTable) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperTableProperties.
func (m MapperTableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dslConnectorProperties", m.DslConnectorProperties)
	populate(objectMap, "schema", m.Schema)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperTableProperties.
func (m *MapperTableProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dslConnectorProperties":
			err = unpopulate(val, "DslConnectorProperties", &m.DslConnectorProperties)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperTableSchema.
func (m MapperTableSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataType", m.DataType)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperTableSchema.
func (m *MapperTableSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &m.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapperTargetConnectionsInfo.
func (m MapperTargetConnectionsInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connection", m.Connection)
	populate(objectMap, "dataMapperMappings", m.DataMapperMappings)
	populate(objectMap, "relationships", m.Relationships)
	populate(objectMap, "targetEntities", m.TargetEntities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapperTargetConnectionsInfo.
func (m *MapperTargetConnectionsInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connection":
			err = unpopulate(val, "Connection", &m.Connection)
			delete(rawMsg, key)
		case "dataMapperMappings":
			err = unpopulate(val, "DataMapperMappings", &m.DataMapperMappings)
			delete(rawMsg, key)
		case "relationships":
			err = unpopulate(val, "Relationships", &m.Relationships)
			delete(rawMsg, key)
		case "targetEntities":
			err = unpopulate(val, "TargetEntities", &m.TargetEntities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MappingDataFlow.
func (m MappingDataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	objectMap["type"] = "MappingDataFlow"
	populate(objectMap, "typeProperties", m.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MappingDataFlow.
func (m *MappingDataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MappingDataFlowTypeProperties.
func (m MappingDataFlowTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "script", m.Script)
	populate(objectMap, "scriptLines", m.ScriptLines)
	populate(objectMap, "sinks", m.Sinks)
	populate(objectMap, "sources", m.Sources)
	populate(objectMap, "transformations", m.Transformations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MappingDataFlowTypeProperties.
func (m *MappingDataFlowTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "script":
			err = unpopulate(val, "Script", &m.Script)
			delete(rawMsg, key)
		case "scriptLines":
			err = unpopulate(val, "ScriptLines", &m.ScriptLines)
			delete(rawMsg, key)
		case "sinks":
			err = unpopulate(val, "Sinks", &m.Sinks)
			delete(rawMsg, key)
		case "sources":
			err = unpopulate(val, "Sources", &m.Sources)
			delete(rawMsg, key)
		case "transformations":
			err = unpopulate(val, "Transformations", &m.Transformations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBLinkedService.
func (m MariaDBLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MariaDB"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBLinkedService.
func (m *MariaDBLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBLinkedServiceTypeProperties.
func (m MariaDBLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", m.ConnectionString)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "pwd", m.Pwd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBLinkedServiceTypeProperties.
func (m *MariaDBLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &m.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &m.EncryptedCredential)
			delete(rawMsg, key)
		case "pwd":
			err = unpopulate(val, "Pwd", &m.Pwd)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBSource.
func (m MariaDBSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "query", m.Query)
	populateAny(objectMap, "queryTimeout", m.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MariaDBSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBSource.
func (m *MariaDBSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBTableDataset.
func (m MariaDBTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MariaDBTable"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBTableDataset.
func (m *MariaDBTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MarketoLinkedService.
func (m MarketoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "Marketo"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedService.
func (m *MarketoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MarketoLinkedServiceTypeProperties.
func (m MarketoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", m.ClientID)
	populate(objectMap, "clientSecret", m.ClientSecret)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populateAny(objectMap, "endpoint", m.Endpoint)
	populateAny(objectMap, "useEncryptedEndpoints", m.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", m.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", m.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedServiceTypeProperties.
func (m *MarketoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &m.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			m.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &m.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &m.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &m.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &m.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &m.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MarketoObjectDataset.
func (m MarketoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MarketoObject"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoObjectDataset.
func (m *MarketoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MarketoSource.
func (m MarketoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "query", m.Query)
	populateAny(objectMap, "queryTimeout", m.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MarketoSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoSource.
func (m *MarketoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetadataItem.
func (m MetadataItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "name", m.Name)
	populateAny(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetadataItem.
func (m *MetadataItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessLinkedService.
func (m MicrosoftAccessLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MicrosoftAccess"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedService.
func (m *MicrosoftAccessLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessLinkedServiceTypeProperties.
func (m MicrosoftAccessLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", m.AuthenticationType)
	populateAny(objectMap, "connectionString", m.ConnectionString)
	populate(objectMap, "credential", m.Credential)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "password", m.Password)
	populateAny(objectMap, "userName", m.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedServiceTypeProperties.
func (m *MicrosoftAccessLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &m.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &m.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			m.Credential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &m.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			m.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &m.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessSink.
func (m MicrosoftAccessSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", m.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", m.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", m.SinkRetryWait)
	objectMap["type"] = "MicrosoftAccessSink"
	populateAny(objectMap, "writeBatchSize", m.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", m.WriteBatchTimeout)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessSink.
func (m *MicrosoftAccessSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &m.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &m.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &m.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &m.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &m.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessSource.
func (m MicrosoftAccessSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "query", m.Query)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MicrosoftAccessSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessSource.
func (m *MicrosoftAccessSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &m.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessTableDataset.
func (m MicrosoftAccessTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MicrosoftAccessTable"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessTableDataset.
func (m *MicrosoftAccessTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessTableDatasetTypeProperties.
func (m MicrosoftAccessTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", m.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessTableDatasetTypeProperties.
func (m *MicrosoftAccessTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &m.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasCollectionDataset.
func (m MongoDbAtlasCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MongoDbAtlasCollection"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasCollectionDataset.
func (m *MongoDbAtlasCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasCollectionDatasetTypeProperties.
func (m MongoDbAtlasCollectionDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "collection", m.Collection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasCollectionDatasetTypeProperties.
func (m *MongoDbAtlasCollectionDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collection":
			err = unpopulate(val, "Collection", &m.Collection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasLinkedService.
func (m MongoDbAtlasLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MongoDbAtlas"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasLinkedService.
func (m *MongoDbAtlasLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasLinkedServiceTypeProperties.
func (m MongoDbAtlasLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", m.ConnectionString)
	populateAny(objectMap, "database", m.Database)
	populateAny(objectMap, "driverVersion", m.DriverVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasLinkedServiceTypeProperties.
func (m *MongoDbAtlasLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &m.ConnectionString)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &m.Database)
			delete(rawMsg, key)
		case "driverVersion":
			err = unpopulate(val, "DriverVersion", &m.DriverVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasSink.
func (m MongoDbAtlasSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", m.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", m.SinkRetryWait)
	objectMap["type"] = "MongoDbAtlasSink"
	populateAny(objectMap, "writeBatchSize", m.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", m.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", m.WriteBehavior)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasSink.
func (m *MongoDbAtlasSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &m.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &m.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &m.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &m.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &m.WriteBehavior)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasSource.
func (m MongoDbAtlasSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "batchSize", m.BatchSize)
	populate(objectMap, "cursorMethods", m.CursorMethods)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "filter", m.Filter)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "queryTimeout", m.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MongoDbAtlasSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasSource.
func (m *MongoDbAtlasSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, "BatchSize", &m.BatchSize)
			delete(rawMsg, key)
		case "cursorMethods":
			err = unpopulate(val, "CursorMethods", &m.CursorMethods)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &m.Filter)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionDataset.
func (m MongoDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MongoDbCollection"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCollectionDataset.
func (m *MongoDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionDatasetTypeProperties.
func (m MongoDbCollectionDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "collectionName", m.CollectionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCollectionDatasetTypeProperties.
func (m *MongoDbCollectionDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collectionName":
			err = unpopulate(val, "CollectionName", &m.CollectionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCursorMethodsProperties.
func (m MongoDbCursorMethodsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "limit", m.Limit)
	populateAny(objectMap, "project", m.Project)
	populateAny(objectMap, "skip", m.Skip)
	populateAny(objectMap, "sort", m.Sort)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCursorMethodsProperties.
func (m *MongoDbCursorMethodsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "limit":
			err = unpopulate(val, "Limit", &m.Limit)
			delete(rawMsg, key)
		case "project":
			err = unpopulate(val, "Project", &m.Project)
			delete(rawMsg, key)
		case "skip":
			err = unpopulate(val, "Skip", &m.Skip)
			delete(rawMsg, key)
		case "sort":
			err = unpopulate(val, "Sort", &m.Sort)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbLinkedService.
func (m MongoDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MongoDb"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedService.
func (m *MongoDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbLinkedServiceTypeProperties.
func (m MongoDbLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowSelfSignedServerCert", m.AllowSelfSignedServerCert)
	populateAny(objectMap, "authSource", m.AuthSource)
	populate(objectMap, "authenticationType", m.AuthenticationType)
	populateAny(objectMap, "databaseName", m.DatabaseName)
	populateAny(objectMap, "enableSsl", m.EnableSSL)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "password", m.Password)
	populateAny(objectMap, "port", m.Port)
	populateAny(objectMap, "server", m.Server)
	populateAny(objectMap, "username", m.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedServiceTypeProperties.
func (m *MongoDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &m.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authSource":
			err = unpopulate(val, "AuthSource", &m.AuthSource)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &m.AuthenticationType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &m.DatabaseName)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &m.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &m.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			m.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &m.Port)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &m.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &m.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbSource.
func (m MongoDbSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "query", m.Query)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MongoDbSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbSource.
func (m *MongoDbSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &m.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2CollectionDataset.
func (m MongoDbV2CollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MongoDbV2Collection"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2CollectionDataset.
func (m *MongoDbV2CollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2CollectionDatasetTypeProperties.
func (m MongoDbV2CollectionDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "collection", m.Collection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2CollectionDatasetTypeProperties.
func (m *MongoDbV2CollectionDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collection":
			err = unpopulate(val, "Collection", &m.Collection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2LinkedService.
func (m MongoDbV2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MongoDbV2"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2LinkedService.
func (m *MongoDbV2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2LinkedServiceTypeProperties.
func (m MongoDbV2LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", m.ConnectionString)
	populateAny(objectMap, "database", m.Database)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2LinkedServiceTypeProperties.
func (m *MongoDbV2LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &m.ConnectionString)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &m.Database)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2Sink.
func (m MongoDbV2Sink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", m.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", m.SinkRetryWait)
	objectMap["type"] = "MongoDbV2Sink"
	populateAny(objectMap, "writeBatchSize", m.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", m.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", m.WriteBehavior)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2Sink.
func (m *MongoDbV2Sink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &m.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &m.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &m.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &m.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &m.WriteBehavior)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2Source.
func (m MongoDbV2Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "batchSize", m.BatchSize)
	populate(objectMap, "cursorMethods", m.CursorMethods)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "filter", m.Filter)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "queryTimeout", m.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MongoDbV2Source"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2Source.
func (m *MongoDbV2Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, "BatchSize", &m.BatchSize)
			delete(rawMsg, key)
		case "cursorMethods":
			err = unpopulate(val, "CursorMethods", &m.CursorMethods)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &m.Filter)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultiplePipelineTrigger.
func (m MultiplePipelineTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "pipelines", m.Pipelines)
	populate(objectMap, "runtimeState", m.RuntimeState)
	objectMap["type"] = "MultiplePipelineTrigger"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, "Pipelines", &m.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &m.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MySQLLinkedService.
func (m MySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MySql"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLLinkedService.
func (m *MySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MySQLLinkedServiceTypeProperties.
func (m MySQLLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", m.ConnectionString)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "password", m.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLLinkedServiceTypeProperties.
func (m *MySQLLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &m.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &m.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &m.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MySQLSource.
func (m MySQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", m.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populateAny(objectMap, "query", m.Query)
	populateAny(objectMap, "queryTimeout", m.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MySqlSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLSource.
func (m *MySQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MySQLTableDataset.
func (m MySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populateAny(objectMap, "schema", m.Schema)
	populateAny(objectMap, "structure", m.Structure)
	objectMap["type"] = "MySqlTable"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLTableDataset.
func (m *MySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MySQLTableDatasetTypeProperties.
func (m MySQLTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", m.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLTableDatasetTypeProperties.
func (m *MySQLTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &m.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaLinkedService.
func (n NetezzaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", n.Annotations)
	populate(objectMap, "connectVia", n.ConnectVia)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "parameters", n.Parameters)
	objectMap["type"] = "Netezza"
	populate(objectMap, "typeProperties", n.TypeProperties)
	if n.AdditionalProperties != nil {
		for key, val := range n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaLinkedService.
func (n *NetezzaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &n.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &n.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &n.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &n.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &n.TypeProperties)
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				n.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaLinkedServiceTypeProperties.
func (n NetezzaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", n.ConnectionString)
	populate(objectMap, "encryptedCredential", n.EncryptedCredential)
	populate(objectMap, "pwd", n.Pwd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaLinkedServiceTypeProperties.
func (n *NetezzaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &n.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &n.EncryptedCredential)
			delete(rawMsg, key)
		case "pwd":
			err = unpopulate(val, "Pwd", &n.Pwd)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaPartitionSettings.
func (n NetezzaPartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "partitionColumnName", n.PartitionColumnName)
	populateAny(objectMap, "partitionLowerBound", n.PartitionLowerBound)
	populateAny(objectMap, "partitionUpperBound", n.PartitionUpperBound)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaPartitionSettings.
func (n *NetezzaPartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &n.PartitionColumnName)
			delete(rawMsg, key)
		case "partitionLowerBound":
			err = unpopulate(val, "PartitionLowerBound", &n.PartitionLowerBound)
			delete(rawMsg, key)
		case "partitionUpperBound":
			err = unpopulate(val, "PartitionUpperBound", &n.PartitionUpperBound)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaSource.
func (n NetezzaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", n.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", n.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", n.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", n.PartitionOption)
	populate(objectMap, "partitionSettings", n.PartitionSettings)
	populateAny(objectMap, "query", n.Query)
	populateAny(objectMap, "queryTimeout", n.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", n.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", n.SourceRetryWait)
	objectMap["type"] = "NetezzaSource"
	if n.AdditionalProperties != nil {
		for key, val := range n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaSource.
func (n *NetezzaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &n.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &n.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &n.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &n.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &n.PartitionSettings)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &n.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &n.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &n.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &n.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				n.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaTableDataset.
func (n NetezzaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", n.Annotations)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "folder", n.Folder)
	populate(objectMap, "linkedServiceName", n.LinkedServiceName)
	populate(objectMap, "parameters", n.Parameters)
	populateAny(objectMap, "schema", n.Schema)
	populateAny(objectMap, "structure", n.Structure)
	objectMap["type"] = "NetezzaTable"
	populate(objectMap, "typeProperties", n.TypeProperties)
	if n.AdditionalProperties != nil {
		for key, val := range n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaTableDataset.
func (n *NetezzaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &n.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &n.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &n.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &n.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &n.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &n.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &n.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &n.TypeProperties)
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				n.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaTableDatasetTypeProperties.
func (n NetezzaTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", n.Schema)
	populateAny(objectMap, "table", n.Table)
	populateAny(objectMap, "tableName", n.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaTableDatasetTypeProperties.
func (n *NetezzaTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &n.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &n.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &n.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NotebookParameter.
func (n NotebookParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", n.Type)
	populateAny(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookParameter.
func (n *NotebookParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ODataLinkedService.
func (o ODataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "OData"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedService.
func (o *ODataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ODataLinkedServiceTypeProperties.
func (o ODataLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "aadResourceId", o.AADResourceID)
	populate(objectMap, "aadServicePrincipalCredentialType", o.AADServicePrincipalCredentialType)
	populateAny(objectMap, "authHeaders", o.AuthHeaders)
	populate(objectMap, "authenticationType", o.AuthenticationType)
	populateAny(objectMap, "azureCloudType", o.AzureCloudType)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "password", o.Password)
	populate(objectMap, "servicePrincipalEmbeddedCert", o.ServicePrincipalEmbeddedCert)
	populate(objectMap, "servicePrincipalEmbeddedCertPassword", o.ServicePrincipalEmbeddedCertPassword)
	populateAny(objectMap, "servicePrincipalId", o.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", o.ServicePrincipalKey)
	populateAny(objectMap, "tenant", o.Tenant)
	populateAny(objectMap, "url", o.URL)
	populateAny(objectMap, "userName", o.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedServiceTypeProperties.
func (o *ODataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			err = unpopulate(val, "AADResourceID", &o.AADResourceID)
			delete(rawMsg, key)
		case "aadServicePrincipalCredentialType":
			err = unpopulate(val, "AADServicePrincipalCredentialType", &o.AADServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "authHeaders":
			err = unpopulate(val, "AuthHeaders", &o.AuthHeaders)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &o.AuthenticationType)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &o.AzureCloudType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &o.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			o.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalEmbeddedCert":
			o.ServicePrincipalEmbeddedCert, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalEmbeddedCertPassword":
			o.ServicePrincipalEmbeddedCertPassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &o.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &o.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &o.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &o.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ODataResourceDataset.
func (o ODataResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "structure", o.Structure)
	objectMap["type"] = "ODataResource"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataResourceDataset.
func (o *ODataResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ODataResourceDatasetTypeProperties.
func (o ODataResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "path", o.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataResourceDatasetTypeProperties.
func (o *ODataResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &o.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ODataSource.
func (o ODataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", o.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", o.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "query", o.Query)
	populateAny(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "ODataSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataSource.
func (o *ODataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &o.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &o.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OdbcLinkedService.
func (o OdbcLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "Odbc"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedService.
func (o *OdbcLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OdbcLinkedServiceTypeProperties.
func (o OdbcLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "authenticationType", o.AuthenticationType)
	populateAny(objectMap, "connectionString", o.ConnectionString)
	populate(objectMap, "credential", o.Credential)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "password", o.Password)
	populateAny(objectMap, "userName", o.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedServiceTypeProperties.
func (o *OdbcLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &o.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &o.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			o.Credential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &o.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			o.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &o.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OdbcSink.
func (o OdbcSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", o.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", o.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", o.SinkRetryWait)
	objectMap["type"] = "OdbcSink"
	populateAny(objectMap, "writeBatchSize", o.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", o.WriteBatchTimeout)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcSink.
func (o *OdbcSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &o.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &o.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &o.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &o.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &o.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OdbcSource.
func (o OdbcSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", o.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "query", o.Query)
	populateAny(objectMap, "queryTimeout", o.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "OdbcSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcSource.
func (o *OdbcSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &o.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &o.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OdbcTableDataset.
func (o OdbcTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "structure", o.Structure)
	objectMap["type"] = "OdbcTable"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcTableDataset.
func (o *OdbcTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OdbcTableDatasetTypeProperties.
func (o OdbcTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", o.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcTableDatasetTypeProperties.
func (o *OdbcTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &o.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Office365Dataset.
func (o Office365Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "structure", o.Structure)
	objectMap["type"] = "Office365Table"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Dataset.
func (o *Office365Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Office365DatasetTypeProperties.
func (o Office365DatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "predicate", o.Predicate)
	populateAny(objectMap, "tableName", o.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365DatasetTypeProperties.
func (o *Office365DatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "predicate":
			err = unpopulate(val, "Predicate", &o.Predicate)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &o.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Office365LinkedService.
func (o Office365LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "Office365"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedService.
func (o *Office365LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Office365LinkedServiceTypeProperties.
func (o Office365LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populateAny(objectMap, "office365TenantId", o.Office365TenantID)
	populateAny(objectMap, "servicePrincipalId", o.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", o.ServicePrincipalKey)
	populateAny(objectMap, "servicePrincipalTenantId", o.ServicePrincipalTenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedServiceTypeProperties.
func (o *Office365LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &o.EncryptedCredential)
			delete(rawMsg, key)
		case "office365TenantId":
			err = unpopulate(val, "Office365TenantID", &o.Office365TenantID)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &o.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalTenantId":
			err = unpopulate(val, "ServicePrincipalTenantID", &o.ServicePrincipalTenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Office365Source.
func (o Office365Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowedGroups", o.AllowedGroups)
	populateAny(objectMap, "dateFilterColumn", o.DateFilterColumn)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "endTime", o.EndTime)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "outputColumns", o.OutputColumns)
	populateAny(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", o.SourceRetryWait)
	populateAny(objectMap, "startTime", o.StartTime)
	objectMap["type"] = "Office365Source"
	populateAny(objectMap, "userScopeFilterUri", o.UserScopeFilterURI)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Source.
func (o *Office365Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedGroups":
			err = unpopulate(val, "AllowedGroups", &o.AllowedGroups)
			delete(rawMsg, key)
		case "dateFilterColumn":
			err = unpopulate(val, "DateFilterColumn", &o.DateFilterColumn)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulate(val, "EndTime", &o.EndTime)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "outputColumns":
			err = unpopulate(val, "OutputColumns", &o.OutputColumns)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &o.SourceRetryWait)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &o.StartTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "userScopeFilterUri":
			err = unpopulate(val, "UserScopeFilterURI", &o.UserScopeFilterURI)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResponse.
func (o OperationListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResponse.
func (o *OperationListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationLogSpecification.
func (o OperationLogSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobDuration", o.BlobDuration)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "name", o.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationLogSpecification.
func (o *OperationLogSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobDuration":
			err = unpopulate(val, "BlobDuration", &o.BlobDuration)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &o.DisplayName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetricAvailability.
func (o OperationMetricAvailability) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobDuration", o.BlobDuration)
	populate(objectMap, "timeGrain", o.TimeGrain)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationMetricAvailability.
func (o *OperationMetricAvailability) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobDuration":
			err = unpopulate(val, "BlobDuration", &o.BlobDuration)
			delete(rawMsg, key)
		case "timeGrain":
			err = unpopulate(val, "TimeGrain", &o.TimeGrain)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetricDimension.
func (o OperationMetricDimension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "toBeExportedForShoebox", o.ToBeExportedForShoebox)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationMetricDimension.
func (o *OperationMetricDimension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &o.DisplayName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "toBeExportedForShoebox":
			err = unpopulate(val, "ToBeExportedForShoebox", &o.ToBeExportedForShoebox)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetricSpecification.
func (o OperationMetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aggregationType", o.AggregationType)
	populate(objectMap, "availabilities", o.Availabilities)
	populate(objectMap, "dimensions", o.Dimensions)
	populate(objectMap, "displayDescription", o.DisplayDescription)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", o.EnableRegionalMdmAccount)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "sourceMdmAccount", o.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", o.SourceMdmNamespace)
	populate(objectMap, "unit", o.Unit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationMetricSpecification.
func (o *OperationMetricSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregationType":
			err = unpopulate(val, "AggregationType", &o.AggregationType)
			delete(rawMsg, key)
		case "availabilities":
			err = unpopulate(val, "Availabilities", &o.Availabilities)
			delete(rawMsg, key)
		case "dimensions":
			err = unpopulate(val, "Dimensions", &o.Dimensions)
			delete(rawMsg, key)
		case "displayDescription":
			err = unpopulate(val, "DisplayDescription", &o.DisplayDescription)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &o.DisplayName)
			delete(rawMsg, key)
		case "enableRegionalMdmAccount":
			err = unpopulate(val, "EnableRegionalMdmAccount", &o.EnableRegionalMdmAccount)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "sourceMdmAccount":
			err = unpopulate(val, "SourceMdmAccount", &o.SourceMdmAccount)
			delete(rawMsg, key)
		case "sourceMdmNamespace":
			err = unpopulate(val, "SourceMdmNamespace", &o.SourceMdmNamespace)
			delete(rawMsg, key)
		case "unit":
			err = unpopulate(val, "Unit", &o.Unit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationProperties.
func (o OperationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "serviceSpecification", o.ServiceSpecification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationProperties.
func (o *OperationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "serviceSpecification":
			err = unpopulate(val, "ServiceSpecification", &o.ServiceSpecification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationServiceSpecification.
func (o OperationServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logSpecifications", o.LogSpecifications)
	populate(objectMap, "metricSpecifications", o.MetricSpecifications)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationServiceSpecification.
func (o *OperationServiceSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logSpecifications":
			err = unpopulate(val, "LogSpecifications", &o.LogSpecifications)
			delete(rawMsg, key)
		case "metricSpecifications":
			err = unpopulate(val, "MetricSpecifications", &o.MetricSpecifications)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageLinkedService.
func (o OracleCloudStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "OracleCloudStorage"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageLinkedService.
func (o *OracleCloudStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageLinkedServiceTypeProperties.
func (o OracleCloudStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "accessKeyId", o.AccessKeyID)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "secretAccessKey", o.SecretAccessKey)
	populateAny(objectMap, "serviceUrl", o.ServiceURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageLinkedServiceTypeProperties.
func (o *OracleCloudStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, "AccessKeyID", &o.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &o.EncryptedCredential)
			delete(rawMsg, key)
		case "secretAccessKey":
			o.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, "ServiceURL", &o.ServiceURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageLocation.
func (o OracleCloudStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "bucketName", o.BucketName)
	populateAny(objectMap, "fileName", o.FileName)
	populateAny(objectMap, "folderPath", o.FolderPath)
	objectMap["type"] = "OracleCloudStorageLocation"
	populateAny(objectMap, "version", o.Version)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageLocation.
func (o *OracleCloudStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, "BucketName", &o.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &o.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &o.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageReadSettings.
func (o OracleCloudStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", o.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", o.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", o.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", o.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", o.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", o.PartitionRootPath)
	populateAny(objectMap, "prefix", o.Prefix)
	populateAny(objectMap, "recursive", o.Recursive)
	objectMap["type"] = "OracleCloudStorageReadSettings"
	populateAny(objectMap, "wildcardFileName", o.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", o.WildcardFolderPath)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageReadSettings.
func (o *OracleCloudStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &o.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &o.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &o.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &o.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &o.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &o.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &o.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &o.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &o.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &o.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleLinkedService.
func (o OracleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "Oracle"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleLinkedService.
func (o *OracleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleLinkedServiceTypeProperties.
func (o OracleLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", o.ConnectionString)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "password", o.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleLinkedServiceTypeProperties.
func (o *OracleLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &o.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &o.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &o.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OraclePartitionSettings.
func (o OraclePartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "partitionColumnName", o.PartitionColumnName)
	populateAny(objectMap, "partitionLowerBound", o.PartitionLowerBound)
	populateAny(objectMap, "partitionNames", o.PartitionNames)
	populateAny(objectMap, "partitionUpperBound", o.PartitionUpperBound)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OraclePartitionSettings.
func (o *OraclePartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &o.PartitionColumnName)
			delete(rawMsg, key)
		case "partitionLowerBound":
			err = unpopulate(val, "PartitionLowerBound", &o.PartitionLowerBound)
			delete(rawMsg, key)
		case "partitionNames":
			err = unpopulate(val, "PartitionNames", &o.PartitionNames)
			delete(rawMsg, key)
		case "partitionUpperBound":
			err = unpopulate(val, "PartitionUpperBound", &o.PartitionUpperBound)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudLinkedService.
func (o OracleServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "OracleServiceCloud"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedService.
func (o *OracleServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudLinkedServiceTypeProperties.
func (o OracleServiceCloudLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populateAny(objectMap, "host", o.Host)
	populate(objectMap, "password", o.Password)
	populateAny(objectMap, "useEncryptedEndpoints", o.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", o.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", o.UsePeerVerification)
	populateAny(objectMap, "username", o.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedServiceTypeProperties.
func (o *OracleServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &o.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &o.Host)
			delete(rawMsg, key)
		case "password":
			o.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &o.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &o.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &o.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &o.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudObjectDataset.
func (o OracleServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "structure", o.Structure)
	objectMap["type"] = "OracleServiceCloudObject"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudObjectDataset.
func (o *OracleServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudSource.
func (o OracleServiceCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", o.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "query", o.Query)
	populateAny(objectMap, "queryTimeout", o.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "OracleServiceCloudSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudSource.
func (o *OracleServiceCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &o.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &o.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSink.
func (o OracleSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", o.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", o.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", o.SinkRetryWait)
	objectMap["type"] = "OracleSink"
	populateAny(objectMap, "writeBatchSize", o.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", o.WriteBatchTimeout)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSink.
func (o *OracleSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &o.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &o.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &o.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &o.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &o.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSource.
func (o OracleSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", o.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "oracleReaderQuery", o.OracleReaderQuery)
	populateAny(objectMap, "partitionOption", o.PartitionOption)
	populate(objectMap, "partitionSettings", o.PartitionSettings)
	populateAny(objectMap, "queryTimeout", o.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "OracleSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSource.
func (o *OracleSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "oracleReaderQuery":
			err = unpopulate(val, "OracleReaderQuery", &o.OracleReaderQuery)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &o.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &o.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &o.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleTableDataset.
func (o OracleTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "structure", o.Structure)
	objectMap["type"] = "OracleTable"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleTableDataset.
func (o *OracleTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleTableDatasetTypeProperties.
func (o OracleTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "table", o.Table)
	populateAny(objectMap, "tableName", o.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleTableDatasetTypeProperties.
func (o *OracleTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &o.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &o.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OrcDataset.
func (o OrcDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populateAny(objectMap, "schema", o.Schema)
	populateAny(objectMap, "structure", o.Structure)
	objectMap["type"] = "Orc"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDataset.
func (o *OrcDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OrcDatasetTypeProperties.
func (o OrcDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "location", o.Location)
	populateAny(objectMap, "orcCompressionCodec", o.OrcCompressionCodec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDatasetTypeProperties.
func (o *OrcDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			o.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "orcCompressionCodec":
			err = unpopulate(val, "OrcCompressionCodec", &o.OrcCompressionCodec)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OrcFormat.
func (o OrcFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deserializer", o.Deserializer)
	populateAny(objectMap, "serializer", o.Serializer)
	objectMap["type"] = "OrcFormat"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcFormat.
func (o *OrcFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, "Deserializer", &o.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, "Serializer", &o.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OrcSink.
func (o OrcSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "formatSettings", o.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", o.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", o.SinkRetryWait)
	populate(objectMap, "storeSettings", o.StoreSettings)
	objectMap["type"] = "OrcSink"
	populateAny(objectMap, "writeBatchSize", o.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", o.WriteBatchTimeout)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcSink.
func (o *OrcSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &o.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &o.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &o.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			o.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &o.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &o.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OrcSource.
func (o OrcSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", o.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", o.SourceRetryWait)
	populate(objectMap, "storeSettings", o.StoreSettings)
	objectMap["type"] = "OrcSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcSource.
func (o *OrcSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &o.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			o.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OrcWriteSettings.
func (o OrcWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileNamePrefix", o.FileNamePrefix)
	populateAny(objectMap, "maxRowsPerFile", o.MaxRowsPerFile)
	objectMap["type"] = "OrcWriteSettings"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcWriteSettings.
func (o *OrcWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileNamePrefix":
			err = unpopulate(val, "FileNamePrefix", &o.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, "MaxRowsPerFile", &o.MaxRowsPerFile)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageStore.
func (p PackageStore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "packageStoreLinkedService", p.PackageStoreLinkedService)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageStore.
func (p *PackageStore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "packageStoreLinkedService":
			err = unpopulate(val, "PackageStoreLinkedService", &p.PackageStoreLinkedService)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParameterSpecification.
func (p ParameterSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "defaultValue", p.DefaultValue)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParameterSpecification.
func (p *ParameterSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultValue":
			err = unpopulate(val, "DefaultValue", &p.DefaultValue)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetDataset.
func (p ParquetDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "structure", p.Structure)
	objectMap["type"] = "Parquet"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDataset.
func (p *ParquetDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetDatasetTypeProperties.
func (p ParquetDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "compressionCodec", p.CompressionCodec)
	populate(objectMap, "location", p.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDatasetTypeProperties.
func (p *ParquetDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionCodec":
			err = unpopulate(val, "CompressionCodec", &p.CompressionCodec)
			delete(rawMsg, key)
		case "location":
			p.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetFormat.
func (p ParquetFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deserializer", p.Deserializer)
	populateAny(objectMap, "serializer", p.Serializer)
	objectMap["type"] = "ParquetFormat"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetFormat.
func (p *ParquetFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, "Deserializer", &p.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, "Serializer", &p.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetReadSettings.
func (p ParquetReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compressionProperties", p.CompressionProperties)
	objectMap["type"] = "ParquetReadSettings"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetReadSettings.
func (p *ParquetReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			p.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSink.
func (p ParquetSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "formatSettings", p.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", p.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", p.SinkRetryWait)
	populate(objectMap, "storeSettings", p.StoreSettings)
	objectMap["type"] = "ParquetSink"
	populateAny(objectMap, "writeBatchSize", p.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", p.WriteBatchTimeout)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSink.
func (p *ParquetSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &p.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &p.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &p.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			p.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &p.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &p.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSource.
func (p ParquetSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", p.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "formatSettings", p.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", p.SourceRetryWait)
	populate(objectMap, "storeSettings", p.StoreSettings)
	objectMap["type"] = "ParquetSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSource.
func (p *ParquetSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &p.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &p.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			p.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ParquetWriteSettings.
func (p ParquetWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileNamePrefix", p.FileNamePrefix)
	populateAny(objectMap, "maxRowsPerFile", p.MaxRowsPerFile)
	objectMap["type"] = "ParquetWriteSettings"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetWriteSettings.
func (p *ParquetWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileNamePrefix":
			err = unpopulate(val, "FileNamePrefix", &p.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, "MaxRowsPerFile", &p.MaxRowsPerFile)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaypalLinkedService.
func (p PaypalLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "Paypal"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedService.
func (p *PaypalLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaypalLinkedServiceTypeProperties.
func (p PaypalLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", p.ClientID)
	populate(objectMap, "clientSecret", p.ClientSecret)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populateAny(objectMap, "host", p.Host)
	populateAny(objectMap, "useEncryptedEndpoints", p.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", p.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", p.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedServiceTypeProperties.
func (p *PaypalLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &p.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			p.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &p.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &p.Host)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &p.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &p.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &p.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaypalObjectDataset.
func (p PaypalObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "structure", p.Structure)
	objectMap["type"] = "PaypalObject"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalObjectDataset.
func (p *PaypalObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaypalSource.
func (p PaypalSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", p.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populateAny(objectMap, "query", p.Query)
	populateAny(objectMap, "queryTimeout", p.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PaypalSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalSource.
func (p *PaypalSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixDatasetTypeProperties.
func (p PhoenixDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "table", p.Table)
	populateAny(objectMap, "tableName", p.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixDatasetTypeProperties.
func (p *PhoenixDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &p.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &p.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixLinkedService.
func (p PhoenixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "Phoenix"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedService.
func (p *PhoenixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixLinkedServiceTypeProperties.
func (p PhoenixLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowHostNameCNMismatch", p.AllowHostNameCNMismatch)
	populateAny(objectMap, "allowSelfSignedServerCert", p.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", p.AuthenticationType)
	populateAny(objectMap, "enableSsl", p.EnableSSL)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populateAny(objectMap, "httpPath", p.HTTPPath)
	populateAny(objectMap, "host", p.Host)
	populate(objectMap, "password", p.Password)
	populateAny(objectMap, "port", p.Port)
	populateAny(objectMap, "trustedCertPath", p.TrustedCertPath)
	populateAny(objectMap, "useSystemTrustStore", p.UseSystemTrustStore)
	populateAny(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedServiceTypeProperties.
func (p *PhoenixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, "AllowHostNameCNMismatch", &p.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &p.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &p.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &p.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &p.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, "HTTPPath", &p.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &p.Host)
			delete(rawMsg, key)
		case "password":
			p.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &p.Port)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &p.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &p.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixObjectDataset.
func (p PhoenixObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "structure", p.Structure)
	objectMap["type"] = "PhoenixObject"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixObjectDataset.
func (p *PhoenixObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixSource.
func (p PhoenixSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", p.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populateAny(objectMap, "query", p.Query)
	populateAny(objectMap, "queryTimeout", p.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PhoenixSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixSource.
func (p *PhoenixSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Pipeline.
func (p Pipeline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activities", p.Activities)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "concurrency", p.Concurrency)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "policy", p.Policy)
	populate(objectMap, "runDimensions", p.RunDimensions)
	populate(objectMap, "variables", p.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Pipeline.
func (p *Pipeline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			p.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "concurrency":
			err = unpopulate(val, "Concurrency", &p.Concurrency)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &p.Folder)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &p.Policy)
			delete(rawMsg, key)
		case "runDimensions":
			err = unpopulate(val, "RunDimensions", &p.RunDimensions)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, "Variables", &p.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineElapsedTimeMetricPolicy.
func (p PipelineElapsedTimeMetricPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "duration", p.Duration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineElapsedTimeMetricPolicy.
func (p *PipelineElapsedTimeMetricPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &p.Duration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineExternalComputeScaleProperties.
func (p PipelineExternalComputeScaleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfExternalNodes", p.NumberOfExternalNodes)
	populate(objectMap, "numberOfPipelineNodes", p.NumberOfPipelineNodes)
	populate(objectMap, "timeToLive", p.TimeToLive)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineExternalComputeScaleProperties.
func (p *PipelineExternalComputeScaleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfExternalNodes":
			err = unpopulate(val, "NumberOfExternalNodes", &p.NumberOfExternalNodes)
			delete(rawMsg, key)
		case "numberOfPipelineNodes":
			err = unpopulate(val, "NumberOfPipelineNodes", &p.NumberOfPipelineNodes)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, "TimeToLive", &p.TimeToLive)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineFolder.
func (p PipelineFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineFolder.
func (p *PipelineFolder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineListResponse.
func (p PipelineListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineListResponse.
func (p *PipelineListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelinePolicy.
func (p PipelinePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "elapsedTimeMetric", p.ElapsedTimeMetric)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelinePolicy.
func (p *PipelinePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "elapsedTimeMetric":
			err = unpopulate(val, "ElapsedTimeMetric", &p.ElapsedTimeMetric)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineReference.
func (p PipelineReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "referenceName", p.ReferenceName)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineReference.
func (p *PipelineReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &p.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineResource.
func (p PipelineResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineResource.
func (p *PipelineResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRun.
func (p PipelineRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "durationInMs", p.DurationInMs)
	populate(objectMap, "invokedBy", p.InvokedBy)
	populate(objectMap, "isLatest", p.IsLatest)
	populateDateTimeRFC3339(objectMap, "lastUpdated", p.LastUpdated)
	populate(objectMap, "message", p.Message)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "pipelineName", p.PipelineName)
	populate(objectMap, "runDimensions", p.RunDimensions)
	populateDateTimeRFC3339(objectMap, "runEnd", p.RunEnd)
	populate(objectMap, "runGroupId", p.RunGroupID)
	populate(objectMap, "runId", p.RunID)
	populateDateTimeRFC3339(objectMap, "runStart", p.RunStart)
	populate(objectMap, "status", p.Status)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRun.
func (p *PipelineRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "durationInMs":
			err = unpopulate(val, "DurationInMs", &p.DurationInMs)
			delete(rawMsg, key)
		case "invokedBy":
			err = unpopulate(val, "InvokedBy", &p.InvokedBy)
			delete(rawMsg, key)
		case "isLatest":
			err = unpopulate(val, "IsLatest", &p.IsLatest)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &p.LastUpdated)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &p.Message)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "pipelineName":
			err = unpopulate(val, "PipelineName", &p.PipelineName)
			delete(rawMsg, key)
		case "runDimensions":
			err = unpopulate(val, "RunDimensions", &p.RunDimensions)
			delete(rawMsg, key)
		case "runEnd":
			err = unpopulateDateTimeRFC3339(val, "RunEnd", &p.RunEnd)
			delete(rawMsg, key)
		case "runGroupId":
			err = unpopulate(val, "RunGroupID", &p.RunGroupID)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, "RunID", &p.RunID)
			delete(rawMsg, key)
		case "runStart":
			err = unpopulateDateTimeRFC3339(val, "RunStart", &p.RunStart)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunInvokedBy.
func (p PipelineRunInvokedBy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "invokedByType", p.InvokedByType)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "pipelineName", p.PipelineName)
	populate(objectMap, "pipelineRunId", p.PipelineRunID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRunInvokedBy.
func (p *PipelineRunInvokedBy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "invokedByType":
			err = unpopulate(val, "InvokedByType", &p.InvokedByType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "pipelineName":
			err = unpopulate(val, "PipelineName", &p.PipelineName)
			delete(rawMsg, key)
		case "pipelineRunId":
			err = unpopulate(val, "PipelineRunID", &p.PipelineRunID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunsQueryResponse.
func (p PipelineRunsQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", p.ContinuationToken)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRunsQueryResponse.
func (p *PipelineRunsQueryResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &p.ContinuationToken)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolybaseSettings.
func (p PolybaseSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "rejectSampleValue", p.RejectSampleValue)
	populate(objectMap, "rejectType", p.RejectType)
	populateAny(objectMap, "rejectValue", p.RejectValue)
	populateAny(objectMap, "useTypeDefault", p.UseTypeDefault)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolybaseSettings.
func (p *PolybaseSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rejectSampleValue":
			err = unpopulate(val, "RejectSampleValue", &p.RejectSampleValue)
			delete(rawMsg, key)
		case "rejectType":
			err = unpopulate(val, "RejectType", &p.RejectType)
			delete(rawMsg, key)
		case "rejectValue":
			err = unpopulate(val, "RejectValue", &p.RejectValue)
			delete(rawMsg, key)
		case "useTypeDefault":
			err = unpopulate(val, "UseTypeDefault", &p.UseTypeDefault)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLLinkedService.
func (p PostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "PostgreSql"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLLinkedService.
func (p *PostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLLinkedServiceTypeProperties.
func (p PostgreSQLLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", p.ConnectionString)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populate(objectMap, "password", p.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLLinkedServiceTypeProperties.
func (p *PostgreSQLLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &p.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &p.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &p.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLSource.
func (p PostgreSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", p.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populateAny(objectMap, "query", p.Query)
	populateAny(objectMap, "queryTimeout", p.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PostgreSqlSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLSource.
func (p *PostgreSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLTableDataset.
func (p PostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "structure", p.Structure)
	objectMap["type"] = "PostgreSqlTable"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLTableDataset.
func (p *PostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLTableDatasetTypeProperties.
func (p PostgreSQLTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "table", p.Table)
	populateAny(objectMap, "tableName", p.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLTableDatasetTypeProperties.
func (p *PostgreSQLTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &p.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &p.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PowerQuerySink.
func (p PowerQuerySink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", p.Dataset)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "flowlet", p.Flowlet)
	populate(objectMap, "linkedService", p.LinkedService)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "rejectedDataLinkedService", p.RejectedDataLinkedService)
	populate(objectMap, "schemaLinkedService", p.SchemaLinkedService)
	populate(objectMap, "script", p.Script)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PowerQuerySink.
func (p *PowerQuerySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &p.Dataset)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "flowlet":
			err = unpopulate(val, "Flowlet", &p.Flowlet)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &p.LinkedService)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "rejectedDataLinkedService":
			err = unpopulate(val, "RejectedDataLinkedService", &p.RejectedDataLinkedService)
			delete(rawMsg, key)
		case "schemaLinkedService":
			err = unpopulate(val, "SchemaLinkedService", &p.SchemaLinkedService)
			delete(rawMsg, key)
		case "script":
			err = unpopulate(val, "Script", &p.Script)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PowerQuerySinkMapping.
func (p PowerQuerySinkMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataflowSinks", p.DataflowSinks)
	populate(objectMap, "queryName", p.QueryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PowerQuerySinkMapping.
func (p *PowerQuerySinkMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataflowSinks":
			err = unpopulate(val, "DataflowSinks", &p.DataflowSinks)
			delete(rawMsg, key)
		case "queryName":
			err = unpopulate(val, "QueryName", &p.QueryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PowerQuerySource.
func (p PowerQuerySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", p.Dataset)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "flowlet", p.Flowlet)
	populate(objectMap, "linkedService", p.LinkedService)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "schemaLinkedService", p.SchemaLinkedService)
	populate(objectMap, "script", p.Script)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PowerQuerySource.
func (p *PowerQuerySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &p.Dataset)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "flowlet":
			err = unpopulate(val, "Flowlet", &p.Flowlet)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &p.LinkedService)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "schemaLinkedService":
			err = unpopulate(val, "SchemaLinkedService", &p.SchemaLinkedService)
			delete(rawMsg, key)
		case "script":
			err = unpopulate(val, "Script", &p.Script)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PowerQueryTypeProperties.
func (p PowerQueryTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "documentLocale", p.DocumentLocale)
	populate(objectMap, "script", p.Script)
	populate(objectMap, "sources", p.Sources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PowerQueryTypeProperties.
func (p *PowerQueryTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "documentLocale":
			err = unpopulate(val, "DocumentLocale", &p.DocumentLocale)
			delete(rawMsg, key)
		case "script":
			err = unpopulate(val, "Script", &p.Script)
			delete(rawMsg, key)
		case "sources":
			err = unpopulate(val, "Sources", &p.Sources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrestoDatasetTypeProperties.
func (p PrestoDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "table", p.Table)
	populateAny(objectMap, "tableName", p.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoDatasetTypeProperties.
func (p *PrestoDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &p.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &p.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrestoLinkedService.
func (p PrestoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "Presto"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedService.
func (p *PrestoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrestoLinkedServiceTypeProperties.
func (p PrestoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowHostNameCNMismatch", p.AllowHostNameCNMismatch)
	populateAny(objectMap, "allowSelfSignedServerCert", p.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", p.AuthenticationType)
	populateAny(objectMap, "catalog", p.Catalog)
	populateAny(objectMap, "enableSsl", p.EnableSSL)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populateAny(objectMap, "host", p.Host)
	populate(objectMap, "password", p.Password)
	populateAny(objectMap, "port", p.Port)
	populateAny(objectMap, "serverVersion", p.ServerVersion)
	populateAny(objectMap, "timeZoneID", p.TimeZoneID)
	populateAny(objectMap, "trustedCertPath", p.TrustedCertPath)
	populateAny(objectMap, "useSystemTrustStore", p.UseSystemTrustStore)
	populateAny(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedServiceTypeProperties.
func (p *PrestoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, "AllowHostNameCNMismatch", &p.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &p.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &p.AuthenticationType)
			delete(rawMsg, key)
		case "catalog":
			err = unpopulate(val, "Catalog", &p.Catalog)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &p.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &p.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &p.Host)
			delete(rawMsg, key)
		case "password":
			p.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &p.Port)
			delete(rawMsg, key)
		case "serverVersion":
			err = unpopulate(val, "ServerVersion", &p.ServerVersion)
			delete(rawMsg, key)
		case "timeZoneID":
			err = unpopulate(val, "TimeZoneID", &p.TimeZoneID)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &p.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &p.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrestoObjectDataset.
func (p PrestoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populateAny(objectMap, "schema", p.Schema)
	populateAny(objectMap, "structure", p.Structure)
	objectMap["type"] = "PrestoObject"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoObjectDataset.
func (p *PrestoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrestoSource.
func (p PrestoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", p.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populateAny(objectMap, "query", p.Query)
	populateAny(objectMap, "queryTimeout", p.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PrestoSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoSource.
func (p *PrestoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpoint.
func (p PrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpoint.
func (p *PrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResponse.
func (p PrivateEndpointConnectionListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionListResponse.
func (p *PrivateEndpointConnectionListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionResource.
func (p PrivateEndpointConnectionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionResource.
func (p *PrivateEndpointConnectionResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkConnectionApprovalRequest.
func (p PrivateLinkConnectionApprovalRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkConnectionApprovalRequest.
func (p *PrivateLinkConnectionApprovalRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &p.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateLinkServiceConnectionState":
			err = unpopulate(val, "PrivateLinkServiceConnectionState", &p.PrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkConnectionApprovalRequestResource.
func (p PrivateLinkConnectionApprovalRequestResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkConnectionApprovalRequestResource.
func (p *PrivateLinkConnectionApprovalRequestResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkConnectionState.
func (p PrivateLinkConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", p.ActionsRequired)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkConnectionState.
func (p *PrivateLinkConnectionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &p.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceProperties.
func (p *PrivateLinkResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &p.GroupID)
			delete(rawMsg, key)
		case "requiredMembers":
			err = unpopulate(val, "RequiredMembers", &p.RequiredMembers)
			delete(rawMsg, key)
		case "requiredZoneNames":
			err = unpopulate(val, "RequiredZoneNames", &p.RequiredZoneNames)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourcesWrapper.
func (p PrivateLinkResourcesWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourcesWrapper.
func (p *PrivateLinkResourcesWrapper) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PurviewConfiguration.
func (p PurviewConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "purviewResourceId", p.PurviewResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PurviewConfiguration.
func (p *PurviewConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "purviewResourceId":
			err = unpopulate(val, "PurviewResourceID", &p.PurviewResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueryDataFlowDebugSessionsResponse.
func (q QueryDataFlowDebugSessionsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", q.NextLink)
	populate(objectMap, "value", q.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueryDataFlowDebugSessionsResponse.
func (q *QueryDataFlowDebugSessionsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &q.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &q.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksLinkedService.
func (q QuickBooksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", q.Annotations)
	populate(objectMap, "connectVia", q.ConnectVia)
	populate(objectMap, "description", q.Description)
	populate(objectMap, "parameters", q.Parameters)
	objectMap["type"] = "QuickBooks"
	populate(objectMap, "typeProperties", q.TypeProperties)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedService.
func (q *QuickBooksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &q.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &q.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &q.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &q.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &q.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &q.TypeProperties)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksLinkedServiceTypeProperties.
func (q QuickBooksLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", q.AccessToken)
	populate(objectMap, "accessTokenSecret", q.AccessTokenSecret)
	populateAny(objectMap, "companyId", q.CompanyID)
	populateAny(objectMap, "connectionProperties", q.ConnectionProperties)
	populateAny(objectMap, "consumerKey", q.ConsumerKey)
	populate(objectMap, "consumerSecret", q.ConsumerSecret)
	populate(objectMap, "encryptedCredential", q.EncryptedCredential)
	populateAny(objectMap, "endpoint", q.Endpoint)
	populateAny(objectMap, "useEncryptedEndpoints", q.UseEncryptedEndpoints)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedServiceTypeProperties.
func (q *QuickBooksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			q.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "accessTokenSecret":
			q.AccessTokenSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "companyId":
			err = unpopulate(val, "CompanyID", &q.CompanyID)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &q.ConnectionProperties)
			delete(rawMsg, key)
		case "consumerKey":
			err = unpopulate(val, "ConsumerKey", &q.ConsumerKey)
			delete(rawMsg, key)
		case "consumerSecret":
			q.ConsumerSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &q.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &q.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &q.UseEncryptedEndpoints)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksObjectDataset.
func (q QuickBooksObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", q.Annotations)
	populate(objectMap, "description", q.Description)
	populate(objectMap, "folder", q.Folder)
	populate(objectMap, "linkedServiceName", q.LinkedServiceName)
	populate(objectMap, "parameters", q.Parameters)
	populateAny(objectMap, "schema", q.Schema)
	populateAny(objectMap, "structure", q.Structure)
	objectMap["type"] = "QuickBooksObject"
	populate(objectMap, "typeProperties", q.TypeProperties)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksObjectDataset.
func (q *QuickBooksObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &q.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &q.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &q.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &q.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &q.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &q.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &q.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &q.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &q.TypeProperties)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksSource.
func (q QuickBooksSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", q.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", q.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", q.MaxConcurrentConnections)
	populateAny(objectMap, "query", q.Query)
	populateAny(objectMap, "queryTimeout", q.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", q.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", q.SourceRetryWait)
	objectMap["type"] = "QuickBooksSource"
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksSource.
func (q *QuickBooksSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &q.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &q.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &q.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &q.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &q.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &q.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &q.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &q.Type)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuickbaseLinkedService.
func (q QuickbaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", q.Annotations)
	populate(objectMap, "connectVia", q.ConnectVia)
	populate(objectMap, "description", q.Description)
	populate(objectMap, "parameters", q.Parameters)
	objectMap["type"] = "Quickbase"
	populate(objectMap, "typeProperties", q.TypeProperties)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickbaseLinkedService.
func (q *QuickbaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &q.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &q.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &q.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &q.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &q.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &q.TypeProperties)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuickbaseLinkedServiceTypeProperties.
func (q QuickbaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", q.EncryptedCredential)
	populateAny(objectMap, "url", q.URL)
	populate(objectMap, "userToken", q.UserToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickbaseLinkedServiceTypeProperties.
func (q *QuickbaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &q.EncryptedCredential)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &q.URL)
			delete(rawMsg, key)
		case "userToken":
			q.UserToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecurrenceSchedule.
func (r RecurrenceSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hours", r.Hours)
	populate(objectMap, "minutes", r.Minutes)
	populate(objectMap, "monthDays", r.MonthDays)
	populate(objectMap, "monthlyOccurrences", r.MonthlyOccurrences)
	populate(objectMap, "weekDays", r.WeekDays)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecurrenceSchedule.
func (r *RecurrenceSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hours":
			err = unpopulate(val, "Hours", &r.Hours)
			delete(rawMsg, key)
		case "minutes":
			err = unpopulate(val, "Minutes", &r.Minutes)
			delete(rawMsg, key)
		case "monthDays":
			err = unpopulate(val, "MonthDays", &r.MonthDays)
			delete(rawMsg, key)
		case "monthlyOccurrences":
			err = unpopulate(val, "MonthlyOccurrences", &r.MonthlyOccurrences)
			delete(rawMsg, key)
		case "weekDays":
			err = unpopulate(val, "WeekDays", &r.WeekDays)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecurrenceScheduleOccurrence.
func (r RecurrenceScheduleOccurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "day", r.Day)
	populate(objectMap, "occurrence", r.Occurrence)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecurrenceScheduleOccurrence.
func (r *RecurrenceScheduleOccurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "day":
			err = unpopulate(val, "Day", &r.Day)
			delete(rawMsg, key)
		case "occurrence":
			err = unpopulate(val, "Occurrence", &r.Occurrence)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RedirectIncompatibleRowSettings.
func (r RedirectIncompatibleRowSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "linkedServiceName", r.LinkedServiceName)
	populateAny(objectMap, "path", r.Path)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedirectIncompatibleRowSettings.
func (r *RedirectIncompatibleRowSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &r.LinkedServiceName)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &r.Path)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RedshiftUnloadSettings.
func (r RedshiftUnloadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "bucketName", r.BucketName)
	populate(objectMap, "s3LinkedServiceName", r.S3LinkedServiceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedshiftUnloadSettings.
func (r *RedshiftUnloadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, "BucketName", &r.BucketName)
			delete(rawMsg, key)
		case "s3LinkedServiceName":
			err = unpopulate(val, "S3LinkedServiceName", &r.S3LinkedServiceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RelationalSource.
func (r RelationalSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", r.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populateAny(objectMap, "query", r.Query)
	populateAny(objectMap, "sourceRetryCount", r.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", r.SourceRetryWait)
	objectMap["type"] = "RelationalSource"
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalSource.
func (r *RelationalSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &r.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &r.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &r.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &r.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RelationalTableDataset.
func (r RelationalTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "folder", r.Folder)
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "parameters", r.Parameters)
	populateAny(objectMap, "schema", r.Schema)
	populateAny(objectMap, "structure", r.Structure)
	objectMap["type"] = "RelationalTable"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalTableDataset.
func (r *RelationalTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &r.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &r.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &r.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &r.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &r.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RelationalTableDatasetTypeProperties.
func (r RelationalTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", r.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalTableDatasetTypeProperties.
func (r *RelationalTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &r.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemotePrivateEndpointConnection.
func (r RemotePrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateEndpoint", r.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", r.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemotePrivateEndpointConnection.
func (r *RemotePrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &r.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateLinkServiceConnectionState":
			err = unpopulate(val, "PrivateLinkServiceConnectionState", &r.PrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &r.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTrigger.
func (r RerunTumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "runtimeState", r.RuntimeState)
	objectMap["type"] = "RerunTumblingWindowTrigger"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTrigger.
func (r *RerunTumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &r.Description)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &r.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r RerunTumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "parentTrigger", r.ParentTrigger)
	populateDateTimeRFC3339(objectMap, "requestedEndTime", r.RequestedEndTime)
	populateDateTimeRFC3339(objectMap, "requestedStartTime", r.RequestedStartTime)
	populate(objectMap, "rerunConcurrency", r.RerunConcurrency)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r *RerunTumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parentTrigger":
			err = unpopulate(val, "ParentTrigger", &r.ParentTrigger)
			delete(rawMsg, key)
		case "requestedEndTime":
			err = unpopulateDateTimeRFC3339(val, "RequestedEndTime", &r.RequestedEndTime)
			delete(rawMsg, key)
		case "requestedStartTime":
			err = unpopulateDateTimeRFC3339(val, "RequestedStartTime", &r.RequestedStartTime)
			delete(rawMsg, key)
		case "rerunConcurrency":
			err = unpopulate(val, "RerunConcurrency", &r.RerunConcurrency)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysLinkedService.
func (r ResponsysLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "connectVia", r.ConnectVia)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "parameters", r.Parameters)
	objectMap["type"] = "Responsys"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedService.
func (r *ResponsysLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &r.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &r.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &r.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysLinkedServiceTypeProperties.
func (r ResponsysLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", r.ClientID)
	populate(objectMap, "clientSecret", r.ClientSecret)
	populate(objectMap, "encryptedCredential", r.EncryptedCredential)
	populateAny(objectMap, "endpoint", r.Endpoint)
	populateAny(objectMap, "useEncryptedEndpoints", r.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", r.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", r.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedServiceTypeProperties.
func (r *ResponsysLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &r.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			r.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &r.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &r.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &r.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &r.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &r.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysObjectDataset.
func (r ResponsysObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "folder", r.Folder)
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "parameters", r.Parameters)
	populateAny(objectMap, "schema", r.Schema)
	populateAny(objectMap, "structure", r.Structure)
	objectMap["type"] = "ResponsysObject"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysObjectDataset.
func (r *ResponsysObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &r.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &r.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &r.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &r.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &r.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysSource.
func (r ResponsysSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", r.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populateAny(objectMap, "query", r.Query)
	populateAny(objectMap, "queryTimeout", r.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", r.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", r.SourceRetryWait)
	objectMap["type"] = "ResponsysSource"
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysSource.
func (r *ResponsysSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &r.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &r.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &r.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &r.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &r.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestResourceDataset.
func (r RestResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "folder", r.Folder)
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "parameters", r.Parameters)
	populateAny(objectMap, "schema", r.Schema)
	populateAny(objectMap, "structure", r.Structure)
	objectMap["type"] = "RestResource"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestResourceDataset.
func (r *RestResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &r.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &r.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &r.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &r.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &r.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestResourceDatasetTypeProperties.
func (r RestResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalHeaders", r.AdditionalHeaders)
	populate(objectMap, "paginationRules", r.PaginationRules)
	populateAny(objectMap, "relativeUrl", r.RelativeURL)
	populateAny(objectMap, "requestBody", r.RequestBody)
	populateAny(objectMap, "requestMethod", r.RequestMethod)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestResourceDatasetTypeProperties.
func (r *RestResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			err = unpopulate(val, "AdditionalHeaders", &r.AdditionalHeaders)
			delete(rawMsg, key)
		case "paginationRules":
			err = unpopulate(val, "PaginationRules", &r.PaginationRules)
			delete(rawMsg, key)
		case "relativeUrl":
			err = unpopulate(val, "RelativeURL", &r.RelativeURL)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, "RequestBody", &r.RequestBody)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, "RequestMethod", &r.RequestMethod)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestServiceLinkedService.
func (r RestServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "connectVia", r.ConnectVia)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "parameters", r.Parameters)
	objectMap["type"] = "RestService"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedService.
func (r *RestServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &r.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &r.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &r.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestServiceLinkedServiceTypeProperties.
func (r RestServiceLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "aadResourceId", r.AADResourceID)
	populateAny(objectMap, "authHeaders", r.AuthHeaders)
	populate(objectMap, "authenticationType", r.AuthenticationType)
	populateAny(objectMap, "azureCloudType", r.AzureCloudType)
	populateAny(objectMap, "clientId", r.ClientID)
	populate(objectMap, "clientSecret", r.ClientSecret)
	populate(objectMap, "credential", r.Credential)
	populateAny(objectMap, "enableServerCertificateValidation", r.EnableServerCertificateValidation)
	populate(objectMap, "encryptedCredential", r.EncryptedCredential)
	populate(objectMap, "password", r.Password)
	populateAny(objectMap, "resource", r.Resource)
	populateAny(objectMap, "scope", r.Scope)
	populateAny(objectMap, "servicePrincipalId", r.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", r.ServicePrincipalKey)
	populateAny(objectMap, "tenant", r.Tenant)
	populateAny(objectMap, "tokenEndpoint", r.TokenEndpoint)
	populateAny(objectMap, "url", r.URL)
	populateAny(objectMap, "userName", r.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedServiceTypeProperties.
func (r *RestServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			err = unpopulate(val, "AADResourceID", &r.AADResourceID)
			delete(rawMsg, key)
		case "authHeaders":
			err = unpopulate(val, "AuthHeaders", &r.AuthHeaders)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &r.AuthenticationType)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, "AzureCloudType", &r.AzureCloudType)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &r.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			r.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &r.Credential)
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			err = unpopulate(val, "EnableServerCertificateValidation", &r.EnableServerCertificateValidation)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &r.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			r.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &r.Resource)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &r.Scope)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &r.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			r.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &r.Tenant)
			delete(rawMsg, key)
		case "tokenEndpoint":
			err = unpopulate(val, "TokenEndpoint", &r.TokenEndpoint)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &r.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &r.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestSink.
func (r RestSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalHeaders", r.AdditionalHeaders)
	populateAny(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populateAny(objectMap, "httpCompressionType", r.HTTPCompressionType)
	populateAny(objectMap, "httpRequestTimeout", r.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populateAny(objectMap, "requestInterval", r.RequestInterval)
	populateAny(objectMap, "requestMethod", r.RequestMethod)
	populateAny(objectMap, "sinkRetryCount", r.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", r.SinkRetryWait)
	objectMap["type"] = "RestSink"
	populateAny(objectMap, "writeBatchSize", r.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", r.WriteBatchTimeout)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestSink.
func (r *RestSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			err = unpopulate(val, "AdditionalHeaders", &r.AdditionalHeaders)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpCompressionType":
			err = unpopulate(val, "HTTPCompressionType", &r.HTTPCompressionType)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &r.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "requestInterval":
			err = unpopulate(val, "RequestInterval", &r.RequestInterval)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, "RequestMethod", &r.RequestMethod)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &r.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &r.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &r.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &r.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestSource.
func (r RestSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", r.AdditionalColumns)
	populateAny(objectMap, "additionalHeaders", r.AdditionalHeaders)
	populateAny(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", r.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populateAny(objectMap, "paginationRules", r.PaginationRules)
	populateAny(objectMap, "requestBody", r.RequestBody)
	populateAny(objectMap, "requestInterval", r.RequestInterval)
	populateAny(objectMap, "requestMethod", r.RequestMethod)
	populateAny(objectMap, "sourceRetryCount", r.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", r.SourceRetryWait)
	objectMap["type"] = "RestSource"
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestSource.
func (r *RestSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &r.AdditionalColumns)
			delete(rawMsg, key)
		case "additionalHeaders":
			err = unpopulate(val, "AdditionalHeaders", &r.AdditionalHeaders)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &r.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "paginationRules":
			err = unpopulate(val, "PaginationRules", &r.PaginationRules)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, "RequestBody", &r.RequestBody)
			delete(rawMsg, key)
		case "requestInterval":
			err = unpopulate(val, "RequestInterval", &r.RequestInterval)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, "RequestMethod", &r.RequestMethod)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &r.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &r.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RetryPolicy.
func (r RetryPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "count", r.Count)
	populate(objectMap, "intervalInSeconds", r.IntervalInSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RetryPolicy.
func (r *RetryPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &r.Count)
			delete(rawMsg, key)
		case "intervalInSeconds":
			err = unpopulate(val, "IntervalInSeconds", &r.IntervalInSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunFilterParameters.
func (r RunFilterParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", r.ContinuationToken)
	populate(objectMap, "filters", r.Filters)
	populateDateTimeRFC3339(objectMap, "lastUpdatedAfter", r.LastUpdatedAfter)
	populateDateTimeRFC3339(objectMap, "lastUpdatedBefore", r.LastUpdatedBefore)
	populate(objectMap, "orderBy", r.OrderBy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunFilterParameters.
func (r *RunFilterParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &r.ContinuationToken)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, "Filters", &r.Filters)
			delete(rawMsg, key)
		case "lastUpdatedAfter":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedAfter", &r.LastUpdatedAfter)
			delete(rawMsg, key)
		case "lastUpdatedBefore":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedBefore", &r.LastUpdatedBefore)
			delete(rawMsg, key)
		case "orderBy":
			err = unpopulate(val, "OrderBy", &r.OrderBy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunQueryFilter.
func (r RunQueryFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "operand", r.Operand)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunQueryFilter.
func (r *RunQueryFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "operand":
			err = unpopulate(val, "Operand", &r.Operand)
			delete(rawMsg, key)
		case "operator":
			err = unpopulate(val, "Operator", &r.Operator)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &r.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunQueryOrderBy.
func (r RunQueryOrderBy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "order", r.Order)
	populate(objectMap, "orderBy", r.OrderBy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunQueryOrderBy.
func (r *RunQueryOrderBy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "order":
			err = unpopulate(val, "Order", &r.Order)
			delete(rawMsg, key)
		case "orderBy":
			err = unpopulate(val, "OrderBy", &r.OrderBy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAlwaysEncryptedProperties.
func (s SQLAlwaysEncryptedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alwaysEncryptedAkvAuthType", s.AlwaysEncryptedAkvAuthType)
	populate(objectMap, "credential", s.Credential)
	populateAny(objectMap, "servicePrincipalId", s.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", s.ServicePrincipalKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAlwaysEncryptedProperties.
func (s *SQLAlwaysEncryptedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedAkvAuthType":
			err = unpopulate(val, "AlwaysEncryptedAkvAuthType", &s.AlwaysEncryptedAkvAuthType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, "Credential", &s.Credential)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &s.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			s.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLDWSink.
func (s SQLDWSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowCopyCommand", s.AllowCopyCommand)
	populateAny(objectMap, "allowPolyBase", s.AllowPolyBase)
	populate(objectMap, "copyCommandSettings", s.CopyCommandSettings)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "polyBaseSettings", s.PolyBaseSettings)
	populateAny(objectMap, "preCopyScript", s.PreCopyScript)
	populateAny(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populateAny(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlDWSink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDWSink.
func (s *SQLDWSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowCopyCommand":
			err = unpopulate(val, "AllowCopyCommand", &s.AllowCopyCommand)
			delete(rawMsg, key)
		case "allowPolyBase":
			err = unpopulate(val, "AllowPolyBase", &s.AllowPolyBase)
			delete(rawMsg, key)
		case "copyCommandSettings":
			err = unpopulate(val, "CopyCommandSettings", &s.CopyCommandSettings)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "polyBaseSettings":
			err = unpopulate(val, "PolyBaseSettings", &s.PolyBaseSettings)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, "SQLWriterUseTableLock", &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, "TableOption", &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, "UpsertSettings", &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLDWSource.
func (s SQLDWSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "isolationLevel", s.IsolationLevel)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populateAny(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlDWSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDWSource.
func (s *SQLDWSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, "IsolationLevel", &s.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &s.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, "SQLReaderQuery", &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, "SQLReaderStoredProcedureName", &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLDWUpsertSettings.
func (s SQLDWUpsertSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "interimSchemaName", s.InterimSchemaName)
	populateAny(objectMap, "keys", s.Keys)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDWUpsertSettings.
func (s *SQLDWUpsertSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interimSchemaName":
			err = unpopulate(val, "InterimSchemaName", &s.InterimSchemaName)
			delete(rawMsg, key)
		case "keys":
			err = unpopulate(val, "Keys", &s.Keys)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLMISink.
func (s SQLMISink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", s.PreCopyScript)
	populateAny(objectMap, "sqlWriterStoredProcedureName", s.SQLWriterStoredProcedureName)
	populateAny(objectMap, "sqlWriterTableType", s.SQLWriterTableType)
	populateAny(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	populateAny(objectMap, "storedProcedureTableTypeParameterName", s.StoredProcedureTableTypeParameterName)
	populateAny(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlMISink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMISink.
func (s *SQLMISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, "SQLWriterStoredProcedureName", &s.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, "SQLWriterTableType", &s.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, "SQLWriterUseTableLock", &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, "StoredProcedureTableTypeParameterName", &s.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, "TableOption", &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, "UpsertSettings", &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLMISource.
func (s SQLMISource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "isolationLevel", s.IsolationLevel)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populateAny(objectMap, "produceAdditionalTypes", s.ProduceAdditionalTypes)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populateAny(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlMISource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMISource.
func (s *SQLMISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, "IsolationLevel", &s.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &s.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, "ProduceAdditionalTypes", &s.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, "SQLReaderQuery", &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, "SQLReaderStoredProcedureName", &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLPartitionSettings.
func (s SQLPartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "partitionColumnName", s.PartitionColumnName)
	populateAny(objectMap, "partitionLowerBound", s.PartitionLowerBound)
	populateAny(objectMap, "partitionUpperBound", s.PartitionUpperBound)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPartitionSettings.
func (s *SQLPartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &s.PartitionColumnName)
			delete(rawMsg, key)
		case "partitionLowerBound":
			err = unpopulate(val, "PartitionLowerBound", &s.PartitionLowerBound)
			delete(rawMsg, key)
		case "partitionUpperBound":
			err = unpopulate(val, "PartitionUpperBound", &s.PartitionUpperBound)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLinkedService.
func (s SQLServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SqlServer"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedService.
func (s *SQLServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLinkedServiceTypeProperties.
func (s SQLServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alwaysEncryptedSettings", s.AlwaysEncryptedSettings)
	populateAny(objectMap, "connectionString", s.ConnectionString)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedServiceTypeProperties.
func (s *SQLServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, "AlwaysEncryptedSettings", &s.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &s.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSink.
func (s SQLServerSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", s.PreCopyScript)
	populateAny(objectMap, "sqlWriterStoredProcedureName", s.SQLWriterStoredProcedureName)
	populateAny(objectMap, "sqlWriterTableType", s.SQLWriterTableType)
	populateAny(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	populateAny(objectMap, "storedProcedureTableTypeParameterName", s.StoredProcedureTableTypeParameterName)
	populateAny(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlServerSink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSink.
func (s *SQLServerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, "SQLWriterStoredProcedureName", &s.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, "SQLWriterTableType", &s.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, "SQLWriterUseTableLock", &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, "StoredProcedureTableTypeParameterName", &s.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, "TableOption", &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, "UpsertSettings", &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSource.
func (s SQLServerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "isolationLevel", s.IsolationLevel)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populateAny(objectMap, "produceAdditionalTypes", s.ProduceAdditionalTypes)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populateAny(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlServerSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSource.
func (s *SQLServerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, "IsolationLevel", &s.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &s.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, "ProduceAdditionalTypes", &s.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, "SQLReaderQuery", &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, "SQLReaderStoredProcedureName", &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerStoredProcedureActivity.
func (s SQLServerStoredProcedureActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "onInactiveMarkAs", s.OnInactiveMarkAs)
	populate(objectMap, "policy", s.Policy)
	populate(objectMap, "state", s.State)
	objectMap["type"] = "SqlServerStoredProcedure"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerStoredProcedureActivity.
func (s *SQLServerStoredProcedureActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &s.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &s.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerStoredProcedureActivityTypeProperties.
func (s SQLServerStoredProcedureActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "storedProcedureName", s.StoredProcedureName)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerStoredProcedureActivityTypeProperties.
func (s *SQLServerStoredProcedureActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storedProcedureName":
			err = unpopulate(val, "StoredProcedureName", &s.StoredProcedureName)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerTableDataset.
func (s SQLServerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SqlServerTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerTableDataset.
func (s *SQLServerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerTableDatasetTypeProperties.
func (s SQLServerTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "table", s.Table)
	populateAny(objectMap, "tableName", s.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerTableDatasetTypeProperties.
func (s *SQLServerTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &s.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &s.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLSink.
func (s SQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", s.PreCopyScript)
	populateAny(objectMap, "sqlWriterStoredProcedureName", s.SQLWriterStoredProcedureName)
	populateAny(objectMap, "sqlWriterTableType", s.SQLWriterTableType)
	populateAny(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	populateAny(objectMap, "storedProcedureTableTypeParameterName", s.StoredProcedureTableTypeParameterName)
	populateAny(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlSink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populateAny(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLSink.
func (s *SQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, "SQLWriterStoredProcedureName", &s.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, "SQLWriterTableType", &s.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, "SQLWriterUseTableLock", &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, "StoredProcedureTableTypeParameterName", &s.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, "TableOption", &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, "UpsertSettings", &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLSource.
func (s SQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "isolationLevel", s.IsolationLevel)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populateAny(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populateAny(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLSource.
func (s *SQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, "IsolationLevel", &s.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &s.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, "SQLReaderQuery", &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, "SQLReaderStoredProcedureName", &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, "StoredProcedureParameters", &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLUpsertSettings.
func (s SQLUpsertSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "interimSchemaName", s.InterimSchemaName)
	populateAny(objectMap, "keys", s.Keys)
	populateAny(objectMap, "useTempDB", s.UseTempDB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLUpsertSettings.
func (s *SQLUpsertSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interimSchemaName":
			err = unpopulate(val, "InterimSchemaName", &s.InterimSchemaName)
			delete(rawMsg, key)
		case "keys":
			err = unpopulate(val, "Keys", &s.Keys)
			delete(rawMsg, key)
		case "useTempDB":
			err = unpopulate(val, "UseTempDB", &s.UseTempDB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISAccessCredential.
func (s SSISAccessCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "domain", s.Domain)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISAccessCredential.
func (s *SSISAccessCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			err = unpopulate(val, "Domain", &s.Domain)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISChildPackage.
func (s SSISChildPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "packageContent", s.PackageContent)
	populate(objectMap, "packageLastModifiedDate", s.PackageLastModifiedDate)
	populate(objectMap, "packageName", s.PackageName)
	populateAny(objectMap, "packagePath", s.PackagePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISChildPackage.
func (s *SSISChildPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "packageContent":
			err = unpopulate(val, "PackageContent", &s.PackageContent)
			delete(rawMsg, key)
		case "packageLastModifiedDate":
			err = unpopulate(val, "PackageLastModifiedDate", &s.PackageLastModifiedDate)
			delete(rawMsg, key)
		case "packageName":
			err = unpopulate(val, "PackageName", &s.PackageName)
			delete(rawMsg, key)
		case "packagePath":
			err = unpopulate(val, "PackagePath", &s.PackagePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISExecutionCredential.
func (s SSISExecutionCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "domain", s.Domain)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISExecutionCredential.
func (s *SSISExecutionCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			err = unpopulate(val, "Domain", &s.Domain)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &s.Password)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISExecutionParameter.
func (s SSISExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISExecutionParameter.
func (s *SSISExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISLogLocation.
func (s SSISLogLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "logPath", s.LogPath)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "typeProperties", s.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISLogLocation.
func (s *SSISLogLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logPath":
			err = unpopulate(val, "LogPath", &s.LogPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISLogLocationTypeProperties.
func (s SSISLogLocationTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessCredential", s.AccessCredential)
	populateAny(objectMap, "logRefreshInterval", s.LogRefreshInterval)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISLogLocationTypeProperties.
func (s *SSISLogLocationTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessCredential":
			err = unpopulate(val, "AccessCredential", &s.AccessCredential)
			delete(rawMsg, key)
		case "logRefreshInterval":
			err = unpopulate(val, "LogRefreshInterval", &s.LogRefreshInterval)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISPackageLocation.
func (s SSISPackageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "packagePath", s.PackagePath)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "typeProperties", s.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISPackageLocation.
func (s *SSISPackageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "packagePath":
			err = unpopulate(val, "PackagePath", &s.PackagePath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISPackageLocationTypeProperties.
func (s SSISPackageLocationTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessCredential", s.AccessCredential)
	populate(objectMap, "childPackages", s.ChildPackages)
	populate(objectMap, "configurationAccessCredential", s.ConfigurationAccessCredential)
	populateAny(objectMap, "configurationPath", s.ConfigurationPath)
	populateAny(objectMap, "packageContent", s.PackageContent)
	populate(objectMap, "packageLastModifiedDate", s.PackageLastModifiedDate)
	populate(objectMap, "packageName", s.PackageName)
	populate(objectMap, "packagePassword", s.PackagePassword)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISPackageLocationTypeProperties.
func (s *SSISPackageLocationTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessCredential":
			err = unpopulate(val, "AccessCredential", &s.AccessCredential)
			delete(rawMsg, key)
		case "childPackages":
			err = unpopulate(val, "ChildPackages", &s.ChildPackages)
			delete(rawMsg, key)
		case "configurationAccessCredential":
			err = unpopulate(val, "ConfigurationAccessCredential", &s.ConfigurationAccessCredential)
			delete(rawMsg, key)
		case "configurationPath":
			err = unpopulate(val, "ConfigurationPath", &s.ConfigurationPath)
			delete(rawMsg, key)
		case "packageContent":
			err = unpopulate(val, "PackageContent", &s.PackageContent)
			delete(rawMsg, key)
		case "packageLastModifiedDate":
			err = unpopulate(val, "PackageLastModifiedDate", &s.PackageLastModifiedDate)
			delete(rawMsg, key)
		case "packageName":
			err = unpopulate(val, "PackageName", &s.PackageName)
			delete(rawMsg, key)
		case "packagePassword":
			s.PackagePassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSISPropertyOverride.
func (s SSISPropertyOverride) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isSensitive", s.IsSensitive)
	populateAny(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISPropertyOverride.
func (s *SSISPropertyOverride) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isSensitive":
			err = unpopulate(val, "IsSensitive", &s.IsSensitive)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceLinkedService.
func (s SalesforceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Salesforce"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedService.
func (s *SalesforceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceLinkedServiceTypeProperties.
func (s SalesforceLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "apiVersion", s.APIVersion)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "environmentUrl", s.EnvironmentURL)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "securityToken", s.SecurityToken)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedServiceTypeProperties.
func (s *SalesforceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersion":
			err = unpopulate(val, "APIVersion", &s.APIVersion)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "environmentUrl":
			err = unpopulate(val, "EnvironmentURL", &s.EnvironmentURL)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "securityToken":
			s.SecurityToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudLinkedService.
func (s SalesforceMarketingCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SalesforceMarketingCloud"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedService.
func (s *SalesforceMarketingCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudLinkedServiceTypeProperties.
func (s SalesforceMarketingCloudLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "clientSecret", s.ClientSecret)
	populateAny(objectMap, "connectionProperties", s.ConnectionProperties)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", s.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", s.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedServiceTypeProperties.
func (s *SalesforceMarketingCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			s.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &s.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &s.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s SalesforceMarketingCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SalesforceMarketingCloudObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s *SalesforceMarketingCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudSource.
func (s SalesforceMarketingCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SalesforceMarketingCloudSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudSource.
func (s *SalesforceMarketingCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceObjectDataset.
func (s SalesforceObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SalesforceObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceObjectDataset.
func (s *SalesforceObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceObjectDatasetTypeProperties.
func (s SalesforceObjectDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "objectApiName", s.ObjectAPIName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceObjectDatasetTypeProperties.
func (s *SalesforceObjectDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectApiName":
			err = unpopulate(val, "ObjectAPIName", &s.ObjectAPIName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudLinkedService.
func (s SalesforceServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SalesforceServiceCloud"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedService.
func (s *SalesforceServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudLinkedServiceTypeProperties.
func (s SalesforceServiceCloudLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "apiVersion", s.APIVersion)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "environmentUrl", s.EnvironmentURL)
	populateAny(objectMap, "extendedProperties", s.ExtendedProperties)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "securityToken", s.SecurityToken)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedServiceTypeProperties.
func (s *SalesforceServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersion":
			err = unpopulate(val, "APIVersion", &s.APIVersion)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "environmentUrl":
			err = unpopulate(val, "EnvironmentURL", &s.EnvironmentURL)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, "ExtendedProperties", &s.ExtendedProperties)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "securityToken":
			s.SecurityToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudObjectDataset.
func (s SalesforceServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SalesforceServiceCloudObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudObjectDataset.
func (s *SalesforceServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudObjectDatasetTypeProperties.
func (s SalesforceServiceCloudObjectDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "objectApiName", s.ObjectAPIName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudObjectDatasetTypeProperties.
func (s *SalesforceServiceCloudObjectDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectApiName":
			err = unpopulate(val, "ObjectAPIName", &s.ObjectAPIName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudSink.
func (s SalesforceServiceCloudSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "externalIdFieldName", s.ExternalIDFieldName)
	populateAny(objectMap, "ignoreNullValues", s.IgnoreNullValues)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SalesforceServiceCloudSink"
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudSink.
func (s *SalesforceServiceCloudSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "externalIdFieldName":
			err = unpopulate(val, "ExternalIDFieldName", &s.ExternalIDFieldName)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, "IgnoreNullValues", &s.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudSource.
func (s SalesforceServiceCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "readBehavior", s.ReadBehavior)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SalesforceServiceCloudSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudSource.
func (s *SalesforceServiceCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "readBehavior":
			err = unpopulate(val, "ReadBehavior", &s.ReadBehavior)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceSink.
func (s SalesforceSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "externalIdFieldName", s.ExternalIDFieldName)
	populateAny(objectMap, "ignoreNullValues", s.IgnoreNullValues)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SalesforceSink"
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceSink.
func (s *SalesforceSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "externalIdFieldName":
			err = unpopulate(val, "ExternalIDFieldName", &s.ExternalIDFieldName)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, "IgnoreNullValues", &s.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceSource.
func (s SalesforceSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "readBehavior", s.ReadBehavior)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SalesforceSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceSource.
func (s *SalesforceSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "readBehavior":
			err = unpopulate(val, "ReadBehavior", &s.ReadBehavior)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapBWLinkedService.
func (s SapBWLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapBW"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBWLinkedService.
func (s *SapBWLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapBWLinkedServiceTypeProperties.
func (s SapBWLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "server", s.Server)
	populateAny(objectMap, "systemNumber", s.SystemNumber)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBWLinkedServiceTypeProperties.
func (s *SapBWLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, "SystemNumber", &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapBwCubeDataset.
func (s SapBwCubeDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapBwCube"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwCubeDataset.
func (s *SapBwCubeDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapBwSource.
func (s SapBwSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapBwSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwSource.
func (s *SapBwSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerLinkedService.
func (s SapCloudForCustomerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapCloudForCustomer"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedService.
func (s *SapCloudForCustomerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerLinkedServiceTypeProperties.
func (s SapCloudForCustomerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "url", s.URL)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedServiceTypeProperties.
func (s *SapCloudForCustomerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &s.URL)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerResourceDataset.
func (s SapCloudForCustomerResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapCloudForCustomerResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerResourceDataset.
func (s *SapCloudForCustomerResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerResourceDatasetTypeProperties.
func (s SapCloudForCustomerResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "path", s.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerResourceDatasetTypeProperties.
func (s *SapCloudForCustomerResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &s.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerSink.
func (s SapCloudForCustomerSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SapCloudForCustomerSink"
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerSink.
func (s *SapCloudForCustomerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, "WriteBehavior", &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerSource.
func (s SapCloudForCustomerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapCloudForCustomerSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerSource.
func (s *SapCloudForCustomerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapEccLinkedService.
func (s SapEccLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapEcc"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedService.
func (s *SapEccLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapEccLinkedServiceTypeProperties.
func (s SapEccLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "url", s.URL)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedServiceTypeProperties.
func (s *SapEccLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &s.URL)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapEccResourceDataset.
func (s SapEccResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapEccResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccResourceDataset.
func (s *SapEccResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapEccResourceDatasetTypeProperties.
func (s SapEccResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "path", s.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccResourceDatasetTypeProperties.
func (s *SapEccResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &s.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapEccSource.
func (s SapEccSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapEccSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccSource.
func (s *SapEccSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaLinkedService.
func (s SapHanaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapHana"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedService.
func (s *SapHanaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaLinkedServiceProperties.
func (s SapHanaLinkedServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populateAny(objectMap, "connectionString", s.ConnectionString)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "server", s.Server)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedServiceProperties.
func (s *SapHanaLinkedServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &s.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &s.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaPartitionSettings.
func (s SapHanaPartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "partitionColumnName", s.PartitionColumnName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaPartitionSettings.
func (s *SapHanaPartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &s.PartitionColumnName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaSource.
func (s SapHanaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "packetSize", s.PacketSize)
	populateAny(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapHanaSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaSource.
func (s *SapHanaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "packetSize":
			err = unpopulate(val, "PacketSize", &s.PacketSize)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &s.PartitionSettings)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaTableDataset.
func (s SapHanaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapHanaTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaTableDataset.
func (s *SapHanaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaTableDatasetTypeProperties.
func (s SapHanaTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "table", s.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaTableDatasetTypeProperties.
func (s *SapHanaTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &s.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOdpLinkedService.
func (s SapOdpLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapOdp"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOdpLinkedService.
func (s *SapOdpLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOdpLinkedServiceTypeProperties.
func (s SapOdpLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "language", s.Language)
	populateAny(objectMap, "logonGroup", s.LogonGroup)
	populateAny(objectMap, "messageServer", s.MessageServer)
	populateAny(objectMap, "messageServerService", s.MessageServerService)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "server", s.Server)
	populateAny(objectMap, "sncLibraryPath", s.SncLibraryPath)
	populateAny(objectMap, "sncMode", s.SncMode)
	populateAny(objectMap, "sncMyName", s.SncMyName)
	populateAny(objectMap, "sncPartnerName", s.SncPartnerName)
	populateAny(objectMap, "sncQop", s.SncQop)
	populateAny(objectMap, "subscriberName", s.SubscriberName)
	populateAny(objectMap, "systemId", s.SystemID)
	populateAny(objectMap, "systemNumber", s.SystemNumber)
	populateAny(objectMap, "userName", s.UserName)
	populateAny(objectMap, "x509CertificatePath", s.X509CertificatePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOdpLinkedServiceTypeProperties.
func (s *SapOdpLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, "Language", &s.Language)
			delete(rawMsg, key)
		case "logonGroup":
			err = unpopulate(val, "LogonGroup", &s.LogonGroup)
			delete(rawMsg, key)
		case "messageServer":
			err = unpopulate(val, "MessageServer", &s.MessageServer)
			delete(rawMsg, key)
		case "messageServerService":
			err = unpopulate(val, "MessageServerService", &s.MessageServerService)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "sncLibraryPath":
			err = unpopulate(val, "SncLibraryPath", &s.SncLibraryPath)
			delete(rawMsg, key)
		case "sncMode":
			err = unpopulate(val, "SncMode", &s.SncMode)
			delete(rawMsg, key)
		case "sncMyName":
			err = unpopulate(val, "SncMyName", &s.SncMyName)
			delete(rawMsg, key)
		case "sncPartnerName":
			err = unpopulate(val, "SncPartnerName", &s.SncPartnerName)
			delete(rawMsg, key)
		case "sncQop":
			err = unpopulate(val, "SncQop", &s.SncQop)
			delete(rawMsg, key)
		case "subscriberName":
			err = unpopulate(val, "SubscriberName", &s.SubscriberName)
			delete(rawMsg, key)
		case "systemId":
			err = unpopulate(val, "SystemID", &s.SystemID)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, "SystemNumber", &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		case "x509CertificatePath":
			err = unpopulate(val, "X509CertificatePath", &s.X509CertificatePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOdpResourceDataset.
func (s SapOdpResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapOdpResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOdpResourceDataset.
func (s *SapOdpResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOdpResourceDatasetTypeProperties.
func (s SapOdpResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "context", s.Context)
	populateAny(objectMap, "objectName", s.ObjectName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOdpResourceDatasetTypeProperties.
func (s *SapOdpResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
			err = unpopulate(val, "Context", &s.Context)
			delete(rawMsg, key)
		case "objectName":
			err = unpopulate(val, "ObjectName", &s.ObjectName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOdpSource.
func (s SapOdpSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "extractionMode", s.ExtractionMode)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "projection", s.Projection)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "selection", s.Selection)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populateAny(objectMap, "subscriberProcess", s.SubscriberProcess)
	objectMap["type"] = "SapOdpSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOdpSource.
func (s *SapOdpSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "extractionMode":
			err = unpopulate(val, "ExtractionMode", &s.ExtractionMode)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "projection":
			err = unpopulate(val, "Projection", &s.Projection)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "selection":
			err = unpopulate(val, "Selection", &s.Selection)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "subscriberProcess":
			err = unpopulate(val, "SubscriberProcess", &s.SubscriberProcess)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubLinkedService.
func (s SapOpenHubLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapOpenHub"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedService.
func (s *SapOpenHubLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubLinkedServiceTypeProperties.
func (s SapOpenHubLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "language", s.Language)
	populateAny(objectMap, "logonGroup", s.LogonGroup)
	populateAny(objectMap, "messageServer", s.MessageServer)
	populateAny(objectMap, "messageServerService", s.MessageServerService)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "server", s.Server)
	populateAny(objectMap, "systemId", s.SystemID)
	populateAny(objectMap, "systemNumber", s.SystemNumber)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedServiceTypeProperties.
func (s *SapOpenHubLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, "Language", &s.Language)
			delete(rawMsg, key)
		case "logonGroup":
			err = unpopulate(val, "LogonGroup", &s.LogonGroup)
			delete(rawMsg, key)
		case "messageServer":
			err = unpopulate(val, "MessageServer", &s.MessageServer)
			delete(rawMsg, key)
		case "messageServerService":
			err = unpopulate(val, "MessageServerService", &s.MessageServerService)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "systemId":
			err = unpopulate(val, "SystemID", &s.SystemID)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, "SystemNumber", &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubSource.
func (s SapOpenHubSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "baseRequestId", s.BaseRequestID)
	populateAny(objectMap, "customRfcReadTableFunctionModule", s.CustomRFCReadTableFunctionModule)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "excludeLastRequest", s.ExcludeLastRequest)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sapDataColumnDelimiter", s.SapDataColumnDelimiter)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapOpenHubSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubSource.
func (s *SapOpenHubSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "baseRequestId":
			err = unpopulate(val, "BaseRequestID", &s.BaseRequestID)
			delete(rawMsg, key)
		case "customRfcReadTableFunctionModule":
			err = unpopulate(val, "CustomRFCReadTableFunctionModule", &s.CustomRFCReadTableFunctionModule)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "excludeLastRequest":
			err = unpopulate(val, "ExcludeLastRequest", &s.ExcludeLastRequest)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sapDataColumnDelimiter":
			err = unpopulate(val, "SapDataColumnDelimiter", &s.SapDataColumnDelimiter)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubTableDataset.
func (s SapOpenHubTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapOpenHubTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubTableDataset.
func (s *SapOpenHubTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubTableDatasetTypeProperties.
func (s SapOpenHubTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "baseRequestId", s.BaseRequestID)
	populateAny(objectMap, "excludeLastRequest", s.ExcludeLastRequest)
	populateAny(objectMap, "openHubDestinationName", s.OpenHubDestinationName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubTableDatasetTypeProperties.
func (s *SapOpenHubTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseRequestId":
			err = unpopulate(val, "BaseRequestID", &s.BaseRequestID)
			delete(rawMsg, key)
		case "excludeLastRequest":
			err = unpopulate(val, "ExcludeLastRequest", &s.ExcludeLastRequest)
			delete(rawMsg, key)
		case "openHubDestinationName":
			err = unpopulate(val, "OpenHubDestinationName", &s.OpenHubDestinationName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapTableLinkedService.
func (s SapTableLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedService.
func (s *SapTableLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapTableLinkedServiceTypeProperties.
func (s SapTableLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "language", s.Language)
	populateAny(objectMap, "logonGroup", s.LogonGroup)
	populateAny(objectMap, "messageServer", s.MessageServer)
	populateAny(objectMap, "messageServerService", s.MessageServerService)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "server", s.Server)
	populateAny(objectMap, "sncLibraryPath", s.SncLibraryPath)
	populateAny(objectMap, "sncMode", s.SncMode)
	populateAny(objectMap, "sncMyName", s.SncMyName)
	populateAny(objectMap, "sncPartnerName", s.SncPartnerName)
	populateAny(objectMap, "sncQop", s.SncQop)
	populateAny(objectMap, "systemId", s.SystemID)
	populateAny(objectMap, "systemNumber", s.SystemNumber)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedServiceTypeProperties.
func (s *SapTableLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, "Language", &s.Language)
			delete(rawMsg, key)
		case "logonGroup":
			err = unpopulate(val, "LogonGroup", &s.LogonGroup)
			delete(rawMsg, key)
		case "messageServer":
			err = unpopulate(val, "MessageServer", &s.MessageServer)
			delete(rawMsg, key)
		case "messageServerService":
			err = unpopulate(val, "MessageServerService", &s.MessageServerService)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "sncLibraryPath":
			err = unpopulate(val, "SncLibraryPath", &s.SncLibraryPath)
			delete(rawMsg, key)
		case "sncMode":
			err = unpopulate(val, "SncMode", &s.SncMode)
			delete(rawMsg, key)
		case "sncMyName":
			err = unpopulate(val, "SncMyName", &s.SncMyName)
			delete(rawMsg, key)
		case "sncPartnerName":
			err = unpopulate(val, "SncPartnerName", &s.SncPartnerName)
			delete(rawMsg, key)
		case "sncQop":
			err = unpopulate(val, "SncQop", &s.SncQop)
			delete(rawMsg, key)
		case "systemId":
			err = unpopulate(val, "SystemID", &s.SystemID)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, "SystemNumber", &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapTablePartitionSettings.
func (s SapTablePartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "maxPartitionsNumber", s.MaxPartitionsNumber)
	populateAny(objectMap, "partitionColumnName", s.PartitionColumnName)
	populateAny(objectMap, "partitionLowerBound", s.PartitionLowerBound)
	populateAny(objectMap, "partitionUpperBound", s.PartitionUpperBound)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTablePartitionSettings.
func (s *SapTablePartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxPartitionsNumber":
			err = unpopulate(val, "MaxPartitionsNumber", &s.MaxPartitionsNumber)
			delete(rawMsg, key)
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &s.PartitionColumnName)
			delete(rawMsg, key)
		case "partitionLowerBound":
			err = unpopulate(val, "PartitionLowerBound", &s.PartitionLowerBound)
			delete(rawMsg, key)
		case "partitionUpperBound":
			err = unpopulate(val, "PartitionUpperBound", &s.PartitionUpperBound)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapTableResourceDataset.
func (s SapTableResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapTableResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableResourceDataset.
func (s *SapTableResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapTableResourceDatasetTypeProperties.
func (s SapTableResourceDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", s.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableResourceDatasetTypeProperties.
func (s *SapTableResourceDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &s.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SapTableSource.
func (s SapTableSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "batchSize", s.BatchSize)
	populateAny(objectMap, "customRfcReadTableFunctionModule", s.CustomRFCReadTableFunctionModule)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "rfcTableFields", s.RFCTableFields)
	populateAny(objectMap, "rfcTableOptions", s.RFCTableOptions)
	populateAny(objectMap, "rowCount", s.RowCount)
	populateAny(objectMap, "rowSkips", s.RowSkips)
	populateAny(objectMap, "sapDataColumnDelimiter", s.SapDataColumnDelimiter)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapTableSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableSource.
func (s *SapTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, "BatchSize", &s.BatchSize)
			delete(rawMsg, key)
		case "customRfcReadTableFunctionModule":
			err = unpopulate(val, "CustomRFCReadTableFunctionModule", &s.CustomRFCReadTableFunctionModule)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &s.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "rfcTableFields":
			err = unpopulate(val, "RFCTableFields", &s.RFCTableFields)
			delete(rawMsg, key)
		case "rfcTableOptions":
			err = unpopulate(val, "RFCTableOptions", &s.RFCTableOptions)
			delete(rawMsg, key)
		case "rowCount":
			err = unpopulate(val, "RowCount", &s.RowCount)
			delete(rawMsg, key)
		case "rowSkips":
			err = unpopulate(val, "RowSkips", &s.RowSkips)
			delete(rawMsg, key)
		case "sapDataColumnDelimiter":
			err = unpopulate(val, "SapDataColumnDelimiter", &s.SapDataColumnDelimiter)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTrigger.
func (s ScheduleTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "pipelines", s.Pipelines)
	populate(objectMap, "runtimeState", s.RuntimeState)
	objectMap["type"] = "ScheduleTrigger"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTrigger.
func (s *ScheduleTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, "Pipelines", &s.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &s.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTriggerRecurrence.
func (s ScheduleTriggerRecurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "frequency", s.Frequency)
	populate(objectMap, "interval", s.Interval)
	populate(objectMap, "schedule", s.Schedule)
	populateDateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "timeZone", s.TimeZone)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTriggerRecurrence.
func (s *ScheduleTriggerRecurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &s.EndTime)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, "Frequency", &s.Frequency)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, "Interval", &s.Interval)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, "Schedule", &s.Schedule)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &s.StartTime)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &s.TimeZone)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTriggerTypeProperties.
func (s ScheduleTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "recurrence", s.Recurrence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTriggerTypeProperties.
func (s *ScheduleTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recurrence":
			err = unpopulate(val, "Recurrence", &s.Recurrence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptAction.
func (s ScriptAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "roles", s.Roles)
	populate(objectMap, "uri", s.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptAction.
func (s *ScriptAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "roles":
			err = unpopulate(val, "Roles", &s.Roles)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &s.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptActivity.
func (s ScriptActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "onInactiveMarkAs", s.OnInactiveMarkAs)
	populate(objectMap, "policy", s.Policy)
	populate(objectMap, "state", s.State)
	objectMap["type"] = "Script"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptActivity.
func (s *ScriptActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &s.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &s.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptActivityParameter.
func (s ScriptActivityParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "direction", s.Direction)
	populateAny(objectMap, "name", s.Name)
	populate(objectMap, "size", s.Size)
	populate(objectMap, "type", s.Type)
	populateAny(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptActivityParameter.
func (s *ScriptActivityParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "direction":
			err = unpopulate(val, "Direction", &s.Direction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, "Size", &s.Size)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptActivityScriptBlock.
func (s ScriptActivityScriptBlock) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "text", s.Text)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptActivityScriptBlock.
func (s *ScriptActivityScriptBlock) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &s.Text)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptActivityTypeProperties.
func (s ScriptActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logSettings", s.LogSettings)
	populateAny(objectMap, "scriptBlockExecutionTimeout", s.ScriptBlockExecutionTimeout)
	populate(objectMap, "scripts", s.Scripts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptActivityTypeProperties.
func (s *ScriptActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logSettings":
			err = unpopulate(val, "LogSettings", &s.LogSettings)
			delete(rawMsg, key)
		case "scriptBlockExecutionTimeout":
			err = unpopulate(val, "ScriptBlockExecutionTimeout", &s.ScriptBlockExecutionTimeout)
			delete(rawMsg, key)
		case "scripts":
			err = unpopulate(val, "Scripts", &s.Scripts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptActivityTypePropertiesLogSettings.
func (s ScriptActivityTypePropertiesLogSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logDestination", s.LogDestination)
	populate(objectMap, "logLocationSettings", s.LogLocationSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptActivityTypePropertiesLogSettings.
func (s *ScriptActivityTypePropertiesLogSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logDestination":
			err = unpopulate(val, "LogDestination", &s.LogDestination)
			delete(rawMsg, key)
		case "logLocationSettings":
			err = unpopulate(val, "LogLocationSettings", &s.LogLocationSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretBase.
func (s SecretBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = s.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretBase.
func (s *SecretBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecureInputOutputPolicy.
func (s SecureInputOutputPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secureInput", s.SecureInput)
	populate(objectMap, "secureOutput", s.SecureOutput)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecureInputOutputPolicy.
func (s *SecureInputOutputPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secureInput":
			err = unpopulate(val, "SecureInput", &s.SecureInput)
			delete(rawMsg, key)
		case "secureOutput":
			err = unpopulate(val, "SecureOutput", &s.SecureOutput)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecureString.
func (s SecureString) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = "SecureString"
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecureString.
func (s *SecureString) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfDependencyTumblingWindowTriggerReference.
func (s SelfDependencyTumblingWindowTriggerReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "offset", s.Offset)
	populate(objectMap, "size", s.Size)
	objectMap["type"] = "SelfDependencyTumblingWindowTriggerReference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfDependencyTumblingWindowTriggerReference.
func (s *SelfDependencyTumblingWindowTriggerReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "offset":
			err = unpopulate(val, "Offset", &s.Offset)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, "Size", &s.Size)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntime.
func (s SelfHostedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	objectMap["type"] = IntegrationRuntimeTypeSelfHosted
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntime.
func (s *SelfHostedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeNode.
func (s SelfHostedIntegrationRuntimeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capabilities", s.Capabilities)
	populate(objectMap, "concurrentJobsLimit", s.ConcurrentJobsLimit)
	populateDateTimeRFC3339(objectMap, "expiryTime", s.ExpiryTime)
	populate(objectMap, "hostServiceUri", s.HostServiceURI)
	populate(objectMap, "isActiveDispatcher", s.IsActiveDispatcher)
	populateDateTimeRFC3339(objectMap, "lastConnectTime", s.LastConnectTime)
	populateDateTimeRFC3339(objectMap, "lastEndUpdateTime", s.LastEndUpdateTime)
	populateDateTimeRFC3339(objectMap, "lastStartTime", s.LastStartTime)
	populateDateTimeRFC3339(objectMap, "lastStartUpdateTime", s.LastStartUpdateTime)
	populateDateTimeRFC3339(objectMap, "lastStopTime", s.LastStopTime)
	populate(objectMap, "lastUpdateResult", s.LastUpdateResult)
	populate(objectMap, "machineName", s.MachineName)
	populate(objectMap, "maxConcurrentJobs", s.MaxConcurrentJobs)
	populate(objectMap, "nodeName", s.NodeName)
	populateDateTimeRFC3339(objectMap, "registerTime", s.RegisterTime)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "version", s.Version)
	populate(objectMap, "versionStatus", s.VersionStatus)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeNode.
func (s *SelfHostedIntegrationRuntimeNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capabilities":
			err = unpopulate(val, "Capabilities", &s.Capabilities)
			delete(rawMsg, key)
		case "concurrentJobsLimit":
			err = unpopulate(val, "ConcurrentJobsLimit", &s.ConcurrentJobsLimit)
			delete(rawMsg, key)
		case "expiryTime":
			err = unpopulateDateTimeRFC3339(val, "ExpiryTime", &s.ExpiryTime)
			delete(rawMsg, key)
		case "hostServiceUri":
			err = unpopulate(val, "HostServiceURI", &s.HostServiceURI)
			delete(rawMsg, key)
		case "isActiveDispatcher":
			err = unpopulate(val, "IsActiveDispatcher", &s.IsActiveDispatcher)
			delete(rawMsg, key)
		case "lastConnectTime":
			err = unpopulateDateTimeRFC3339(val, "LastConnectTime", &s.LastConnectTime)
			delete(rawMsg, key)
		case "lastEndUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastEndUpdateTime", &s.LastEndUpdateTime)
			delete(rawMsg, key)
		case "lastStartTime":
			err = unpopulateDateTimeRFC3339(val, "LastStartTime", &s.LastStartTime)
			delete(rawMsg, key)
		case "lastStartUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastStartUpdateTime", &s.LastStartUpdateTime)
			delete(rawMsg, key)
		case "lastStopTime":
			err = unpopulateDateTimeRFC3339(val, "LastStopTime", &s.LastStopTime)
			delete(rawMsg, key)
		case "lastUpdateResult":
			err = unpopulate(val, "LastUpdateResult", &s.LastUpdateResult)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &s.MachineName)
			delete(rawMsg, key)
		case "maxConcurrentJobs":
			err = unpopulate(val, "MaxConcurrentJobs", &s.MaxConcurrentJobs)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, "NodeName", &s.NodeName)
			delete(rawMsg, key)
		case "registerTime":
			err = unpopulateDateTimeRFC3339(val, "RegisterTime", &s.RegisterTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		case "versionStatus":
			err = unpopulate(val, "VersionStatus", &s.VersionStatus)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeStatus.
func (s SelfHostedIntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataFactoryName", s.DataFactoryName)
	populate(objectMap, "state", s.State)
	objectMap["type"] = IntegrationRuntimeTypeSelfHosted
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeStatus.
func (s *SelfHostedIntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, "DataFactoryName", &s.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeStatusTypeProperties.
func (s SelfHostedIntegrationRuntimeStatusTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpdate", s.AutoUpdate)
	populateDateTimeRFC3339(objectMap, "autoUpdateETA", s.AutoUpdateETA)
	populate(objectMap, "capabilities", s.Capabilities)
	populateDateTimeRFC3339(objectMap, "createTime", s.CreateTime)
	populate(objectMap, "internalChannelEncryption", s.InternalChannelEncryption)
	populate(objectMap, "latestVersion", s.LatestVersion)
	populate(objectMap, "links", s.Links)
	populate(objectMap, "localTimeZoneOffset", s.LocalTimeZoneOffset)
	populate(objectMap, "nodes", s.Nodes)
	populate(objectMap, "pushedVersion", s.PushedVersion)
	populateDateTimeRFC3339(objectMap, "scheduledUpdateDate", s.ScheduledUpdateDate)
	populate(objectMap, "selfContainedInteractiveAuthoringEnabled", s.SelfContainedInteractiveAuthoringEnabled)
	populate(objectMap, "serviceUrls", s.ServiceUrls)
	populate(objectMap, "taskQueueId", s.TaskQueueID)
	populate(objectMap, "updateDelayOffset", s.UpdateDelayOffset)
	populate(objectMap, "version", s.Version)
	populate(objectMap, "versionStatus", s.VersionStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeStatusTypeProperties.
func (s *SelfHostedIntegrationRuntimeStatusTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpdate":
			err = unpopulate(val, "AutoUpdate", &s.AutoUpdate)
			delete(rawMsg, key)
		case "autoUpdateETA":
			err = unpopulateDateTimeRFC3339(val, "AutoUpdateETA", &s.AutoUpdateETA)
			delete(rawMsg, key)
		case "capabilities":
			err = unpopulate(val, "Capabilities", &s.Capabilities)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateDateTimeRFC3339(val, "CreateTime", &s.CreateTime)
			delete(rawMsg, key)
		case "internalChannelEncryption":
			err = unpopulate(val, "InternalChannelEncryption", &s.InternalChannelEncryption)
			delete(rawMsg, key)
		case "latestVersion":
			err = unpopulate(val, "LatestVersion", &s.LatestVersion)
			delete(rawMsg, key)
		case "links":
			err = unpopulate(val, "Links", &s.Links)
			delete(rawMsg, key)
		case "localTimeZoneOffset":
			err = unpopulate(val, "LocalTimeZoneOffset", &s.LocalTimeZoneOffset)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, "Nodes", &s.Nodes)
			delete(rawMsg, key)
		case "pushedVersion":
			err = unpopulate(val, "PushedVersion", &s.PushedVersion)
			delete(rawMsg, key)
		case "scheduledUpdateDate":
			err = unpopulateDateTimeRFC3339(val, "ScheduledUpdateDate", &s.ScheduledUpdateDate)
			delete(rawMsg, key)
		case "selfContainedInteractiveAuthoringEnabled":
			err = unpopulate(val, "SelfContainedInteractiveAuthoringEnabled", &s.SelfContainedInteractiveAuthoringEnabled)
			delete(rawMsg, key)
		case "serviceUrls":
			err = unpopulate(val, "ServiceUrls", &s.ServiceUrls)
			delete(rawMsg, key)
		case "taskQueueId":
			err = unpopulate(val, "TaskQueueID", &s.TaskQueueID)
			delete(rawMsg, key)
		case "updateDelayOffset":
			err = unpopulate(val, "UpdateDelayOffset", &s.UpdateDelayOffset)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		case "versionStatus":
			err = unpopulate(val, "VersionStatus", &s.VersionStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s SelfHostedIntegrationRuntimeTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "linkedInfo", s.LinkedInfo)
	populate(objectMap, "selfContainedInteractiveAuthoringEnabled", s.SelfContainedInteractiveAuthoringEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s *SelfHostedIntegrationRuntimeTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedInfo":
			s.LinkedInfo, err = unmarshalLinkedIntegrationRuntimeTypeClassification(val)
			delete(rawMsg, key)
		case "selfContainedInteractiveAuthoringEnabled":
			err = unpopulate(val, "SelfContainedInteractiveAuthoringEnabled", &s.SelfContainedInteractiveAuthoringEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowLinkedService.
func (s ServiceNowLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "ServiceNow"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedService.
func (s *ServiceNowLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowLinkedServiceTypeProperties.
func (s ServiceNowLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "clientSecret", s.ClientSecret)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "endpoint", s.Endpoint)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", s.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", s.UsePeerVerification)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedServiceTypeProperties.
func (s *ServiceNowLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &s.AuthenticationType)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			s.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &s.Endpoint)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &s.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowObjectDataset.
func (s ServiceNowObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "ServiceNowObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowObjectDataset.
func (s *ServiceNowObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowSource.
func (s ServiceNowSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "ServiceNowSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowSource.
func (s *ServiceNowSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalCredential.
func (s ServicePrincipalCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	objectMap["type"] = "ServicePrincipal"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalCredential.
func (s *ServicePrincipalCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalCredentialTypeProperties.
func (s ServicePrincipalCredentialTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "servicePrincipalId", s.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", s.ServicePrincipalKey)
	populateAny(objectMap, "tenant", s.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalCredentialTypeProperties.
func (s *ServicePrincipalCredentialTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &s.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			err = unpopulate(val, "ServicePrincipalKey", &s.ServicePrincipalKey)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &s.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SetVariableActivity.
func (s SetVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "onInactiveMarkAs", s.OnInactiveMarkAs)
	populate(objectMap, "policy", s.Policy)
	populate(objectMap, "state", s.State)
	objectMap["type"] = "SetVariable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SetVariableActivity.
func (s *SetVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &s.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &s.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SetVariableActivityTypeProperties.
func (s SetVariableActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "setSystemVariable", s.SetSystemVariable)
	populateAny(objectMap, "value", s.Value)
	populate(objectMap, "variableName", s.VariableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SetVariableActivityTypeProperties.
func (s *SetVariableActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "setSystemVariable":
			err = unpopulate(val, "SetSystemVariable", &s.SetSystemVariable)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		case "variableName":
			err = unpopulate(val, "VariableName", &s.VariableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SftpLocation.
func (s SftpLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "fileName", s.FileName)
	populateAny(objectMap, "folderPath", s.FolderPath)
	objectMap["type"] = "SftpLocation"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpLocation.
func (s *SftpLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &s.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, "FolderPath", &s.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SftpReadSettings.
func (s SftpReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "deleteFilesAfterCompletion", s.DeleteFilesAfterCompletion)
	populateAny(objectMap, "disableChunking", s.DisableChunking)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "enablePartitionDiscovery", s.EnablePartitionDiscovery)
	populateAny(objectMap, "fileListPath", s.FileListPath)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "modifiedDatetimeEnd", s.ModifiedDatetimeEnd)
	populateAny(objectMap, "modifiedDatetimeStart", s.ModifiedDatetimeStart)
	populateAny(objectMap, "partitionRootPath", s.PartitionRootPath)
	populateAny(objectMap, "recursive", s.Recursive)
	objectMap["type"] = "SftpReadSettings"
	populateAny(objectMap, "wildcardFileName", s.WildcardFileName)
	populateAny(objectMap, "wildcardFolderPath", s.WildcardFolderPath)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpReadSettings.
func (s *SftpReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, "DeleteFilesAfterCompletion", &s.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableChunking":
			err = unpopulate(val, "DisableChunking", &s.DisableChunking)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, "EnablePartitionDiscovery", &s.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, "FileListPath", &s.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, "ModifiedDatetimeEnd", &s.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, "ModifiedDatetimeStart", &s.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, "PartitionRootPath", &s.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, "Recursive", &s.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, "WildcardFileName", &s.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, "WildcardFolderPath", &s.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SftpServerLinkedService.
func (s SftpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Sftp"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedService.
func (s *SftpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SftpServerLinkedServiceTypeProperties.
func (s SftpServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "host", s.Host)
	populateAny(objectMap, "hostKeyFingerprint", s.HostKeyFingerprint)
	populate(objectMap, "passPhrase", s.PassPhrase)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "port", s.Port)
	populate(objectMap, "privateKeyContent", s.PrivateKeyContent)
	populateAny(objectMap, "privateKeyPath", s.PrivateKeyPath)
	populateAny(objectMap, "skipHostKeyValidation", s.SkipHostKeyValidation)
	populateAny(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedServiceTypeProperties.
func (s *SftpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &s.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &s.Host)
			delete(rawMsg, key)
		case "hostKeyFingerprint":
			err = unpopulate(val, "HostKeyFingerprint", &s.HostKeyFingerprint)
			delete(rawMsg, key)
		case "passPhrase":
			s.PassPhrase, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &s.Port)
			delete(rawMsg, key)
		case "privateKeyContent":
			s.PrivateKeyContent, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "privateKeyPath":
			err = unpopulate(val, "PrivateKeyPath", &s.PrivateKeyPath)
			delete(rawMsg, key)
		case "skipHostKeyValidation":
			err = unpopulate(val, "SkipHostKeyValidation", &s.SkipHostKeyValidation)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SftpWriteSettings.
func (s SftpWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", s.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "operationTimeout", s.OperationTimeout)
	objectMap["type"] = "SftpWriteSettings"
	populateAny(objectMap, "useTempFileRename", s.UseTempFileRename)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpWriteSettings.
func (s *SftpWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &s.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "operationTimeout":
			err = unpopulate(val, "OperationTimeout", &s.OperationTimeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "useTempFileRename":
			err = unpopulate(val, "UseTempFileRename", &s.UseTempFileRename)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListDatasetTypeProperties.
func (s SharePointOnlineListDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "listName", s.ListName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListDatasetTypeProperties.
func (s *SharePointOnlineListDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "listName":
			err = unpopulate(val, "ListName", &s.ListName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListLinkedService.
func (s SharePointOnlineListLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SharePointOnlineList"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListLinkedService.
func (s *SharePointOnlineListLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListLinkedServiceTypeProperties.
func (s SharePointOnlineListLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "servicePrincipalId", s.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", s.ServicePrincipalKey)
	populateAny(objectMap, "siteUrl", s.SiteURL)
	populateAny(objectMap, "tenantId", s.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListLinkedServiceTypeProperties.
func (s *SharePointOnlineListLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &s.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			s.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "siteUrl":
			err = unpopulate(val, "SiteURL", &s.SiteURL)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &s.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListResourceDataset.
func (s SharePointOnlineListResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SharePointOnlineListResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListResourceDataset.
func (s *SharePointOnlineListResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListSource.
func (s SharePointOnlineListSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SharePointOnlineListSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListSource.
func (s *SharePointOnlineListSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, "HTTPRequestTimeout", &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyLinkedService.
func (s ShopifyLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Shopify"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedService.
func (s *ShopifyLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyLinkedServiceTypeProperties.
func (s ShopifyLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", s.AccessToken)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "host", s.Host)
	populateAny(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", s.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", s.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedServiceTypeProperties.
func (s *ShopifyLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			s.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &s.Host)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &s.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyObjectDataset.
func (s ShopifyObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "ShopifyObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyObjectDataset.
func (s *ShopifyObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ShopifySource.
func (s ShopifySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "ShopifySource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifySource.
func (s *ShopifySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SkipErrorFile.
func (s SkipErrorFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "dataInconsistency", s.DataInconsistency)
	populateAny(objectMap, "fileMissing", s.FileMissing)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SkipErrorFile.
func (s *SkipErrorFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataInconsistency":
			err = unpopulate(val, "DataInconsistency", &s.DataInconsistency)
			delete(rawMsg, key)
		case "fileMissing":
			err = unpopulate(val, "FileMissing", &s.FileMissing)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SmartsheetLinkedService.
func (s SmartsheetLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Smartsheet"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SmartsheetLinkedService.
func (s *SmartsheetLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SmartsheetLinkedServiceTypeProperties.
func (s SmartsheetLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiToken", s.APIToken)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SmartsheetLinkedServiceTypeProperties.
func (s *SmartsheetLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiToken":
			s.APIToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeDataset.
func (s SnowflakeDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SnowflakeTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeDataset.
func (s *SnowflakeDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeDatasetTypeProperties.
func (s SnowflakeDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "table", s.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeDatasetTypeProperties.
func (s *SnowflakeDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &s.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeExportCopyCommand.
func (s SnowflakeExportCopyCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalCopyOptions", s.AdditionalCopyOptions)
	populate(objectMap, "additionalFormatOptions", s.AdditionalFormatOptions)
	objectMap["type"] = "SnowflakeExportCopyCommand"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeExportCopyCommand.
func (s *SnowflakeExportCopyCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCopyOptions":
			err = unpopulate(val, "AdditionalCopyOptions", &s.AdditionalCopyOptions)
			delete(rawMsg, key)
		case "additionalFormatOptions":
			err = unpopulate(val, "AdditionalFormatOptions", &s.AdditionalFormatOptions)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeImportCopyCommand.
func (s SnowflakeImportCopyCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalCopyOptions", s.AdditionalCopyOptions)
	populate(objectMap, "additionalFormatOptions", s.AdditionalFormatOptions)
	objectMap["type"] = "SnowflakeImportCopyCommand"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeImportCopyCommand.
func (s *SnowflakeImportCopyCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCopyOptions":
			err = unpopulate(val, "AdditionalCopyOptions", &s.AdditionalCopyOptions)
			delete(rawMsg, key)
		case "additionalFormatOptions":
			err = unpopulate(val, "AdditionalFormatOptions", &s.AdditionalFormatOptions)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeLinkedService.
func (s SnowflakeLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Snowflake"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeLinkedService.
func (s *SnowflakeLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeLinkedServiceTypeProperties.
func (s SnowflakeLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", s.ConnectionString)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeLinkedServiceTypeProperties.
func (s *SnowflakeLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &s.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &s.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeSink.
func (s SnowflakeSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "importSettings", s.ImportSettings)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "preCopyScript", s.PreCopyScript)
	populateAny(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populateAny(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SnowflakeSink"
	populateAny(objectMap, "writeBatchSize", s.WriteBatchSize)
	populateAny(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeSink.
func (s *SnowflakeSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "importSettings":
			err = unpopulate(val, "ImportSettings", &s.ImportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, "PreCopyScript", &s.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, "SinkRetryCount", &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, "SinkRetryWait", &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, "WriteBatchSize", &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, "WriteBatchTimeout", &s.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeSource.
func (s SnowflakeSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "exportSettings", s.ExportSettings)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SnowflakeSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeSource.
func (s *SnowflakeSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "exportSettings":
			err = unpopulate(val, "ExportSettings", &s.ExportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SparkConfigurationParametrizationReference.
func (s SparkConfigurationParametrizationReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "referenceName", s.ReferenceName)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkConfigurationParametrizationReference.
func (s *SparkConfigurationParametrizationReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &s.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SparkDatasetTypeProperties.
func (s SparkDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "table", s.Table)
	populateAny(objectMap, "tableName", s.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkDatasetTypeProperties.
func (s *SparkDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &s.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &s.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SparkLinkedService.
func (s SparkLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Spark"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedService.
func (s *SparkLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SparkLinkedServiceTypeProperties.
func (s SparkLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "allowHostNameCNMismatch", s.AllowHostNameCNMismatch)
	populateAny(objectMap, "allowSelfSignedServerCert", s.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populateAny(objectMap, "enableSsl", s.EnableSSL)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "httpPath", s.HTTPPath)
	populateAny(objectMap, "host", s.Host)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "port", s.Port)
	populate(objectMap, "serverType", s.ServerType)
	populate(objectMap, "thriftTransportProtocol", s.ThriftTransportProtocol)
	populateAny(objectMap, "trustedCertPath", s.TrustedCertPath)
	populateAny(objectMap, "useSystemTrustStore", s.UseSystemTrustStore)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedServiceTypeProperties.
func (s *SparkLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, "AllowHostNameCNMismatch", &s.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, "AllowSelfSignedServerCert", &s.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &s.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, "EnableSSL", &s.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, "HTTPPath", &s.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &s.Host)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &s.Port)
			delete(rawMsg, key)
		case "serverType":
			err = unpopulate(val, "ServerType", &s.ServerType)
			delete(rawMsg, key)
		case "thriftTransportProtocol":
			err = unpopulate(val, "ThriftTransportProtocol", &s.ThriftTransportProtocol)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, "TrustedCertPath", &s.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, "UseSystemTrustStore", &s.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SparkObjectDataset.
func (s SparkObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SparkObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkObjectDataset.
func (s *SparkObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SparkSource.
func (s SparkSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SparkSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkSource.
func (s *SparkSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SquareLinkedService.
func (s SquareLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Square"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedService.
func (s *SquareLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SquareLinkedServiceTypeProperties.
func (s SquareLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "clientId", s.ClientID)
	populate(objectMap, "clientSecret", s.ClientSecret)
	populateAny(objectMap, "connectionProperties", s.ConnectionProperties)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populateAny(objectMap, "host", s.Host)
	populateAny(objectMap, "redirectUri", s.RedirectURI)
	populateAny(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", s.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", s.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedServiceTypeProperties.
func (s *SquareLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			s.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &s.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &s.Host)
			delete(rawMsg, key)
		case "redirectUri":
			err = unpopulate(val, "RedirectURI", &s.RedirectURI)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &s.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SquareObjectDataset.
func (s SquareObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SquareObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareObjectDataset.
func (s *SquareObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SquareSource.
func (s SquareSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SquareSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareSource.
func (s *SquareSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisEnvironment.
func (s SsisEnvironment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = SsisObjectMetadataTypeEnvironment
	populate(objectMap, "variables", s.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisEnvironment.
func (s *SsisEnvironment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, "FolderID", &s.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, "Variables", &s.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisEnvironmentReference.
func (s SsisEnvironmentReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "environmentFolderName", s.EnvironmentFolderName)
	populate(objectMap, "environmentName", s.EnvironmentName)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "referenceType", s.ReferenceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisEnvironmentReference.
func (s *SsisEnvironmentReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "environmentFolderName":
			err = unpopulate(val, "EnvironmentFolderName", &s.EnvironmentFolderName)
			delete(rawMsg, key)
		case "environmentName":
			err = unpopulate(val, "EnvironmentName", &s.EnvironmentName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "referenceType":
			err = unpopulate(val, "ReferenceType", &s.ReferenceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisFolder.
func (s SsisFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = SsisObjectMetadataTypeFolder
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisFolder.
func (s *SsisFolder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisObjectMetadata.
func (s SsisObjectMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = s.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisObjectMetadata.
func (s *SsisObjectMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisObjectMetadataListResponse.
func (s SsisObjectMetadataListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisObjectMetadataListResponse.
func (s *SsisObjectMetadataListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			s.Value, err = unmarshalSsisObjectMetadataClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisObjectMetadataStatusResponse.
func (s SsisObjectMetadataStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", s.Error)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisObjectMetadataStatusResponse.
func (s *SsisObjectMetadataStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &s.Error)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisPackage.
func (s SsisPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "projectId", s.ProjectID)
	populate(objectMap, "projectVersion", s.ProjectVersion)
	objectMap["type"] = SsisObjectMetadataTypePackage
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisPackage.
func (s *SsisPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, "FolderID", &s.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "projectId":
			err = unpopulate(val, "ProjectID", &s.ProjectID)
			delete(rawMsg, key)
		case "projectVersion":
			err = unpopulate(val, "ProjectVersion", &s.ProjectVersion)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisParameter.
func (s SsisParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataType", s.DataType)
	populate(objectMap, "defaultValue", s.DefaultValue)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "designDefaultValue", s.DesignDefaultValue)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "required", s.Required)
	populate(objectMap, "sensitive", s.Sensitive)
	populate(objectMap, "sensitiveDefaultValue", s.SensitiveDefaultValue)
	populate(objectMap, "valueSet", s.ValueSet)
	populate(objectMap, "valueType", s.ValueType)
	populate(objectMap, "variable", s.Variable)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisParameter.
func (s *SsisParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &s.DataType)
			delete(rawMsg, key)
		case "defaultValue":
			err = unpopulate(val, "DefaultValue", &s.DefaultValue)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "designDefaultValue":
			err = unpopulate(val, "DesignDefaultValue", &s.DesignDefaultValue)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "required":
			err = unpopulate(val, "Required", &s.Required)
			delete(rawMsg, key)
		case "sensitive":
			err = unpopulate(val, "Sensitive", &s.Sensitive)
			delete(rawMsg, key)
		case "sensitiveDefaultValue":
			err = unpopulate(val, "SensitiveDefaultValue", &s.SensitiveDefaultValue)
			delete(rawMsg, key)
		case "valueSet":
			err = unpopulate(val, "ValueSet", &s.ValueSet)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &s.ValueType)
			delete(rawMsg, key)
		case "variable":
			err = unpopulate(val, "Variable", &s.Variable)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisProject.
func (s SsisProject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "environmentRefs", s.EnvironmentRefs)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = SsisObjectMetadataTypeProject
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisProject.
func (s *SsisProject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "environmentRefs":
			err = unpopulate(val, "EnvironmentRefs", &s.EnvironmentRefs)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, "FolderID", &s.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SsisVariable.
func (s SsisVariable) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataType", s.DataType)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "sensitive", s.Sensitive)
	populate(objectMap, "sensitiveValue", s.SensitiveValue)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisVariable.
func (s *SsisVariable) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &s.DataType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "sensitive":
			err = unpopulate(val, "Sensitive", &s.Sensitive)
			delete(rawMsg, key)
		case "sensitiveValue":
			err = unpopulate(val, "SensitiveValue", &s.SensitiveValue)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StagingSettings.
func (s StagingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "enableCompression", s.EnableCompression)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populateAny(objectMap, "path", s.Path)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StagingSettings.
func (s *StagingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableCompression":
			err = unpopulate(val, "EnableCompression", &s.EnableCompression)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &s.Path)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StoreReadSettings.
func (s StoreReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	objectMap["type"] = s.Type
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StoreReadSettings.
func (s *StoreReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StoreWriteSettings.
func (s StoreWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "copyBehavior", s.CopyBehavior)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	objectMap["type"] = s.Type
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StoreWriteSettings.
func (s *StoreWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, "CopyBehavior", &s.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SwitchActivity.
func (s SwitchActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "onInactiveMarkAs", s.OnInactiveMarkAs)
	populate(objectMap, "state", s.State)
	objectMap["type"] = "Switch"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivity.
func (s *SwitchActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &s.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SwitchActivityTypeProperties.
func (s SwitchActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cases", s.Cases)
	populate(objectMap, "defaultActivities", s.DefaultActivities)
	populate(objectMap, "on", s.On)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivityTypeProperties.
func (s *SwitchActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cases":
			err = unpopulate(val, "Cases", &s.Cases)
			delete(rawMsg, key)
		case "defaultActivities":
			s.DefaultActivities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "on":
			err = unpopulate(val, "On", &s.On)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SwitchCase.
func (s SwitchCase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activities", s.Activities)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchCase.
func (s *SwitchCase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			s.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SybaseLinkedService.
func (s SybaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Sybase"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedService.
func (s *SybaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SybaseLinkedServiceTypeProperties.
func (s SybaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populateAny(objectMap, "database", s.Database)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "server", s.Server)
	populateAny(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedServiceTypeProperties.
func (s *SybaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &s.AuthenticationType)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &s.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SybaseSource.
func (s SybaseSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", s.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populateAny(objectMap, "query", s.Query)
	populateAny(objectMap, "queryTimeout", s.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SybaseSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseSource.
func (s *SybaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SybaseTableDataset.
func (s SybaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populateAny(objectMap, "schema", s.Schema)
	populateAny(objectMap, "structure", s.Structure)
	objectMap["type"] = "SybaseTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseTableDataset.
func (s *SybaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SybaseTableDatasetTypeProperties.
func (s SybaseTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tableName", s.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseTableDatasetTypeProperties.
func (s *SybaseTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tableName":
			err = unpopulate(val, "TableName", &s.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseNotebookActivity.
func (s SynapseNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "onInactiveMarkAs", s.OnInactiveMarkAs)
	populate(objectMap, "policy", s.Policy)
	populate(objectMap, "state", s.State)
	objectMap["type"] = "SynapseNotebook"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseNotebookActivity.
func (s *SynapseNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &s.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &s.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseNotebookActivityTypeProperties.
func (s SynapseNotebookActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "conf", s.Conf)
	populate(objectMap, "configurationType", s.ConfigurationType)
	populateAny(objectMap, "driverSize", s.DriverSize)
	populateAny(objectMap, "executorSize", s.ExecutorSize)
	populate(objectMap, "notebook", s.Notebook)
	populateAny(objectMap, "numExecutors", s.NumExecutors)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "sparkConfig", s.SparkConfig)
	populate(objectMap, "sparkPool", s.SparkPool)
	populate(objectMap, "targetSparkConfiguration", s.TargetSparkConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseNotebookActivityTypeProperties.
func (s *SynapseNotebookActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conf":
			err = unpopulate(val, "Conf", &s.Conf)
			delete(rawMsg, key)
		case "configurationType":
			err = unpopulate(val, "ConfigurationType", &s.ConfigurationType)
			delete(rawMsg, key)
		case "driverSize":
			err = unpopulate(val, "DriverSize", &s.DriverSize)
			delete(rawMsg, key)
		case "executorSize":
			err = unpopulate(val, "ExecutorSize", &s.ExecutorSize)
			delete(rawMsg, key)
		case "notebook":
			err = unpopulate(val, "Notebook", &s.Notebook)
			delete(rawMsg, key)
		case "numExecutors":
			err = unpopulate(val, "NumExecutors", &s.NumExecutors)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "sparkConfig":
			err = unpopulate(val, "SparkConfig", &s.SparkConfig)
			delete(rawMsg, key)
		case "sparkPool":
			err = unpopulate(val, "SparkPool", &s.SparkPool)
			delete(rawMsg, key)
		case "targetSparkConfiguration":
			err = unpopulate(val, "TargetSparkConfiguration", &s.TargetSparkConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseNotebookReference.
func (s SynapseNotebookReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "referenceName", s.ReferenceName)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseNotebookReference.
func (s *SynapseNotebookReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &s.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSparkJobActivityTypeProperties.
func (s SynapseSparkJobActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "args", s.Arguments)
	populateAny(objectMap, "className", s.ClassName)
	populateAny(objectMap, "conf", s.Conf)
	populate(objectMap, "configurationType", s.ConfigurationType)
	populateAny(objectMap, "driverSize", s.DriverSize)
	populateAny(objectMap, "executorSize", s.ExecutorSize)
	populateAny(objectMap, "file", s.File)
	populate(objectMap, "files", s.Files)
	populate(objectMap, "filesV2", s.FilesV2)
	populateAny(objectMap, "numExecutors", s.NumExecutors)
	populate(objectMap, "pythonCodeReference", s.PythonCodeReference)
	populateAny(objectMap, "scanFolder", s.ScanFolder)
	populate(objectMap, "sparkConfig", s.SparkConfig)
	populate(objectMap, "sparkJob", s.SparkJob)
	populate(objectMap, "targetBigDataPool", s.TargetBigDataPool)
	populate(objectMap, "targetSparkConfiguration", s.TargetSparkConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSparkJobActivityTypeProperties.
func (s *SynapseSparkJobActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "args":
			err = unpopulate(val, "Arguments", &s.Arguments)
			delete(rawMsg, key)
		case "className":
			err = unpopulate(val, "ClassName", &s.ClassName)
			delete(rawMsg, key)
		case "conf":
			err = unpopulate(val, "Conf", &s.Conf)
			delete(rawMsg, key)
		case "configurationType":
			err = unpopulate(val, "ConfigurationType", &s.ConfigurationType)
			delete(rawMsg, key)
		case "driverSize":
			err = unpopulate(val, "DriverSize", &s.DriverSize)
			delete(rawMsg, key)
		case "executorSize":
			err = unpopulate(val, "ExecutorSize", &s.ExecutorSize)
			delete(rawMsg, key)
		case "file":
			err = unpopulate(val, "File", &s.File)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, "Files", &s.Files)
			delete(rawMsg, key)
		case "filesV2":
			err = unpopulate(val, "FilesV2", &s.FilesV2)
			delete(rawMsg, key)
		case "numExecutors":
			err = unpopulate(val, "NumExecutors", &s.NumExecutors)
			delete(rawMsg, key)
		case "pythonCodeReference":
			err = unpopulate(val, "PythonCodeReference", &s.PythonCodeReference)
			delete(rawMsg, key)
		case "scanFolder":
			err = unpopulate(val, "ScanFolder", &s.ScanFolder)
			delete(rawMsg, key)
		case "sparkConfig":
			err = unpopulate(val, "SparkConfig", &s.SparkConfig)
			delete(rawMsg, key)
		case "sparkJob":
			err = unpopulate(val, "SparkJob", &s.SparkJob)
			delete(rawMsg, key)
		case "targetBigDataPool":
			err = unpopulate(val, "TargetBigDataPool", &s.TargetBigDataPool)
			delete(rawMsg, key)
		case "targetSparkConfiguration":
			err = unpopulate(val, "TargetSparkConfiguration", &s.TargetSparkConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSparkJobDefinitionActivity.
func (s SynapseSparkJobDefinitionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "onInactiveMarkAs", s.OnInactiveMarkAs)
	populate(objectMap, "policy", s.Policy)
	populate(objectMap, "state", s.State)
	objectMap["type"] = "SparkJob"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSparkJobDefinitionActivity.
func (s *SynapseSparkJobDefinitionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &s.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &s.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &s.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSparkJobReference.
func (s SynapseSparkJobReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "referenceName", s.ReferenceName)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSparkJobReference.
func (s *SynapseSparkJobReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &s.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TabularSource.
func (t TabularSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", t.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", t.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", t.MaxConcurrentConnections)
	populateAny(objectMap, "queryTimeout", t.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", t.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", t.SourceRetryWait)
	objectMap["type"] = "TabularSource"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TabularSource.
func (t *TabularSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &t.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &t.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &t.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &t.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &t.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &t.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TarGZipReadSettings.
func (t TarGZipReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "preserveCompressionFileNameAsFolder", t.PreserveCompressionFileNameAsFolder)
	objectMap["type"] = "TarGZipReadSettings"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TarGZipReadSettings.
func (t *TarGZipReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preserveCompressionFileNameAsFolder":
			err = unpopulate(val, "PreserveCompressionFileNameAsFolder", &t.PreserveCompressionFileNameAsFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TarReadSettings.
func (t TarReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "preserveCompressionFileNameAsFolder", t.PreserveCompressionFileNameAsFolder)
	objectMap["type"] = "TarReadSettings"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TarReadSettings.
func (t *TarReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preserveCompressionFileNameAsFolder":
			err = unpopulate(val, "PreserveCompressionFileNameAsFolder", &t.PreserveCompressionFileNameAsFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeamDeskLinkedService.
func (t TeamDeskLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "connectVia", t.ConnectVia)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "parameters", t.Parameters)
	objectMap["type"] = "TeamDesk"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeamDeskLinkedService.
func (t *TeamDeskLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &t.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &t.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeamDeskLinkedServiceTypeProperties.
func (t TeamDeskLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiToken", t.APIToken)
	populate(objectMap, "authenticationType", t.AuthenticationType)
	populate(objectMap, "encryptedCredential", t.EncryptedCredential)
	populate(objectMap, "password", t.Password)
	populateAny(objectMap, "url", t.URL)
	populateAny(objectMap, "userName", t.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeamDeskLinkedServiceTypeProperties.
func (t *TeamDeskLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiToken":
			t.APIToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &t.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &t.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			t.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &t.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &t.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeradataLinkedService.
func (t TeradataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "connectVia", t.ConnectVia)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "parameters", t.Parameters)
	objectMap["type"] = "Teradata"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedService.
func (t *TeradataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &t.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &t.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeradataLinkedServiceTypeProperties.
func (t TeradataLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationType", t.AuthenticationType)
	populateAny(objectMap, "connectionString", t.ConnectionString)
	populate(objectMap, "encryptedCredential", t.EncryptedCredential)
	populate(objectMap, "password", t.Password)
	populateAny(objectMap, "server", t.Server)
	populateAny(objectMap, "username", t.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedServiceTypeProperties.
func (t *TeradataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &t.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &t.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &t.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			t.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &t.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &t.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeradataPartitionSettings.
func (t TeradataPartitionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "partitionColumnName", t.PartitionColumnName)
	populateAny(objectMap, "partitionLowerBound", t.PartitionLowerBound)
	populateAny(objectMap, "partitionUpperBound", t.PartitionUpperBound)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataPartitionSettings.
func (t *TeradataPartitionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionColumnName":
			err = unpopulate(val, "PartitionColumnName", &t.PartitionColumnName)
			delete(rawMsg, key)
		case "partitionLowerBound":
			err = unpopulate(val, "PartitionLowerBound", &t.PartitionLowerBound)
			delete(rawMsg, key)
		case "partitionUpperBound":
			err = unpopulate(val, "PartitionUpperBound", &t.PartitionUpperBound)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeradataSource.
func (t TeradataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", t.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", t.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", t.MaxConcurrentConnections)
	populateAny(objectMap, "partitionOption", t.PartitionOption)
	populate(objectMap, "partitionSettings", t.PartitionSettings)
	populateAny(objectMap, "query", t.Query)
	populateAny(objectMap, "queryTimeout", t.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", t.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", t.SourceRetryWait)
	objectMap["type"] = "TeradataSource"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataSource.
func (t *TeradataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &t.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &t.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &t.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, "PartitionOption", &t.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, "PartitionSettings", &t.PartitionSettings)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &t.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &t.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &t.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &t.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeradataTableDataset.
func (t TeradataTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "folder", t.Folder)
	populate(objectMap, "linkedServiceName", t.LinkedServiceName)
	populate(objectMap, "parameters", t.Parameters)
	populateAny(objectMap, "schema", t.Schema)
	populateAny(objectMap, "structure", t.Structure)
	objectMap["type"] = "TeradataTable"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataTableDataset.
func (t *TeradataTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &t.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &t.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &t.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &t.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &t.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeradataTableDatasetTypeProperties.
func (t TeradataTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "database", t.Database)
	populateAny(objectMap, "table", t.Table)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataTableDatasetTypeProperties.
func (t *TeradataTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			err = unpopulate(val, "Database", &t.Database)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &t.Table)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextFormat.
func (t TextFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "columnDelimiter", t.ColumnDelimiter)
	populateAny(objectMap, "deserializer", t.Deserializer)
	populateAny(objectMap, "encodingName", t.EncodingName)
	populateAny(objectMap, "escapeChar", t.EscapeChar)
	populateAny(objectMap, "firstRowAsHeader", t.FirstRowAsHeader)
	populateAny(objectMap, "nullValue", t.NullValue)
	populateAny(objectMap, "quoteChar", t.QuoteChar)
	populateAny(objectMap, "rowDelimiter", t.RowDelimiter)
	populateAny(objectMap, "serializer", t.Serializer)
	populateAny(objectMap, "skipLineCount", t.SkipLineCount)
	populateAny(objectMap, "treatEmptyAsNull", t.TreatEmptyAsNull)
	objectMap["type"] = "TextFormat"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextFormat.
func (t *TextFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			err = unpopulate(val, "ColumnDelimiter", &t.ColumnDelimiter)
			delete(rawMsg, key)
		case "deserializer":
			err = unpopulate(val, "Deserializer", &t.Deserializer)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, "EncodingName", &t.EncodingName)
			delete(rawMsg, key)
		case "escapeChar":
			err = unpopulate(val, "EscapeChar", &t.EscapeChar)
			delete(rawMsg, key)
		case "firstRowAsHeader":
			err = unpopulate(val, "FirstRowAsHeader", &t.FirstRowAsHeader)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, "NullValue", &t.NullValue)
			delete(rawMsg, key)
		case "quoteChar":
			err = unpopulate(val, "QuoteChar", &t.QuoteChar)
			delete(rawMsg, key)
		case "rowDelimiter":
			err = unpopulate(val, "RowDelimiter", &t.RowDelimiter)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, "Serializer", &t.Serializer)
			delete(rawMsg, key)
		case "skipLineCount":
			err = unpopulate(val, "SkipLineCount", &t.SkipLineCount)
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			err = unpopulate(val, "TreatEmptyAsNull", &t.TreatEmptyAsNull)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Transformation.
func (t Transformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataset", t.Dataset)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "flowlet", t.Flowlet)
	populate(objectMap, "linkedService", t.LinkedService)
	populate(objectMap, "name", t.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Transformation.
func (t *Transformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, "Dataset", &t.Dataset)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "flowlet":
			err = unpopulate(val, "Flowlet", &t.Flowlet)
			delete(rawMsg, key)
		case "linkedService":
			err = unpopulate(val, "LinkedService", &t.LinkedService)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Trigger.
func (t Trigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "runtimeState", t.RuntimeState)
	objectMap["type"] = t.Type
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Trigger.
func (t *Trigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &t.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &t.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerDependencyReference.
func (t TriggerDependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "referenceTrigger", t.ReferenceTrigger)
	objectMap["type"] = "TriggerDependencyReference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerDependencyReference.
func (t *TriggerDependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceTrigger":
			err = unpopulate(val, "ReferenceTrigger", &t.ReferenceTrigger)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerFilterParameters.
func (t TriggerFilterParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", t.ContinuationToken)
	populate(objectMap, "parentTriggerName", t.ParentTriggerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerFilterParameters.
func (t *TriggerFilterParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &t.ContinuationToken)
			delete(rawMsg, key)
		case "parentTriggerName":
			err = unpopulate(val, "ParentTriggerName", &t.ParentTriggerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerListResponse.
func (t TriggerListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerListResponse.
func (t *TriggerListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerPipelineReference.
func (t TriggerPipelineReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", t.Parameters)
	populate(objectMap, "pipelineReference", t.PipelineReference)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerPipelineReference.
func (t *TriggerPipelineReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "pipelineReference":
			err = unpopulate(val, "PipelineReference", &t.PipelineReference)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerQueryResponse.
func (t TriggerQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", t.ContinuationToken)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerQueryResponse.
func (t *TriggerQueryResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &t.ContinuationToken)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerReference.
func (t TriggerReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "referenceName", t.ReferenceName)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerReference.
func (t *TriggerReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, "ReferenceName", &t.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerResource.
func (t TriggerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerResource.
func (t *TriggerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &t.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "properties":
			t.Properties, err = unmarshalTriggerClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerRun.
func (t TriggerRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependencyStatus", t.DependencyStatus)
	populate(objectMap, "message", t.Message)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "runDimension", t.RunDimension)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "triggerName", t.TriggerName)
	populate(objectMap, "triggerRunId", t.TriggerRunID)
	populateDateTimeRFC3339(objectMap, "triggerRunTimestamp", t.TriggerRunTimestamp)
	populate(objectMap, "triggerType", t.TriggerType)
	populate(objectMap, "triggeredPipelines", t.TriggeredPipelines)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerRun.
func (t *TriggerRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependencyStatus":
			err = unpopulate(val, "DependencyStatus", &t.DependencyStatus)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &t.Message)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "runDimension":
			err = unpopulate(val, "RunDimension", &t.RunDimension)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		case "triggerName":
			err = unpopulate(val, "TriggerName", &t.TriggerName)
			delete(rawMsg, key)
		case "triggerRunId":
			err = unpopulate(val, "TriggerRunID", &t.TriggerRunID)
			delete(rawMsg, key)
		case "triggerRunTimestamp":
			err = unpopulateDateTimeRFC3339(val, "TriggerRunTimestamp", &t.TriggerRunTimestamp)
			delete(rawMsg, key)
		case "triggerType":
			err = unpopulate(val, "TriggerType", &t.TriggerType)
			delete(rawMsg, key)
		case "triggeredPipelines":
			err = unpopulate(val, "TriggeredPipelines", &t.TriggeredPipelines)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerRunsQueryResponse.
func (t TriggerRunsQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", t.ContinuationToken)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerRunsQueryResponse.
func (t *TriggerRunsQueryResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &t.ContinuationToken)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerSubscriptionOperationStatus.
func (t TriggerSubscriptionOperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "triggerName", t.TriggerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerSubscriptionOperationStatus.
func (t *TriggerSubscriptionOperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		case "triggerName":
			err = unpopulate(val, "TriggerName", &t.TriggerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTrigger.
func (t TumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "pipeline", t.Pipeline)
	populate(objectMap, "runtimeState", t.RuntimeState)
	objectMap["type"] = "TumblingWindowTrigger"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTrigger.
func (t *TumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &t.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "pipeline":
			err = unpopulate(val, "Pipeline", &t.Pipeline)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, "RuntimeState", &t.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTriggerDependencyReference.
func (t TumblingWindowTriggerDependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "offset", t.Offset)
	populate(objectMap, "referenceTrigger", t.ReferenceTrigger)
	populate(objectMap, "size", t.Size)
	objectMap["type"] = "TumblingWindowTriggerDependencyReference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTriggerDependencyReference.
func (t *TumblingWindowTriggerDependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "offset":
			err = unpopulate(val, "Offset", &t.Offset)
			delete(rawMsg, key)
		case "referenceTrigger":
			err = unpopulate(val, "ReferenceTrigger", &t.ReferenceTrigger)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, "Size", &t.Size)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTriggerTypeProperties.
func (t TumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "delay", t.Delay)
	populate(objectMap, "dependsOn", t.DependsOn)
	populateDateTimeRFC3339(objectMap, "endTime", t.EndTime)
	populate(objectMap, "frequency", t.Frequency)
	populate(objectMap, "interval", t.Interval)
	populate(objectMap, "maxConcurrency", t.MaxConcurrency)
	populate(objectMap, "retryPolicy", t.RetryPolicy)
	populateDateTimeRFC3339(objectMap, "startTime", t.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTriggerTypeProperties.
func (t *TumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delay":
			err = unpopulate(val, "Delay", &t.Delay)
			delete(rawMsg, key)
		case "dependsOn":
			t.DependsOn, err = unmarshalDependencyReferenceClassificationArray(val)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &t.EndTime)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, "Frequency", &t.Frequency)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, "Interval", &t.Interval)
			delete(rawMsg, key)
		case "maxConcurrency":
			err = unpopulate(val, "MaxConcurrency", &t.MaxConcurrency)
			delete(rawMsg, key)
		case "retryPolicy":
			err = unpopulate(val, "RetryPolicy", &t.RetryPolicy)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &t.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TwilioLinkedService.
func (t TwilioLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "connectVia", t.ConnectVia)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "parameters", t.Parameters)
	objectMap["type"] = "Twilio"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TwilioLinkedService.
func (t *TwilioLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &t.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &t.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TwilioLinkedServiceTypeProperties.
func (t TwilioLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "password", t.Password)
	populateAny(objectMap, "userName", t.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TwilioLinkedServiceTypeProperties.
func (t *TwilioLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			t.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &t.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UntilActivity.
func (u UntilActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", u.DependsOn)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "onInactiveMarkAs", u.OnInactiveMarkAs)
	populate(objectMap, "state", u.State)
	objectMap["type"] = "Until"
	populate(objectMap, "typeProperties", u.TypeProperties)
	populate(objectMap, "userProperties", u.UserProperties)
	if u.AdditionalProperties != nil {
		for key, val := range u.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivity.
func (u *UntilActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &u.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &u.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &u.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &u.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &u.UserProperties)
			delete(rawMsg, key)
		default:
			if u.AdditionalProperties == nil {
				u.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				u.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UntilActivityTypeProperties.
func (u UntilActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activities", u.Activities)
	populate(objectMap, "expression", u.Expression)
	populateAny(objectMap, "timeout", u.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivityTypeProperties.
func (u *UntilActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			u.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, "Expression", &u.Expression)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &u.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIntegrationRuntimeNodeRequest.
func (u UpdateIntegrationRuntimeNodeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "concurrentJobsLimit", u.ConcurrentJobsLimit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateIntegrationRuntimeNodeRequest.
func (u *UpdateIntegrationRuntimeNodeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "concurrentJobsLimit":
			err = unpopulate(val, "ConcurrentJobsLimit", &u.ConcurrentJobsLimit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIntegrationRuntimeRequest.
func (u UpdateIntegrationRuntimeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpdate", u.AutoUpdate)
	populate(objectMap, "updateDelayOffset", u.UpdateDelayOffset)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateIntegrationRuntimeRequest.
func (u *UpdateIntegrationRuntimeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpdate":
			err = unpopulate(val, "AutoUpdate", &u.AutoUpdate)
			delete(rawMsg, key)
		case "updateDelayOffset":
			err = unpopulate(val, "UpdateDelayOffset", &u.UpdateDelayOffset)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAccessPolicy.
func (u UserAccessPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessResourcePath", u.AccessResourcePath)
	populate(objectMap, "expireTime", u.ExpireTime)
	populate(objectMap, "permissions", u.Permissions)
	populate(objectMap, "profileName", u.ProfileName)
	populate(objectMap, "startTime", u.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAccessPolicy.
func (u *UserAccessPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessResourcePath":
			err = unpopulate(val, "AccessResourcePath", &u.AccessResourcePath)
			delete(rawMsg, key)
		case "expireTime":
			err = unpopulate(val, "ExpireTime", &u.ExpireTime)
			delete(rawMsg, key)
		case "permissions":
			err = unpopulate(val, "Permissions", &u.Permissions)
			delete(rawMsg, key)
		case "profileName":
			err = unpopulate(val, "ProfileName", &u.ProfileName)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &u.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserProperty.
func (u UserProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", u.Name)
	populateAny(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserProperty.
func (u *UserProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidationActivity.
func (v ValidationActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", v.DependsOn)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "onInactiveMarkAs", v.OnInactiveMarkAs)
	populate(objectMap, "state", v.State)
	objectMap["type"] = "Validation"
	populate(objectMap, "typeProperties", v.TypeProperties)
	populate(objectMap, "userProperties", v.UserProperties)
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationActivity.
func (v *ValidationActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &v.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &v.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &v.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &v.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &v.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &v.UserProperties)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidationActivityTypeProperties.
func (v ValidationActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "childItems", v.ChildItems)
	populate(objectMap, "dataset", v.Dataset)
	populateAny(objectMap, "minimumSize", v.MinimumSize)
	populateAny(objectMap, "sleep", v.Sleep)
	populateAny(objectMap, "timeout", v.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationActivityTypeProperties.
func (v *ValidationActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "childItems":
			err = unpopulate(val, "ChildItems", &v.ChildItems)
			delete(rawMsg, key)
		case "dataset":
			err = unpopulate(val, "Dataset", &v.Dataset)
			delete(rawMsg, key)
		case "minimumSize":
			err = unpopulate(val, "MinimumSize", &v.MinimumSize)
			delete(rawMsg, key)
		case "sleep":
			err = unpopulate(val, "Sleep", &v.Sleep)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &v.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VariableSpecification.
func (v VariableSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "defaultValue", v.DefaultValue)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VariableSpecification.
func (v *VariableSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultValue":
			err = unpopulate(val, "DefaultValue", &v.DefaultValue)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerticaDatasetTypeProperties.
func (v VerticaDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "schema", v.Schema)
	populateAny(objectMap, "table", v.Table)
	populateAny(objectMap, "tableName", v.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaDatasetTypeProperties.
func (v *VerticaDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schema":
			err = unpopulate(val, "Schema", &v.Schema)
			delete(rawMsg, key)
		case "table":
			err = unpopulate(val, "Table", &v.Table)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &v.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerticaLinkedService.
func (v VerticaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", v.Annotations)
	populate(objectMap, "connectVia", v.ConnectVia)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "parameters", v.Parameters)
	objectMap["type"] = "Vertica"
	populate(objectMap, "typeProperties", v.TypeProperties)
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaLinkedService.
func (v *VerticaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &v.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &v.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &v.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &v.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &v.TypeProperties)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerticaLinkedServiceTypeProperties.
func (v VerticaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionString", v.ConnectionString)
	populate(objectMap, "encryptedCredential", v.EncryptedCredential)
	populate(objectMap, "pwd", v.Pwd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaLinkedServiceTypeProperties.
func (v *VerticaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &v.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &v.EncryptedCredential)
			delete(rawMsg, key)
		case "pwd":
			err = unpopulate(val, "Pwd", &v.Pwd)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerticaSource.
func (v VerticaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", v.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", v.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", v.MaxConcurrentConnections)
	populateAny(objectMap, "query", v.Query)
	populateAny(objectMap, "queryTimeout", v.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", v.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", v.SourceRetryWait)
	objectMap["type"] = "VerticaSource"
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaSource.
func (v *VerticaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &v.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &v.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &v.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &v.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &v.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &v.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &v.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerticaTableDataset.
func (v VerticaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", v.Annotations)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "folder", v.Folder)
	populate(objectMap, "linkedServiceName", v.LinkedServiceName)
	populate(objectMap, "parameters", v.Parameters)
	populateAny(objectMap, "schema", v.Schema)
	populateAny(objectMap, "structure", v.Structure)
	objectMap["type"] = "VerticaTable"
	populate(objectMap, "typeProperties", v.TypeProperties)
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaTableDataset.
func (v *VerticaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &v.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &v.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &v.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &v.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &v.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &v.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &v.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &v.TypeProperties)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WaitActivity.
func (w WaitActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", w.DependsOn)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "onInactiveMarkAs", w.OnInactiveMarkAs)
	populate(objectMap, "state", w.State)
	objectMap["type"] = "Wait"
	populate(objectMap, "typeProperties", w.TypeProperties)
	populate(objectMap, "userProperties", w.UserProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WaitActivity.
func (w *WaitActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &w.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &w.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &w.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &w.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &w.UserProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WaitActivityTypeProperties.
func (w WaitActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "waitTimeInSeconds", w.WaitTimeInSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WaitActivityTypeProperties.
func (w *WaitActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "waitTimeInSeconds":
			err = unpopulate(val, "WaitTimeInSeconds", &w.WaitTimeInSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebActivity.
func (w WebActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", w.DependsOn)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "linkedServiceName", w.LinkedServiceName)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "onInactiveMarkAs", w.OnInactiveMarkAs)
	populate(objectMap, "policy", w.Policy)
	populate(objectMap, "state", w.State)
	objectMap["type"] = "WebActivity"
	populate(objectMap, "typeProperties", w.TypeProperties)
	populate(objectMap, "userProperties", w.UserProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivity.
func (w *WebActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &w.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &w.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &w.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &w.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &w.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &w.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &w.UserProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebActivityAuthentication.
func (w WebActivityAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "credential", w.Credential)
	populate(objectMap, "password", w.Password)
	populate(objectMap, "pfx", w.Pfx)
	populateAny(objectMap, "resource", w.Resource)
	populate(objectMap, "type", w.Type)
	populateAny(objectMap, "userTenant", w.UserTenant)
	populateAny(objectMap, "username", w.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivityAuthentication.
func (w *WebActivityAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credential":
			err = unpopulate(val, "Credential", &w.Credential)
			delete(rawMsg, key)
		case "password":
			w.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "pfx":
			w.Pfx, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &w.Resource)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "userTenant":
			err = unpopulate(val, "UserTenant", &w.UserTenant)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &w.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebActivityTypeProperties.
func (w WebActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", w.Authentication)
	populateAny(objectMap, "body", w.Body)
	populate(objectMap, "connectVia", w.ConnectVia)
	populate(objectMap, "datasets", w.Datasets)
	populate(objectMap, "disableCertValidation", w.DisableCertValidation)
	populateAny(objectMap, "headers", w.Headers)
	populate(objectMap, "linkedServices", w.LinkedServices)
	populate(objectMap, "method", w.Method)
	populateAny(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivityTypeProperties.
func (w *WebActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &w.Authentication)
			delete(rawMsg, key)
		case "body":
			err = unpopulate(val, "Body", &w.Body)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &w.ConnectVia)
			delete(rawMsg, key)
		case "datasets":
			err = unpopulate(val, "Datasets", &w.Datasets)
			delete(rawMsg, key)
		case "disableCertValidation":
			err = unpopulate(val, "DisableCertValidation", &w.DisableCertValidation)
			delete(rawMsg, key)
		case "headers":
			err = unpopulate(val, "Headers", &w.Headers)
			delete(rawMsg, key)
		case "linkedServices":
			err = unpopulate(val, "LinkedServices", &w.LinkedServices)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &w.Method)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAnonymousAuthentication.
func (w WebAnonymousAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authenticationType"] = WebAuthenticationTypeAnonymous
	populateAny(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAnonymousAuthentication.
func (w *WebAnonymousAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &w.AuthenticationType)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebBasicAuthentication.
func (w WebBasicAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authenticationType"] = WebAuthenticationTypeBasic
	populate(objectMap, "password", w.Password)
	populateAny(objectMap, "url", w.URL)
	populateAny(objectMap, "username", w.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebBasicAuthentication.
func (w *WebBasicAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &w.AuthenticationType)
			delete(rawMsg, key)
		case "password":
			w.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &w.URL)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &w.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebClientCertificateAuthentication.
func (w WebClientCertificateAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authenticationType"] = WebAuthenticationTypeClientCertificate
	populate(objectMap, "password", w.Password)
	populate(objectMap, "pfx", w.Pfx)
	populateAny(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebClientCertificateAuthentication.
func (w *WebClientCertificateAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &w.AuthenticationType)
			delete(rawMsg, key)
		case "password":
			w.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "pfx":
			w.Pfx, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookActivity.
func (w WebHookActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependsOn", w.DependsOn)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "onInactiveMarkAs", w.OnInactiveMarkAs)
	populate(objectMap, "policy", w.Policy)
	populate(objectMap, "state", w.State)
	objectMap["type"] = "WebHook"
	populate(objectMap, "typeProperties", w.TypeProperties)
	populate(objectMap, "userProperties", w.UserProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookActivity.
func (w *WebHookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &w.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "onInactiveMarkAs":
			err = unpopulate(val, "OnInactiveMarkAs", &w.OnInactiveMarkAs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &w.Policy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &w.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &w.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, "UserProperties", &w.UserProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookActivityTypeProperties.
func (w WebHookActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", w.Authentication)
	populateAny(objectMap, "body", w.Body)
	populateAny(objectMap, "headers", w.Headers)
	populate(objectMap, "method", w.Method)
	populateAny(objectMap, "reportStatusOnCallBack", w.ReportStatusOnCallBack)
	populate(objectMap, "timeout", w.Timeout)
	populateAny(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookActivityTypeProperties.
func (w *WebHookActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &w.Authentication)
			delete(rawMsg, key)
		case "body":
			err = unpopulate(val, "Body", &w.Body)
			delete(rawMsg, key)
		case "headers":
			err = unpopulate(val, "Headers", &w.Headers)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &w.Method)
			delete(rawMsg, key)
		case "reportStatusOnCallBack":
			err = unpopulate(val, "ReportStatusOnCallBack", &w.ReportStatusOnCallBack)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &w.Timeout)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebLinkedService.
func (w WebLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", w.Annotations)
	populate(objectMap, "connectVia", w.ConnectVia)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "parameters", w.Parameters)
	objectMap["type"] = "Web"
	populate(objectMap, "typeProperties", w.TypeProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedService.
func (w *WebLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &w.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &w.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &w.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			w.TypeProperties, err = unmarshalWebLinkedServiceTypePropertiesClassification(val)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebLinkedServiceTypeProperties.
func (w WebLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["authenticationType"] = w.AuthenticationType
	populateAny(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedServiceTypeProperties.
func (w *WebLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &w.AuthenticationType)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSource.
func (w WebSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", w.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", w.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", w.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", w.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", w.SourceRetryWait)
	objectMap["type"] = "WebSource"
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSource.
func (w *WebSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &w.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &w.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &w.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &w.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &w.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebTableDataset.
func (w WebTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", w.Annotations)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "folder", w.Folder)
	populate(objectMap, "linkedServiceName", w.LinkedServiceName)
	populate(objectMap, "parameters", w.Parameters)
	populateAny(objectMap, "schema", w.Schema)
	populateAny(objectMap, "structure", w.Structure)
	objectMap["type"] = "WebTable"
	populate(objectMap, "typeProperties", w.TypeProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebTableDataset.
func (w *WebTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &w.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &w.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &w.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &w.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &w.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &w.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &w.TypeProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebTableDatasetTypeProperties.
func (w WebTableDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "index", w.Index)
	populateAny(objectMap, "path", w.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebTableDatasetTypeProperties.
func (w *WebTableDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "index":
			err = unpopulate(val, "Index", &w.Index)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &w.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WranglingDataFlow.
func (w WranglingDataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", w.Annotations)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "folder", w.Folder)
	objectMap["type"] = "WranglingDataFlow"
	populate(objectMap, "typeProperties", w.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WranglingDataFlow.
func (w *WranglingDataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &w.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &w.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &w.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XMLDataset.
func (x XMLDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", x.Annotations)
	populate(objectMap, "description", x.Description)
	populate(objectMap, "folder", x.Folder)
	populate(objectMap, "linkedServiceName", x.LinkedServiceName)
	populate(objectMap, "parameters", x.Parameters)
	populateAny(objectMap, "schema", x.Schema)
	populateAny(objectMap, "structure", x.Structure)
	objectMap["type"] = "Xml"
	populate(objectMap, "typeProperties", x.TypeProperties)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLDataset.
func (x *XMLDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &x.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &x.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &x.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &x.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &x.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &x.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &x.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &x.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &x.TypeProperties)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XMLDatasetTypeProperties.
func (x XMLDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compression", x.Compression)
	populateAny(objectMap, "encodingName", x.EncodingName)
	populate(objectMap, "location", x.Location)
	populateAny(objectMap, "nullValue", x.NullValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLDatasetTypeProperties.
func (x *XMLDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, "Compression", &x.Compression)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, "EncodingName", &x.EncodingName)
			delete(rawMsg, key)
		case "location":
			x.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, "NullValue", &x.NullValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XMLReadSettings.
func (x XMLReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compressionProperties", x.CompressionProperties)
	populateAny(objectMap, "detectDataType", x.DetectDataType)
	populateAny(objectMap, "namespacePrefixes", x.NamespacePrefixes)
	populateAny(objectMap, "namespaces", x.Namespaces)
	objectMap["type"] = "XmlReadSettings"
	populateAny(objectMap, "validationMode", x.ValidationMode)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLReadSettings.
func (x *XMLReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			x.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "detectDataType":
			err = unpopulate(val, "DetectDataType", &x.DetectDataType)
			delete(rawMsg, key)
		case "namespacePrefixes":
			err = unpopulate(val, "NamespacePrefixes", &x.NamespacePrefixes)
			delete(rawMsg, key)
		case "namespaces":
			err = unpopulate(val, "Namespaces", &x.Namespaces)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &x.Type)
			delete(rawMsg, key)
		case "validationMode":
			err = unpopulate(val, "ValidationMode", &x.ValidationMode)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XMLSource.
func (x XMLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", x.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", x.DisableMetricsCollection)
	populate(objectMap, "formatSettings", x.FormatSettings)
	populateAny(objectMap, "maxConcurrentConnections", x.MaxConcurrentConnections)
	populateAny(objectMap, "sourceRetryCount", x.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", x.SourceRetryWait)
	populate(objectMap, "storeSettings", x.StoreSettings)
	objectMap["type"] = "XmlSource"
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLSource.
func (x *XMLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &x.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &x.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, "FormatSettings", &x.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &x.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &x.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &x.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			x.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &x.Type)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XeroLinkedService.
func (x XeroLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", x.Annotations)
	populate(objectMap, "connectVia", x.ConnectVia)
	populate(objectMap, "description", x.Description)
	populate(objectMap, "parameters", x.Parameters)
	objectMap["type"] = "Xero"
	populate(objectMap, "typeProperties", x.TypeProperties)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedService.
func (x *XeroLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &x.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &x.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &x.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &x.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &x.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &x.TypeProperties)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XeroLinkedServiceTypeProperties.
func (x XeroLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "connectionProperties", x.ConnectionProperties)
	populate(objectMap, "consumerKey", x.ConsumerKey)
	populate(objectMap, "encryptedCredential", x.EncryptedCredential)
	populateAny(objectMap, "host", x.Host)
	populate(objectMap, "privateKey", x.PrivateKey)
	populateAny(objectMap, "useEncryptedEndpoints", x.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", x.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", x.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedServiceTypeProperties.
func (x *XeroLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &x.ConnectionProperties)
			delete(rawMsg, key)
		case "consumerKey":
			x.ConsumerKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &x.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &x.Host)
			delete(rawMsg, key)
		case "privateKey":
			x.PrivateKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &x.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &x.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &x.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XeroObjectDataset.
func (x XeroObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", x.Annotations)
	populate(objectMap, "description", x.Description)
	populate(objectMap, "folder", x.Folder)
	populate(objectMap, "linkedServiceName", x.LinkedServiceName)
	populate(objectMap, "parameters", x.Parameters)
	populateAny(objectMap, "schema", x.Schema)
	populateAny(objectMap, "structure", x.Structure)
	objectMap["type"] = "XeroObject"
	populate(objectMap, "typeProperties", x.TypeProperties)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroObjectDataset.
func (x *XeroObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &x.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &x.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &x.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &x.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &x.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &x.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &x.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &x.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &x.TypeProperties)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type XeroSource.
func (x XeroSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", x.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", x.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", x.MaxConcurrentConnections)
	populateAny(objectMap, "query", x.Query)
	populateAny(objectMap, "queryTimeout", x.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", x.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", x.SourceRetryWait)
	objectMap["type"] = "XeroSource"
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroSource.
func (x *XeroSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &x.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &x.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &x.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &x.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &x.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &x.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &x.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &x.Type)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZendeskLinkedService.
func (z ZendeskLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", z.Annotations)
	populate(objectMap, "connectVia", z.ConnectVia)
	populate(objectMap, "description", z.Description)
	populate(objectMap, "parameters", z.Parameters)
	objectMap["type"] = "Zendesk"
	populate(objectMap, "typeProperties", z.TypeProperties)
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZendeskLinkedService.
func (z *ZendeskLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &z.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &z.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &z.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &z.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &z.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &z.TypeProperties)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZendeskLinkedServiceTypeProperties.
func (z ZendeskLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiToken", z.APIToken)
	populate(objectMap, "authenticationType", z.AuthenticationType)
	populate(objectMap, "encryptedCredential", z.EncryptedCredential)
	populate(objectMap, "password", z.Password)
	populateAny(objectMap, "url", z.URL)
	populateAny(objectMap, "userName", z.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZendeskLinkedServiceTypeProperties.
func (z *ZendeskLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiToken":
			z.APIToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &z.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &z.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			z.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &z.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &z.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZipDeflateReadSettings.
func (z ZipDeflateReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "preserveZipFileNameAsFolder", z.PreserveZipFileNameAsFolder)
	objectMap["type"] = "ZipDeflateReadSettings"
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZipDeflateReadSettings.
func (z *ZipDeflateReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preserveZipFileNameAsFolder":
			err = unpopulate(val, "PreserveZipFileNameAsFolder", &z.PreserveZipFileNameAsFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &z.Type)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZohoLinkedService.
func (z ZohoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", z.Annotations)
	populate(objectMap, "connectVia", z.ConnectVia)
	populate(objectMap, "description", z.Description)
	populate(objectMap, "parameters", z.Parameters)
	objectMap["type"] = "Zoho"
	populate(objectMap, "typeProperties", z.TypeProperties)
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedService.
func (z *ZohoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &z.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, "ConnectVia", &z.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &z.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &z.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &z.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &z.TypeProperties)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZohoLinkedServiceTypeProperties.
func (z ZohoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessToken", z.AccessToken)
	populateAny(objectMap, "connectionProperties", z.ConnectionProperties)
	populate(objectMap, "encryptedCredential", z.EncryptedCredential)
	populateAny(objectMap, "endpoint", z.Endpoint)
	populateAny(objectMap, "useEncryptedEndpoints", z.UseEncryptedEndpoints)
	populateAny(objectMap, "useHostVerification", z.UseHostVerification)
	populateAny(objectMap, "usePeerVerification", z.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedServiceTypeProperties.
func (z *ZohoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			z.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, "ConnectionProperties", &z.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, "EncryptedCredential", &z.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &z.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, "UseEncryptedEndpoints", &z.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, "UseHostVerification", &z.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, "UsePeerVerification", &z.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZohoObjectDataset.
func (z ZohoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", z.Annotations)
	populate(objectMap, "description", z.Description)
	populate(objectMap, "folder", z.Folder)
	populate(objectMap, "linkedServiceName", z.LinkedServiceName)
	populate(objectMap, "parameters", z.Parameters)
	populateAny(objectMap, "schema", z.Schema)
	populateAny(objectMap, "structure", z.Structure)
	objectMap["type"] = "ZohoObject"
	populate(objectMap, "typeProperties", z.TypeProperties)
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoObjectDataset.
func (z *ZohoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &z.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &z.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, "Folder", &z.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, "LinkedServiceName", &z.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &z.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, "Schema", &z.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, "Structure", &z.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &z.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, "TypeProperties", &z.TypeProperties)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZohoSource.
func (z ZohoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "additionalColumns", z.AdditionalColumns)
	populateAny(objectMap, "disableMetricsCollection", z.DisableMetricsCollection)
	populateAny(objectMap, "maxConcurrentConnections", z.MaxConcurrentConnections)
	populateAny(objectMap, "query", z.Query)
	populateAny(objectMap, "queryTimeout", z.QueryTimeout)
	populateAny(objectMap, "sourceRetryCount", z.SourceRetryCount)
	populateAny(objectMap, "sourceRetryWait", z.SourceRetryWait)
	objectMap["type"] = "ZohoSource"
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoSource.
func (z *ZohoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, "AdditionalColumns", &z.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, "DisableMetricsCollection", &z.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, "MaxConcurrentConnections", &z.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &z.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, "QueryTimeout", &z.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, "SourceRetryCount", &z.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, "SourceRetryWait", &z.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &z.Type)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
