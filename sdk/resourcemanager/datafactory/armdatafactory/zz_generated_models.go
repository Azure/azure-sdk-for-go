//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatafactory

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccessPolicyResponse - Get Data Plane read only token response definition.
type AccessPolicyResponse struct {
	// Data Plane read only access token.
	AccessToken *string `json:"accessToken,omitempty"`

	// Data Plane service base URL.
	DataPlaneURL *string `json:"dataPlaneUrl,omitempty"`

	// The user access policy.
	Policy *UserAccessPolicy `json:"policy,omitempty"`
}

// ActivityClassification provides polymorphic access to related types.
// Call the interface's GetActivity() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Activity, *AppendVariableActivity, *AzureDataExplorerCommandActivity, *AzureFunctionActivity, *AzureMLBatchExecutionActivity,
// - *AzureMLExecutePipelineActivity, *AzureMLUpdateResourceActivity, *ControlActivity, *CopyActivity, *CustomActivity, *DataLakeAnalyticsUSQLActivity,
// - *DatabricksNotebookActivity, *DatabricksSparkJarActivity, *DatabricksSparkPythonActivity, *DeleteActivity, *ExecuteDataFlowActivity,
// - *ExecutePipelineActivity, *ExecuteSSISPackageActivity, *ExecuteWranglingDataflowActivity, *ExecutionActivity, *FailActivity,
// - *FilterActivity, *ForEachActivity, *GetMetadataActivity, *HDInsightHiveActivity, *HDInsightMapReduceActivity, *HDInsightPigActivity,
// - *HDInsightSparkActivity, *HDInsightStreamingActivity, *IfConditionActivity, *LookupActivity, *SQLServerStoredProcedureActivity,
// - *SetVariableActivity, *SwitchActivity, *UntilActivity, *ValidationActivity, *WaitActivity, *WebActivity, *WebHookActivity
type ActivityClassification interface {
	// GetActivity returns the Activity content of the underlying type.
	GetActivity() *Activity
}

// Activity - A pipeline activity.
type Activity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type Activity.
func (a *Activity) GetActivity() *Activity { return a }

// MarshalJSON implements the json.Marshaller interface for type Activity.
func (a Activity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "name", a.Name)
	objectMap["type"] = a.Type
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Activity.
func (a *Activity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ActivityDependency - Activity dependency information.
type ActivityDependency struct {
	// REQUIRED; Activity name.
	Activity *string `json:"activity,omitempty"`

	// REQUIRED; Match-Condition for the dependency.
	DependencyConditions []*DependencyCondition `json:"dependencyConditions,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// MarshalJSON implements the json.Marshaller interface for type ActivityDependency.
func (a ActivityDependency) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activity", a.Activity)
	populate(objectMap, "dependencyConditions", a.DependencyConditions)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityDependency.
func (a *ActivityDependency) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activity":
			err = unpopulate(val, &a.Activity)
			delete(rawMsg, key)
		case "dependencyConditions":
			err = unpopulate(val, &a.DependencyConditions)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ActivityPolicy - Execution policy for an activity.
type ActivityPolicy struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
	Retry map[string]interface{} `json:"retry,omitempty"`

	// Interval between each retry attempt (in seconds). The default is 30 sec.
	RetryIntervalInSeconds *int32 `json:"retryIntervalInSeconds,omitempty"`

	// When set to true, Input from activity is considered as secure and will not be logged to monitoring.
	SecureInput *bool `json:"secureInput,omitempty"`

	// When set to true, Output from activity is considered as secure and will not be logged to monitoring.
	SecureOutput *bool `json:"secureOutput,omitempty"`

	// Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout map[string]interface{} `json:"timeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityPolicy.
func (a ActivityPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "retry", a.Retry)
	populate(objectMap, "retryIntervalInSeconds", a.RetryIntervalInSeconds)
	populate(objectMap, "secureInput", a.SecureInput)
	populate(objectMap, "secureOutput", a.SecureOutput)
	populate(objectMap, "timeout", a.Timeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityPolicy.
func (a *ActivityPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retry":
			err = unpopulate(val, &a.Retry)
			delete(rawMsg, key)
		case "retryIntervalInSeconds":
			err = unpopulate(val, &a.RetryIntervalInSeconds)
			delete(rawMsg, key)
		case "secureInput":
			err = unpopulate(val, &a.SecureInput)
			delete(rawMsg, key)
		case "secureOutput":
			err = unpopulate(val, &a.SecureOutput)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &a.Timeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ActivityRun - Information about an activity run in a pipeline.
type ActivityRun struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The name of the activity.
	ActivityName *string `json:"activityName,omitempty" azure:"ro"`

	// READ-ONLY; The end time of the activity run in 'ISO 8601' format.
	ActivityRunEnd *time.Time `json:"activityRunEnd,omitempty" azure:"ro"`

	// READ-ONLY; The id of the activity run.
	ActivityRunID *string `json:"activityRunId,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the activity run in 'ISO 8601' format.
	ActivityRunStart *time.Time `json:"activityRunStart,omitempty" azure:"ro"`

	// READ-ONLY; The type of the activity.
	ActivityType *string `json:"activityType,omitempty" azure:"ro"`

	// READ-ONLY; The duration of the activity run.
	DurationInMs *int32 `json:"durationInMs,omitempty" azure:"ro"`

	// READ-ONLY; The error if any from the activity run.
	Error map[string]interface{} `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; The input for the activity.
	Input map[string]interface{} `json:"input,omitempty" azure:"ro"`

	// READ-ONLY; The name of the compute linked service.
	LinkedServiceName *string `json:"linkedServiceName,omitempty" azure:"ro"`

	// READ-ONLY; The output for the activity.
	Output map[string]interface{} `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The name of the pipeline.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// READ-ONLY; The id of the pipeline run.
	PipelineRunID *string `json:"pipelineRunId,omitempty" azure:"ro"`

	// READ-ONLY; The status of the activity run.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityRun.
func (a ActivityRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activityName", a.ActivityName)
	populateTimeRFC3339(objectMap, "activityRunEnd", a.ActivityRunEnd)
	populate(objectMap, "activityRunId", a.ActivityRunID)
	populateTimeRFC3339(objectMap, "activityRunStart", a.ActivityRunStart)
	populate(objectMap, "activityType", a.ActivityType)
	populate(objectMap, "durationInMs", a.DurationInMs)
	populate(objectMap, "error", a.Error)
	populate(objectMap, "input", a.Input)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "output", a.Output)
	populate(objectMap, "pipelineName", a.PipelineName)
	populate(objectMap, "pipelineRunId", a.PipelineRunID)
	populate(objectMap, "status", a.Status)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityRun.
func (a *ActivityRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityName":
			err = unpopulate(val, &a.ActivityName)
			delete(rawMsg, key)
		case "activityRunEnd":
			err = unpopulateTimeRFC3339(val, &a.ActivityRunEnd)
			delete(rawMsg, key)
		case "activityRunId":
			err = unpopulate(val, &a.ActivityRunID)
			delete(rawMsg, key)
		case "activityRunStart":
			err = unpopulateTimeRFC3339(val, &a.ActivityRunStart)
			delete(rawMsg, key)
		case "activityType":
			err = unpopulate(val, &a.ActivityType)
			delete(rawMsg, key)
		case "durationInMs":
			err = unpopulate(val, &a.DurationInMs)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &a.Error)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &a.Input)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &a.Output)
			delete(rawMsg, key)
		case "pipelineName":
			err = unpopulate(val, &a.PipelineName)
			delete(rawMsg, key)
		case "pipelineRunId":
			err = unpopulate(val, &a.PipelineRunID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ActivityRunsClientQueryByPipelineRunOptions contains the optional parameters for the ActivityRunsClient.QueryByPipelineRun
// method.
type ActivityRunsClientQueryByPipelineRunOptions struct {
	// placeholder for future optional parameters
}

// ActivityRunsQueryResponse - A list activity runs.
type ActivityRunsQueryResponse struct {
	// REQUIRED; List of activity runs.
	Value []*ActivityRun `json:"value,omitempty"`

	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityRunsQueryResponse.
func (a ActivityRunsQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "continuationToken", a.ContinuationToken)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AddDataFlowToDebugSessionResponse - Response body structure for starting data flow debug session.
type AddDataFlowToDebugSessionResponse struct {
	// The ID of data flow debug job version.
	JobVersion *string `json:"jobVersion,omitempty"`
}

// AdditionalColumns - Specify the column name and value of additional columns.
type AdditionalColumns struct {
	// Additional column name. Type: string (or Expression with resultType string).
	Name map[string]interface{} `json:"name,omitempty"`

	// Additional column value. Type: string (or Expression with resultType string).
	Value map[string]interface{} `json:"value,omitempty"`
}

// AmazonMWSLinkedService - Amazon Marketplace Web Service linked service.
type AmazonMWSLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Amazon Marketplace Web Service linked service properties.
	TypeProperties *AmazonMWSLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AmazonMWSLinkedService.
func (a *AmazonMWSLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSLinkedService.
func (a AmazonMWSLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonMWS"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSLinkedService.
func (a *AmazonMWSLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonMWSLinkedServiceTypeProperties - Amazon Marketplace Web Service linked service properties.
type AmazonMWSLinkedServiceTypeProperties struct {
	// REQUIRED; The access key id used to access data.
	AccessKeyID map[string]interface{} `json:"accessKeyId,omitempty"`

	// REQUIRED; The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// REQUIRED; The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate
	// them with a comma (,). (i.e. A2EUQ1WTGCTBG2)
	MarketplaceID map[string]interface{} `json:"marketplaceID,omitempty"`

	// REQUIRED; The Amazon seller ID.
	SellerID map[string]interface{} `json:"sellerID,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Amazon MWS authentication token.
	MwsAuthToken SecretBaseClassification `json:"mwsAuthToken,omitempty"`

	// The secret key used to access data.
	SecretKey SecretBaseClassification `json:"secretKey,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSLinkedServiceTypeProperties.
func (a AmazonMWSLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessKeyId", a.AccessKeyID)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "marketplaceID", a.MarketplaceID)
	populate(objectMap, "mwsAuthToken", a.MwsAuthToken)
	populate(objectMap, "secretKey", a.SecretKey)
	populate(objectMap, "sellerID", a.SellerID)
	populate(objectMap, "useEncryptedEndpoints", a.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", a.UseHostVerification)
	populate(objectMap, "usePeerVerification", a.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSLinkedServiceTypeProperties.
func (a *AmazonMWSLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, &a.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &a.Endpoint)
			delete(rawMsg, key)
		case "marketplaceID":
			err = unpopulate(val, &a.MarketplaceID)
			delete(rawMsg, key)
		case "mwsAuthToken":
			a.MwsAuthToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "secretKey":
			a.SecretKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sellerID":
			err = unpopulate(val, &a.SellerID)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &a.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &a.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &a.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonMWSObjectDataset - Amazon Marketplace Web Service dataset.
type AmazonMWSObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AmazonMWSObjectDataset.
func (a *AmazonMWSObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSObjectDataset.
func (a AmazonMWSObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonMWSObject"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSObjectDataset.
func (a *AmazonMWSObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonMWSSource - A copy activity Amazon Marketplace Web Service source.
type AmazonMWSSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AmazonMWSSource.
func (a *AmazonMWSSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AmazonMWSSource.
func (a *AmazonMWSSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMWSSource.
func (a AmazonMWSSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AmazonMWSSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMWSSource.
func (a *AmazonMWSSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForLinkedServiceTypeProperties - AmazonRdsForOracle database linked service properties.
type AmazonRdsForLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password SecretBaseClassification `json:"password,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForLinkedServiceTypeProperties.
func (a AmazonRdsForLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForLinkedServiceTypeProperties.
func (a *AmazonRdsForLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForOracleLinkedService - AmazonRdsForOracle database.
type AmazonRdsForOracleLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; AmazonRdsForOracle database linked service properties.
	TypeProperties *AmazonRdsForLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AmazonRdsForOracleLinkedService.
func (a *AmazonRdsForOracleLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleLinkedService.
func (a AmazonRdsForOracleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonRdsForOracle"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleLinkedService.
func (a *AmazonRdsForOracleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForOraclePartitionSettings - The settings that will be leveraged for AmazonRdsForOracle source partitioning.
type AmazonRdsForOraclePartitionSettings struct {
	// The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression
	// with resultType string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionLowerBound map[string]interface{} `json:"partitionLowerBound,omitempty"`

	// Names of the physical partitions of AmazonRdsForOracle table.
	PartitionNames map[string]interface{} `json:"partitionNames,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionUpperBound map[string]interface{} `json:"partitionUpperBound,omitempty"`
}

// AmazonRdsForOracleSource - A copy activity AmazonRdsForOracle source.
type AmazonRdsForOracleSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// AmazonRdsForOracle reader query. Type: string (or Expression with resultType string).
	OracleReaderQuery map[string]interface{} `json:"oracleReaderQuery,omitempty"`

	// The partition mechanism that will be used for AmazonRdsForOracle read in parallel. Type: string (or Expression with resultType
	// string).
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for AmazonRdsForOracle source partitioning.
	PartitionSettings *AmazonRdsForOraclePartitionSettings `json:"partitionSettings,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AmazonRdsForOracleSource.
func (a *AmazonRdsForOracleSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleSource.
func (a AmazonRdsForOracleSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "oracleReaderQuery", a.OracleReaderQuery)
	populate(objectMap, "partitionOption", a.PartitionOption)
	populate(objectMap, "partitionSettings", a.PartitionSettings)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AmazonRdsForOracleSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleSource.
func (a *AmazonRdsForOracleSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "oracleReaderQuery":
			err = unpopulate(val, &a.OracleReaderQuery)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &a.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &a.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForOracleTableDataset - The AmazonRdsForOracle database dataset.
type AmazonRdsForOracleTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// AmazonRdsForOracle dataset properties.
	TypeProperties *AmazonRdsForOracleTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AmazonRdsForOracleTableDataset.
func (a *AmazonRdsForOracleTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForOracleTableDataset.
func (a AmazonRdsForOracleTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonRdsForOracleTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForOracleTableDataset.
func (a *AmazonRdsForOracleTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForOracleTableDatasetTypeProperties - AmazonRdsForOracle dataset properties.
type AmazonRdsForOracleTableDatasetTypeProperties struct {
	// The schema name of the AmazonRdsForOracle database. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the AmazonRdsForOracle database. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// AmazonRdsForSQLServerLinkedService - Amazon RDS for SQL Server linked service.
type AmazonRdsForSQLServerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Amazon RDS for SQL Server linked service properties.
	TypeProperties *AmazonRdsForSQLServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AmazonRdsForSQLServerLinkedService.
func (a *AmazonRdsForSQLServerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerLinkedService.
func (a AmazonRdsForSQLServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonRdsForSqlServer"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerLinkedService.
func (a *AmazonRdsForSQLServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForSQLServerLinkedServiceTypeProperties - Amazon Rds for SQL Server linked service properties.
type AmazonRdsForSQLServerLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Sql always encrypted properties.
	AlwaysEncryptedSettings *SQLAlwaysEncryptedProperties `json:"alwaysEncryptedSettings,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The on-premises Windows authentication password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerLinkedServiceTypeProperties.
func (a AmazonRdsForSQLServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alwaysEncryptedSettings", a.AlwaysEncryptedSettings)
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "userName", a.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerLinkedServiceTypeProperties.
func (a *AmazonRdsForSQLServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, &a.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &a.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForSQLServerSource - A copy activity Amazon RDS for SQL Server source.
type AmazonRdsForSQLServerSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Sql source partitioning.
	PartitionSettings *SQLPartitionSettings `json:"partitionSettings,omitempty"`

	// Which additional types to produce.
	ProduceAdditionalTypes map[string]interface{} `json:"produceAdditionalTypes,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery map[string]interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string
	// (or Expression with resultType string).
	SQLReaderStoredProcedureName map[string]interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AmazonRdsForSQLServerSource.
func (a *AmazonRdsForSQLServerSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AmazonRdsForSQLServerSource.
func (a *AmazonRdsForSQLServerSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerSource.
func (a AmazonRdsForSQLServerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", a.PartitionOption)
	populate(objectMap, "partitionSettings", a.PartitionSettings)
	populate(objectMap, "produceAdditionalTypes", a.ProduceAdditionalTypes)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sqlReaderQuery", a.SQLReaderQuery)
	populate(objectMap, "sqlReaderStoredProcedureName", a.SQLReaderStoredProcedureName)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populate(objectMap, "storedProcedureParameters", a.StoredProcedureParameters)
	objectMap["type"] = "AmazonRdsForSqlServerSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerSource.
func (a *AmazonRdsForSQLServerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &a.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &a.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, &a.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, &a.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, &a.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &a.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForSQLServerTableDataset - The Amazon RDS for SQL Server dataset.
type AmazonRdsForSQLServerTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// The Amazon RDS for SQL Server dataset properties.
	TypeProperties *AmazonRdsForSQLServerTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AmazonRdsForSQLServerTableDataset.
func (a *AmazonRdsForSQLServerTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRdsForSQLServerTableDataset.
func (a AmazonRdsForSQLServerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonRdsForSqlServerTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRdsForSQLServerTableDataset.
func (a *AmazonRdsForSQLServerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRdsForSQLServerTableDatasetTypeProperties - The Amazon RDS for SQL Server dataset properties.
type AmazonRdsForSQLServerTableDatasetTypeProperties struct {
	// The schema name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// AmazonRedshiftLinkedService - Linked service for Amazon Redshift.
type AmazonRedshiftLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Amazon Redshift linked service properties.
	TypeProperties *AmazonRedshiftLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AmazonRedshiftLinkedService.
func (a *AmazonRedshiftLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftLinkedService.
func (a AmazonRedshiftLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonRedshift"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedService.
func (a *AmazonRedshiftLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRedshiftLinkedServiceTypeProperties - Amazon Redshift linked service properties.
type AmazonRedshiftLinkedServiceTypeProperties struct {
	// REQUIRED; The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`

	// REQUIRED; The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password of the Amazon Redshift source.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type:
	// integer (or Expression with resultType integer).
	Port map[string]interface{} `json:"port,omitempty"`

	// The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftLinkedServiceTypeProperties.
func (a AmazonRedshiftLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "database", a.Database)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "port", a.Port)
	populate(objectMap, "server", a.Server)
	populate(objectMap, "username", a.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedServiceTypeProperties.
func (a *AmazonRedshiftLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			err = unpopulate(val, &a.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &a.Port)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &a.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &a.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRedshiftSource - A copy activity source for Amazon Redshift Source.
type AmazonRedshiftSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with unload. With this, data
	// from Amazon Redshift source will be unloaded into S3 first and then copied into
	// the targeted sink from the interim S3.
	RedshiftUnloadSettings *RedshiftUnloadSettings `json:"redshiftUnloadSettings,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AmazonRedshiftSource.
func (a *AmazonRedshiftSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AmazonRedshiftSource.
func (a *AmazonRedshiftSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftSource.
func (a AmazonRedshiftSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "redshiftUnloadSettings", a.RedshiftUnloadSettings)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AmazonRedshiftSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftSource.
func (a *AmazonRedshiftSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "redshiftUnloadSettings":
			err = unpopulate(val, &a.RedshiftUnloadSettings)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRedshiftTableDataset - The Amazon Redshift table dataset.
type AmazonRedshiftTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Amazon Redshift table dataset properties.
	TypeProperties *AmazonRedshiftTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AmazonRedshiftTableDataset.
func (a *AmazonRedshiftTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftTableDataset.
func (a AmazonRedshiftTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonRedshiftTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftTableDataset.
func (a *AmazonRedshiftTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonRedshiftTableDatasetTypeProperties - Amazon Redshift table dataset properties.
type AmazonRedshiftTableDatasetTypeProperties struct {
	// The Amazon Redshift schema name. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The Amazon Redshift table name. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AmazonS3CompatibleLinkedService - Linked service for Amazon S3 Compatible.
type AmazonS3CompatibleLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Amazon S3 Compatible linked service properties.
	TypeProperties *AmazonS3CompatibleLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AmazonS3CompatibleLinkedService.
func (a *AmazonS3CompatibleLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleLinkedService.
func (a AmazonS3CompatibleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonS3Compatible"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleLinkedService.
func (a *AmazonS3CompatibleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3CompatibleLinkedServiceTypeProperties - Amazon S3 Compatible linked service properties.
type AmazonS3CompatibleLinkedServiceTypeProperties struct {
	// The access key identifier of the Amazon S3 Compatible Identity and Access Management (IAM) user. Type: string (or Expression
	// with resultType string).
	AccessKeyID map[string]interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// If true, use S3 path-style access instead of virtual hosted-style access. Default value is false. Type: boolean (or Expression
	// with resultType boolean).
	ForcePathStyle map[string]interface{} `json:"forcePathStyle,omitempty"`

	// The secret access key of the Amazon S3 Compatible Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the Amazon S3 Compatible Connector. This is an optional property; change
	// it only if you want to try a different service endpoint or want to switch
	// between https and http. Type: string (or Expression with resultType string).
	ServiceURL map[string]interface{} `json:"serviceUrl,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleLinkedServiceTypeProperties.
func (a AmazonS3CompatibleLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessKeyId", a.AccessKeyID)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "forcePathStyle", a.ForcePathStyle)
	populate(objectMap, "secretAccessKey", a.SecretAccessKey)
	populate(objectMap, "serviceUrl", a.ServiceURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleLinkedServiceTypeProperties.
func (a *AmazonS3CompatibleLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, &a.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "forcePathStyle":
			err = unpopulate(val, &a.ForcePathStyle)
			delete(rawMsg, key)
		case "secretAccessKey":
			a.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, &a.ServiceURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3CompatibleLocation - The location of Amazon S3 Compatible dataset.
type AmazonS3CompatibleLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the bucketName of Amazon S3 Compatible. Type: string (or Expression with resultType string)
	BucketName map[string]interface{} `json:"bucketName,omitempty"`

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Specify the version of Amazon S3 Compatible. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type AmazonS3CompatibleLocation.
func (a *AmazonS3CompatibleLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 a.Type,
		FolderPath:           a.FolderPath,
		FileName:             a.FileName,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleLocation.
func (a AmazonS3CompatibleLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bucketName", a.BucketName)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AmazonS3CompatibleLocation"
	populate(objectMap, "version", a.Version)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleLocation.
func (a *AmazonS3CompatibleLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, &a.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &a.Version)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3CompatibleReadSettings - Amazon S3 Compatible read settings.
type AmazonS3CompatibleReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The prefix filter for the S3 Compatible object name. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Amazon S3 Compatible wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Amazon S3 Compatible wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type AmazonS3CompatibleReadSettings.
func (a *AmazonS3CompatibleReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3CompatibleReadSettings.
func (a AmazonS3CompatibleReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", a.FileListPath)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", a.PartitionRootPath)
	populate(objectMap, "prefix", a.Prefix)
	populate(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AmazonS3CompatibleReadSettings"
	populate(objectMap, "wildcardFileName", a.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3CompatibleReadSettings.
func (a *AmazonS3CompatibleReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3Dataset - A single Amazon Simple Storage Service (S3) object or a set of S3 objects.
type AmazonS3Dataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Amazon S3 dataset properties.
	TypeProperties *AmazonS3DatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AmazonS3Dataset.
func (a *AmazonS3Dataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3Dataset.
func (a AmazonS3Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AmazonS3Object"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3Dataset.
func (a *AmazonS3Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3DatasetTypeProperties - Amazon S3 dataset properties.
type AmazonS3DatasetTypeProperties struct {
	// REQUIRED; The name of the Amazon S3 bucket. Type: string (or Expression with resultType string).
	BucketName map[string]interface{} `json:"bucketName,omitempty"`

	// The data compression method used for the Amazon S3 object.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The format of files.
	Format DatasetStorageFormatClassification `json:"format,omitempty"`

	// The key of the Amazon S3 object. Type: string (or Expression with resultType string).
	Key map[string]interface{} `json:"key,omitempty"`

	// The end of S3 object's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of S3 object's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// The version for the S3 object. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3DatasetTypeProperties.
func (a AmazonS3DatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bucketName", a.BucketName)
	populate(objectMap, "compression", a.Compression)
	populate(objectMap, "format", a.Format)
	populate(objectMap, "key", a.Key)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "prefix", a.Prefix)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3DatasetTypeProperties.
func (a *AmazonS3DatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, &a.BucketName)
			delete(rawMsg, key)
		case "compression":
			err = unpopulate(val, &a.Compression)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, &a.Key)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &a.Prefix)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3LinkedService - Linked service for Amazon S3.
type AmazonS3LinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Amazon S3 linked service properties.
	TypeProperties *AmazonS3LinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AmazonS3LinkedService.
func (a *AmazonS3LinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3LinkedService.
func (a AmazonS3LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AmazonS3"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedService.
func (a *AmazonS3LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3LinkedServiceTypeProperties - Amazon S3 linked service properties.
type AmazonS3LinkedServiceTypeProperties struct {
	// The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with
	// resultType string).
	AccessKeyID map[string]interface{} `json:"accessKeyId,omitempty"`

	// The authentication type of S3. Allowed value: AccessKey (default) or TemporarySecurityCredentials. Type: string (or Expression
	// with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you
	// want to try a different service endpoint or want to switch between https and
	// http. Type: string (or Expression with resultType string).
	ServiceURL map[string]interface{} `json:"serviceUrl,omitempty"`

	// The session token for the S3 temporary security credential.
	SessionToken SecretBaseClassification `json:"sessionToken,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3LinkedServiceTypeProperties.
func (a AmazonS3LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessKeyId", a.AccessKeyID)
	populate(objectMap, "authenticationType", a.AuthenticationType)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "secretAccessKey", a.SecretAccessKey)
	populate(objectMap, "serviceUrl", a.ServiceURL)
	populate(objectMap, "sessionToken", a.SessionToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedServiceTypeProperties.
func (a *AmazonS3LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, &a.AccessKeyID)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &a.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "secretAccessKey":
			a.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, &a.ServiceURL)
			delete(rawMsg, key)
		case "sessionToken":
			a.SessionToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3Location - The location of amazon S3 dataset.
type AmazonS3Location struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the bucketName of amazon S3. Type: string (or Expression with resultType string)
	BucketName map[string]interface{} `json:"bucketName,omitempty"`

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Specify the version of amazon S3. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type AmazonS3Location.
func (a *AmazonS3Location) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 a.Type,
		FolderPath:           a.FolderPath,
		FileName:             a.FileName,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3Location.
func (a AmazonS3Location) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bucketName", a.BucketName)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AmazonS3Location"
	populate(objectMap, "version", a.Version)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3Location.
func (a *AmazonS3Location) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, &a.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &a.Version)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmazonS3ReadSettings - Amazon S3 read settings.
type AmazonS3ReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// AmazonS3 wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// AmazonS3 wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type AmazonS3ReadSettings.
func (a *AmazonS3ReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3ReadSettings.
func (a AmazonS3ReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", a.FileListPath)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", a.PartitionRootPath)
	populate(objectMap, "prefix", a.Prefix)
	populate(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AmazonS3ReadSettings"
	populate(objectMap, "wildcardFileName", a.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3ReadSettings.
func (a *AmazonS3ReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AppendVariableActivity - Append value for a Variable of type Array.
type AppendVariableActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Append Variable activity properties.
	TypeProperties *AppendVariableActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type AppendVariableActivity.
func (a *AppendVariableActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type AppendVariableActivity.
func (a *AppendVariableActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AppendVariableActivity.
func (a AppendVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "name", a.Name)
	objectMap["type"] = "AppendVariable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppendVariableActivity.
func (a *AppendVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AppendVariableActivityTypeProperties - AppendVariable activity properties.
type AppendVariableActivityTypeProperties struct {
	// Value to be appended. Could be a static value or Expression
	Value map[string]interface{} `json:"value,omitempty"`

	// Name of the variable whose value needs to be appended to.
	VariableName *string `json:"variableName,omitempty"`
}

// ArmIDWrapper - A wrapper for an ARM resource id
type ArmIDWrapper struct {
	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`
}

// AvroDataset - Avro dataset.
type AvroDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Avro dataset properties.
	TypeProperties *AvroDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AvroDataset.
func (a *AvroDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AvroDataset.
func (a AvroDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "Avro"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDataset.
func (a *AvroDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AvroDatasetTypeProperties - Avro dataset properties.
type AvroDatasetTypeProperties struct {
	// REQUIRED; The location of the avro storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data avroCompressionCodec. Type: string (or Expression with resultType string).
	AvroCompressionCodec map[string]interface{} `json:"avroCompressionCodec,omitempty"`
	AvroCompressionLevel *int32                 `json:"avroCompressionLevel,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvroDatasetTypeProperties.
func (a AvroDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "avroCompressionCodec", a.AvroCompressionCodec)
	populate(objectMap, "avroCompressionLevel", a.AvroCompressionLevel)
	populate(objectMap, "location", a.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDatasetTypeProperties.
func (a *AvroDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avroCompressionCodec":
			err = unpopulate(val, &a.AvroCompressionCodec)
			delete(rawMsg, key)
		case "avroCompressionLevel":
			err = unpopulate(val, &a.AvroCompressionLevel)
			delete(rawMsg, key)
		case "location":
			a.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AvroFormat - The data stored in Avro format.
type AvroFormat struct {
	// REQUIRED; Type of dataset storage format.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer map[string]interface{} `json:"deserializer,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer map[string]interface{} `json:"serializer,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type AvroFormat.
func (a *AvroFormat) GetDatasetStorageFormat() *DatasetStorageFormat {
	return &DatasetStorageFormat{
		Type:                 a.Type,
		Serializer:           a.Serializer,
		Deserializer:         a.Deserializer,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AvroFormat.
func (a AvroFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deserializer", a.Deserializer)
	populate(objectMap, "serializer", a.Serializer)
	objectMap["type"] = "AvroFormat"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroFormat.
func (a *AvroFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, &a.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, &a.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AvroSink - A copy activity Avro sink.
type AvroSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Avro format settings.
	FormatSettings *AvroWriteSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Avro store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AvroSink.
func (a *AvroSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AvroSink.
func (a AvroSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "formatSettings", a.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	populate(objectMap, "storeSettings", a.StoreSettings)
	objectMap["type"] = "AvroSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSink.
func (a *AvroSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &a.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			a.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AvroSource - A copy activity Avro source.
type AvroSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Avro store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AvroSource.
func (a *AvroSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AvroSource.
func (a AvroSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populate(objectMap, "storeSettings", a.StoreSettings)
	objectMap["type"] = "AvroSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSource.
func (a *AvroSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			a.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AvroWriteSettings - Avro write settings.
type AvroWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the file name pattern _. when copy from non-file based store without partitionOptions. Type: string (or Expression
	// with resultType string).
	FileNamePrefix map[string]interface{} `json:"fileNamePrefix,omitempty"`

	// Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with
	// resultType integer).
	MaxRowsPerFile map[string]interface{} `json:"maxRowsPerFile,omitempty"`

	// Top level record name in write result, which is required in AVRO spec.
	RecordName *string `json:"recordName,omitempty"`

	// Record namespace in the write result.
	RecordNamespace *string `json:"recordNamespace,omitempty"`
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type AvroWriteSettings.
func (a *AvroWriteSettings) GetFormatWriteSettings() *FormatWriteSettings {
	return &FormatWriteSettings{
		Type:                 a.Type,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AvroWriteSettings.
func (a AvroWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileNamePrefix", a.FileNamePrefix)
	populate(objectMap, "maxRowsPerFile", a.MaxRowsPerFile)
	populate(objectMap, "recordName", a.RecordName)
	populate(objectMap, "recordNamespace", a.RecordNamespace)
	objectMap["type"] = "AvroWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroWriteSettings.
func (a *AvroWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileNamePrefix":
			err = unpopulate(val, &a.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, &a.MaxRowsPerFile)
			delete(rawMsg, key)
		case "recordName":
			err = unpopulate(val, &a.RecordName)
			delete(rawMsg, key)
		case "recordNamespace":
			err = unpopulate(val, &a.RecordNamespace)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzPowerShellSetup - The express custom setup of installing Azure PowerShell.
type AzPowerShellSetup struct {
	// REQUIRED; The type of custom setup.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Install Azure PowerShell type properties.
	TypeProperties *AzPowerShellSetupTypeProperties `json:"typeProperties,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type AzPowerShellSetup.
func (a *AzPowerShellSetup) GetCustomSetupBase() *CustomSetupBase {
	return &CustomSetupBase{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzPowerShellSetup.
func (a AzPowerShellSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = "AzPowerShellSetup"
	populate(objectMap, "typeProperties", a.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzPowerShellSetup.
func (a *AzPowerShellSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzPowerShellSetupTypeProperties - Installation of Azure PowerShell type properties.
type AzPowerShellSetupTypeProperties struct {
	// REQUIRED; The required version of Azure PowerShell to install.
	Version *string `json:"version,omitempty"`
}

// AzureBatchLinkedService - Azure Batch linked service.
type AzureBatchLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Batch linked service properties.
	TypeProperties *AzureBatchLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureBatchLinkedService.
func (a *AzureBatchLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBatchLinkedService.
func (a AzureBatchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureBatch"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedService.
func (a *AzureBatchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBatchLinkedServiceTypeProperties - Azure Batch linked service properties.
type AzureBatchLinkedServiceTypeProperties struct {
	// REQUIRED; The Azure Batch account name. Type: string (or Expression with resultType string).
	AccountName map[string]interface{} `json:"accountName,omitempty"`

	// REQUIRED; The Azure Batch URI. Type: string (or Expression with resultType string).
	BatchURI map[string]interface{} `json:"batchUri,omitempty"`

	// REQUIRED; The Azure Storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; The Azure Batch pool name. Type: string (or Expression with resultType string).
	PoolName map[string]interface{} `json:"poolName,omitempty"`

	// The Azure Batch account access key.
	AccessKey SecretBaseClassification `json:"accessKey,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBatchLinkedServiceTypeProperties.
func (a AzureBatchLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessKey", a.AccessKey)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "batchUri", a.BatchURI)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "poolName", a.PoolName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedServiceTypeProperties.
func (a *AzureBatchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKey":
			a.AccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "accountName":
			err = unpopulate(val, &a.AccountName)
			delete(rawMsg, key)
		case "batchUri":
			err = unpopulate(val, &a.BatchURI)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "poolName":
			err = unpopulate(val, &a.PoolName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobDataset - The Azure Blob storage.
type AzureBlobDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Azure Blob dataset properties.
	TypeProperties *AzureBlobDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureBlobDataset.
func (a *AzureBlobDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobDataset.
func (a AzureBlobDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureBlob"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobDataset.
func (a *AzureBlobDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobDatasetTypeProperties - Azure Blob dataset properties.
type AzureBlobDatasetTypeProperties struct {
	// The data compression method used for the blob storage.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The name of the Azure Blob. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// The path of the Azure Blob storage. Type: string (or Expression with resultType string).
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// The format of the Azure Blob storage.
	Format DatasetStorageFormatClassification `json:"format,omitempty"`

	// The end of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// The root of blob path. Type: string (or Expression with resultType string).
	TableRootLocation map[string]interface{} `json:"tableRootLocation,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobDatasetTypeProperties.
func (a AzureBlobDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", a.Compression)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "format", a.Format)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "tableRootLocation", a.TableRootLocation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobDatasetTypeProperties.
func (a *AzureBlobDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &a.Compression)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "tableRootLocation":
			err = unpopulate(val, &a.TableRootLocation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSDataset - The Azure Data Lake Storage Gen2 storage.
type AzureBlobFSDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Azure Data Lake Storage Gen2 dataset properties.
	TypeProperties *AzureBlobFSDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureBlobFSDataset.
func (a *AzureBlobFSDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSDataset.
func (a AzureBlobFSDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureBlobFSFile"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSDataset.
func (a *AzureBlobFSDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSDatasetTypeProperties - Azure Data Lake Storage Gen2 dataset properties.
type AzureBlobFSDatasetTypeProperties struct {
	// The data compression method used for the blob storage.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The name of the Azure Data Lake Storage Gen2. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// The path of the Azure Data Lake Storage Gen2 storage. Type: string (or Expression with resultType string).
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// The format of the Azure Data Lake Storage Gen2 storage.
	Format DatasetStorageFormatClassification `json:"format,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSDatasetTypeProperties.
func (a AzureBlobFSDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", a.Compression)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "format", a.Format)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSDatasetTypeProperties.
func (a *AzureBlobFSDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &a.Compression)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSLinkedService - Azure Data Lake Storage Gen2 linked service.
type AzureBlobFSLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Data Lake Storage Gen2 linked service properties.
	TypeProperties *AzureBlobFSLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureBlobFSLinkedService.
func (a *AzureBlobFSLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSLinkedService.
func (a AzureBlobFSLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureBlobFS"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSLinkedService.
func (a *AzureBlobFSLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSLinkedServiceTypeProperties - Azure Data Lake Storage Gen2 linked service properties.
type AzureBlobFSLinkedServiceTypeProperties struct {
	// REQUIRED; Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
	AccountKey map[string]interface{} `json:"accountKey,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can
	// only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType map[string]interface{} `json:"servicePrincipalCredentialType,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSLinkedServiceTypeProperties.
func (a AzureBlobFSLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "servicePrincipalCredential", a.ServicePrincipalCredential)
	populate(objectMap, "servicePrincipalCredentialType", a.ServicePrincipalCredentialType)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	populate(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSLinkedServiceTypeProperties.
func (a *AzureBlobFSLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, &a.AccountKey)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &a.AzureCloudType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			a.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, &a.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSLocation - The location of azure blobFS dataset.
type AzureBlobFSLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the fileSystem of azure blobFS. Type: string (or Expression with resultType string).
	FileSystem map[string]interface{} `json:"fileSystem,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type AzureBlobFSLocation.
func (a *AzureBlobFSLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 a.Type,
		FolderPath:           a.FolderPath,
		FileName:             a.FileName,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSLocation.
func (a AzureBlobFSLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "fileSystem", a.FileSystem)
	populate(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureBlobFSLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSLocation.
func (a *AzureBlobFSLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "fileSystem":
			err = unpopulate(val, &a.FileSystem)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSReadSettings - Azure blobFS read settings.
type AzureBlobFSReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Azure blobFS wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Azure blobFS wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type AzureBlobFSReadSettings.
func (a *AzureBlobFSReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSReadSettings.
func (a AzureBlobFSReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", a.FileListPath)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", a.PartitionRootPath)
	populate(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureBlobFSReadSettings"
	populate(objectMap, "wildcardFileName", a.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSReadSettings.
func (a *AzureBlobFSReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &a.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSSink - A copy activity Azure Data Lake Storage Gen2 sink.
type AzureBlobFSSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Specify the custom metadata to be added to sink data. Type: array of objects (or Expression with resultType array of objects).
	Metadata []*MetadataItem `json:"metadata,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureBlobFSSink.
func (a *AzureBlobFSSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSSink.
func (a AzureBlobFSSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", a.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "metadata", a.Metadata)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureBlobFSSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSSink.
func (a *AzureBlobFSSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, &a.Metadata)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSSource - A copy activity Azure BlobFS source.
type AzureBlobFSSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
	SkipHeaderLineCount map[string]interface{} `json:"skipHeaderLineCount,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Treat empty as null. Type: boolean (or Expression with resultType boolean).
	TreatEmptyAsNull map[string]interface{} `json:"treatEmptyAsNull,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureBlobFSSource.
func (a *AzureBlobFSSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSSource.
func (a AzureBlobFSSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "recursive", a.Recursive)
	populate(objectMap, "skipHeaderLineCount", a.SkipHeaderLineCount)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populate(objectMap, "treatEmptyAsNull", a.TreatEmptyAsNull)
	objectMap["type"] = "AzureBlobFSSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSSource.
func (a *AzureBlobFSSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "skipHeaderLineCount":
			err = unpopulate(val, &a.SkipHeaderLineCount)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			err = unpopulate(val, &a.TreatEmptyAsNull)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobFSWriteSettings - Azure blobFS write settings.
type AzureBlobFSWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
	BlockSizeInMB map[string]interface{} `json:"blockSizeInMB,omitempty"`

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type AzureBlobFSWriteSettings.
func (a *AzureBlobFSWriteSettings) GetStoreWriteSettings() *StoreWriteSettings {
	return &StoreWriteSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		CopyBehavior:             a.CopyBehavior,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFSWriteSettings.
func (a AzureBlobFSWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blockSizeInMB", a.BlockSizeInMB)
	populate(objectMap, "copyBehavior", a.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureBlobFSWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFSWriteSettings.
func (a *AzureBlobFSWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blockSizeInMB":
			err = unpopulate(val, &a.BlockSizeInMB)
			delete(rawMsg, key)
		case "copyBehavior":
			err = unpopulate(val, &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobStorageLinkedService - The azure blob storage linked service.
type AzureBlobStorageLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Blob Storage linked service properties.
	TypeProperties *AzureBlobStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureBlobStorageLinkedService.
func (a *AzureBlobStorageLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLinkedService.
func (a AzureBlobStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureBlobStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedService.
func (a *AzureBlobStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobStorageLinkedServiceTypeProperties - Azure Blob Storage linked service properties.
type AzureBlobStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// Specify the kind of your storage account. Allowed values are: Storage (general purpose v1), StorageV2 (general purpose
	// v2), BlobStorage, or BlockBlobStorage. Type: string (or Expression with
	// resultType string).
	AccountKind *string `json:"accountKind,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type:
	// string, SecureString or AzureKeyVaultSecretReference.
	SasURI map[string]interface{} `json:"sasUri,omitempty"`

	// Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
	ServiceEndpoint *string `json:"serviceEndpoint,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Data Warehouse.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLinkedServiceTypeProperties.
func (a AzureBlobStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "accountKind", a.AccountKind)
	populate(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "sasToken", a.SasToken)
	populate(objectMap, "sasUri", a.SasURI)
	populate(objectMap, "serviceEndpoint", a.ServiceEndpoint)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedServiceTypeProperties.
func (a *AzureBlobStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, &a.AccountKey)
			delete(rawMsg, key)
		case "accountKind":
			err = unpopulate(val, &a.AccountKind)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, &a.SasToken)
			delete(rawMsg, key)
		case "sasUri":
			err = unpopulate(val, &a.SasURI)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, &a.ServiceEndpoint)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobStorageLocation - The location of azure blob dataset.
type AzureBlobStorageLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the container of azure blob. Type: string (or Expression with resultType string).
	Container map[string]interface{} `json:"container,omitempty"`

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type AzureBlobStorageLocation.
func (a *AzureBlobStorageLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 a.Type,
		FolderPath:           a.FolderPath,
		FileName:             a.FileName,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLocation.
func (a AzureBlobStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "container", a.Container)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureBlobStorageLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLocation.
func (a *AzureBlobStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "container":
			err = unpopulate(val, &a.Container)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobStorageReadSettings - Azure blob read settings.
type AzureBlobStorageReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The prefix filter for the Azure Blob name. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Azure blob wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Azure blob wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type AzureBlobStorageReadSettings.
func (a *AzureBlobStorageReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageReadSettings.
func (a AzureBlobStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", a.FileListPath)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", a.PartitionRootPath)
	populate(objectMap, "prefix", a.Prefix)
	populate(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureBlobStorageReadSettings"
	populate(objectMap, "wildcardFileName", a.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageReadSettings.
func (a *AzureBlobStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureBlobStorageWriteSettings - Azure blob write settings.
type AzureBlobStorageWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
	BlockSizeInMB map[string]interface{} `json:"blockSizeInMB,omitempty"`

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type AzureBlobStorageWriteSettings.
func (a *AzureBlobStorageWriteSettings) GetStoreWriteSettings() *StoreWriteSettings {
	return &StoreWriteSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		CopyBehavior:             a.CopyBehavior,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageWriteSettings.
func (a AzureBlobStorageWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blockSizeInMB", a.BlockSizeInMB)
	populate(objectMap, "copyBehavior", a.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureBlobStorageWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageWriteSettings.
func (a *AzureBlobStorageWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blockSizeInMB":
			err = unpopulate(val, &a.BlockSizeInMB)
			delete(rawMsg, key)
		case "copyBehavior":
			err = unpopulate(val, &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataExplorerCommandActivity - Azure Data Explorer command activity.
type AzureDataExplorerCommandActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Data Explorer command activity properties.
	TypeProperties *AzureDataExplorerCommandActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type AzureDataExplorerCommandActivity.
func (a *AzureDataExplorerCommandActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type AzureDataExplorerCommandActivity.
func (a *AzureDataExplorerCommandActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    a.LinkedServiceName,
		Policy:               a.Policy,
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerCommandActivity.
func (a AzureDataExplorerCommandActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "policy", a.Policy)
	objectMap["type"] = "AzureDataExplorerCommand"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerCommandActivity.
func (a *AzureDataExplorerCommandActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &a.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataExplorerCommandActivityTypeProperties - Azure Data Explorer command activity properties.
type AzureDataExplorerCommandActivityTypeProperties struct {
	// REQUIRED; A control command, according to the Azure Data Explorer command syntax. Type: string (or Expression with resultType
	// string).
	Command map[string]interface{} `json:"command,omitempty"`

	// Control command timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..)
	CommandTimeout map[string]interface{} `json:"commandTimeout,omitempty"`
}

// AzureDataExplorerDatasetTypeProperties - Azure Data Explorer (Kusto) dataset properties.
type AzureDataExplorerDatasetTypeProperties struct {
	// The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// AzureDataExplorerLinkedService - Azure Data Explorer (Kusto) linked service.
type AzureDataExplorerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Data Explorer (Kusto) linked service properties.
	TypeProperties *AzureDataExplorerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureDataExplorerLinkedService.
func (a *AzureDataExplorerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerLinkedService.
func (a AzureDataExplorerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDataExplorer"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedService.
func (a *AzureDataExplorerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataExplorerLinkedServiceTypeProperties - Azure Data Explorer (Kusto) linked service properties.
type AzureDataExplorerLinkedServiceTypeProperties struct {
	// REQUIRED; Database name for connection. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`

	// REQUIRED; The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://..kusto.windows.net.
	// Type: string (or Expression with resultType string)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Kusto.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerLinkedServiceTypeProperties.
func (a AzureDataExplorerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "database", a.Database)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedServiceTypeProperties.
func (a *AzureDataExplorerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, &a.Database)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &a.Endpoint)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataExplorerSink - A copy activity Azure Data Explorer sink.
type AzureDataExplorerSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// If set to true, any aggregation will be skipped. Default is false. Type: boolean.
	FlushImmediately map[string]interface{} `json:"flushImmediately,omitempty"`

	// An explicit column mapping description provided in a json format. Type: string.
	IngestionMappingAsJSON map[string]interface{} `json:"ingestionMappingAsJson,omitempty"`

	// A name of a pre-created csv mapping that was defined on the target Kusto table. Type: string.
	IngestionMappingName map[string]interface{} `json:"ingestionMappingName,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureDataExplorerSink.
func (a *AzureDataExplorerSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerSink.
func (a AzureDataExplorerSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "flushImmediately", a.FlushImmediately)
	populate(objectMap, "ingestionMappingAsJson", a.IngestionMappingAsJSON)
	populate(objectMap, "ingestionMappingName", a.IngestionMappingName)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureDataExplorerSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerSink.
func (a *AzureDataExplorerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "flushImmediately":
			err = unpopulate(val, &a.FlushImmediately)
			delete(rawMsg, key)
		case "ingestionMappingAsJson":
			err = unpopulate(val, &a.IngestionMappingAsJSON)
			delete(rawMsg, key)
		case "ingestionMappingName":
			err = unpopulate(val, &a.IngestionMappingName)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataExplorerSource - A copy activity Azure Data Explorer (Kusto) source.
type AzureDataExplorerSource struct {
	// REQUIRED; Database query. Should be a Kusto Query Language (KQL) query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The name of the Boolean option that controls whether truncation is applied to result-sets that go beyond a certain row-count
	// limit.
	NoTruncation map[string]interface{} `json:"noTruncation,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureDataExplorerSource.
func (a *AzureDataExplorerSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerSource.
func (a AzureDataExplorerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "noTruncation", a.NoTruncation)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureDataExplorerSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerSource.
func (a *AzureDataExplorerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "noTruncation":
			err = unpopulate(val, &a.NoTruncation)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataExplorerTableDataset - The Azure Data Explorer (Kusto) dataset.
type AzureDataExplorerTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Data Explorer (Kusto) dataset properties.
	TypeProperties *AzureDataExplorerDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureDataExplorerTableDataset.
func (a *AzureDataExplorerTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerTableDataset.
func (a AzureDataExplorerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureDataExplorerTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerTableDataset.
func (a *AzureDataExplorerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeAnalyticsLinkedService - Azure Data Lake Analytics linked service.
type AzureDataLakeAnalyticsLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Data Lake Analytics linked service properties.
	TypeProperties *AzureDataLakeAnalyticsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureDataLakeAnalyticsLinkedService.
func (a *AzureDataLakeAnalyticsLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a AzureDataLakeAnalyticsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDataLakeAnalytics"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a *AzureDataLakeAnalyticsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeAnalyticsLinkedServiceTypeProperties - Azure Data Lake Analytics linked service properties.
type AzureDataLakeAnalyticsLinkedServiceTypeProperties struct {
	// REQUIRED; The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
	AccountName map[string]interface{} `json:"accountName,omitempty"`

	// REQUIRED; The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType
	// string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`

	// Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
	DataLakeAnalyticsURI map[string]interface{} `json:"dataLakeAnalyticsUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with
	// resultType string).
	ResourceGroupName map[string]interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Analytics account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with
	// resultType string).
	SubscriptionID map[string]interface{} `json:"subscriptionId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeAnalyticsLinkedServiceTypeProperties.
func (a AzureDataLakeAnalyticsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "dataLakeAnalyticsUri", a.DataLakeAnalyticsURI)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "resourceGroupName", a.ResourceGroupName)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "subscriptionId", a.SubscriptionID)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedServiceTypeProperties.
func (a *AzureDataLakeAnalyticsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &a.AccountName)
			delete(rawMsg, key)
		case "dataLakeAnalyticsUri":
			err = unpopulate(val, &a.DataLakeAnalyticsURI)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, &a.ResourceGroupName)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &a.SubscriptionID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreDataset - Azure Data Lake Store dataset.
type AzureDataLakeStoreDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Azure Data Lake Store dataset properties.
	TypeProperties *AzureDataLakeStoreDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureDataLakeStoreDataset.
func (a *AzureDataLakeStoreDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreDataset.
func (a AzureDataLakeStoreDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureDataLakeStoreFile"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreDataset.
func (a *AzureDataLakeStoreDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreDatasetTypeProperties - Azure Data Lake Store dataset properties.
type AzureDataLakeStoreDatasetTypeProperties struct {
	// The data compression method used for the item(s) in the Azure Data Lake Store.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The name of the file in the Azure Data Lake Store. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Path to the folder in the Azure Data Lake Store. Type: string (or Expression with resultType string).
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// The format of the Data Lake Store.
	Format DatasetStorageFormatClassification `json:"format,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreDatasetTypeProperties.
func (a AzureDataLakeStoreDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", a.Compression)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "format", a.Format)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreDatasetTypeProperties.
func (a *AzureDataLakeStoreDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &a.Compression)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "format":
			a.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreLinkedService - Azure Data Lake Store linked service.
type AzureDataLakeStoreLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Data Lake Store linked service properties.
	TypeProperties *AzureDataLakeStoreLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureDataLakeStoreLinkedService.
func (a *AzureDataLakeStoreLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLinkedService.
func (a AzureDataLakeStoreLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDataLakeStore"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedService.
func (a *AzureDataLakeStoreLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreLinkedServiceTypeProperties - Azure Data Lake Store linked service properties.
type AzureDataLakeStoreLinkedServiceTypeProperties struct {
	// REQUIRED; Data Lake Store service URI. Type: string (or Expression with resultType string).
	DataLakeStoreURI map[string]interface{} `json:"dataLakeStoreUri,omitempty"`

	// Data Lake Store account name. Type: string (or Expression with resultType string).
	AccountName map[string]interface{} `json:"accountName,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with
	// resultType string).
	ResourceGroupName map[string]interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Store account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType
	// string).
	SubscriptionID map[string]interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLinkedServiceTypeProperties.
func (a AzureDataLakeStoreLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "dataLakeStoreUri", a.DataLakeStoreURI)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "resourceGroupName", a.ResourceGroupName)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "subscriptionId", a.SubscriptionID)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedServiceTypeProperties.
func (a *AzureDataLakeStoreLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &a.AccountName)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &a.AzureCloudType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "dataLakeStoreUri":
			err = unpopulate(val, &a.DataLakeStoreURI)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, &a.ResourceGroupName)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &a.SubscriptionID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreLocation - The location of azure data lake store dataset.
type AzureDataLakeStoreLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type AzureDataLakeStoreLocation.
func (a *AzureDataLakeStoreLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 a.Type,
		FolderPath:           a.FolderPath,
		FileName:             a.FileName,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLocation.
func (a AzureDataLakeStoreLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureDataLakeStoreLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLocation.
func (a *AzureDataLakeStoreLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreReadSettings - Azure data lake store read settings.
type AzureDataLakeStoreReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// Lists files after the value (exclusive) based on file/folder names lexicographical order. Applies under the folderPath
	// in data set, and filter files/sub-folders under the folderPath. Type: string (or
	// Expression with resultType string).
	ListAfter map[string]interface{} `json:"listAfter,omitempty"`

	// Lists files before the value (inclusive) based on file/folder names lexicographical order. Applies under the folderPath
	// in data set, and filter files/sub-folders under the folderPath. Type: string
	// (or Expression with resultType string).
	ListBefore map[string]interface{} `json:"listBefore,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// ADLS wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// ADLS wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type AzureDataLakeStoreReadSettings.
func (a *AzureDataLakeStoreReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreReadSettings.
func (a AzureDataLakeStoreReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", a.FileListPath)
	populate(objectMap, "listAfter", a.ListAfter)
	populate(objectMap, "listBefore", a.ListBefore)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", a.PartitionRootPath)
	populate(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureDataLakeStoreReadSettings"
	populate(objectMap, "wildcardFileName", a.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreReadSettings.
func (a *AzureDataLakeStoreReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &a.FileListPath)
			delete(rawMsg, key)
		case "listAfter":
			err = unpopulate(val, &a.ListAfter)
			delete(rawMsg, key)
		case "listBefore":
			err = unpopulate(val, &a.ListBefore)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &a.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreSink - A copy activity Azure Data Lake Store sink.
type AzureDataLakeStoreSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Single File Parallel.
	EnableAdlsSingleFileParallel map[string]interface{} `json:"enableAdlsSingleFileParallel,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureDataLakeStoreSink.
func (a *AzureDataLakeStoreSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreSink.
func (a AzureDataLakeStoreSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", a.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enableAdlsSingleFileParallel", a.EnableAdlsSingleFileParallel)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureDataLakeStoreSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreSink.
func (a *AzureDataLakeStoreSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enableAdlsSingleFileParallel":
			err = unpopulate(val, &a.EnableAdlsSingleFileParallel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreSource - A copy activity Azure Data Lake source.
type AzureDataLakeStoreSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureDataLakeStoreSource.
func (a *AzureDataLakeStoreSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreSource.
func (a AzureDataLakeStoreSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "recursive", a.Recursive)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureDataLakeStoreSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreSource.
func (a *AzureDataLakeStoreSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDataLakeStoreWriteSettings - Azure data lake store write settings.
type AzureDataLakeStoreWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies the expiry time of the written files. The time is applied to the UTC time zone in the format of "2018-12-01T05:00:00Z".
	// Default value is NULL. Type: integer (or Expression with resultType
	// integer).
	ExpiryDateTime map[string]interface{} `json:"expiryDateTime,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type AzureDataLakeStoreWriteSettings.
func (a *AzureDataLakeStoreWriteSettings) GetStoreWriteSettings() *StoreWriteSettings {
	return &StoreWriteSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		CopyBehavior:             a.CopyBehavior,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreWriteSettings.
func (a AzureDataLakeStoreWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", a.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "expiryDateTime", a.ExpiryDateTime)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureDataLakeStoreWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreWriteSettings.
func (a *AzureDataLakeStoreWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "expiryDateTime":
			err = unpopulate(val, &a.ExpiryDateTime)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDeltaLakeDataset - Azure Databricks Delta Lake dataset.
type AzureDatabricksDeltaLakeDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *AzureDatabricksDeltaLakeDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureDatabricksDeltaLakeDataset.
func (a *AzureDatabricksDeltaLakeDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeDataset.
func (a AzureDatabricksDeltaLakeDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureDatabricksDeltaLakeDataset"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeDataset.
func (a *AzureDatabricksDeltaLakeDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDeltaLakeDatasetTypeProperties - Azure Databricks Delta Lake Dataset Properties
type AzureDatabricksDeltaLakeDatasetTypeProperties struct {
	// The database name of delta table. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`

	// The name of delta table. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// AzureDatabricksDeltaLakeExportCommand - Azure Databricks Delta Lake export command settings.
type AzureDatabricksDeltaLakeExportCommand struct {
	// REQUIRED; The export setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the date format for the csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
	DateFormat map[string]interface{} `json:"dateFormat,omitempty"`

	// Specify the timestamp format for the csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType
	// string).
	TimestampFormat map[string]interface{} `json:"timestampFormat,omitempty"`
}

// GetExportSettings implements the ExportSettingsClassification interface for type AzureDatabricksDeltaLakeExportCommand.
func (a *AzureDatabricksDeltaLakeExportCommand) GetExportSettings() *ExportSettings {
	return &ExportSettings{
		Type:                 a.Type,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeExportCommand.
func (a AzureDatabricksDeltaLakeExportCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dateFormat", a.DateFormat)
	populate(objectMap, "timestampFormat", a.TimestampFormat)
	objectMap["type"] = "AzureDatabricksDeltaLakeExportCommand"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeExportCommand.
func (a *AzureDatabricksDeltaLakeExportCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateFormat":
			err = unpopulate(val, &a.DateFormat)
			delete(rawMsg, key)
		case "timestampFormat":
			err = unpopulate(val, &a.TimestampFormat)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDeltaLakeImportCommand - Azure Databricks Delta Lake import command settings.
type AzureDatabricksDeltaLakeImportCommand struct {
	// REQUIRED; The import setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the date format for csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
	DateFormat map[string]interface{} `json:"dateFormat,omitempty"`

	// Specify the timestamp format for csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
	TimestampFormat map[string]interface{} `json:"timestampFormat,omitempty"`
}

// GetImportSettings implements the ImportSettingsClassification interface for type AzureDatabricksDeltaLakeImportCommand.
func (a *AzureDatabricksDeltaLakeImportCommand) GetImportSettings() *ImportSettings {
	return &ImportSettings{
		Type:                 a.Type,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeImportCommand.
func (a AzureDatabricksDeltaLakeImportCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dateFormat", a.DateFormat)
	populate(objectMap, "timestampFormat", a.TimestampFormat)
	objectMap["type"] = "AzureDatabricksDeltaLakeImportCommand"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeImportCommand.
func (a *AzureDatabricksDeltaLakeImportCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dateFormat":
			err = unpopulate(val, &a.DateFormat)
			delete(rawMsg, key)
		case "timestampFormat":
			err = unpopulate(val, &a.TimestampFormat)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDeltaLakeLinkedService - Azure Databricks Delta Lake linked service.
type AzureDatabricksDeltaLakeLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Databricks Delta Lake linked service properties.
	TypeProperties *AzureDatabricksDetltaLakeLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureDatabricksDeltaLakeLinkedService.
func (a *AzureDatabricksDeltaLakeLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeLinkedService.
func (a AzureDatabricksDeltaLakeLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDatabricksDeltaLake"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeLinkedService.
func (a *AzureDatabricksDeltaLakeLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDeltaLakeSink - A copy activity Azure Databricks Delta Lake sink.
type AzureDatabricksDeltaLakeSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Azure Databricks Delta Lake import settings.
	ImportSettings *AzureDatabricksDeltaLakeImportCommand `json:"importSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureDatabricksDeltaLakeSink.
func (a *AzureDatabricksDeltaLakeSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeSink.
func (a AzureDatabricksDeltaLakeSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "importSettings", a.ImportSettings)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", a.PreCopyScript)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureDatabricksDeltaLakeSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeSink.
func (a *AzureDatabricksDeltaLakeSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "importSettings":
			err = unpopulate(val, &a.ImportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &a.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDeltaLakeSource - A copy activity Azure Databricks Delta Lake source.
type AzureDatabricksDeltaLakeSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Azure Databricks Delta Lake export settings.
	ExportSettings *AzureDatabricksDeltaLakeExportCommand `json:"exportSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Azure Databricks Delta Lake Sql query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureDatabricksDeltaLakeSource.
func (a *AzureDatabricksDeltaLakeSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDeltaLakeSource.
func (a AzureDatabricksDeltaLakeSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "exportSettings", a.ExportSettings)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureDatabricksDeltaLakeSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDeltaLakeSource.
func (a *AzureDatabricksDeltaLakeSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "exportSettings":
			err = unpopulate(val, &a.ExportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksDetltaLakeLinkedServiceTypeProperties - Azure Databricks Delta Lake linked service properties.
type AzureDatabricksDetltaLakeLinkedServiceTypeProperties struct {
	// REQUIRED; .azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType
	// string).
	Domain map[string]interface{} `json:"domain,omitempty"`

	// Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string,
	// SecureString or AzureKeyVaultSecretReference.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The id of an existing interactive cluster that will be used for all runs of this job. Type: string (or Expression with
	// resultType string).
	ClusterID map[string]interface{} `json:"clusterId,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Workspace resource id for databricks REST API. Type: string (or Expression with resultType string).
	WorkspaceResourceID map[string]interface{} `json:"workspaceResourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksDetltaLakeLinkedServiceTypeProperties.
func (a AzureDatabricksDetltaLakeLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", a.AccessToken)
	populate(objectMap, "clusterId", a.ClusterID)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "domain", a.Domain)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "workspaceResourceId", a.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksDetltaLakeLinkedServiceTypeProperties.
func (a *AzureDatabricksDetltaLakeLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			a.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clusterId":
			err = unpopulate(val, &a.ClusterID)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, &a.Domain)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "workspaceResourceId":
			err = unpopulate(val, &a.WorkspaceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksLinkedService - Azure Databricks linked service.
type AzureDatabricksLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Databricks linked service properties.
	TypeProperties *AzureDatabricksLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureDatabricksLinkedService.
func (a *AzureDatabricksLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksLinkedService.
func (a AzureDatabricksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureDatabricks"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedService.
func (a *AzureDatabricksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureDatabricksLinkedServiceTypeProperties - Azure Databricks linked service properties.
type AzureDatabricksLinkedServiceTypeProperties struct {
	// REQUIRED; .azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType
	// string).
	Domain map[string]interface{} `json:"domain,omitempty"`

	// Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string
	// (or Expression with resultType string).
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// Required to specify MSI, if using Workspace resource id for databricks REST API. Type: string (or Expression with resultType
	// string).
	Authentication map[string]interface{} `json:"authentication,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression
	// with resultType string).
	ExistingClusterID map[string]interface{} `json:"existingClusterId,omitempty"`

	// The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType
	// string).
	InstancePoolID map[string]interface{} `json:"instancePoolId,omitempty"`

	// Additional tags for cluster resources. This property is ignored in instance pool configurations.
	NewClusterCustomTags map[string]map[string]interface{} `json:"newClusterCustomTags,omitempty"`

	// The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or
	// Expression with resultType string).
	NewClusterDriverNodeType map[string]interface{} `json:"newClusterDriverNodeType,omitempty"`

	// Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in
	// Databricks (elastic disks are always enabled). Type: boolean (or Expression
	// with resultType boolean).
	NewClusterEnableElasticDisk map[string]interface{} `json:"newClusterEnableElasticDisk,omitempty"`

	// User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of
	// strings).
	NewClusterInitScripts map[string]interface{} `json:"newClusterInitScripts,omitempty"`

	// Specify a location to deliver Spark driver, worker, and event logs. Type: string (or Expression with resultType string).
	NewClusterLogDestination map[string]interface{} `json:"newClusterLogDestination,omitempty"`

	// The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is
	// not specified. If instancePoolId is specified, this property is ignored. Type:
	// string (or Expression with resultType string).
	NewClusterNodeType map[string]interface{} `json:"newClusterNodeType,omitempty"`

	// If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster
	// or instance pool. For new job clusters, this a string-formatted Int32, like '1'
	// means numOfWorker is 1 or '1:10' means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted
	// Int32, and can only specify a fixed number of worker nodes, such as '2'.
	// Required if newClusterVersion is specified. Type: string (or Expression with resultType string).
	NewClusterNumOfWorker map[string]interface{} `json:"newClusterNumOfWorker,omitempty"`

	// A set of optional, user-specified Spark configuration key-value pairs.
	NewClusterSparkConf map[string]map[string]interface{} `json:"newClusterSparkConf,omitempty"`

	// A set of optional, user-specified Spark environment variables key-value pairs.
	NewClusterSparkEnvVars map[string]map[string]interface{} `json:"newClusterSparkEnvVars,omitempty"`

	// If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes
	// created for each run of this activity. Required if instancePoolId is
	// specified. Type: string (or Expression with resultType string).
	NewClusterVersion map[string]interface{} `json:"newClusterVersion,omitempty"`

	// The policy id for limiting the ability to configure clusters based on a user defined set of rules. Type: string (or Expression
	// with resultType string).
	PolicyID map[string]interface{} `json:"policyId,omitempty"`

	// Workspace resource id for databricks REST API. Type: string (or Expression with resultType string).
	WorkspaceResourceID map[string]interface{} `json:"workspaceResourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksLinkedServiceTypeProperties.
func (a AzureDatabricksLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", a.AccessToken)
	populate(objectMap, "authentication", a.Authentication)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "domain", a.Domain)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "existingClusterId", a.ExistingClusterID)
	populate(objectMap, "instancePoolId", a.InstancePoolID)
	populate(objectMap, "newClusterCustomTags", a.NewClusterCustomTags)
	populate(objectMap, "newClusterDriverNodeType", a.NewClusterDriverNodeType)
	populate(objectMap, "newClusterEnableElasticDisk", a.NewClusterEnableElasticDisk)
	populate(objectMap, "newClusterInitScripts", a.NewClusterInitScripts)
	populate(objectMap, "newClusterLogDestination", a.NewClusterLogDestination)
	populate(objectMap, "newClusterNodeType", a.NewClusterNodeType)
	populate(objectMap, "newClusterNumOfWorker", a.NewClusterNumOfWorker)
	populate(objectMap, "newClusterSparkConf", a.NewClusterSparkConf)
	populate(objectMap, "newClusterSparkEnvVars", a.NewClusterSparkEnvVars)
	populate(objectMap, "newClusterVersion", a.NewClusterVersion)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "workspaceResourceId", a.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedServiceTypeProperties.
func (a *AzureDatabricksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			a.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &a.Authentication)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, &a.Domain)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "existingClusterId":
			err = unpopulate(val, &a.ExistingClusterID)
			delete(rawMsg, key)
		case "instancePoolId":
			err = unpopulate(val, &a.InstancePoolID)
			delete(rawMsg, key)
		case "newClusterCustomTags":
			err = unpopulate(val, &a.NewClusterCustomTags)
			delete(rawMsg, key)
		case "newClusterDriverNodeType":
			err = unpopulate(val, &a.NewClusterDriverNodeType)
			delete(rawMsg, key)
		case "newClusterEnableElasticDisk":
			err = unpopulate(val, &a.NewClusterEnableElasticDisk)
			delete(rawMsg, key)
		case "newClusterInitScripts":
			err = unpopulate(val, &a.NewClusterInitScripts)
			delete(rawMsg, key)
		case "newClusterLogDestination":
			err = unpopulate(val, &a.NewClusterLogDestination)
			delete(rawMsg, key)
		case "newClusterNodeType":
			err = unpopulate(val, &a.NewClusterNodeType)
			delete(rawMsg, key)
		case "newClusterNumOfWorker":
			err = unpopulate(val, &a.NewClusterNumOfWorker)
			delete(rawMsg, key)
		case "newClusterSparkConf":
			err = unpopulate(val, &a.NewClusterSparkConf)
			delete(rawMsg, key)
		case "newClusterSparkEnvVars":
			err = unpopulate(val, &a.NewClusterSparkEnvVars)
			delete(rawMsg, key)
		case "newClusterVersion":
			err = unpopulate(val, &a.NewClusterVersion)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, &a.PolicyID)
			delete(rawMsg, key)
		case "workspaceResourceId":
			err = unpopulate(val, &a.WorkspaceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFileStorageLinkedService - Azure File Storage linked service.
type AzureFileStorageLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure File Storage linked service properties.
	TypeProperties *AzureFileStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureFileStorageLinkedService.
func (a *AzureFileStorageLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLinkedService.
func (a AzureFileStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureFileStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedService.
func (a *AzureFileStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFileStorageLinkedServiceTypeProperties - Azure File Storage linked service properties.
type AzureFileStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The azure file share name. It is required when auth with accountKey/sasToken. Type: string (or Expression with resultType
	// string).
	FileShare map[string]interface{} `json:"fileShare,omitempty"`

	// Host name of the server. Type: string (or Expression with resultType string).
	Host map[string]interface{} `json:"host,omitempty"`

	// Password to logon the server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure File resource. It is mutually exclusive with connectionString property. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	SasURI map[string]interface{} `json:"sasUri,omitempty"`

	// The azure file share snapshot version. Type: string (or Expression with resultType string).
	Snapshot map[string]interface{} `json:"snapshot,omitempty"`

	// User ID to logon the server. Type: string (or Expression with resultType string).
	UserID map[string]interface{} `json:"userId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLinkedServiceTypeProperties.
func (a AzureFileStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "fileShare", a.FileShare)
	populate(objectMap, "host", a.Host)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "sasToken", a.SasToken)
	populate(objectMap, "sasUri", a.SasURI)
	populate(objectMap, "snapshot", a.Snapshot)
	populate(objectMap, "userId", a.UserID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedServiceTypeProperties.
func (a *AzureFileStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, &a.AccountKey)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "fileShare":
			err = unpopulate(val, &a.FileShare)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &a.Host)
			delete(rawMsg, key)
		case "password":
			a.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, &a.SasToken)
			delete(rawMsg, key)
		case "sasUri":
			err = unpopulate(val, &a.SasURI)
			delete(rawMsg, key)
		case "snapshot":
			err = unpopulate(val, &a.Snapshot)
			delete(rawMsg, key)
		case "userId":
			err = unpopulate(val, &a.UserID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFileStorageLocation - The location of file server dataset.
type AzureFileStorageLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type AzureFileStorageLocation.
func (a *AzureFileStorageLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 a.Type,
		FolderPath:           a.FolderPath,
		FileName:             a.FileName,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLocation.
func (a AzureFileStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "folderPath", a.FolderPath)
	objectMap["type"] = "AzureFileStorageLocation"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLocation.
func (a *AzureFileStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &a.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFileStorageReadSettings - Azure File Storage read settings.
type AzureFileStorageReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The prefix filter for the Azure File name starting from root path. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Azure File Storage wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Azure File Storage wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type AzureFileStorageReadSettings.
func (a *AzureFileStorageReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageReadSettings.
func (a AzureFileStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", a.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", a.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", a.FileListPath)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", a.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", a.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", a.PartitionRootPath)
	populate(objectMap, "prefix", a.Prefix)
	populate(objectMap, "recursive", a.Recursive)
	objectMap["type"] = "AzureFileStorageReadSettings"
	populate(objectMap, "wildcardFileName", a.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", a.WildcardFolderPath)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageReadSettings.
func (a *AzureFileStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &a.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &a.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &a.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &a.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &a.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &a.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &a.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &a.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &a.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &a.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFileStorageWriteSettings - Azure File Storage write settings.
type AzureFileStorageWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type AzureFileStorageWriteSettings.
func (a *AzureFileStorageWriteSettings) GetStoreWriteSettings() *StoreWriteSettings {
	return &StoreWriteSettings{
		Type:                     a.Type,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		CopyBehavior:             a.CopyBehavior,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageWriteSettings.
func (a AzureFileStorageWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", a.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	objectMap["type"] = "AzureFileStorageWriteSettings"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageWriteSettings.
func (a *AzureFileStorageWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &a.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFunctionActivity - Azure Function activity.
type AzureFunctionActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Function activity properties.
	TypeProperties *AzureFunctionActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type AzureFunctionActivity.
func (a *AzureFunctionActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type AzureFunctionActivity.
func (a *AzureFunctionActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    a.LinkedServiceName,
		Policy:               a.Policy,
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionActivity.
func (a AzureFunctionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "policy", a.Policy)
	objectMap["type"] = "AzureFunctionActivity"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionActivity.
func (a *AzureFunctionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &a.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFunctionActivityTypeProperties - Azure Function activity type properties.
type AzureFunctionActivityTypeProperties struct {
	// REQUIRED; Name of the Function that the Azure Function Activity will call. Type: string (or Expression with resultType
	// string)
	FunctionName map[string]interface{} `json:"functionName,omitempty"`

	// REQUIRED; Rest API method for target endpoint.
	Method *AzureFunctionActivityMethod `json:"method,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type:
	// string (or Expression with resultType string).
	Body map[string]interface{} `json:"body,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers"
	// : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type:
	// string (or Expression with resultType string).
	Headers map[string]interface{} `json:"headers,omitempty"`
}

// AzureFunctionLinkedService - Azure Function linked service.
type AzureFunctionLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Function linked service properties.
	TypeProperties *AzureFunctionLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureFunctionLinkedService.
func (a *AzureFunctionLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionLinkedService.
func (a AzureFunctionLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureFunction"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedService.
func (a *AzureFunctionLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFunctionLinkedServiceTypeProperties - Azure Function linked service properties.
type AzureFunctionLinkedServiceTypeProperties struct {
	// REQUIRED; The endpoint of the Azure Function App. URL will be in the format https://.azurewebsites.net.
	FunctionAppURL map[string]interface{} `json:"functionAppUrl,omitempty"`

	// Type of authentication (Required to specify MSI) used to connect to AzureFunction. Type: string (or Expression with resultType
	// string).
	Authentication map[string]interface{} `json:"authentication,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Function or Host key for Azure Function App.
	FunctionKey SecretBaseClassification `json:"functionKey,omitempty"`

	// Allowed token audiences for azure function.
	ResourceID map[string]interface{} `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionLinkedServiceTypeProperties.
func (a AzureFunctionLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authentication", a.Authentication)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "functionAppUrl", a.FunctionAppURL)
	populate(objectMap, "functionKey", a.FunctionKey)
	populate(objectMap, "resourceId", a.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedServiceTypeProperties.
func (a *AzureFunctionLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, &a.Authentication)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "functionAppUrl":
			err = unpopulate(val, &a.FunctionAppURL)
			delete(rawMsg, key)
		case "functionKey":
			a.FunctionKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &a.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureKeyVaultLinkedService - Azure Key Vault linked service.
type AzureKeyVaultLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Key Vault linked service properties.
	TypeProperties *AzureKeyVaultLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureKeyVaultLinkedService.
func (a *AzureKeyVaultLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultLinkedService.
func (a AzureKeyVaultLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureKeyVault"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultLinkedService.
func (a *AzureKeyVaultLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureKeyVaultLinkedServiceTypeProperties - Azure Key Vault linked service properties.
type AzureKeyVaultLinkedServiceTypeProperties struct {
	// REQUIRED; The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType
	// string).
	BaseURL map[string]interface{} `json:"baseUrl,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`
}

// AzureKeyVaultSecretReference - Azure Key Vault secret reference.
type AzureKeyVaultSecretReference struct {
	// REQUIRED; The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
	SecretName map[string]interface{} `json:"secretName,omitempty"`

	// REQUIRED; The Azure Key Vault linked service reference.
	Store *LinkedServiceReference `json:"store,omitempty"`

	// REQUIRED; Type of the secret.
	Type *string `json:"type,omitempty"`

	// The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression
	// with resultType string).
	SecretVersion map[string]interface{} `json:"secretVersion,omitempty"`
}

// GetSecretBase implements the SecretBaseClassification interface for type AzureKeyVaultSecretReference.
func (a *AzureKeyVaultSecretReference) GetSecretBase() *SecretBase {
	return &SecretBase{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultSecretReference.
func (a AzureKeyVaultSecretReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "secretName", a.SecretName)
	populate(objectMap, "secretVersion", a.SecretVersion)
	populate(objectMap, "store", a.Store)
	objectMap["type"] = "AzureKeyVaultSecret"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultSecretReference.
func (a *AzureKeyVaultSecretReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretName":
			err = unpopulate(val, &a.SecretName)
			delete(rawMsg, key)
		case "secretVersion":
			err = unpopulate(val, &a.SecretVersion)
			delete(rawMsg, key)
		case "store":
			err = unpopulate(val, &a.Store)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLBatchExecutionActivity - Azure ML Batch Execution activity.
type AzureMLBatchExecutionActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure ML Batch Execution activity properties.
	TypeProperties *AzureMLBatchExecutionActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type AzureMLBatchExecutionActivity.
func (a *AzureMLBatchExecutionActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type AzureMLBatchExecutionActivity.
func (a *AzureMLBatchExecutionActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    a.LinkedServiceName,
		Policy:               a.Policy,
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLBatchExecutionActivity.
func (a AzureMLBatchExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "policy", a.Policy)
	objectMap["type"] = "AzureMLBatchExecution"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLBatchExecutionActivity.
func (a *AzureMLBatchExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &a.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLBatchExecutionActivityTypeProperties - Azure ML Batch Execution activity properties.
type AzureMLBatchExecutionActivityTypeProperties struct {
	// Key,Value pairs to be passed to the Azure ML Batch Execution Service endpoint. Keys must match the names of web service
	// parameters defined in the published Azure ML web service. Values will be passed
	// in the GlobalParameters property of the Azure ML batch execution request.
	GlobalParameters map[string]map[string]interface{} `json:"globalParameters,omitempty"`

	// Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Inputs to AzureMLWebServiceFile objects specifying
	// the input Blob locations.. This information will be passed in the
	// WebServiceInputs property of the Azure ML batch execution request.
	WebServiceInputs map[string]*AzureMLWebServiceFile `json:"webServiceInputs,omitempty"`

	// Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Outputs to AzureMLWebServiceFile objects specifying
	// the output Blob locations. This information will be passed in the
	// WebServiceOutputs property of the Azure ML batch execution request.
	WebServiceOutputs map[string]*AzureMLWebServiceFile `json:"webServiceOutputs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLBatchExecutionActivityTypeProperties.
func (a AzureMLBatchExecutionActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "globalParameters", a.GlobalParameters)
	populate(objectMap, "webServiceInputs", a.WebServiceInputs)
	populate(objectMap, "webServiceOutputs", a.WebServiceOutputs)
	return json.Marshal(objectMap)
}

// AzureMLExecutePipelineActivity - Azure ML Execute Pipeline activity.
type AzureMLExecutePipelineActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure ML Execute Pipeline activity properties.
	TypeProperties *AzureMLExecutePipelineActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type AzureMLExecutePipelineActivity.
func (a *AzureMLExecutePipelineActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type AzureMLExecutePipelineActivity.
func (a *AzureMLExecutePipelineActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    a.LinkedServiceName,
		Policy:               a.Policy,
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLExecutePipelineActivity.
func (a AzureMLExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "policy", a.Policy)
	objectMap["type"] = "AzureMLExecutePipeline"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLExecutePipelineActivity.
func (a *AzureMLExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &a.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLExecutePipelineActivityTypeProperties - Azure ML Execute Pipeline activity properties.
type AzureMLExecutePipelineActivityTypeProperties struct {
	// Whether to continue execution of other steps in the PipelineRun if a step fails. This information will be passed in the
	// continueOnStepFailure property of the published pipeline execution request.
	// Type: boolean (or Expression with resultType boolean).
	ContinueOnStepFailure map[string]interface{} `json:"continueOnStepFailure,omitempty"`

	// Dictionary used for changing data path assignments without retraining. Values will be passed in the dataPathAssignments
	// property of the published pipeline execution request. Type: object with key
	// value pairs (or Expression with resultType object).
	DataPathAssignments map[string]interface{} `json:"dataPathAssignments,omitempty"`

	// Run history experiment name of the pipeline run. This information will be passed in the ExperimentName property of the
	// published pipeline execution request. Type: string (or Expression with resultType
	// string).
	ExperimentName map[string]interface{} `json:"experimentName,omitempty"`

	// The parent Azure ML Service pipeline run id. This information will be passed in the ParentRunId property of the published
	// pipeline execution request. Type: string (or Expression with resultType
	// string).
	MlParentRunID map[string]interface{} `json:"mlParentRunId,omitempty"`

	// ID of the published Azure ML pipeline endpoint. Type: string (or Expression with resultType string).
	MlPipelineEndpointID map[string]interface{} `json:"mlPipelineEndpointId,omitempty"`

	// ID of the published Azure ML pipeline. Type: string (or Expression with resultType string).
	MlPipelineID map[string]interface{} `json:"mlPipelineId,omitempty"`

	// Key,Value pairs to be passed to the published Azure ML pipeline endpoint. Keys must match the names of pipeline parameters
	// defined in the published pipeline. Values will be passed in the
	// ParameterAssignments property of the published pipeline execution request. Type: object with key value pairs (or Expression
	// with resultType object).
	MlPipelineParameters map[string]interface{} `json:"mlPipelineParameters,omitempty"`

	// Version of the published Azure ML pipeline endpoint. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`
}

// AzureMLLinkedService - Azure ML Studio Web Service linked service.
type AzureMLLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure ML Studio Web Service linked service properties.
	TypeProperties *AzureMLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureMLLinkedService.
func (a *AzureMLLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLLinkedService.
func (a AzureMLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureML"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLLinkedService.
func (a *AzureMLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLLinkedServiceTypeProperties - Azure ML Studio Web Service linked service properties.
type AzureMLLinkedServiceTypeProperties struct {
	// REQUIRED; The API key for accessing the Azure ML model endpoint.
	APIKey SecretBaseClassification `json:"apiKey,omitempty"`

	// REQUIRED; The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType
	// string).
	MlEndpoint map[string]interface{} `json:"mlEndpoint,omitempty"`

	// Type of authentication (Required to specify MSI) used to connect to AzureML. Type: string (or Expression with resultType
	// string).
	Authentication map[string]interface{} `json:"authentication,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio
	// web service. Type: string (or Expression with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio
	// web service.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`

	// The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
	UpdateResourceEndpoint map[string]interface{} `json:"updateResourceEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLLinkedServiceTypeProperties.
func (a AzureMLLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiKey", a.APIKey)
	populate(objectMap, "authentication", a.Authentication)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "mlEndpoint", a.MlEndpoint)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	populate(objectMap, "updateResourceEndpoint", a.UpdateResourceEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLLinkedServiceTypeProperties.
func (a *AzureMLLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiKey":
			a.APIKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &a.Authentication)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "mlEndpoint":
			err = unpopulate(val, &a.MlEndpoint)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		case "updateResourceEndpoint":
			err = unpopulate(val, &a.UpdateResourceEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLServiceLinkedService - Azure ML Service linked service.
type AzureMLServiceLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure ML Service linked service properties.
	TypeProperties *AzureMLServiceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureMLServiceLinkedService.
func (a *AzureMLServiceLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLServiceLinkedService.
func (a AzureMLServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureMLService"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLServiceLinkedService.
func (a *AzureMLServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLServiceLinkedServiceTypeProperties - Azure ML Service linked service properties.
type AzureMLServiceLinkedServiceTypeProperties struct {
	// REQUIRED; Azure ML Service workspace name. Type: string (or Expression with resultType string).
	MlWorkspaceName map[string]interface{} `json:"mlWorkspaceName,omitempty"`

	// REQUIRED; Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
	ResourceGroupName map[string]interface{} `json:"resourceGroupName,omitempty"`

	// REQUIRED; Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
	SubscriptionID map[string]interface{} `json:"subscriptionId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type:
	// string (or Expression with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLServiceLinkedServiceTypeProperties.
func (a AzureMLServiceLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "mlWorkspaceName", a.MlWorkspaceName)
	populate(objectMap, "resourceGroupName", a.ResourceGroupName)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "subscriptionId", a.SubscriptionID)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLServiceLinkedServiceTypeProperties.
func (a *AzureMLServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "mlWorkspaceName":
			err = unpopulate(val, &a.MlWorkspaceName)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, &a.ResourceGroupName)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &a.SubscriptionID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLUpdateResourceActivity - Azure ML Update Resource management activity.
type AzureMLUpdateResourceActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure ML Update Resource management activity properties.
	TypeProperties *AzureMLUpdateResourceActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type AzureMLUpdateResourceActivity.
func (a *AzureMLUpdateResourceActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type AzureMLUpdateResourceActivity.
func (a *AzureMLUpdateResourceActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    a.LinkedServiceName,
		Policy:               a.Policy,
		Name:                 a.Name,
		Type:                 a.Type,
		Description:          a.Description,
		DependsOn:            a.DependsOn,
		UserProperties:       a.UserProperties,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMLUpdateResourceActivity.
func (a AzureMLUpdateResourceActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", a.DependsOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "policy", a.Policy)
	objectMap["type"] = "AzureMLUpdateResource"
	populate(objectMap, "typeProperties", a.TypeProperties)
	populate(objectMap, "userProperties", a.UserProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMLUpdateResourceActivity.
func (a *AzureMLUpdateResourceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &a.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &a.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &a.UserProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMLUpdateResourceActivityTypeProperties - Azure ML Update Resource activity properties.
type AzureMLUpdateResourceActivityTypeProperties struct {
	// REQUIRED; The relative file path in trainedModelLinkedService to represent the .ilearner file that will be uploaded by
	// the update operation. Type: string (or Expression with resultType string).
	TrainedModelFilePath map[string]interface{} `json:"trainedModelFilePath,omitempty"`

	// REQUIRED; Name of Azure Storage linked service holding the .ilearner file that will be uploaded by the update operation.
	TrainedModelLinkedServiceName *LinkedServiceReference `json:"trainedModelLinkedServiceName,omitempty"`

	// REQUIRED; Name of the Trained Model module in the Web Service experiment to be updated. Type: string (or Expression with
	// resultType string).
	TrainedModelName map[string]interface{} `json:"trainedModelName,omitempty"`
}

// AzureMLWebServiceFile - Azure ML WebService Input/Output file
type AzureMLWebServiceFile struct {
	// REQUIRED; The relative file path, including container name, in the Azure Blob Storage specified by the LinkedService. Type:
	// string (or Expression with resultType string).
	FilePath map[string]interface{} `json:"filePath,omitempty"`

	// REQUIRED; Reference to an Azure Storage LinkedService, where Azure ML WebService Input/Output file located.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`
}

// AzureMariaDBLinkedService - Azure Database for MariaDB linked service.
type AzureMariaDBLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Database for MariaDB linked service properties.
	TypeProperties *AzureMariaDBLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureMariaDBLinkedService.
func (a *AzureMariaDBLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBLinkedService.
func (a AzureMariaDBLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureMariaDB"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBLinkedService.
func (a *AzureMariaDBLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMariaDBLinkedServiceTypeProperties - Azure Database for MariaDB linked service properties.
type AzureMariaDBLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// AzureMariaDBSource - A copy activity Azure MariaDB source.
type AzureMariaDBSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureMariaDBSource.
func (a *AzureMariaDBSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AzureMariaDBSource.
func (a *AzureMariaDBSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBSource.
func (a AzureMariaDBSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureMariaDBSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBSource.
func (a *AzureMariaDBSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMariaDBTableDataset - Azure Database for MariaDB dataset.
type AzureMariaDBTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureMariaDBTableDataset.
func (a *AzureMariaDBTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDBTableDataset.
func (a AzureMariaDBTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureMariaDBTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDBTableDataset.
func (a *AzureMariaDBTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMySQLLinkedService - Azure MySQL database linked service.
type AzureMySQLLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure MySQL database linked service properties.
	TypeProperties *AzureMySQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureMySQLLinkedService.
func (a *AzureMySQLLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLLinkedService.
func (a AzureMySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureMySql"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLLinkedService.
func (a *AzureMySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMySQLLinkedServiceTypeProperties - Azure MySQL database linked service properties.
type AzureMySQLLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// AzureMySQLSink - A copy activity Azure MySql sink.
type AzureMySQLSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureMySQLSink.
func (a *AzureMySQLSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLSink.
func (a AzureMySQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", a.PreCopyScript)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureMySqlSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLSink.
func (a *AzureMySQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &a.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMySQLSource - A copy activity Azure MySQL source.
type AzureMySQLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureMySQLSource.
func (a *AzureMySQLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AzureMySQLSource.
func (a *AzureMySQLSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLSource.
func (a AzureMySQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureMySqlSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLSource.
func (a *AzureMySQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMySQLTableDataset - The Azure MySQL database dataset.
type AzureMySQLTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure MySQL database dataset properties.
	TypeProperties *AzureMySQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureMySQLTableDataset.
func (a *AzureMySQLTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLTableDataset.
func (a AzureMySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureMySqlTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLTableDataset.
func (a *AzureMySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureMySQLTableDatasetTypeProperties - Azure MySQL database dataset properties.
type AzureMySQLTableDatasetTypeProperties struct {
	// The name of Azure MySQL database table. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// The Azure MySQL database table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AzurePostgreSQLLinkedService - Azure PostgreSQL linked service.
type AzurePostgreSQLLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure PostgreSQL linked service properties.
	TypeProperties *AzurePostgreSQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzurePostgreSQLLinkedService.
func (a *AzurePostgreSQLLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLLinkedService.
func (a AzurePostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzurePostgreSql"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLLinkedService.
func (a *AzurePostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzurePostgreSQLLinkedServiceTypeProperties - Azure PostgreSQL linked service properties.
type AzurePostgreSQLLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// AzurePostgreSQLSink - A copy activity Azure PostgreSQL sink.
type AzurePostgreSQLSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzurePostgreSQLSink.
func (a *AzurePostgreSQLSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLSink.
func (a AzurePostgreSQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", a.PreCopyScript)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzurePostgreSqlSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLSink.
func (a *AzurePostgreSQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &a.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzurePostgreSQLSource - A copy activity Azure PostgreSQL source.
type AzurePostgreSQLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzurePostgreSQLSource.
func (a *AzurePostgreSQLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AzurePostgreSQLSource.
func (a *AzurePostgreSQLSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLSource.
func (a AzurePostgreSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "query", a.Query)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzurePostgreSqlSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLSource.
func (a *AzurePostgreSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &a.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzurePostgreSQLTableDataset - Azure PostgreSQL dataset.
type AzurePostgreSQLTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *AzurePostgreSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzurePostgreSQLTableDataset.
func (a *AzurePostgreSQLTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLTableDataset.
func (a AzurePostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzurePostgreSqlTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLTableDataset.
func (a *AzurePostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzurePostgreSQLTableDatasetTypeProperties - Azure PostgreSQL dataset properties.
type AzurePostgreSQLTableDatasetTypeProperties struct {
	// The schema name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with
	// resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AzureQueueSink - A copy activity Azure Queue sink.
type AzureQueueSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureQueueSink.
func (a *AzureQueueSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureQueueSink.
func (a AzureQueueSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureQueueSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureQueueSink.
func (a *AzureQueueSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLDWLinkedService - Azure SQL Data Warehouse linked service.
type AzureSQLDWLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure SQL Data Warehouse linked service properties.
	TypeProperties *AzureSQLDWLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureSQLDWLinkedService.
func (a *AzureSQLDWLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWLinkedService.
func (a AzureSQLDWLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSqlDW"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWLinkedService.
func (a *AzureSQLDWLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLDWLinkedServiceTypeProperties - Azure SQL Data Warehouse linked service properties.
type AzureSQLDWLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Data Warehouse.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWLinkedServiceTypeProperties.
func (a AzureSQLDWLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWLinkedServiceTypeProperties.
func (a *AzureSQLDWLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureCloudType":
			err = unpopulate(val, &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &a.Password)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLDWTableDataset - The Azure SQL Data Warehouse dataset.
type AzureSQLDWTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Azure SQL Data Warehouse dataset properties.
	TypeProperties *AzureSQLDWTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureSQLDWTableDataset.
func (a *AzureSQLDWTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDWTableDataset.
func (a AzureSQLDWTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSqlDWTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDWTableDataset.
func (a *AzureSQLDWTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLDWTableDatasetTypeProperties - Azure SQL Data Warehouse dataset properties.
type AzureSQLDWTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AzureSQLDatabaseLinkedService - Microsoft Azure SQL Database linked service.
type AzureSQLDatabaseLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure SQL Database linked service properties.
	TypeProperties *AzureSQLDatabaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureSQLDatabaseLinkedService.
func (a *AzureSQLDatabaseLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseLinkedService.
func (a AzureSQLDatabaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSqlDatabase"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedService.
func (a *AzureSQLDatabaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLDatabaseLinkedServiceTypeProperties - Azure SQL Database linked service properties.
type AzureSQLDatabaseLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Sql always encrypted properties.
	AlwaysEncryptedSettings *SQLAlwaysEncryptedProperties `json:"alwaysEncryptedSettings,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Database.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseLinkedServiceTypeProperties.
func (a AzureSQLDatabaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alwaysEncryptedSettings", a.AlwaysEncryptedSettings)
	populate(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedServiceTypeProperties.
func (a *AzureSQLDatabaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, &a.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &a.Password)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLMILinkedService - Azure SQL Managed Instance linked service.
type AzureSQLMILinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure SQL Managed Instance linked service properties.
	TypeProperties *AzureSQLMILinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureSQLMILinkedService.
func (a *AzureSQLMILinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMILinkedService.
func (a AzureSQLMILinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSqlMI"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMILinkedService.
func (a *AzureSQLMILinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLMILinkedServiceTypeProperties - Azure SQL Managed Instance linked service properties.
type AzureSQLMILinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Sql always encrypted properties.
	AlwaysEncryptedSettings *SQLAlwaysEncryptedProperties `json:"alwaysEncryptedSettings,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Managed Instance.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMILinkedServiceTypeProperties.
func (a AzureSQLMILinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alwaysEncryptedSettings", a.AlwaysEncryptedSettings)
	populate(objectMap, "azureCloudType", a.AzureCloudType)
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "credential", a.Credential)
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "password", a.Password)
	populate(objectMap, "servicePrincipalId", a.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", a.ServicePrincipalKey)
	populate(objectMap, "tenant", a.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMILinkedServiceTypeProperties.
func (a *AzureSQLMILinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, &a.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &a.AzureCloudType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &a.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &a.Credential)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &a.Password)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &a.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &a.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLMITableDataset - The Azure SQL Managed Instance dataset.
type AzureSQLMITableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Azure SQL Managed Instance dataset properties.
	TypeProperties *AzureSQLMITableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureSQLMITableDataset.
func (a *AzureSQLMITableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMITableDataset.
func (a AzureSQLMITableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSqlMITable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMITableDataset.
func (a *AzureSQLMITableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLMITableDatasetTypeProperties - Azure SQL Managed Instance dataset properties.
type AzureSQLMITableDatasetTypeProperties struct {
	// The schema name of the Azure SQL Managed Instance. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AzureSQLSink - A copy activity Azure SQL sink.
type AzureSQLSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName map[string]interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType map[string]interface{} `json:"sqlWriterTableType,omitempty"`

	// Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
	SQLWriterUseTableLock map[string]interface{} `json:"sqlWriterUseTableLock,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName map[string]interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression
	// with resultType string).
	TableOption map[string]interface{} `json:"tableOption,omitempty"`

	// SQL upsert settings.
	UpsertSettings *SQLUpsertSettings `json:"upsertSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Write behavior when copying data into Azure SQL. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureSQLSink.
func (a *AzureSQLSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSink.
func (a AzureSQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", a.PreCopyScript)
	populate(objectMap, "sqlWriterStoredProcedureName", a.SQLWriterStoredProcedureName)
	populate(objectMap, "sqlWriterTableType", a.SQLWriterTableType)
	populate(objectMap, "sqlWriterUseTableLock", a.SQLWriterUseTableLock)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	populate(objectMap, "storedProcedureParameters", a.StoredProcedureParameters)
	populate(objectMap, "storedProcedureTableTypeParameterName", a.StoredProcedureTableTypeParameterName)
	populate(objectMap, "tableOption", a.TableOption)
	objectMap["type"] = "AzureSqlSink"
	populate(objectMap, "upsertSettings", a.UpsertSettings)
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", a.WriteBehavior)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSink.
func (a *AzureSQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &a.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, &a.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, &a.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, &a.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &a.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, &a.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, &a.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, &a.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &a.WriteBehavior)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLSource - A copy activity Azure SQL source.
type AzureSQLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Sql source partitioning.
	PartitionSettings *SQLPartitionSettings `json:"partitionSettings,omitempty"`

	// Which additional types to produce.
	ProduceAdditionalTypes map[string]interface{} `json:"produceAdditionalTypes,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery map[string]interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string
	// (or Expression with resultType string).
	SQLReaderStoredProcedureName map[string]interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureSQLSource.
func (a *AzureSQLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AzureSQLSource.
func (a *AzureSQLSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSource.
func (a AzureSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", a.PartitionOption)
	populate(objectMap, "partitionSettings", a.PartitionSettings)
	populate(objectMap, "produceAdditionalTypes", a.ProduceAdditionalTypes)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sqlReaderQuery", a.SQLReaderQuery)
	populate(objectMap, "sqlReaderStoredProcedureName", a.SQLReaderStoredProcedureName)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	populate(objectMap, "storedProcedureParameters", a.StoredProcedureParameters)
	objectMap["type"] = "AzureSqlSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSource.
func (a *AzureSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &a.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &a.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, &a.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, &a.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, &a.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &a.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLTableDataset - The Azure SQL Server database dataset.
type AzureSQLTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Azure SQL dataset properties.
	TypeProperties *AzureSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureSQLTableDataset.
func (a *AzureSQLTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLTableDataset.
func (a AzureSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSqlTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLTableDataset.
func (a *AzureSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSQLTableDatasetTypeProperties - Azure SQL dataset properties.
type AzureSQLTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL database. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL database. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AzureSearchIndexDataset - The Azure Search Index.
type AzureSearchIndexDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this dataset type.
	TypeProperties *AzureSearchIndexDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureSearchIndexDataset.
func (a *AzureSearchIndexDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexDataset.
func (a AzureSearchIndexDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureSearchIndex"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexDataset.
func (a *AzureSearchIndexDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSearchIndexDatasetTypeProperties - Properties specific to this dataset type.
type AzureSearchIndexDatasetTypeProperties struct {
	// REQUIRED; The name of the Azure Search Index. Type: string (or Expression with resultType string).
	IndexName map[string]interface{} `json:"indexName,omitempty"`
}

// AzureSearchIndexSink - A copy activity Azure Search Index sink.
type AzureSearchIndexSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Specify the write behavior when upserting documents into Azure Search Index.
	WriteBehavior *AzureSearchIndexWriteBehaviorType `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureSearchIndexSink.
func (a *AzureSearchIndexSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexSink.
func (a AzureSearchIndexSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureSearchIndexSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", a.WriteBehavior)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexSink.
func (a *AzureSearchIndexSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &a.WriteBehavior)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSearchLinkedService - Linked service for Windows Azure Search Service.
type AzureSearchLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Windows Azure Search Service linked service properties.
	TypeProperties *AzureSearchLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureSearchLinkedService.
func (a *AzureSearchLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchLinkedService.
func (a AzureSearchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureSearch"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedService.
func (a *AzureSearchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureSearchLinkedServiceTypeProperties - Windows Azure Search Service linked service properties.
type AzureSearchLinkedServiceTypeProperties struct {
	// REQUIRED; URL for Azure Search service. Type: string (or Expression with resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Admin Key for Azure Search service
	Key SecretBaseClassification `json:"key,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchLinkedServiceTypeProperties.
func (a AzureSearchLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", a.EncryptedCredential)
	populate(objectMap, "key", a.Key)
	populate(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedServiceTypeProperties.
func (a *AzureSearchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &a.EncryptedCredential)
			delete(rawMsg, key)
		case "key":
			a.Key, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureStorageLinkedService - The storage account linked service.
type AzureStorageLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Storage linked service properties.
	TypeProperties *AzureStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureStorageLinkedService.
func (a *AzureStorageLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageLinkedService.
func (a AzureStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageLinkedService.
func (a *AzureStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureStorageLinkedServiceTypeProperties - Azure Storage linked service properties.
type AzureStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	SasURI map[string]interface{} `json:"sasUri,omitempty"`
}

// AzureTableDataset - The Azure Table storage dataset.
type AzureTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Table dataset properties.
	TypeProperties *AzureTableDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type AzureTableDataset.
func (a *AzureTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 a.Type,
		Description:          a.Description,
		Structure:            a.Structure,
		Schema:               a.Schema,
		LinkedServiceName:    a.LinkedServiceName,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		Folder:               a.Folder,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableDataset.
func (a AzureTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "folder", a.Folder)
	populate(objectMap, "linkedServiceName", a.LinkedServiceName)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "schema", a.Schema)
	populate(objectMap, "structure", a.Structure)
	objectMap["type"] = "AzureTable"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableDataset.
func (a *AzureTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &a.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &a.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &a.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &a.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureTableDatasetTypeProperties - Azure Table dataset properties.
type AzureTableDatasetTypeProperties struct {
	// REQUIRED; The table name of the Azure Table storage. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// AzureTableSink - A copy activity Azure Table sink.
type AzureTableSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Azure Table default partition key value. Type: string (or Expression with resultType string).
	AzureTableDefaultPartitionKeyValue map[string]interface{} `json:"azureTableDefaultPartitionKeyValue,omitempty"`

	// Azure Table insert type. Type: string (or Expression with resultType string).
	AzureTableInsertType map[string]interface{} `json:"azureTableInsertType,omitempty"`

	// Azure Table partition key name. Type: string (or Expression with resultType string).
	AzureTablePartitionKeyName map[string]interface{} `json:"azureTablePartitionKeyName,omitempty"`

	// Azure Table row key name. Type: string (or Expression with resultType string).
	AzureTableRowKeyName map[string]interface{} `json:"azureTableRowKeyName,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type AzureTableSink.
func (a *AzureTableSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     a.Type,
		WriteBatchSize:           a.WriteBatchSize,
		WriteBatchTimeout:        a.WriteBatchTimeout,
		SinkRetryCount:           a.SinkRetryCount,
		SinkRetryWait:            a.SinkRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableSink.
func (a AzureTableSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureTableDefaultPartitionKeyValue", a.AzureTableDefaultPartitionKeyValue)
	populate(objectMap, "azureTableInsertType", a.AzureTableInsertType)
	populate(objectMap, "azureTablePartitionKeyName", a.AzureTablePartitionKeyName)
	populate(objectMap, "azureTableRowKeyName", a.AzureTableRowKeyName)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", a.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", a.SinkRetryWait)
	objectMap["type"] = "AzureTableSink"
	populate(objectMap, "writeBatchSize", a.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", a.WriteBatchTimeout)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableSink.
func (a *AzureTableSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureTableDefaultPartitionKeyValue":
			err = unpopulate(val, &a.AzureTableDefaultPartitionKeyValue)
			delete(rawMsg, key)
		case "azureTableInsertType":
			err = unpopulate(val, &a.AzureTableInsertType)
			delete(rawMsg, key)
		case "azureTablePartitionKeyName":
			err = unpopulate(val, &a.AzureTablePartitionKeyName)
			delete(rawMsg, key)
		case "azureTableRowKeyName":
			err = unpopulate(val, &a.AzureTableRowKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &a.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &a.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &a.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &a.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureTableSource - A copy activity Azure Table source.
type AzureTableSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Azure Table source ignore table not found. Type: boolean (or Expression with resultType boolean).
	AzureTableSourceIgnoreTableNotFound map[string]interface{} `json:"azureTableSourceIgnoreTableNotFound,omitempty"`

	// Azure Table source query. Type: string (or Expression with resultType string).
	AzureTableSourceQuery map[string]interface{} `json:"azureTableSourceQuery,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type AzureTableSource.
func (a *AzureTableSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type AzureTableSource.
func (a *AzureTableSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             a.QueryTimeout,
		AdditionalColumns:        a.AdditionalColumns,
		Type:                     a.Type,
		SourceRetryCount:         a.SourceRetryCount,
		SourceRetryWait:          a.SourceRetryWait,
		MaxConcurrentConnections: a.MaxConcurrentConnections,
		DisableMetricsCollection: a.DisableMetricsCollection,
		AdditionalProperties:     a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableSource.
func (a AzureTableSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", a.AdditionalColumns)
	populate(objectMap, "azureTableSourceIgnoreTableNotFound", a.AzureTableSourceIgnoreTableNotFound)
	populate(objectMap, "azureTableSourceQuery", a.AzureTableSourceQuery)
	populate(objectMap, "disableMetricsCollection", a.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", a.MaxConcurrentConnections)
	populate(objectMap, "queryTimeout", a.QueryTimeout)
	populate(objectMap, "sourceRetryCount", a.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", a.SourceRetryWait)
	objectMap["type"] = "AzureTableSource"
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableSource.
func (a *AzureTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &a.AdditionalColumns)
			delete(rawMsg, key)
		case "azureTableSourceIgnoreTableNotFound":
			err = unpopulate(val, &a.AzureTableSourceIgnoreTableNotFound)
			delete(rawMsg, key)
		case "azureTableSourceQuery":
			err = unpopulate(val, &a.AzureTableSourceQuery)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &a.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &a.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &a.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &a.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &a.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureTableStorageLinkedService - The azure table storage linked service.
type AzureTableStorageLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Azure Table Storage linked service properties.
	TypeProperties *AzureStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type AzureTableStorageLinkedService.
func (a *AzureTableStorageLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 a.Type,
		ConnectVia:           a.ConnectVia,
		Description:          a.Description,
		Parameters:           a.Parameters,
		Annotations:          a.Annotations,
		AdditionalProperties: a.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableStorageLinkedService.
func (a AzureTableStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	populate(objectMap, "connectVia", a.ConnectVia)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = "AzureTableStorage"
	populate(objectMap, "typeProperties", a.TypeProperties)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableStorageLinkedService.
func (a *AzureTableStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &a.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &a.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &a.TypeProperties)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BinaryDataset - Binary dataset.
type BinaryDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Binary dataset properties.
	TypeProperties *BinaryDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type BinaryDataset.
func (b *BinaryDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 b.Type,
		Description:          b.Description,
		Structure:            b.Structure,
		Schema:               b.Schema,
		LinkedServiceName:    b.LinkedServiceName,
		Parameters:           b.Parameters,
		Annotations:          b.Annotations,
		Folder:               b.Folder,
		AdditionalProperties: b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BinaryDataset.
func (b BinaryDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", b.Annotations)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "folder", b.Folder)
	populate(objectMap, "linkedServiceName", b.LinkedServiceName)
	populate(objectMap, "parameters", b.Parameters)
	populate(objectMap, "schema", b.Schema)
	populate(objectMap, "structure", b.Structure)
	objectMap["type"] = "Binary"
	populate(objectMap, "typeProperties", b.TypeProperties)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDataset.
func (b *BinaryDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &b.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &b.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &b.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &b.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &b.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &b.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &b.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &b.TypeProperties)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BinaryDatasetTypeProperties - Binary dataset properties.
type BinaryDatasetTypeProperties struct {
	// REQUIRED; The location of the Binary storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data compression method used for the binary dataset.
	Compression *DatasetCompression `json:"compression,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BinaryDatasetTypeProperties.
func (b BinaryDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", b.Compression)
	populate(objectMap, "location", b.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDatasetTypeProperties.
func (b *BinaryDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &b.Compression)
			delete(rawMsg, key)
		case "location":
			b.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BinaryReadSettings - Binary read settings.
type BinaryReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Compression settings.
	CompressionProperties CompressionReadSettingsClassification `json:"compressionProperties,omitempty"`
}

// GetFormatReadSettings implements the FormatReadSettingsClassification interface for type BinaryReadSettings.
func (b *BinaryReadSettings) GetFormatReadSettings() *FormatReadSettings {
	return &FormatReadSettings{
		Type:                 b.Type,
		AdditionalProperties: b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BinaryReadSettings.
func (b BinaryReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compressionProperties", b.CompressionProperties)
	objectMap["type"] = "BinaryReadSettings"
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryReadSettings.
func (b *BinaryReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			b.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BinarySink - A copy activity Binary sink.
type BinarySink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Binary store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type BinarySink.
func (b *BinarySink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     b.Type,
		WriteBatchSize:           b.WriteBatchSize,
		WriteBatchTimeout:        b.WriteBatchTimeout,
		SinkRetryCount:           b.SinkRetryCount,
		SinkRetryWait:            b.SinkRetryWait,
		MaxConcurrentConnections: b.MaxConcurrentConnections,
		DisableMetricsCollection: b.DisableMetricsCollection,
		AdditionalProperties:     b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BinarySink.
func (b BinarySink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", b.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", b.SinkRetryWait)
	populate(objectMap, "storeSettings", b.StoreSettings)
	objectMap["type"] = "BinarySink"
	populate(objectMap, "writeBatchSize", b.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", b.WriteBatchTimeout)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinarySink.
func (b *BinarySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &b.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &b.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			b.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &b.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &b.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BinarySource - A copy activity Binary source.
type BinarySource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Binary format settings.
	FormatSettings *BinaryReadSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Binary store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type BinarySource.
func (b *BinarySource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     b.Type,
		SourceRetryCount:         b.SourceRetryCount,
		SourceRetryWait:          b.SourceRetryWait,
		MaxConcurrentConnections: b.MaxConcurrentConnections,
		DisableMetricsCollection: b.DisableMetricsCollection,
		AdditionalProperties:     b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BinarySource.
func (b BinarySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populate(objectMap, "formatSettings", b.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", b.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", b.SourceRetryWait)
	populate(objectMap, "storeSettings", b.StoreSettings)
	objectMap["type"] = "BinarySource"
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinarySource.
func (b *BinarySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &b.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &b.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &b.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			b.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobEventsTrigger - Trigger that runs every time a Blob event occurs.
type BlobEventsTrigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Blob Events Trigger properties.
	TypeProperties *BlobEventsTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Pipelines that need to be started.
	Pipelines []*TriggerPipelineReference `json:"pipelines,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetMultiplePipelineTrigger implements the MultiplePipelineTriggerClassification interface for type BlobEventsTrigger.
func (b *BlobEventsTrigger) GetMultiplePipelineTrigger() *MultiplePipelineTrigger {
	return &MultiplePipelineTrigger{
		Pipelines:            b.Pipelines,
		Type:                 b.Type,
		Description:          b.Description,
		RuntimeState:         b.RuntimeState,
		Annotations:          b.Annotations,
		AdditionalProperties: b.AdditionalProperties,
	}
}

// GetTrigger implements the TriggerClassification interface for type BlobEventsTrigger.
func (b *BlobEventsTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 b.Type,
		Description:          b.Description,
		RuntimeState:         b.RuntimeState,
		Annotations:          b.Annotations,
		AdditionalProperties: b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobEventsTrigger.
func (b BlobEventsTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", b.Annotations)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "pipelines", b.Pipelines)
	populate(objectMap, "runtimeState", b.RuntimeState)
	objectMap["type"] = "BlobEventsTrigger"
	populate(objectMap, "typeProperties", b.TypeProperties)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobEventsTrigger.
func (b *BlobEventsTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &b.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &b.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, &b.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &b.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &b.TypeProperties)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobEventsTriggerTypeProperties - Blob Events Trigger properties.
type BlobEventsTriggerTypeProperties struct {
	// REQUIRED; The type of events that cause this trigger to fire.
	Events []*BlobEventTypes `json:"events,omitempty"`

	// REQUIRED; The ARM resource ID of the Storage Account.
	Scope *string `json:"scope,omitempty"`

	// The blob path must begin with the pattern provided for trigger to fire. For example, '/records/blobs/december/' will only
	// fire the trigger for blobs in the december folder under the records container.
	// At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
	BlobPathBeginsWith *string `json:"blobPathBeginsWith,omitempty"`

	// The blob path must end with the pattern provided for trigger to fire. For example, 'december/boxes.csv' will only fire
	// the trigger for blobs named boxes in a december folder. At least one of these
	// must be provided: blobPathBeginsWith, blobPathEndsWith.
	BlobPathEndsWith *string `json:"blobPathEndsWith,omitempty"`

	// If set to true, blobs with zero bytes will be ignored.
	IgnoreEmptyBlobs *bool `json:"ignoreEmptyBlobs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobEventsTriggerTypeProperties.
func (b BlobEventsTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobPathBeginsWith", b.BlobPathBeginsWith)
	populate(objectMap, "blobPathEndsWith", b.BlobPathEndsWith)
	populate(objectMap, "events", b.Events)
	populate(objectMap, "ignoreEmptyBlobs", b.IgnoreEmptyBlobs)
	populate(objectMap, "scope", b.Scope)
	return json.Marshal(objectMap)
}

// BlobSink - A copy activity Azure Blob sink.
type BlobSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Blob writer add header. Type: boolean (or Expression with resultType boolean).
	BlobWriterAddHeader map[string]interface{} `json:"blobWriterAddHeader,omitempty"`

	// Blob writer date time format. Type: string (or Expression with resultType string).
	BlobWriterDateTimeFormat map[string]interface{} `json:"blobWriterDateTimeFormat,omitempty"`

	// Blob writer overwrite files. Type: boolean (or Expression with resultType boolean).
	BlobWriterOverwriteFiles map[string]interface{} `json:"blobWriterOverwriteFiles,omitempty"`

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Specify the custom metadata to be added to sink data. Type: array of objects (or Expression with resultType array of objects).
	Metadata []*MetadataItem `json:"metadata,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type BlobSink.
func (b *BlobSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     b.Type,
		WriteBatchSize:           b.WriteBatchSize,
		WriteBatchTimeout:        b.WriteBatchTimeout,
		SinkRetryCount:           b.SinkRetryCount,
		SinkRetryWait:            b.SinkRetryWait,
		MaxConcurrentConnections: b.MaxConcurrentConnections,
		DisableMetricsCollection: b.DisableMetricsCollection,
		AdditionalProperties:     b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobSink.
func (b BlobSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobWriterAddHeader", b.BlobWriterAddHeader)
	populate(objectMap, "blobWriterDateTimeFormat", b.BlobWriterDateTimeFormat)
	populate(objectMap, "blobWriterOverwriteFiles", b.BlobWriterOverwriteFiles)
	populate(objectMap, "copyBehavior", b.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "sinkRetryCount", b.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", b.SinkRetryWait)
	objectMap["type"] = "BlobSink"
	populate(objectMap, "writeBatchSize", b.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", b.WriteBatchTimeout)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobSink.
func (b *BlobSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobWriterAddHeader":
			err = unpopulate(val, &b.BlobWriterAddHeader)
			delete(rawMsg, key)
		case "blobWriterDateTimeFormat":
			err = unpopulate(val, &b.BlobWriterDateTimeFormat)
			delete(rawMsg, key)
		case "blobWriterOverwriteFiles":
			err = unpopulate(val, &b.BlobWriterOverwriteFiles)
			delete(rawMsg, key)
		case "copyBehavior":
			err = unpopulate(val, &b.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, &b.Metadata)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &b.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &b.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &b.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &b.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobSource - A copy activity Azure Blob source.
type BlobSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
	SkipHeaderLineCount map[string]interface{} `json:"skipHeaderLineCount,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Treat empty as null. Type: boolean (or Expression with resultType boolean).
	TreatEmptyAsNull map[string]interface{} `json:"treatEmptyAsNull,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type BlobSource.
func (b *BlobSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     b.Type,
		SourceRetryCount:         b.SourceRetryCount,
		SourceRetryWait:          b.SourceRetryWait,
		MaxConcurrentConnections: b.MaxConcurrentConnections,
		DisableMetricsCollection: b.DisableMetricsCollection,
		AdditionalProperties:     b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobSource.
func (b BlobSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", b.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", b.MaxConcurrentConnections)
	populate(objectMap, "recursive", b.Recursive)
	populate(objectMap, "skipHeaderLineCount", b.SkipHeaderLineCount)
	populate(objectMap, "sourceRetryCount", b.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", b.SourceRetryWait)
	populate(objectMap, "treatEmptyAsNull", b.TreatEmptyAsNull)
	objectMap["type"] = "BlobSource"
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobSource.
func (b *BlobSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &b.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &b.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &b.Recursive)
			delete(rawMsg, key)
		case "skipHeaderLineCount":
			err = unpopulate(val, &b.SkipHeaderLineCount)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &b.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &b.SourceRetryWait)
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			err = unpopulate(val, &b.TreatEmptyAsNull)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobTrigger - Trigger that runs every time the selected Blob container changes.
type BlobTrigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Blob Trigger properties.
	TypeProperties *BlobTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Pipelines that need to be started.
	Pipelines []*TriggerPipelineReference `json:"pipelines,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetMultiplePipelineTrigger implements the MultiplePipelineTriggerClassification interface for type BlobTrigger.
func (b *BlobTrigger) GetMultiplePipelineTrigger() *MultiplePipelineTrigger {
	return &MultiplePipelineTrigger{
		Pipelines:            b.Pipelines,
		Type:                 b.Type,
		Description:          b.Description,
		RuntimeState:         b.RuntimeState,
		Annotations:          b.Annotations,
		AdditionalProperties: b.AdditionalProperties,
	}
}

// GetTrigger implements the TriggerClassification interface for type BlobTrigger.
func (b *BlobTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 b.Type,
		Description:          b.Description,
		RuntimeState:         b.RuntimeState,
		Annotations:          b.Annotations,
		AdditionalProperties: b.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobTrigger.
func (b BlobTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", b.Annotations)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "pipelines", b.Pipelines)
	populate(objectMap, "runtimeState", b.RuntimeState)
	objectMap["type"] = "BlobTrigger"
	populate(objectMap, "typeProperties", b.TypeProperties)
	if b.AdditionalProperties != nil {
		for key, val := range b.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobTrigger.
func (b *BlobTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &b.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &b.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, &b.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &b.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &b.TypeProperties)
			delete(rawMsg, key)
		default:
			if b.AdditionalProperties == nil {
				b.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				b.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobTriggerTypeProperties - Blob Trigger properties.
type BlobTriggerTypeProperties struct {
	// REQUIRED; The path of the container/folder that will trigger the pipeline.
	FolderPath *string `json:"folderPath,omitempty"`

	// REQUIRED; The Azure Storage linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`

	// REQUIRED; The max number of parallel files to handle when it is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`
}

// CMKIdentityDefinition - Managed Identity used for CMK.
type CMKIdentityDefinition struct {
	// The resource id of the user assigned identity to authenticate to customer's key vault.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// CassandraLinkedService - Linked service for Cassandra data source.
type CassandraLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Cassandra linked service properties.
	TypeProperties *CassandraLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type CassandraLinkedService.
func (c *CassandraLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CassandraLinkedService.
func (c CassandraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "Cassandra"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedService.
func (c *CassandraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CassandraLinkedServiceTypeProperties - Cassandra linked service properties.
type CassandraLinkedServiceTypeProperties struct {
	// REQUIRED; Host name for connection. Type: string (or Expression with resultType string).
	Host map[string]interface{} `json:"host,omitempty"`

	// AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port for the connection. Type: integer (or Expression with resultType integer).
	Port map[string]interface{} `json:"port,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CassandraLinkedServiceTypeProperties.
func (c CassandraLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", c.AuthenticationType)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populate(objectMap, "host", c.Host)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "port", c.Port)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedServiceTypeProperties.
func (c *CassandraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &c.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &c.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &c.Host)
			delete(rawMsg, key)
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &c.Port)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CassandraSource - A copy activity source for a Cassandra database.
type CassandraSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The consistency level specifies how many Cassandra servers must respond to a read request before returning data to the
	// client application. Cassandra checks the specified number of Cassandra servers
	// for data to satisfy the read request. Must be one of cassandraSourceReadConsistencyLevels. The default value is 'ONE'.
	// It is case-insensitive.
	ConsistencyLevel *CassandraSourceReadConsistencyLevels `json:"consistencyLevel,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Should be a SQL-92 query expression or Cassandra Query Language (CQL) command. Type: string (or Expression
	// with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CassandraSource.
func (c *CassandraSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type CassandraSource.
func (c *CassandraSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             c.QueryTimeout,
		AdditionalColumns:        c.AdditionalColumns,
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CassandraSource.
func (c CassandraSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "consistencyLevel", c.ConsistencyLevel)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "query", c.Query)
	populate(objectMap, "queryTimeout", c.QueryTimeout)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CassandraSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraSource.
func (c *CassandraSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &c.AdditionalColumns)
			delete(rawMsg, key)
		case "consistencyLevel":
			err = unpopulate(val, &c.ConsistencyLevel)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &c.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CassandraTableDataset - The Cassandra database dataset.
type CassandraTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Cassandra dataset properties.
	TypeProperties *CassandraTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type CassandraTableDataset.
func (c *CassandraTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CassandraTableDataset.
func (c CassandraTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "CassandraTable"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraTableDataset.
func (c *CassandraTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CassandraTableDatasetTypeProperties - Cassandra dataset properties.
type CassandraTableDatasetTypeProperties struct {
	// The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
	Keyspace map[string]interface{} `json:"keyspace,omitempty"`

	// The table name of the Cassandra database. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// ChainingTrigger - Trigger that allows the referenced pipeline to depend on other pipeline runs based on runDimension Name/Value
// pairs. Upstream pipelines should declare the same runDimension Name and their runs should
// have the values for those runDimensions. The referenced pipeline run would be triggered if the values for the runDimension
// match for all upstream pipeline runs.
type ChainingTrigger struct {
	// REQUIRED; Pipeline for which runs are created when all upstream pipelines complete successfully.
	Pipeline *TriggerPipelineReference `json:"pipeline,omitempty"`

	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Chaining Trigger properties.
	TypeProperties *ChainingTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetTrigger implements the TriggerClassification interface for type ChainingTrigger.
func (c *ChainingTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 c.Type,
		Description:          c.Description,
		RuntimeState:         c.RuntimeState,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ChainingTrigger.
func (c ChainingTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "pipeline", c.Pipeline)
	populate(objectMap, "runtimeState", c.RuntimeState)
	objectMap["type"] = "ChainingTrigger"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChainingTrigger.
func (c *ChainingTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "pipeline":
			err = unpopulate(val, &c.Pipeline)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &c.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ChainingTriggerTypeProperties - Chaining Trigger properties.
type ChainingTriggerTypeProperties struct {
	// REQUIRED; Upstream Pipelines.
	DependsOn []*PipelineReference `json:"dependsOn,omitempty"`

	// REQUIRED; Run Dimension property that needs to be emitted by upstream pipelines.
	RunDimension *string `json:"runDimension,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ChainingTriggerTypeProperties.
func (c ChainingTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "runDimension", c.RunDimension)
	return json.Marshal(objectMap)
}

// CloudError - The object that defines the structure of an Azure Data Factory error response.
type CloudError struct {
	// REQUIRED; Error data
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody - The object that defines the structure of an Azure Data Factory error.
type CloudErrorBody struct {
	// REQUIRED; Error code.
	Code *string `json:"code,omitempty"`

	// REQUIRED; Error message.
	Message *string `json:"message,omitempty"`

	// Array with additional error details.
	Details []*CloudError `json:"details,omitempty"`

	// Property name/path in request associated with error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudErrorBody.
func (c CloudErrorBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", c.Code)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// CmdkeySetup - The custom setup of running cmdkey commands.
type CmdkeySetup struct {
	// REQUIRED; The type of custom setup.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Cmdkey command custom setup type properties.
	TypeProperties *CmdkeySetupTypeProperties `json:"typeProperties,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type CmdkeySetup.
func (c *CmdkeySetup) GetCustomSetupBase() *CustomSetupBase {
	return &CustomSetupBase{
		Type: c.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CmdkeySetup.
func (c CmdkeySetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = "CmdkeySetup"
	populate(objectMap, "typeProperties", c.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CmdkeySetup.
func (c *CmdkeySetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CmdkeySetupTypeProperties - Cmdkey command custom setup type properties.
type CmdkeySetupTypeProperties struct {
	// REQUIRED; The password of data source access.
	Password SecretBaseClassification `json:"password,omitempty"`

	// REQUIRED; The server name of data source access.
	TargetName map[string]interface{} `json:"targetName,omitempty"`

	// REQUIRED; The user name of data source access.
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CmdkeySetupTypeProperties.
func (c CmdkeySetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "password", c.Password)
	populate(objectMap, "targetName", c.TargetName)
	populate(objectMap, "userName", c.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CmdkeySetupTypeProperties.
func (c *CmdkeySetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "targetName":
			err = unpopulate(val, &c.TargetName)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &c.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommonDataServiceForAppsEntityDataset - The Common Data Service for Apps entity dataset.
type CommonDataServiceForAppsEntityDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Common Data Service for Apps entity dataset properties.
	TypeProperties *CommonDataServiceForAppsEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type CommonDataServiceForAppsEntityDataset.
func (c *CommonDataServiceForAppsEntityDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c CommonDataServiceForAppsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "CommonDataServiceForAppsEntity"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c *CommonDataServiceForAppsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommonDataServiceForAppsEntityDatasetTypeProperties - Common Data Service for Apps entity dataset properties.
type CommonDataServiceForAppsEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName map[string]interface{} `json:"entityName,omitempty"`
}

// CommonDataServiceForAppsLinkedService - Common Data Service for Apps linked service.
type CommonDataServiceForAppsLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Common Data Service for Apps linked service properties.
	TypeProperties *CommonDataServiceForAppsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type CommonDataServiceForAppsLinkedService.
func (c *CommonDataServiceForAppsLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsLinkedService.
func (c CommonDataServiceForAppsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CommonDataServiceForApps"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedService.
func (c *CommonDataServiceForAppsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommonDataServiceForAppsLinkedServiceTypeProperties - Common Data Service for Apps linked service properties.
type CommonDataServiceForAppsLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd'
	// for on-premises with Ifd scenario. 'AADServicePrincipal' for Server-To-Server
	// authentication in online scenario. Type: string (or Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// REQUIRED; The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online
	// and 'OnPremisesWithIfd' for Common Data Service for Apps on-premises with Ifd. Type:
	// string (or Expression with resultType string).
	DeploymentType map[string]interface{} `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed
	// for online. Type: string (or Expression with resultType string).
	HostName map[string]interface{} `json:"hostName,omitempty"`

	// The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for
	// online when there are more than one Common Data Service for Apps instances
	// associated with the user. Type: string (or Expression with resultType string).
	OrganizationName map[string]interface{} `json:"organizationName,omitempty"`

	// Password to access the Common Data Service for Apps instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online.
	// Default is 443. Type: integer (or Expression with resultType integer),
	// minimum: 0.
	Port map[string]interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can
	// only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType map[string]interface{} `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for
	// on-prem. Type: string (or Expression with resultType string).
	ServiceURI map[string]interface{} `json:"serviceUri,omitempty"`

	// User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsLinkedServiceTypeProperties.
func (c CommonDataServiceForAppsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", c.AuthenticationType)
	populate(objectMap, "deploymentType", c.DeploymentType)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populate(objectMap, "hostName", c.HostName)
	populate(objectMap, "organizationName", c.OrganizationName)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "port", c.Port)
	populate(objectMap, "servicePrincipalCredential", c.ServicePrincipalCredential)
	populate(objectMap, "servicePrincipalCredentialType", c.ServicePrincipalCredentialType)
	populate(objectMap, "servicePrincipalId", c.ServicePrincipalID)
	populate(objectMap, "serviceUri", c.ServiceURI)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedServiceTypeProperties.
func (c *CommonDataServiceForAppsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &c.AuthenticationType)
			delete(rawMsg, key)
		case "deploymentType":
			err = unpopulate(val, &c.DeploymentType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &c.EncryptedCredential)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &c.HostName)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, &c.OrganizationName)
			delete(rawMsg, key)
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &c.Port)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			c.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, &c.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &c.ServicePrincipalID)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, &c.ServiceURI)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommonDataServiceForAppsSink - A copy activity Common Data Service for Apps sink.
type CommonDataServiceForAppsSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; The write behavior for the operation.
	WriteBehavior *DynamicsSinkWriteBehavior `json:"writeBehavior,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType
	// string).
	AlternateKeyName map[string]interface{} `json:"alternateKeyName,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default
	// is false. Type: boolean (or Expression with resultType boolean).
	IgnoreNullValues map[string]interface{} `json:"ignoreNullValues,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type CommonDataServiceForAppsSink.
func (c *CommonDataServiceForAppsSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     c.Type,
		WriteBatchSize:           c.WriteBatchSize,
		WriteBatchTimeout:        c.WriteBatchTimeout,
		SinkRetryCount:           c.SinkRetryCount,
		SinkRetryWait:            c.SinkRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsSink.
func (c CommonDataServiceForAppsSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateKeyName", c.AlternateKeyName)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "ignoreNullValues", c.IgnoreNullValues)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = "CommonDataServiceForAppsSink"
	populate(objectMap, "writeBatchSize", c.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", c.WriteBehavior)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsSink.
func (c *CommonDataServiceForAppsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			err = unpopulate(val, &c.AlternateKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, &c.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &c.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &c.WriteBehavior)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommonDataServiceForAppsSource - A copy activity Common Data Service for Apps source.
type CommonDataServiceForAppsSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// FetchXML is a proprietary query language that is used in Microsoft Common Data Service for Apps (online & on-premises).
	// Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CommonDataServiceForAppsSource.
func (c *CommonDataServiceForAppsSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsSource.
func (c CommonDataServiceForAppsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "query", c.Query)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CommonDataServiceForAppsSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsSource.
func (c *CommonDataServiceForAppsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &c.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &c.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ComponentSetup - The custom setup of installing 3rd party components.
type ComponentSetup struct {
	// REQUIRED; The type of custom setup.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Install 3rd party component type properties.
	TypeProperties *LicensedComponentSetupTypeProperties `json:"typeProperties,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type ComponentSetup.
func (c *ComponentSetup) GetCustomSetupBase() *CustomSetupBase {
	return &CustomSetupBase{
		Type: c.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ComponentSetup.
func (c ComponentSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = "ComponentSetup"
	populate(objectMap, "typeProperties", c.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComponentSetup.
func (c *ComponentSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CompressionReadSettingsClassification provides polymorphic access to related types.
// Call the interface's GetCompressionReadSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CompressionReadSettings, *TarGZipReadSettings, *TarReadSettings, *ZipDeflateReadSettings
type CompressionReadSettingsClassification interface {
	// GetCompressionReadSettings returns the CompressionReadSettings content of the underlying type.
	GetCompressionReadSettings() *CompressionReadSettings
}

// CompressionReadSettings - Compression read settings.
type CompressionReadSettings struct {
	// REQUIRED; The Compression setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetCompressionReadSettings implements the CompressionReadSettingsClassification interface for type CompressionReadSettings.
func (c *CompressionReadSettings) GetCompressionReadSettings() *CompressionReadSettings { return c }

// MarshalJSON implements the json.Marshaller interface for type CompressionReadSettings.
func (c CompressionReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompressionReadSettings.
func (c *CompressionReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConcurLinkedService - Concur Service linked service.
type ConcurLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Concur Service linked service properties.
	TypeProperties *ConcurLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ConcurLinkedService.
func (c *ConcurLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConcurLinkedService.
func (c ConcurLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "Concur"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedService.
func (c *ConcurLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConcurLinkedServiceTypeProperties - Concur Service linked service properties.
type ConcurLinkedServiceTypeProperties struct {
	// REQUIRED; Application client_id supplied by Concur App Management.
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// REQUIRED; The user name that you use to access Concur Service.
	Username map[string]interface{} `json:"username,omitempty"`

	// Properties used to connect to Concur. It is mutually exclusive with any other properties in the linked service. Type: object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name that you provided in the username field.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConcurLinkedServiceTypeProperties.
func (c ConcurLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", c.ClientID)
	populate(objectMap, "connectionProperties", c.ConnectionProperties)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "useEncryptedEndpoints", c.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", c.UseHostVerification)
	populate(objectMap, "usePeerVerification", c.UsePeerVerification)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedServiceTypeProperties.
func (c *ConcurLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &c.ClientID)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, &c.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &c.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &c.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &c.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &c.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConcurObjectDataset - Concur Service dataset.
type ConcurObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ConcurObjectDataset.
func (c *ConcurObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConcurObjectDataset.
func (c ConcurObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "ConcurObject"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurObjectDataset.
func (c *ConcurObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConcurSource - A copy activity Concur Service source.
type ConcurSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ConcurSource.
func (c *ConcurSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type ConcurSource.
func (c *ConcurSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             c.QueryTimeout,
		AdditionalColumns:        c.AdditionalColumns,
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConcurSource.
func (c ConcurSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "query", c.Query)
	populate(objectMap, "queryTimeout", c.QueryTimeout)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "ConcurSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurSource.
func (c *ConcurSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &c.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &c.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectionStateProperties - The connection state of a managed private endpoint
type ConnectionStateProperties struct {
	// READ-ONLY; The actions required on the managed private endpoint
	ActionsRequired *string `json:"actionsRequired,omitempty" azure:"ro"`

	// READ-ONLY; The managed private endpoint description
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The approval status
	Status *string `json:"status,omitempty" azure:"ro"`
}

// ControlActivityClassification provides polymorphic access to related types.
// Call the interface's GetControlActivity() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AppendVariableActivity, *ControlActivity, *ExecutePipelineActivity, *FailActivity, *FilterActivity, *ForEachActivity,
// - *IfConditionActivity, *SetVariableActivity, *SwitchActivity, *UntilActivity, *ValidationActivity, *WaitActivity, *WebHookActivity
type ControlActivityClassification interface {
	ActivityClassification
	// GetControlActivity returns the ControlActivity content of the underlying type.
	GetControlActivity() *ControlActivity
}

// ControlActivity - Base class for all control activities like IfCondition, ForEach , Until.
type ControlActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ControlActivity.
func (c *ControlActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 c.Name,
		Type:                 c.Type,
		Description:          c.Description,
		DependsOn:            c.DependsOn,
		UserProperties:       c.UserProperties,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type ControlActivity.
func (c *ControlActivity) GetControlActivity() *ControlActivity { return c }

// MarshalJSON implements the json.Marshaller interface for type ControlActivity.
func (c ControlActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "name", c.Name)
	objectMap["type"] = "Container"
	populate(objectMap, "userProperties", c.UserProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ControlActivity.
func (c *ControlActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &c.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &c.UserProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyActivity - Copy activity.
type CopyActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Copy activity properties.
	TypeProperties *CopyActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// List of inputs for the activity.
	Inputs []*DatasetReference `json:"inputs,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// List of outputs for the activity.
	Outputs []*DatasetReference `json:"outputs,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type CopyActivity.
func (c *CopyActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 c.Name,
		Type:                 c.Type,
		Description:          c.Description,
		DependsOn:            c.DependsOn,
		UserProperties:       c.UserProperties,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type CopyActivity.
func (c *CopyActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    c.LinkedServiceName,
		Policy:               c.Policy,
		Name:                 c.Name,
		Type:                 c.Type,
		Description:          c.Description,
		DependsOn:            c.DependsOn,
		UserProperties:       c.UserProperties,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivity.
func (c CopyActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "inputs", c.Inputs)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "outputs", c.Outputs)
	populate(objectMap, "policy", c.Policy)
	objectMap["type"] = "Copy"
	populate(objectMap, "typeProperties", c.TypeProperties)
	populate(objectMap, "userProperties", c.UserProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivity.
func (c *CopyActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &c.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, &c.Inputs)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, &c.Outputs)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &c.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &c.UserProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyActivityLogSettings - Settings for copy activity log.
type CopyActivityLogSettings struct {
	// Specifies whether to enable reliable logging. Type: boolean (or Expression with resultType boolean).
	EnableReliableLogging map[string]interface{} `json:"enableReliableLogging,omitempty"`

	// Gets or sets the log level, support: Info, Warning. Type: string (or Expression with resultType string).
	LogLevel map[string]interface{} `json:"logLevel,omitempty"`
}

// CopyActivityTypeProperties - Copy activity properties.
type CopyActivityTypeProperties struct {
	// REQUIRED; Copy activity sink.
	Sink CopySinkClassification `json:"sink,omitempty"`

	// REQUIRED; Copy activity source.
	Source CopySourceClassification `json:"source,omitempty"`

	// Maximum number of data integration units that can be used to perform this data movement. Type: integer (or Expression with
	// resultType integer), minimum: 0.
	DataIntegrationUnits map[string]interface{} `json:"dataIntegrationUnits,omitempty"`

	// Whether to skip incompatible row. Default value is false. Type: boolean (or Expression with resultType boolean).
	EnableSkipIncompatibleRow map[string]interface{} `json:"enableSkipIncompatibleRow,omitempty"`

	// Specifies whether to copy data via an interim staging. Default value is false. Type: boolean (or Expression with resultType
	// boolean).
	EnableStaging map[string]interface{} `json:"enableStaging,omitempty"`

	// Log settings customer needs provide when enabling log.
	LogSettings *LogSettings `json:"logSettings,omitempty"`

	// (Deprecated. Please use LogSettings) Log storage settings customer need to provide when enabling session log.
	LogStorageSettings *LogStorageSettings `json:"logStorageSettings,omitempty"`

	// Maximum number of concurrent sessions opened on the source or sink to avoid overloading the data store. Type: integer (or
	// Expression with resultType integer), minimum: 0.
	ParallelCopies map[string]interface{} `json:"parallelCopies,omitempty"`

	// Preserve rules.
	Preserve []map[string]interface{} `json:"preserve,omitempty"`

	// Preserve Rules.
	PreserveRules []map[string]interface{} `json:"preserveRules,omitempty"`

	// Redirect incompatible row settings when EnableSkipIncompatibleRow is true.
	RedirectIncompatibleRowSettings *RedirectIncompatibleRowSettings `json:"redirectIncompatibleRowSettings,omitempty"`

	// Specify the fault tolerance for data consistency.
	SkipErrorFile *SkipErrorFile `json:"skipErrorFile,omitempty"`

	// Specifies interim staging settings when EnableStaging is true.
	StagingSettings *StagingSettings `json:"stagingSettings,omitempty"`

	// Copy activity translator. If not specified, tabular translator is used.
	Translator map[string]interface{} `json:"translator,omitempty"`

	// Whether to enable Data Consistency validation. Type: boolean (or Expression with resultType boolean).
	ValidateDataConsistency map[string]interface{} `json:"validateDataConsistency,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivityTypeProperties.
func (c CopyActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataIntegrationUnits", c.DataIntegrationUnits)
	populate(objectMap, "enableSkipIncompatibleRow", c.EnableSkipIncompatibleRow)
	populate(objectMap, "enableStaging", c.EnableStaging)
	populate(objectMap, "logSettings", c.LogSettings)
	populate(objectMap, "logStorageSettings", c.LogStorageSettings)
	populate(objectMap, "parallelCopies", c.ParallelCopies)
	populate(objectMap, "preserve", c.Preserve)
	populate(objectMap, "preserveRules", c.PreserveRules)
	populate(objectMap, "redirectIncompatibleRowSettings", c.RedirectIncompatibleRowSettings)
	populate(objectMap, "sink", c.Sink)
	populate(objectMap, "skipErrorFile", c.SkipErrorFile)
	populate(objectMap, "source", c.Source)
	populate(objectMap, "stagingSettings", c.StagingSettings)
	populate(objectMap, "translator", c.Translator)
	populate(objectMap, "validateDataConsistency", c.ValidateDataConsistency)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivityTypeProperties.
func (c *CopyActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrationUnits":
			err = unpopulate(val, &c.DataIntegrationUnits)
			delete(rawMsg, key)
		case "enableSkipIncompatibleRow":
			err = unpopulate(val, &c.EnableSkipIncompatibleRow)
			delete(rawMsg, key)
		case "enableStaging":
			err = unpopulate(val, &c.EnableStaging)
			delete(rawMsg, key)
		case "logSettings":
			err = unpopulate(val, &c.LogSettings)
			delete(rawMsg, key)
		case "logStorageSettings":
			err = unpopulate(val, &c.LogStorageSettings)
			delete(rawMsg, key)
		case "parallelCopies":
			err = unpopulate(val, &c.ParallelCopies)
			delete(rawMsg, key)
		case "preserve":
			err = unpopulate(val, &c.Preserve)
			delete(rawMsg, key)
		case "preserveRules":
			err = unpopulate(val, &c.PreserveRules)
			delete(rawMsg, key)
		case "redirectIncompatibleRowSettings":
			err = unpopulate(val, &c.RedirectIncompatibleRowSettings)
			delete(rawMsg, key)
		case "sink":
			c.Sink, err = unmarshalCopySinkClassification(val)
			delete(rawMsg, key)
		case "skipErrorFile":
			err = unpopulate(val, &c.SkipErrorFile)
			delete(rawMsg, key)
		case "source":
			c.Source, err = unmarshalCopySourceClassification(val)
			delete(rawMsg, key)
		case "stagingSettings":
			err = unpopulate(val, &c.StagingSettings)
			delete(rawMsg, key)
		case "translator":
			err = unpopulate(val, &c.Translator)
			delete(rawMsg, key)
		case "validateDataConsistency":
			err = unpopulate(val, &c.ValidateDataConsistency)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopySinkClassification provides polymorphic access to related types.
// Call the interface's GetCopySink() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AvroSink, *AzureBlobFSSink, *AzureDataExplorerSink, *AzureDataLakeStoreSink, *AzureDatabricksDeltaLakeSink, *AzureMySQLSink,
// - *AzurePostgreSQLSink, *AzureQueueSink, *AzureSQLSink, *AzureSearchIndexSink, *AzureTableSink, *BinarySink, *BlobSink,
// - *CommonDataServiceForAppsSink, *CopySink, *CosmosDbMongoDbAPISink, *CosmosDbSQLAPISink, *DelimitedTextSink, *DocumentDbCollectionSink,
// - *DynamicsCrmSink, *DynamicsSink, *FileSystemSink, *InformixSink, *JSONSink, *MicrosoftAccessSink, *MongoDbAtlasSink,
// - *MongoDbV2Sink, *OdbcSink, *OracleSink, *OrcSink, *ParquetSink, *RestSink, *SQLDWSink, *SQLMISink, *SQLServerSink, *SQLSink,
// - *SalesforceServiceCloudSink, *SalesforceSink, *SapCloudForCustomerSink, *SnowflakeSink
type CopySinkClassification interface {
	// GetCopySink returns the CopySink content of the underlying type.
	GetCopySink() *CopySink
}

// CopySink - A copy activity sink.
type CopySink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type CopySink.
func (c *CopySink) GetCopySink() *CopySink { return c }

// MarshalJSON implements the json.Marshaller interface for type CopySink.
func (c CopySink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = c.Type
	populate(objectMap, "writeBatchSize", c.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySink.
func (c *CopySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &c.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopySourceClassification provides polymorphic access to related types.
// Call the interface's GetCopySource() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AmazonMWSSource, *AmazonRdsForOracleSource, *AmazonRdsForSQLServerSource, *AmazonRedshiftSource, *AvroSource, *AzureBlobFSSource,
// - *AzureDataExplorerSource, *AzureDataLakeStoreSource, *AzureDatabricksDeltaLakeSource, *AzureMariaDBSource, *AzureMySQLSource,
// - *AzurePostgreSQLSource, *AzureSQLSource, *AzureTableSource, *BinarySource, *BlobSource, *CassandraSource, *CommonDataServiceForAppsSource,
// - *ConcurSource, *CopySource, *CosmosDbMongoDbAPISource, *CosmosDbSQLAPISource, *CouchbaseSource, *Db2Source, *DelimitedTextSource,
// - *DocumentDbCollectionSource, *DrillSource, *DynamicsAXSource, *DynamicsCrmSource, *DynamicsSource, *EloquaSource, *ExcelSource,
// - *FileSystemSource, *GoogleAdWordsSource, *GoogleBigQuerySource, *GreenplumSource, *HBaseSource, *HTTPSource, *HdfsSource,
// - *HiveSource, *HubspotSource, *ImpalaSource, *InformixSource, *JSONSource, *JiraSource, *MagentoSource, *MariaDBSource,
// - *MarketoSource, *MicrosoftAccessSource, *MongoDbAtlasSource, *MongoDbSource, *MongoDbV2Source, *MySQLSource, *NetezzaSource,
// - *ODataSource, *OdbcSource, *Office365Source, *OracleServiceCloudSource, *OracleSource, *OrcSource, *ParquetSource, *PaypalSource,
// - *PhoenixSource, *PostgreSQLSource, *PrestoSource, *QuickBooksSource, *RelationalSource, *ResponsysSource, *RestSource,
// - *SQLDWSource, *SQLMISource, *SQLServerSource, *SQLSource, *SalesforceMarketingCloudSource, *SalesforceServiceCloudSource,
// - *SalesforceSource, *SapBwSource, *SapCloudForCustomerSource, *SapEccSource, *SapHanaSource, *SapOpenHubSource, *SapTableSource,
// - *ServiceNowSource, *SharePointOnlineListSource, *ShopifySource, *SnowflakeSource, *SparkSource, *SquareSource, *SybaseSource,
// - *TabularSource, *TeradataSource, *VerticaSource, *WebSource, *XMLSource, *XeroSource, *ZohoSource
type CopySourceClassification interface {
	// GetCopySource returns the CopySource content of the underlying type.
	GetCopySource() *CopySource
}

// CopySource - A copy activity source.
type CopySource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CopySource.
func (c *CopySource) GetCopySource() *CopySource { return c }

// MarshalJSON implements the json.Marshaller interface for type CopySource.
func (c CopySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySource.
func (c *CopySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyTranslatorClassification provides polymorphic access to related types.
// Call the interface's GetCopyTranslator() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CopyTranslator, *TabularTranslator
type CopyTranslatorClassification interface {
	// GetCopyTranslator returns the CopyTranslator content of the underlying type.
	GetCopyTranslator() *CopyTranslator
}

// CopyTranslator - A copy activity translator.
type CopyTranslator struct {
	// REQUIRED; Copy translator type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetCopyTranslator implements the CopyTranslatorClassification interface for type CopyTranslator.
func (c *CopyTranslator) GetCopyTranslator() *CopyTranslator { return c }

// MarshalJSON implements the json.Marshaller interface for type CopyTranslator.
func (c CopyTranslator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyTranslator.
func (c *CopyTranslator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbLinkedService - Microsoft Azure Cosmos Database (CosmosDB) linked service.
type CosmosDbLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; CosmosDB linked service properties.
	TypeProperties *CosmosDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type CosmosDbLinkedService.
func (c *CosmosDbLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbLinkedService.
func (c CosmosDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CosmosDb"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedService.
func (c *CosmosDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbLinkedServiceTypeProperties - CosmosDB linked service properties.
type CosmosDbLinkedServiceTypeProperties struct {
	// The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
	AccountEndpoint map[string]interface{} `json:"accountEndpoint,omitempty"`

	// The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
	AccountKey SecretBaseClassification `json:"accountKey,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The connection mode used to access CosmosDB account. Type: string (or Expression with resultType string).
	ConnectionMode *CosmosDbConnectionMode `json:"connectionMode,omitempty"`

	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The name of the database. Type: string (or Expression with resultType string)
	Database map[string]interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can
	// only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType *CosmosDbServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbLinkedServiceTypeProperties.
func (c CosmosDbLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountEndpoint", c.AccountEndpoint)
	populate(objectMap, "accountKey", c.AccountKey)
	populate(objectMap, "azureCloudType", c.AzureCloudType)
	populate(objectMap, "connectionMode", c.ConnectionMode)
	populate(objectMap, "connectionString", c.ConnectionString)
	populate(objectMap, "credential", c.Credential)
	populate(objectMap, "database", c.Database)
	populate(objectMap, "encryptedCredential", c.EncryptedCredential)
	populate(objectMap, "servicePrincipalCredential", c.ServicePrincipalCredential)
	populate(objectMap, "servicePrincipalCredentialType", c.ServicePrincipalCredentialType)
	populate(objectMap, "servicePrincipalId", c.ServicePrincipalID)
	populate(objectMap, "tenant", c.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedServiceTypeProperties.
func (c *CosmosDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountEndpoint":
			err = unpopulate(val, &c.AccountEndpoint)
			delete(rawMsg, key)
		case "accountKey":
			c.AccountKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &c.AzureCloudType)
			delete(rawMsg, key)
		case "connectionMode":
			err = unpopulate(val, &c.ConnectionMode)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &c.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &c.Credential)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, &c.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &c.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			c.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, &c.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &c.ServicePrincipalID)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &c.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbMongoDbAPICollectionDataset - The CosmosDB (MongoDB API) database dataset.
type CosmosDbMongoDbAPICollectionDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; CosmosDB (MongoDB API) database dataset properties.
	TypeProperties *CosmosDbMongoDbAPICollectionDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type CosmosDbMongoDbAPICollectionDataset.
func (c *CosmosDbMongoDbAPICollectionDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c CosmosDbMongoDbAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "CosmosDbMongoDbApiCollection"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c *CosmosDbMongoDbAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbMongoDbAPICollectionDatasetTypeProperties - CosmosDB (MongoDB API) database dataset properties.
type CosmosDbMongoDbAPICollectionDatasetTypeProperties struct {
	// REQUIRED; The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
	Collection map[string]interface{} `json:"collection,omitempty"`
}

// CosmosDbMongoDbAPILinkedService - Linked service for CosmosDB (MongoDB API) data source.
type CosmosDbMongoDbAPILinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; CosmosDB (MongoDB API) linked service properties.
	TypeProperties *CosmosDbMongoDbAPILinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type CosmosDbMongoDbAPILinkedService.
func (c *CosmosDbMongoDbAPILinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c CosmosDbMongoDbAPILinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CosmosDbMongoDbApi"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c *CosmosDbMongoDbAPILinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbMongoDbAPILinkedServiceTypeProperties - CosmosDB (MongoDB API) linked service properties.
type CosmosDbMongoDbAPILinkedServiceTypeProperties struct {
	// REQUIRED; The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type:
	// string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// REQUIRED; The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType
	// string).
	Database map[string]interface{} `json:"database,omitempty"`

	// Whether the CosmosDB (MongoDB API) server version is higher than 3.2. The default value is false. Type: boolean (or Expression
	// with resultType boolean).
	IsServerVersionAbove32 map[string]interface{} `json:"isServerVersionAbove32,omitempty"`
}

// CosmosDbMongoDbAPISink - A copy activity sink for a CosmosDB (MongoDB API) database.
type CosmosDbMongoDbAPISink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default
	// value is "insert". Type: string (or Expression with resultType string). Type:
	// string (or Expression with resultType string).
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type CosmosDbMongoDbAPISink.
func (c *CosmosDbMongoDbAPISink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     c.Type,
		WriteBatchSize:           c.WriteBatchSize,
		WriteBatchTimeout:        c.WriteBatchTimeout,
		SinkRetryCount:           c.SinkRetryCount,
		SinkRetryWait:            c.SinkRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPISink.
func (c CosmosDbMongoDbAPISink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = "CosmosDbMongoDbApiSink"
	populate(objectMap, "writeBatchSize", c.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", c.WriteBehavior)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPISink.
func (c *CosmosDbMongoDbAPISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &c.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &c.WriteBehavior)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbMongoDbAPISource - A copy activity source for a CosmosDB (MongoDB API) database.
type CosmosDbMongoDbAPISource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying
	// the batch size will not affect the user or the application. This property's
	// main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
	BatchSize map[string]interface{} `json:"batchSize,omitempty"`

	// Cursor methods for Mongodb query.
	CursorMethods *MongoDbCursorMethodsProperties `json:"cursorMethods,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass
	// an empty document ({}). Type: string (or Expression with resultType string).
	Filter map[string]interface{} `json:"filter,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CosmosDbMongoDbAPISource.
func (c *CosmosDbMongoDbAPISource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPISource.
func (c CosmosDbMongoDbAPISource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "batchSize", c.BatchSize)
	populate(objectMap, "cursorMethods", c.CursorMethods)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "filter", c.Filter)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "queryTimeout", c.QueryTimeout)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CosmosDbMongoDbApiSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPISource.
func (c *CosmosDbMongoDbAPISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &c.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, &c.BatchSize)
			delete(rawMsg, key)
		case "cursorMethods":
			err = unpopulate(val, &c.CursorMethods)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &c.Filter)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbSQLAPICollectionDataset - Microsoft Azure CosmosDB (SQL API) Collection dataset.
type CosmosDbSQLAPICollectionDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; CosmosDB (SQL API) Collection dataset properties.
	TypeProperties *CosmosDbSQLAPICollectionDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type CosmosDbSQLAPICollectionDataset.
func (c *CosmosDbSQLAPICollectionDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c CosmosDbSQLAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "CosmosDbSqlApiCollection"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c *CosmosDbSQLAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbSQLAPICollectionDatasetTypeProperties - CosmosDB (SQL API) Collection dataset properties.
type CosmosDbSQLAPICollectionDatasetTypeProperties struct {
	// REQUIRED; CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
	CollectionName map[string]interface{} `json:"collectionName,omitempty"`
}

// CosmosDbSQLAPISink - A copy activity Azure CosmosDB (SQL API) Collection sink.
type CosmosDbSQLAPISink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert
	// and upsert.
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type CosmosDbSQLAPISink.
func (c *CosmosDbSQLAPISink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     c.Type,
		WriteBatchSize:           c.WriteBatchSize,
		WriteBatchTimeout:        c.WriteBatchTimeout,
		SinkRetryCount:           c.SinkRetryCount,
		SinkRetryWait:            c.SinkRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPISink.
func (c CosmosDbSQLAPISink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", c.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", c.SinkRetryWait)
	objectMap["type"] = "CosmosDbSqlApiSink"
	populate(objectMap, "writeBatchSize", c.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", c.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", c.WriteBehavior)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPISink.
func (c *CosmosDbSQLAPISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &c.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &c.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &c.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &c.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &c.WriteBehavior)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CosmosDbSQLAPISource - A copy activity Azure CosmosDB (SQL API) Collection source.
type CosmosDbSQLAPISource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Whether detect primitive values as datetime values. Type: boolean (or Expression with resultType boolean).
	DetectDatetime map[string]interface{} `json:"detectDatetime,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Page size of the result. Type: integer (or Expression with resultType integer).
	PageSize map[string]interface{} `json:"pageSize,omitempty"`

	// Preferred regions. Type: array of strings (or Expression with resultType array of strings).
	PreferredRegions map[string]interface{} `json:"preferredRegions,omitempty"`

	// SQL API query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CosmosDbSQLAPISource.
func (c *CosmosDbSQLAPISource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPISource.
func (c CosmosDbSQLAPISource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "detectDatetime", c.DetectDatetime)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "pageSize", c.PageSize)
	populate(objectMap, "preferredRegions", c.PreferredRegions)
	populate(objectMap, "query", c.Query)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CosmosDbSqlApiSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPISource.
func (c *CosmosDbSQLAPISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &c.AdditionalColumns)
			delete(rawMsg, key)
		case "detectDatetime":
			err = unpopulate(val, &c.DetectDatetime)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "pageSize":
			err = unpopulate(val, &c.PageSize)
			delete(rawMsg, key)
		case "preferredRegions":
			err = unpopulate(val, &c.PreferredRegions)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &c.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CouchbaseLinkedService - Couchbase server linked service.
type CouchbaseLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Couchbase server linked service properties.
	TypeProperties *CouchbaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type CouchbaseLinkedService.
func (c *CouchbaseLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseLinkedService.
func (c CouchbaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "Couchbase"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseLinkedService.
func (c *CouchbaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CouchbaseLinkedServiceTypeProperties - Couchbase server linked service properties.
type CouchbaseLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The Azure key vault secret reference of credString in connection string.
	CredString *AzureKeyVaultSecretReference `json:"credString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`
}

// CouchbaseSource - A copy activity Couchbase server source.
type CouchbaseSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CouchbaseSource.
func (c *CouchbaseSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type CouchbaseSource.
func (c *CouchbaseSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             c.QueryTimeout,
		AdditionalColumns:        c.AdditionalColumns,
		Type:                     c.Type,
		SourceRetryCount:         c.SourceRetryCount,
		SourceRetryWait:          c.SourceRetryWait,
		MaxConcurrentConnections: c.MaxConcurrentConnections,
		DisableMetricsCollection: c.DisableMetricsCollection,
		AdditionalProperties:     c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseSource.
func (c CouchbaseSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", c.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", c.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", c.MaxConcurrentConnections)
	populate(objectMap, "query", c.Query)
	populate(objectMap, "queryTimeout", c.QueryTimeout)
	populate(objectMap, "sourceRetryCount", c.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", c.SourceRetryWait)
	objectMap["type"] = "CouchbaseSource"
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseSource.
func (c *CouchbaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &c.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &c.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &c.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &c.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &c.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &c.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &c.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CouchbaseTableDataset - Couchbase server dataset.
type CouchbaseTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type CouchbaseTableDataset.
func (c *CouchbaseTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseTableDataset.
func (c CouchbaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "CouchbaseTable"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseTableDataset.
func (c *CouchbaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CreateDataFlowDebugSessionRequest - Request body structure for creating data flow debug session.
type CreateDataFlowDebugSessionRequest struct {
	// Compute type of the cluster. The value will be overwritten by the same setting in integration runtime if provided.
	ComputeType *string `json:"computeType,omitempty"`

	// Core count of the cluster. The value will be overwritten by the same setting in integration runtime if provided.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// Set to use integration runtime setting for data flow debug session.
	IntegrationRuntime *IntegrationRuntimeDebugResource `json:"integrationRuntime,omitempty"`

	// Time to live setting of the cluster in minutes.
	TimeToLive *int32 `json:"timeToLive,omitempty"`
}

// CreateDataFlowDebugSessionResponse - Response body structure for creating data flow debug session.
type CreateDataFlowDebugSessionResponse struct {
	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The state of the debug session.
	Status *string `json:"status,omitempty"`
}

// CreateLinkedIntegrationRuntimeRequest - The linked integration runtime information.
type CreateLinkedIntegrationRuntimeRequest struct {
	// The location of the data factory that the linked integration runtime belongs to.
	DataFactoryLocation *string `json:"dataFactoryLocation,omitempty"`

	// The name of the data factory that the linked integration runtime belongs to.
	DataFactoryName *string `json:"dataFactoryName,omitempty"`

	// The name of the linked integration runtime.
	Name *string `json:"name,omitempty"`

	// The ID of the subscription that the linked integration runtime belongs to.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
}

// CreateRunResponse - Response body with a run identifier.
type CreateRunResponse struct {
	// REQUIRED; Identifier of a run.
	RunID *string `json:"runId,omitempty"`
}

// CredentialClassification provides polymorphic access to related types.
// Call the interface's GetCredential() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Credential, *ManagedIdentityCredential, *ServicePrincipalCredential
type CredentialClassification interface {
	// GetCredential returns the Credential content of the underlying type.
	GetCredential() *Credential
}

// Credential - The Azure Data Factory nested object which contains the information and credential which can be used to connect
// with related store or compute resource.
type Credential struct {
	// REQUIRED; Type of credential.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Credential.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Credential description.
	Description *string `json:"description,omitempty"`
}

// GetCredential implements the CredentialClassification interface for type Credential.
func (c *Credential) GetCredential() *Credential { return c }

// MarshalJSON implements the json.Marshaller interface for type Credential.
func (c Credential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Credential.
func (c *Credential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CredentialReference - Credential reference type.
type CredentialReference struct {
	// REQUIRED; Reference credential name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Credential reference type.
	Type *CredentialReferenceType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// MarshalJSON implements the json.Marshaller interface for type CredentialReference.
func (c CredentialReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "referenceName", c.ReferenceName)
	populate(objectMap, "type", c.Type)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialReference.
func (c *CredentialReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceName":
			err = unpopulate(val, &c.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CredentialResource - Credential resource type.
type CredentialResource struct {
	// REQUIRED; Properties of credentials.
	Properties CredentialClassification `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CredentialResource.
func (c CredentialResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialResource.
func (c *CredentialResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &c.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "properties":
			c.Properties, err = unmarshalCredentialClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomActivity - Custom activity type.
type CustomActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Custom activity properties.
	TypeProperties *CustomActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type CustomActivity.
func (c *CustomActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 c.Name,
		Type:                 c.Type,
		Description:          c.Description,
		DependsOn:            c.DependsOn,
		UserProperties:       c.UserProperties,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type CustomActivity.
func (c *CustomActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    c.LinkedServiceName,
		Policy:               c.Policy,
		Name:                 c.Name,
		Type:                 c.Type,
		Description:          c.Description,
		DependsOn:            c.DependsOn,
		UserProperties:       c.UserProperties,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivity.
func (c CustomActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "policy", c.Policy)
	objectMap["type"] = "Custom"
	populate(objectMap, "typeProperties", c.TypeProperties)
	populate(objectMap, "userProperties", c.UserProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomActivity.
func (c *CustomActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &c.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &c.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &c.UserProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomActivityReferenceObject - Reference objects for custom activity
type CustomActivityReferenceObject struct {
	// Dataset references.
	Datasets []*DatasetReference `json:"datasets,omitempty"`

	// Linked service references.
	LinkedServices []*LinkedServiceReference `json:"linkedServices,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivityReferenceObject.
func (c CustomActivityReferenceObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasets", c.Datasets)
	populate(objectMap, "linkedServices", c.LinkedServices)
	return json.Marshal(objectMap)
}

// CustomActivityTypeProperties - Custom activity properties.
type CustomActivityTypeProperties struct {
	// REQUIRED; Command for custom activity Type: string (or Expression with resultType string).
	Command map[string]interface{} `json:"command,omitempty"`

	// Elevation level and scope for the user, default is nonadmin task. Type: string (or Expression with resultType double).
	AutoUserSpecification map[string]interface{} `json:"autoUserSpecification,omitempty"`

	// User defined property bag. There is no restriction on the keys or values that can be used. The user specified custom activity
	// has the full responsibility to consume and interpret the content defined.
	ExtendedProperties map[string]map[string]interface{} `json:"extendedProperties,omitempty"`

	// Folder path for resource files Type: string (or Expression with resultType string).
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Reference objects
	ReferenceObjects *CustomActivityReferenceObject `json:"referenceObjects,omitempty"`

	// Resource linked service reference.
	ResourceLinkedService *LinkedServiceReference `json:"resourceLinkedService,omitempty"`

	// The retention time for the files submitted for custom activity. Type: double (or Expression with resultType double).
	RetentionTimeInDays map[string]interface{} `json:"retentionTimeInDays,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivityTypeProperties.
func (c CustomActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoUserSpecification", c.AutoUserSpecification)
	populate(objectMap, "command", c.Command)
	populate(objectMap, "extendedProperties", c.ExtendedProperties)
	populate(objectMap, "folderPath", c.FolderPath)
	populate(objectMap, "referenceObjects", c.ReferenceObjects)
	populate(objectMap, "resourceLinkedService", c.ResourceLinkedService)
	populate(objectMap, "retentionTimeInDays", c.RetentionTimeInDays)
	return json.Marshal(objectMap)
}

// CustomDataSourceLinkedService - Custom linked service.
type CustomDataSourceLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Custom linked service properties.
	TypeProperties map[string]interface{} `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type CustomDataSourceLinkedService.
func (c *CustomDataSourceLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 c.Type,
		ConnectVia:           c.ConnectVia,
		Description:          c.Description,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataSourceLinkedService.
func (c CustomDataSourceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "connectVia", c.ConnectVia)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "parameters", c.Parameters)
	objectMap["type"] = "CustomDataSource"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataSourceLinkedService.
func (c *CustomDataSourceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &c.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomDataset - The custom dataset.
type CustomDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Custom dataset properties.
	TypeProperties map[string]interface{} `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type CustomDataset.
func (c *CustomDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 c.Type,
		Description:          c.Description,
		Structure:            c.Structure,
		Schema:               c.Schema,
		LinkedServiceName:    c.LinkedServiceName,
		Parameters:           c.Parameters,
		Annotations:          c.Annotations,
		Folder:               c.Folder,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataset.
func (c CustomDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "folder", c.Folder)
	populate(objectMap, "linkedServiceName", c.LinkedServiceName)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "schema", c.Schema)
	populate(objectMap, "structure", c.Structure)
	objectMap["type"] = "CustomDataset"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataset.
func (c *CustomDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &c.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &c.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &c.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &c.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &c.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomEventsTrigger - Trigger that runs every time a custom event is received.
type CustomEventsTrigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Custom Events Trigger properties.
	TypeProperties *CustomEventsTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Pipelines that need to be started.
	Pipelines []*TriggerPipelineReference `json:"pipelines,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetMultiplePipelineTrigger implements the MultiplePipelineTriggerClassification interface for type CustomEventsTrigger.
func (c *CustomEventsTrigger) GetMultiplePipelineTrigger() *MultiplePipelineTrigger {
	return &MultiplePipelineTrigger{
		Pipelines:            c.Pipelines,
		Type:                 c.Type,
		Description:          c.Description,
		RuntimeState:         c.RuntimeState,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// GetTrigger implements the TriggerClassification interface for type CustomEventsTrigger.
func (c *CustomEventsTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 c.Type,
		Description:          c.Description,
		RuntimeState:         c.RuntimeState,
		Annotations:          c.Annotations,
		AdditionalProperties: c.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CustomEventsTrigger.
func (c CustomEventsTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "pipelines", c.Pipelines)
	populate(objectMap, "runtimeState", c.RuntimeState)
	objectMap["type"] = "CustomEventsTrigger"
	populate(objectMap, "typeProperties", c.TypeProperties)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomEventsTrigger.
func (c *CustomEventsTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &c.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, &c.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &c.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomEventsTriggerTypeProperties - Custom Events Trigger properties.
type CustomEventsTriggerTypeProperties struct {
	// REQUIRED; The list of event types that cause this trigger to fire.
	Events []map[string]interface{} `json:"events,omitempty"`

	// REQUIRED; The ARM resource ID of the Azure Event Grid Topic.
	Scope *string `json:"scope,omitempty"`

	// The event subject must begin with the pattern provided for trigger to fire. At least one of these must be provided: subjectBeginsWith,
	// subjectEndsWith.
	SubjectBeginsWith *string `json:"subjectBeginsWith,omitempty"`

	// The event subject must end with the pattern provided for trigger to fire. At least one of these must be provided: subjectBeginsWith,
	// subjectEndsWith.
	SubjectEndsWith *string `json:"subjectEndsWith,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomEventsTriggerTypeProperties.
func (c CustomEventsTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "events", c.Events)
	populate(objectMap, "scope", c.Scope)
	populate(objectMap, "subjectBeginsWith", c.SubjectBeginsWith)
	populate(objectMap, "subjectEndsWith", c.SubjectEndsWith)
	return json.Marshal(objectMap)
}

// CustomSetupBaseClassification provides polymorphic access to related types.
// Call the interface's GetCustomSetupBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzPowerShellSetup, *CmdkeySetup, *ComponentSetup, *CustomSetupBase, *EnvironmentVariableSetup
type CustomSetupBaseClassification interface {
	// GetCustomSetupBase returns the CustomSetupBase content of the underlying type.
	GetCustomSetupBase() *CustomSetupBase
}

// CustomSetupBase - The base definition of the custom setup.
type CustomSetupBase struct {
	// REQUIRED; The type of custom setup.
	Type *string `json:"type,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type CustomSetupBase.
func (c *CustomSetupBase) GetCustomSetupBase() *CustomSetupBase { return c }

// DWCopyCommandDefaultValue - Default value.
type DWCopyCommandDefaultValue struct {
	// Column name. Type: object (or Expression with resultType string).
	ColumnName map[string]interface{} `json:"columnName,omitempty"`

	// The default value of the column. Type: object (or Expression with resultType string).
	DefaultValue map[string]interface{} `json:"defaultValue,omitempty"`
}

// DWCopyCommandSettings - DW Copy Command settings.
type DWCopyCommandSettings struct {
	// Additional options directly passed to SQL DW in Copy Command. Type: key value pairs (value should be string type) (or Expression
	// with resultType object). Example: "additionalOptions": { "MAXERRORS":
	// "1000", "DATEFORMAT": "'ymd'" }
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	// Specifies the default values for each target column in SQL DW. The default values in the property overwrite the DEFAULT
	// constraint set in the DB, and identity column cannot have a default value. Type:
	// array of objects (or Expression with resultType array of objects).
	DefaultValues []*DWCopyCommandDefaultValue `json:"defaultValues,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DWCopyCommandSettings.
func (d DWCopyCommandSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalOptions", d.AdditionalOptions)
	populate(objectMap, "defaultValues", d.DefaultValues)
	return json.Marshal(objectMap)
}

// DataFlowClassification provides polymorphic access to related types.
// Call the interface's GetDataFlow() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DataFlow, *Flowlet, *MappingDataFlow, *WranglingDataFlow
type DataFlowClassification interface {
	// GetDataFlow returns the DataFlow content of the underlying type.
	GetDataFlow() *DataFlow
}

// DataFlow - Azure Data Factory nested object which contains a flow with data movements and transformations.
type DataFlow struct {
	// REQUIRED; Type of data flow.
	Type *string `json:"type,omitempty"`

	// List of tags that can be used for describing the data flow.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The description of the data flow.
	Description *string `json:"description,omitempty"`

	// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
	Folder *DataFlowFolder `json:"folder,omitempty"`
}

// GetDataFlow implements the DataFlowClassification interface for type DataFlow.
func (d *DataFlow) GetDataFlow() *DataFlow { return d }

// MarshalJSON implements the json.Marshaller interface for type DataFlow.
func (d DataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	objectMap["type"] = d.Type
	return json.Marshal(objectMap)
}

// DataFlowDebugCommandPayload - Structure of command payload.
type DataFlowDebugCommandPayload struct {
	// REQUIRED; The stream name which is used for preview.
	StreamName *string `json:"streamName,omitempty"`

	// Array of column names.
	Columns []*string `json:"columns,omitempty"`

	// The expression which is used for preview.
	Expression *string `json:"expression,omitempty"`

	// Row limits for preview response.
	RowLimits *int32 `json:"rowLimits,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugCommandPayload.
func (d DataFlowDebugCommandPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", d.Columns)
	populate(objectMap, "expression", d.Expression)
	populate(objectMap, "rowLimits", d.RowLimits)
	populate(objectMap, "streamName", d.StreamName)
	return json.Marshal(objectMap)
}

// DataFlowDebugCommandRequest - Request body structure for data flow debug command.
type DataFlowDebugCommandRequest struct {
	// The command type.
	Command *DataFlowDebugCommandType `json:"command,omitempty"`

	// The command payload object.
	CommandPayload *DataFlowDebugCommandPayload `json:"commandPayload,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// DataFlowDebugCommandResponse - Response body structure of data flow result for data preview, statistics or expression preview.
type DataFlowDebugCommandResponse struct {
	// The result data of data preview, statistics or expression preview.
	Data *string `json:"data,omitempty"`

	// The run status of data preview, statistics or expression preview.
	Status *string `json:"status,omitempty"`
}

// DataFlowDebugPackage - Request body structure for starting data flow debug session.
type DataFlowDebugPackage struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Data flow instance.
	DataFlow *DataFlowDebugResource `json:"dataFlow,omitempty"`

	// List of Data flows
	DataFlows []*DataFlowDebugResource `json:"dataFlows,omitempty"`

	// List of datasets.
	Datasets []*DatasetDebugResource `json:"datasets,omitempty"`

	// Data flow debug settings.
	DebugSettings *DataFlowDebugPackageDebugSettings `json:"debugSettings,omitempty"`

	// List of linked services.
	LinkedServices []*LinkedServiceDebugResource `json:"linkedServices,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Staging info for debug session.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugPackage.
func (d DataFlowDebugPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataFlow", d.DataFlow)
	populate(objectMap, "dataFlows", d.DataFlows)
	populate(objectMap, "datasets", d.Datasets)
	populate(objectMap, "debugSettings", d.DebugSettings)
	populate(objectMap, "linkedServices", d.LinkedServices)
	populate(objectMap, "sessionId", d.SessionID)
	populate(objectMap, "staging", d.Staging)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugPackage.
func (d *DataFlowDebugPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlow":
			err = unpopulate(val, &d.DataFlow)
			delete(rawMsg, key)
		case "dataFlows":
			err = unpopulate(val, &d.DataFlows)
			delete(rawMsg, key)
		case "datasets":
			err = unpopulate(val, &d.Datasets)
			delete(rawMsg, key)
		case "debugSettings":
			err = unpopulate(val, &d.DebugSettings)
			delete(rawMsg, key)
		case "linkedServices":
			err = unpopulate(val, &d.LinkedServices)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, &d.SessionID)
			delete(rawMsg, key)
		case "staging":
			err = unpopulate(val, &d.Staging)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowDebugPackageDebugSettings - Data flow debug settings.
type DataFlowDebugPackageDebugSettings struct {
	// Parameters for dataset.
	DatasetParameters map[string]interface{} `json:"datasetParameters,omitempty"`

	// Data flow parameters.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`

	// Source setting for data flow debug.
	SourceSettings []*DataFlowSourceSetting `json:"sourceSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugPackageDebugSettings.
func (d DataFlowDebugPackageDebugSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasetParameters", d.DatasetParameters)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "sourceSettings", d.SourceSettings)
	return json.Marshal(objectMap)
}

// DataFlowDebugResource - Data flow debug resource.
type DataFlowDebugResource struct {
	// REQUIRED; Data flow properties.
	Properties DataFlowClassification `json:"properties,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugResource.
func (d DataFlowDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugResource.
func (d *DataFlowDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDataFlowClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowDebugSessionClientAddDataFlowOptions contains the optional parameters for the DataFlowDebugSessionClient.AddDataFlow
// method.
type DataFlowDebugSessionClientAddDataFlowOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionClientBeginCreateOptions contains the optional parameters for the DataFlowDebugSessionClient.BeginCreate
// method.
type DataFlowDebugSessionClientBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionClientBeginExecuteCommandOptions contains the optional parameters for the DataFlowDebugSessionClient.BeginExecuteCommand
// method.
type DataFlowDebugSessionClientBeginExecuteCommandOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionClientDeleteOptions contains the optional parameters for the DataFlowDebugSessionClient.Delete method.
type DataFlowDebugSessionClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionClientQueryByFactoryOptions contains the optional parameters for the DataFlowDebugSessionClient.QueryByFactory
// method.
type DataFlowDebugSessionClientQueryByFactoryOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionInfo - Data flow debug session info.
type DataFlowDebugSessionInfo struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Compute type of the cluster.
	ComputeType *string `json:"computeType,omitempty"`

	// Core count of the cluster.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// The name of the data flow.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// Attached integration runtime name of data flow debug session.
	IntegrationRuntimeName *string `json:"integrationRuntimeName,omitempty"`

	// Last activity time of data flow debug session.
	LastActivityTime *string `json:"lastActivityTime,omitempty"`

	// Node count of the cluster. (deprecated property)
	NodeCount *int32 `json:"nodeCount,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Start time of data flow debug session.
	StartTime *string `json:"startTime,omitempty"`

	// Compute type of the cluster.
	TimeToLiveInMinutes *int32 `json:"timeToLiveInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugSessionInfo.
func (d DataFlowDebugSessionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeType", d.ComputeType)
	populate(objectMap, "coreCount", d.CoreCount)
	populate(objectMap, "dataFlowName", d.DataFlowName)
	populate(objectMap, "integrationRuntimeName", d.IntegrationRuntimeName)
	populate(objectMap, "lastActivityTime", d.LastActivityTime)
	populate(objectMap, "nodeCount", d.NodeCount)
	populate(objectMap, "sessionId", d.SessionID)
	populate(objectMap, "startTime", d.StartTime)
	populate(objectMap, "timeToLiveInMinutes", d.TimeToLiveInMinutes)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugSessionInfo.
func (d *DataFlowDebugSessionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			err = unpopulate(val, &d.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, &d.CoreCount)
			delete(rawMsg, key)
		case "dataFlowName":
			err = unpopulate(val, &d.DataFlowName)
			delete(rawMsg, key)
		case "integrationRuntimeName":
			err = unpopulate(val, &d.IntegrationRuntimeName)
			delete(rawMsg, key)
		case "lastActivityTime":
			err = unpopulate(val, &d.LastActivityTime)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, &d.NodeCount)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, &d.SessionID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, &d.StartTime)
			delete(rawMsg, key)
		case "timeToLiveInMinutes":
			err = unpopulate(val, &d.TimeToLiveInMinutes)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowFolder - The folder that this data flow is in. If not specified, Data flow will appear at the root level.
type DataFlowFolder struct {
	// The name of the folder that this data flow is in.
	Name *string `json:"name,omitempty"`
}

// DataFlowListResponse - A list of data flow resources.
type DataFlowListResponse struct {
	// REQUIRED; List of data flows.
	Value []*DataFlowResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowListResponse.
func (d DataFlowListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataFlowReference - Data flow reference type.
type DataFlowReference struct {
	// REQUIRED; Reference data flow name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Data flow reference type.
	Type *DataFlowReferenceType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Reference data flow parameters from dataset.
	DatasetParameters map[string]interface{} `json:"datasetParameters,omitempty"`

	// Data flow parameters
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowReference.
func (d DataFlowReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasetParameters", d.DatasetParameters)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "referenceName", d.ReferenceName)
	populate(objectMap, "type", d.Type)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowReference.
func (d *DataFlowReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasetParameters":
			err = unpopulate(val, &d.DatasetParameters)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "referenceName":
			err = unpopulate(val, &d.ReferenceName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowResource - Data flow resource type.
type DataFlowResource struct {
	// REQUIRED; Data flow properties.
	Properties DataFlowClassification `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowResource.
func (d DataFlowResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowResource.
func (d *DataFlowResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDataFlowClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowSink - Transformation for data flow sink.
type DataFlowSink struct {
	// REQUIRED; Transformation name.
	Name *string `json:"name,omitempty"`

	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Flowlet Reference
	Flowlet *DataFlowReference `json:"flowlet,omitempty"`

	// Linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`

	// Schema linked service reference.
	SchemaLinkedService *LinkedServiceReference `json:"schemaLinkedService,omitempty"`
}

// DataFlowSource - Transformation for data flow source.
type DataFlowSource struct {
	// REQUIRED; Transformation name.
	Name *string `json:"name,omitempty"`

	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Flowlet Reference
	Flowlet *DataFlowReference `json:"flowlet,omitempty"`

	// Linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`

	// Schema linked service reference.
	SchemaLinkedService *LinkedServiceReference `json:"schemaLinkedService,omitempty"`
}

// DataFlowSourceSetting - Definition of data flow source setting for debug.
type DataFlowSourceSetting struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Defines the row limit of data flow source in debug.
	RowLimit *int32 `json:"rowLimit,omitempty"`

	// The data flow source name.
	SourceName *string `json:"sourceName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowSourceSetting.
func (d DataFlowSourceSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rowLimit", d.RowLimit)
	populate(objectMap, "sourceName", d.SourceName)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowSourceSetting.
func (d *DataFlowSourceSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rowLimit":
			err = unpopulate(val, &d.RowLimit)
			delete(rawMsg, key)
		case "sourceName":
			err = unpopulate(val, &d.SourceName)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowStagingInfo - Staging info for execute data flow activity.
type DataFlowStagingInfo struct {
	// Folder path for staging blob. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Staging linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`
}

// DataFlowsClientCreateOrUpdateOptions contains the optional parameters for the DataFlowsClient.CreateOrUpdate method.
type DataFlowsClientCreateOrUpdateOptions struct {
	// ETag of the data flow entity. Should only be specified for update, for which it should match existing entity or can be
	// * for unconditional update.
	IfMatch *string
}

// DataFlowsClientDeleteOptions contains the optional parameters for the DataFlowsClient.Delete method.
type DataFlowsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// DataFlowsClientGetOptions contains the optional parameters for the DataFlowsClient.Get method.
type DataFlowsClientGetOptions struct {
	// ETag of the data flow entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// DataFlowsClientListByFactoryOptions contains the optional parameters for the DataFlowsClient.ListByFactory method.
type DataFlowsClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// DataLakeAnalyticsUSQLActivity - Data Lake Analytics U-SQL activity.
type DataLakeAnalyticsUSQLActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Data Lake Analytics U-SQL activity properties.
	TypeProperties *DataLakeAnalyticsUSQLActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type DataLakeAnalyticsUSQLActivity.
func (d *DataLakeAnalyticsUSQLActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type DataLakeAnalyticsUSQLActivity.
func (d *DataLakeAnalyticsUSQLActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    d.LinkedServiceName,
		Policy:               d.Policy,
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsUSQLActivity.
func (d DataLakeAnalyticsUSQLActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "policy", d.Policy)
	objectMap["type"] = "DataLakeAnalyticsU-SQL"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsUSQLActivity.
func (d *DataLakeAnalyticsUSQLActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &d.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataLakeAnalyticsUSQLActivityTypeProperties - DataLakeAnalyticsU-SQL activity properties.
type DataLakeAnalyticsUSQLActivityTypeProperties struct {
	// REQUIRED; Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// REQUIRED; Case-sensitive path to folder that contains the U-SQL script. Type: string (or Expression with resultType string).
	ScriptPath map[string]interface{} `json:"scriptPath,omitempty"`

	// Compilation mode of U-SQL. Must be one of these values : Semantic, Full and SingleBox. Type: string (or Expression with
	// resultType string).
	CompilationMode map[string]interface{} `json:"compilationMode,omitempty"`

	// The maximum number of nodes simultaneously used to run the job. Default value is 1. Type: integer (or Expression with resultType
	// integer), minimum: 1.
	DegreeOfParallelism map[string]interface{} `json:"degreeOfParallelism,omitempty"`

	// Parameters for U-SQL job request.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`

	// Determines which jobs out of all that are queued should be selected to run first. The lower the number, the higher the
	// priority. Default value is 1000. Type: integer (or Expression with resultType
	// integer), minimum: 1.
	Priority map[string]interface{} `json:"priority,omitempty"`

	// Runtime version of the U-SQL engine to use. Type: string (or Expression with resultType string).
	RuntimeVersion map[string]interface{} `json:"runtimeVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsUSQLActivityTypeProperties.
func (d DataLakeAnalyticsUSQLActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compilationMode", d.CompilationMode)
	populate(objectMap, "degreeOfParallelism", d.DegreeOfParallelism)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "priority", d.Priority)
	populate(objectMap, "runtimeVersion", d.RuntimeVersion)
	populate(objectMap, "scriptLinkedService", d.ScriptLinkedService)
	populate(objectMap, "scriptPath", d.ScriptPath)
	return json.Marshal(objectMap)
}

// DatabricksNotebookActivity - DatabricksNotebook activity.
type DatabricksNotebookActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Databricks Notebook activity properties.
	TypeProperties *DatabricksNotebookActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type DatabricksNotebookActivity.
func (d *DatabricksNotebookActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type DatabricksNotebookActivity.
func (d *DatabricksNotebookActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    d.LinkedServiceName,
		Policy:               d.Policy,
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksNotebookActivity.
func (d DatabricksNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "policy", d.Policy)
	objectMap["type"] = "DatabricksNotebook"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksNotebookActivity.
func (d *DatabricksNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &d.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabricksNotebookActivityTypeProperties - Databricks Notebook activity properties.
type DatabricksNotebookActivityTypeProperties struct {
	// REQUIRED; The absolute path of the notebook to be run in the Databricks Workspace. This path must begin with a slash. Type:
	// string (or Expression with resultType string).
	NotebookPath map[string]interface{} `json:"notebookPath,omitempty"`

	// Base parameters to be used for each run of this job.If the notebook takes a parameter that is not specified, the default
	// value from the notebook will be used.
	BaseParameters map[string]map[string]interface{} `json:"baseParameters,omitempty"`

	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries []map[string]map[string]interface{} `json:"libraries,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksNotebookActivityTypeProperties.
func (d DatabricksNotebookActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseParameters", d.BaseParameters)
	populate(objectMap, "libraries", d.Libraries)
	populate(objectMap, "notebookPath", d.NotebookPath)
	return json.Marshal(objectMap)
}

// DatabricksSparkJarActivity - DatabricksSparkJar activity.
type DatabricksSparkJarActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Databricks SparkJar activity properties.
	TypeProperties *DatabricksSparkJarActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type DatabricksSparkJarActivity.
func (d *DatabricksSparkJarActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type DatabricksSparkJarActivity.
func (d *DatabricksSparkJarActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    d.LinkedServiceName,
		Policy:               d.Policy,
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkJarActivity.
func (d DatabricksSparkJarActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "policy", d.Policy)
	objectMap["type"] = "DatabricksSparkJar"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkJarActivity.
func (d *DatabricksSparkJarActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &d.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabricksSparkJarActivityTypeProperties - Databricks SparkJar activity properties.
type DatabricksSparkJarActivityTypeProperties struct {
	// REQUIRED; The full name of the class containing the main method to be executed. This class must be contained in a JAR provided
	// as a library. Type: string (or Expression with resultType string).
	MainClassName map[string]interface{} `json:"mainClassName,omitempty"`

	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries []map[string]map[string]interface{} `json:"libraries,omitempty"`

	// Parameters that will be passed to the main method.
	Parameters []map[string]interface{} `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkJarActivityTypeProperties.
func (d DatabricksSparkJarActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "libraries", d.Libraries)
	populate(objectMap, "mainClassName", d.MainClassName)
	populate(objectMap, "parameters", d.Parameters)
	return json.Marshal(objectMap)
}

// DatabricksSparkPythonActivity - DatabricksSparkPython activity.
type DatabricksSparkPythonActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Databricks SparkPython activity properties.
	TypeProperties *DatabricksSparkPythonActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type DatabricksSparkPythonActivity.
func (d *DatabricksSparkPythonActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type DatabricksSparkPythonActivity.
func (d *DatabricksSparkPythonActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    d.LinkedServiceName,
		Policy:               d.Policy,
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkPythonActivity.
func (d DatabricksSparkPythonActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "policy", d.Policy)
	objectMap["type"] = "DatabricksSparkPython"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkPythonActivity.
func (d *DatabricksSparkPythonActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &d.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabricksSparkPythonActivityTypeProperties - Databricks SparkPython activity properties.
type DatabricksSparkPythonActivityTypeProperties struct {
	// REQUIRED; The URI of the Python file to be executed. DBFS paths are supported. Type: string (or Expression with resultType
	// string).
	PythonFile map[string]interface{} `json:"pythonFile,omitempty"`

	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries []map[string]map[string]interface{} `json:"libraries,omitempty"`

	// Command line parameters that will be passed to the Python file.
	Parameters []map[string]interface{} `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkPythonActivityTypeProperties.
func (d DatabricksSparkPythonActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "libraries", d.Libraries)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "pythonFile", d.PythonFile)
	return json.Marshal(objectMap)
}

// DatasetClassification provides polymorphic access to related types.
// Call the interface's GetDataset() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AmazonMWSObjectDataset, *AmazonRdsForOracleTableDataset, *AmazonRdsForSQLServerTableDataset, *AmazonRedshiftTableDataset,
// - *AmazonS3Dataset, *AvroDataset, *AzureBlobDataset, *AzureBlobFSDataset, *AzureDataExplorerTableDataset, *AzureDataLakeStoreDataset,
// - *AzureDatabricksDeltaLakeDataset, *AzureMariaDBTableDataset, *AzureMySQLTableDataset, *AzurePostgreSQLTableDataset, *AzureSQLDWTableDataset,
// - *AzureSQLMITableDataset, *AzureSQLTableDataset, *AzureSearchIndexDataset, *AzureTableDataset, *BinaryDataset, *CassandraTableDataset,
// - *CommonDataServiceForAppsEntityDataset, *ConcurObjectDataset, *CosmosDbMongoDbAPICollectionDataset, *CosmosDbSQLAPICollectionDataset,
// - *CouchbaseTableDataset, *CustomDataset, *Dataset, *Db2TableDataset, *DelimitedTextDataset, *DocumentDbCollectionDataset,
// - *DrillTableDataset, *DynamicsAXResourceDataset, *DynamicsCrmEntityDataset, *DynamicsEntityDataset, *EloquaObjectDataset,
// - *ExcelDataset, *FileShareDataset, *GoogleAdWordsObjectDataset, *GoogleBigQueryObjectDataset, *GreenplumTableDataset,
// - *HBaseObjectDataset, *HTTPDataset, *HiveObjectDataset, *HubspotObjectDataset, *ImpalaObjectDataset, *InformixTableDataset,
// - *JSONDataset, *JiraObjectDataset, *MagentoObjectDataset, *MariaDBTableDataset, *MarketoObjectDataset, *MicrosoftAccessTableDataset,
// - *MongoDbAtlasCollectionDataset, *MongoDbCollectionDataset, *MongoDbV2CollectionDataset, *MySQLTableDataset, *NetezzaTableDataset,
// - *ODataResourceDataset, *OdbcTableDataset, *Office365Dataset, *OracleServiceCloudObjectDataset, *OracleTableDataset, *OrcDataset,
// - *ParquetDataset, *PaypalObjectDataset, *PhoenixObjectDataset, *PostgreSQLTableDataset, *PrestoObjectDataset, *QuickBooksObjectDataset,
// - *RelationalTableDataset, *ResponsysObjectDataset, *RestResourceDataset, *SQLServerTableDataset, *SalesforceMarketingCloudObjectDataset,
// - *SalesforceObjectDataset, *SalesforceServiceCloudObjectDataset, *SapBwCubeDataset, *SapCloudForCustomerResourceDataset,
// - *SapEccResourceDataset, *SapHanaTableDataset, *SapOpenHubTableDataset, *SapTableResourceDataset, *ServiceNowObjectDataset,
// - *SharePointOnlineListResourceDataset, *ShopifyObjectDataset, *SnowflakeDataset, *SparkObjectDataset, *SquareObjectDataset,
// - *SybaseTableDataset, *TeradataTableDataset, *VerticaTableDataset, *WebTableDataset, *XMLDataset, *XeroObjectDataset,
// - *ZohoObjectDataset
type DatasetClassification interface {
	// GetDataset returns the Dataset content of the underlying type.
	GetDataset() *Dataset
}

// Dataset - The Azure Data Factory nested object which identifies data within different data stores, such as tables, files,
// folders, and documents.
type Dataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type Dataset.
func (d *Dataset) GetDataset() *Dataset { return d }

// MarshalJSON implements the json.Marshaller interface for type Dataset.
func (d Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Dataset.
func (d *Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetCompression - The compression method used on a dataset.
type DatasetCompression struct {
	// REQUIRED; Type of dataset compression. Type: string (or Expression with resultType string).
	Type map[string]interface{} `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The dataset compression level. Type: string (or Expression with resultType string).
	Level map[string]interface{} `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetCompression.
func (d DatasetCompression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "level", d.Level)
	populate(objectMap, "type", d.Type)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetCompression.
func (d *DatasetCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			err = unpopulate(val, &d.Level)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetDataElement - Columns that define the structure of the dataset.
type DatasetDataElement struct {
	// Name of the column. Type: string (or Expression with resultType string).
	Name map[string]interface{} `json:"name,omitempty"`

	// Type of the column. Type: string (or Expression with resultType string).
	Type map[string]interface{} `json:"type,omitempty"`
}

// DatasetDebugResource - Dataset debug resource.
type DatasetDebugResource struct {
	// REQUIRED; Dataset properties.
	Properties DatasetClassification `json:"properties,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetDebugResource.
func (d DatasetDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetDebugResource.
func (d *DatasetDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDatasetClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetFolder - The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
type DatasetFolder struct {
	// The name of the folder that this Dataset is in.
	Name *string `json:"name,omitempty"`
}

// DatasetListResponse - A list of dataset resources.
type DatasetListResponse struct {
	// REQUIRED; List of datasets.
	Value []*DatasetResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetListResponse.
func (d DatasetListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DatasetLocationClassification provides polymorphic access to related types.
// Call the interface's GetDatasetLocation() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AmazonS3CompatibleLocation, *AmazonS3Location, *AzureBlobFSLocation, *AzureBlobStorageLocation, *AzureDataLakeStoreLocation,
// - *AzureFileStorageLocation, *DatasetLocation, *FileServerLocation, *FtpServerLocation, *GoogleCloudStorageLocation, *HTTPServerLocation,
// - *HdfsLocation, *OracleCloudStorageLocation, *SftpLocation
type DatasetLocationClassification interface {
	// GetDatasetLocation returns the DatasetLocation content of the underlying type.
	GetDatasetLocation() *DatasetLocation
}

// DatasetLocation - Dataset location.
type DatasetLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type DatasetLocation.
func (d *DatasetLocation) GetDatasetLocation() *DatasetLocation { return d }

// MarshalJSON implements the json.Marshaller interface for type DatasetLocation.
func (d DatasetLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", d.FileName)
	populate(objectMap, "folderPath", d.FolderPath)
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetLocation.
func (d *DatasetLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &d.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &d.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetReference - Dataset reference type.
type DatasetReference struct {
	// REQUIRED; Reference dataset name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Dataset reference type.
	Type *DatasetReferenceType `json:"type,omitempty"`

	// Arguments for dataset.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetReference.
func (d DatasetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "referenceName", d.ReferenceName)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// DatasetResource - Dataset resource type.
type DatasetResource struct {
	// REQUIRED; Dataset properties.
	Properties DatasetClassification `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetResource.
func (d DatasetResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetResource.
func (d *DatasetResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDatasetClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetSchemaDataElement - Columns that define the physical type schema of the dataset.
type DatasetSchemaDataElement struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Name of the schema column. Type: string (or Expression with resultType string).
	Name map[string]interface{} `json:"name,omitempty"`

	// Type of the schema column. Type: string (or Expression with resultType string).
	Type map[string]interface{} `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetSchemaDataElement.
func (d DatasetSchemaDataElement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", d.Name)
	populate(objectMap, "type", d.Type)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetSchemaDataElement.
func (d *DatasetSchemaDataElement) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetStorageFormatClassification provides polymorphic access to related types.
// Call the interface's GetDatasetStorageFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AvroFormat, *DatasetStorageFormat, *JSONFormat, *OrcFormat, *ParquetFormat, *TextFormat
type DatasetStorageFormatClassification interface {
	// GetDatasetStorageFormat returns the DatasetStorageFormat content of the underlying type.
	GetDatasetStorageFormat() *DatasetStorageFormat
}

// DatasetStorageFormat - The format definition of a storage.
type DatasetStorageFormat struct {
	// REQUIRED; Type of dataset storage format.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer map[string]interface{} `json:"deserializer,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer map[string]interface{} `json:"serializer,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type DatasetStorageFormat.
func (d *DatasetStorageFormat) GetDatasetStorageFormat() *DatasetStorageFormat { return d }

// MarshalJSON implements the json.Marshaller interface for type DatasetStorageFormat.
func (d DatasetStorageFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deserializer", d.Deserializer)
	populate(objectMap, "serializer", d.Serializer)
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetStorageFormat.
func (d *DatasetStorageFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, &d.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, &d.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetsClientCreateOrUpdateOptions contains the optional parameters for the DatasetsClient.CreateOrUpdate method.
type DatasetsClientCreateOrUpdateOptions struct {
	// ETag of the dataset entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// DatasetsClientDeleteOptions contains the optional parameters for the DatasetsClient.Delete method.
type DatasetsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// DatasetsClientGetOptions contains the optional parameters for the DatasetsClient.Get method.
type DatasetsClientGetOptions struct {
	// ETag of the dataset entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// DatasetsClientListByFactoryOptions contains the optional parameters for the DatasetsClient.ListByFactory method.
type DatasetsClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// Db2LinkedService - Linked service for DB2 data source.
type Db2LinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; DB2 linked service properties.
	TypeProperties *Db2LinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type Db2LinkedService.
func (d *Db2LinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 d.Type,
		ConnectVia:           d.ConnectVia,
		Description:          d.Description,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Db2LinkedService.
func (d Db2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Db2"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedService.
func (d *Db2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Db2LinkedServiceTypeProperties - DB2 linked service properties.
type Db2LinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection. It is mutually exclusive with connectionString property.
	AuthenticationType *Db2AuthenticationType `json:"authenticationType,omitempty"`

	// Certificate Common Name when TLS is enabled. It is mutually exclusive with connectionString property. Type: string (or
	// Expression with resultType string).
	CertificateCommonName map[string]interface{} `json:"certificateCommonName,omitempty"`

	// The connection string. It is mutually exclusive with server, database, authenticationType, userName, packageCollection
	// and certificateCommonName property. Type: string, SecureString or
	// AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Database name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with
	// resultType string).
	Database map[string]interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// It is mutually exclusive with connectionString property. Type: string (or
	// Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Under where packages are created when querying database. It is mutually exclusive with connectionString property. Type:
	// string (or Expression with resultType string).
	PackageCollection map[string]interface{} `json:"packageCollection,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Server name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType
	// string).
	Server map[string]interface{} `json:"server,omitempty"`

	// Username for authentication. It is mutually exclusive with connectionString property. Type: string (or Expression with
	// resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Db2LinkedServiceTypeProperties.
func (d Db2LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", d.AuthenticationType)
	populate(objectMap, "certificateCommonName", d.CertificateCommonName)
	populate(objectMap, "connectionString", d.ConnectionString)
	populate(objectMap, "database", d.Database)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populate(objectMap, "packageCollection", d.PackageCollection)
	populate(objectMap, "password", d.Password)
	populate(objectMap, "server", d.Server)
	populate(objectMap, "username", d.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedServiceTypeProperties.
func (d *Db2LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &d.AuthenticationType)
			delete(rawMsg, key)
		case "certificateCommonName":
			err = unpopulate(val, &d.CertificateCommonName)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &d.ConnectionString)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, &d.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &d.EncryptedCredential)
			delete(rawMsg, key)
		case "packageCollection":
			err = unpopulate(val, &d.PackageCollection)
			delete(rawMsg, key)
		case "password":
			d.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &d.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &d.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Db2Source - A copy activity source for Db2 databases.
type Db2Source struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type Db2Source.
func (d *Db2Source) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type Db2Source.
func (d *Db2Source) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             d.QueryTimeout,
		AdditionalColumns:        d.AdditionalColumns,
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Db2Source.
func (d Db2Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "query", d.Query)
	populate(objectMap, "queryTimeout", d.QueryTimeout)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "Db2Source"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2Source.
func (d *Db2Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Db2TableDataset - The Db2 table dataset.
type Db2TableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Db2 table dataset properties.
	TypeProperties *Db2TableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type Db2TableDataset.
func (d *Db2TableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Db2TableDataset.
func (d Db2TableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "Db2Table"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2TableDataset.
func (d *Db2TableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Db2TableDatasetTypeProperties - Db2 table dataset properties.
type Db2TableDatasetTypeProperties struct {
	// The Db2 schema name. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The Db2 table name. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// DeleteActivity - Delete activity.
type DeleteActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Delete activity properties.
	TypeProperties *DeleteActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type DeleteActivity.
func (d *DeleteActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type DeleteActivity.
func (d *DeleteActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    d.LinkedServiceName,
		Policy:               d.Policy,
		Name:                 d.Name,
		Type:                 d.Type,
		Description:          d.Description,
		DependsOn:            d.DependsOn,
		UserProperties:       d.UserProperties,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DeleteActivity.
func (d DeleteActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", d.DependsOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "policy", d.Policy)
	objectMap["type"] = "Delete"
	populate(objectMap, "typeProperties", d.TypeProperties)
	populate(objectMap, "userProperties", d.UserProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteActivity.
func (d *DeleteActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &d.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &d.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &d.UserProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeleteActivityTypeProperties - Delete activity properties.
type DeleteActivityTypeProperties struct {
	// REQUIRED; Delete activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Whether to record detailed logs of delete-activity execution. Default value is false. Type: boolean (or Expression with
	// resultType boolean).
	EnableLogging map[string]interface{} `json:"enableLogging,omitempty"`

	// Log storage settings customer need to provide when enableLogging is true.
	LogStorageSettings *LogStorageSettings `json:"logStorageSettings,omitempty"`

	// The max concurrent connections to connect data source at the same time.
	MaxConcurrentConnections *int32 `json:"maxConcurrentConnections,omitempty"`

	// If true, files or sub-folders under current folder path will be deleted recursively. Default is false. Type: boolean (or
	// Expression with resultType boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Delete activity store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeleteActivityTypeProperties.
func (d DeleteActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataset", d.Dataset)
	populate(objectMap, "enableLogging", d.EnableLogging)
	populate(objectMap, "logStorageSettings", d.LogStorageSettings)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "recursive", d.Recursive)
	populate(objectMap, "storeSettings", d.StoreSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteActivityTypeProperties.
func (d *DeleteActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, &d.Dataset)
			delete(rawMsg, key)
		case "enableLogging":
			err = unpopulate(val, &d.EnableLogging)
			delete(rawMsg, key)
		case "logStorageSettings":
			err = unpopulate(val, &d.LogStorageSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &d.Recursive)
			delete(rawMsg, key)
		case "storeSettings":
			d.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeleteDataFlowDebugSessionRequest - Request body structure for deleting data flow debug session.
type DeleteDataFlowDebugSessionRequest struct {
	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// DelimitedTextDataset - Delimited text dataset.
type DelimitedTextDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Delimited text dataset properties.
	TypeProperties *DelimitedTextDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type DelimitedTextDataset.
func (d *DelimitedTextDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextDataset.
func (d DelimitedTextDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "DelimitedText"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDataset.
func (d *DelimitedTextDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DelimitedTextDatasetTypeProperties - DelimitedText dataset properties.
type DelimitedTextDatasetTypeProperties struct {
	// REQUIRED; The location of the delimited text storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The column delimiter. Type: string (or Expression with resultType string).
	ColumnDelimiter map[string]interface{} `json:"columnDelimiter,omitempty"`

	// The data compressionCodec. Type: string (or Expression with resultType string).
	CompressionCodec map[string]interface{} `json:"compressionCodec,omitempty"`

	// The data compression method used for DelimitedText.
	CompressionLevel map[string]interface{} `json:"compressionLevel,omitempty"`

	// The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding.
	// Refer to the name column of the table in the following link to set
	// supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType
	// string).
	EncodingName map[string]interface{} `json:"encodingName,omitempty"`

	// The escape character. Type: string (or Expression with resultType string).
	EscapeChar map[string]interface{} `json:"escapeChar,omitempty"`

	// When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the
	// first row of data. The default value is false. Type: boolean (or Expression
	// with resultType boolean).
	FirstRowAsHeader map[string]interface{} `json:"firstRowAsHeader,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue map[string]interface{} `json:"nullValue,omitempty"`

	// The quote character. Type: string (or Expression with resultType string).
	QuoteChar map[string]interface{} `json:"quoteChar,omitempty"`

	// The row delimiter. Type: string (or Expression with resultType string).
	RowDelimiter map[string]interface{} `json:"rowDelimiter,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextDatasetTypeProperties.
func (d DelimitedTextDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columnDelimiter", d.ColumnDelimiter)
	populate(objectMap, "compressionCodec", d.CompressionCodec)
	populate(objectMap, "compressionLevel", d.CompressionLevel)
	populate(objectMap, "encodingName", d.EncodingName)
	populate(objectMap, "escapeChar", d.EscapeChar)
	populate(objectMap, "firstRowAsHeader", d.FirstRowAsHeader)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "nullValue", d.NullValue)
	populate(objectMap, "quoteChar", d.QuoteChar)
	populate(objectMap, "rowDelimiter", d.RowDelimiter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDatasetTypeProperties.
func (d *DelimitedTextDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			err = unpopulate(val, &d.ColumnDelimiter)
			delete(rawMsg, key)
		case "compressionCodec":
			err = unpopulate(val, &d.CompressionCodec)
			delete(rawMsg, key)
		case "compressionLevel":
			err = unpopulate(val, &d.CompressionLevel)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, &d.EncodingName)
			delete(rawMsg, key)
		case "escapeChar":
			err = unpopulate(val, &d.EscapeChar)
			delete(rawMsg, key)
		case "firstRowAsHeader":
			err = unpopulate(val, &d.FirstRowAsHeader)
			delete(rawMsg, key)
		case "location":
			d.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, &d.NullValue)
			delete(rawMsg, key)
		case "quoteChar":
			err = unpopulate(val, &d.QuoteChar)
			delete(rawMsg, key)
		case "rowDelimiter":
			err = unpopulate(val, &d.RowDelimiter)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DelimitedTextReadSettings - Delimited text read settings.
type DelimitedTextReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Compression settings.
	CompressionProperties CompressionReadSettingsClassification `json:"compressionProperties,omitempty"`

	// Indicates the number of non-empty rows to skip when reading data from input files. Type: integer (or Expression with resultType
	// integer).
	SkipLineCount map[string]interface{} `json:"skipLineCount,omitempty"`
}

// GetFormatReadSettings implements the FormatReadSettingsClassification interface for type DelimitedTextReadSettings.
func (d *DelimitedTextReadSettings) GetFormatReadSettings() *FormatReadSettings {
	return &FormatReadSettings{
		Type:                 d.Type,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextReadSettings.
func (d DelimitedTextReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compressionProperties", d.CompressionProperties)
	populate(objectMap, "skipLineCount", d.SkipLineCount)
	objectMap["type"] = "DelimitedTextReadSettings"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextReadSettings.
func (d *DelimitedTextReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			d.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "skipLineCount":
			err = unpopulate(val, &d.SkipLineCount)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DelimitedTextSink - A copy activity DelimitedText sink.
type DelimitedTextSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// DelimitedText format settings.
	FormatSettings *DelimitedTextWriteSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// DelimitedText store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type DelimitedTextSink.
func (d *DelimitedTextSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     d.Type,
		WriteBatchSize:           d.WriteBatchSize,
		WriteBatchTimeout:        d.WriteBatchTimeout,
		SinkRetryCount:           d.SinkRetryCount,
		SinkRetryWait:            d.SinkRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextSink.
func (d DelimitedTextSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "formatSettings", d.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", d.SinkRetryWait)
	populate(objectMap, "storeSettings", d.StoreSettings)
	objectMap["type"] = "DelimitedTextSink"
	populate(objectMap, "writeBatchSize", d.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextSink.
func (d *DelimitedTextSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &d.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &d.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			d.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &d.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DelimitedTextSource - A copy activity DelimitedText source.
type DelimitedTextSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// DelimitedText format settings.
	FormatSettings *DelimitedTextReadSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// DelimitedText store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type DelimitedTextSource.
func (d *DelimitedTextSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextSource.
func (d DelimitedTextSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "formatSettings", d.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	populate(objectMap, "storeSettings", d.StoreSettings)
	objectMap["type"] = "DelimitedTextSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextSource.
func (d *DelimitedTextSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &d.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			d.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DelimitedTextWriteSettings - Delimited text write settings.
type DelimitedTextWriteSettings struct {
	// REQUIRED; The file extension used to create the files. Type: string (or Expression with resultType string).
	FileExtension map[string]interface{} `json:"fileExtension,omitempty"`

	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the file name pattern _. when copy from non-file based store without partitionOptions. Type: string (or Expression
	// with resultType string).
	FileNamePrefix map[string]interface{} `json:"fileNamePrefix,omitempty"`

	// Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with
	// resultType integer).
	MaxRowsPerFile map[string]interface{} `json:"maxRowsPerFile,omitempty"`

	// Indicates whether string values should always be enclosed with quotes. Type: boolean (or Expression with resultType boolean).
	QuoteAllText map[string]interface{} `json:"quoteAllText,omitempty"`
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type DelimitedTextWriteSettings.
func (d *DelimitedTextWriteSettings) GetFormatWriteSettings() *FormatWriteSettings {
	return &FormatWriteSettings{
		Type:                 d.Type,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextWriteSettings.
func (d DelimitedTextWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileExtension", d.FileExtension)
	populate(objectMap, "fileNamePrefix", d.FileNamePrefix)
	populate(objectMap, "maxRowsPerFile", d.MaxRowsPerFile)
	populate(objectMap, "quoteAllText", d.QuoteAllText)
	objectMap["type"] = "DelimitedTextWriteSettings"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextWriteSettings.
func (d *DelimitedTextWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileExtension":
			err = unpopulate(val, &d.FileExtension)
			delete(rawMsg, key)
		case "fileNamePrefix":
			err = unpopulate(val, &d.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, &d.MaxRowsPerFile)
			delete(rawMsg, key)
		case "quoteAllText":
			err = unpopulate(val, &d.QuoteAllText)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DependencyReferenceClassification provides polymorphic access to related types.
// Call the interface's GetDependencyReference() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DependencyReference, *SelfDependencyTumblingWindowTriggerReference, *TriggerDependencyReference, *TumblingWindowTriggerDependencyReference
type DependencyReferenceClassification interface {
	// GetDependencyReference returns the DependencyReference content of the underlying type.
	GetDependencyReference() *DependencyReference
}

// DependencyReference - Referenced dependency.
type DependencyReference struct {
	// REQUIRED; The type of dependency reference.
	Type *string `json:"type,omitempty"`
}

// GetDependencyReference implements the DependencyReferenceClassification interface for type DependencyReference.
func (d *DependencyReference) GetDependencyReference() *DependencyReference { return d }

// DistcpSettings - Distcp settings.
type DistcpSettings struct {
	// REQUIRED; Specifies the Yarn ResourceManager endpoint. Type: string (or Expression with resultType string).
	ResourceManagerEndpoint map[string]interface{} `json:"resourceManagerEndpoint,omitempty"`

	// REQUIRED; Specifies an existing folder path which will be used to store temp Distcp command script. The script file is
	// generated by ADF and will be removed after Copy job finished. Type: string (or Expression
	// with resultType string).
	TempScriptPath map[string]interface{} `json:"tempScriptPath,omitempty"`

	// Specifies the Distcp options. Type: string (or Expression with resultType string).
	DistcpOptions map[string]interface{} `json:"distcpOptions,omitempty"`
}

// DocumentDbCollectionDataset - Microsoft Azure Document Database Collection dataset.
type DocumentDbCollectionDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; DocumentDB Collection dataset properties.
	TypeProperties *DocumentDbCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type DocumentDbCollectionDataset.
func (d *DocumentDbCollectionDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionDataset.
func (d DocumentDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "DocumentDbCollection"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionDataset.
func (d *DocumentDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DocumentDbCollectionDatasetTypeProperties - DocumentDB Collection dataset properties.
type DocumentDbCollectionDatasetTypeProperties struct {
	// REQUIRED; Document Database collection name. Type: string (or Expression with resultType string).
	CollectionName map[string]interface{} `json:"collectionName,omitempty"`
}

// DocumentDbCollectionSink - A copy activity Document Database Collection sink.
type DocumentDbCollectionSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Nested properties separator. Default is . (dot). Type: string (or Expression with resultType string).
	NestingSeparator map[string]interface{} `json:"nestingSeparator,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert
	// and upsert.
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type DocumentDbCollectionSink.
func (d *DocumentDbCollectionSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     d.Type,
		WriteBatchSize:           d.WriteBatchSize,
		WriteBatchTimeout:        d.WriteBatchTimeout,
		SinkRetryCount:           d.SinkRetryCount,
		SinkRetryWait:            d.SinkRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionSink.
func (d DocumentDbCollectionSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "nestingSeparator", d.NestingSeparator)
	populate(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", d.SinkRetryWait)
	objectMap["type"] = "DocumentDbCollectionSink"
	populate(objectMap, "writeBatchSize", d.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", d.WriteBehavior)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionSink.
func (d *DocumentDbCollectionSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "nestingSeparator":
			err = unpopulate(val, &d.NestingSeparator)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &d.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &d.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &d.WriteBehavior)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DocumentDbCollectionSource - A copy activity Document Database Collection source.
type DocumentDbCollectionSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Nested properties separator. Type: string (or Expression with resultType string).
	NestingSeparator map[string]interface{} `json:"nestingSeparator,omitempty"`

	// Documents query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type DocumentDbCollectionSource.
func (d *DocumentDbCollectionSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionSource.
func (d DocumentDbCollectionSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "nestingSeparator", d.NestingSeparator)
	populate(objectMap, "query", d.Query)
	populate(objectMap, "queryTimeout", d.QueryTimeout)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DocumentDbCollectionSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionSource.
func (d *DocumentDbCollectionSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "nestingSeparator":
			err = unpopulate(val, &d.NestingSeparator)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DrillDatasetTypeProperties - Drill Dataset Properties
type DrillDatasetTypeProperties struct {
	// The schema name of the Drill. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Drill. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// DrillLinkedService - Drill server linked service.
type DrillLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Drill server linked service properties.
	TypeProperties *DrillLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type DrillLinkedService.
func (d *DrillLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 d.Type,
		ConnectVia:           d.ConnectVia,
		Description:          d.Description,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DrillLinkedService.
func (d DrillLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Drill"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillLinkedService.
func (d *DrillLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DrillLinkedServiceTypeProperties - Drill server linked service properties.
type DrillLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// DrillSource - A copy activity Drill server source.
type DrillSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type DrillSource.
func (d *DrillSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type DrillSource.
func (d *DrillSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             d.QueryTimeout,
		AdditionalColumns:        d.AdditionalColumns,
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DrillSource.
func (d DrillSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "query", d.Query)
	populate(objectMap, "queryTimeout", d.QueryTimeout)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DrillSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillSource.
func (d *DrillSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DrillTableDataset - Drill server dataset.
type DrillTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *DrillDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type DrillTableDataset.
func (d *DrillTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DrillTableDataset.
func (d DrillTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "DrillTable"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillTableDataset.
func (d *DrillTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsAXLinkedService - Dynamics AX linked service.
type DynamicsAXLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dynamics AX linked service properties.
	TypeProperties *DynamicsAXLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type DynamicsAXLinkedService.
func (d *DynamicsAXLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 d.Type,
		ConnectVia:           d.ConnectVia,
		Description:          d.Description,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXLinkedService.
func (d DynamicsAXLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "DynamicsAX"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXLinkedService.
func (d *DynamicsAXLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsAXLinkedServiceTypeProperties - Dynamics AX linked service properties.
type DynamicsAXLinkedServiceTypeProperties struct {
	// REQUIRED; Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
	AADResourceID map[string]interface{} `json:"aadResourceId,omitempty"`

	// REQUIRED; Specify the application's client ID. Type: string (or Expression with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// REQUIRED; Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference
	// a secret stored in Azure Key Vault. Type: string (or Expression with resultType
	// string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// REQUIRED; Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by
	// hovering the mouse in the top-right corner of the Azure portal. Type: string (or
	// Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`

	// REQUIRED; The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
	URL map[string]interface{} `json:"url,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXLinkedServiceTypeProperties.
func (d DynamicsAXLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aadResourceId", d.AADResourceID)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populate(objectMap, "servicePrincipalId", d.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", d.ServicePrincipalKey)
	populate(objectMap, "tenant", d.Tenant)
	populate(objectMap, "url", d.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXLinkedServiceTypeProperties.
func (d *DynamicsAXLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			err = unpopulate(val, &d.AADResourceID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &d.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &d.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			d.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &d.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &d.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsAXResourceDataset - The path of the Dynamics AX OData entity.
type DynamicsAXResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dynamics AX OData resource dataset properties.
	TypeProperties *DynamicsAXResourceDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type DynamicsAXResourceDataset.
func (d *DynamicsAXResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXResourceDataset.
func (d DynamicsAXResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "DynamicsAXResource"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXResourceDataset.
func (d *DynamicsAXResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsAXResourceDatasetTypeProperties - Dynamics AX OData resource dataset properties.
type DynamicsAXResourceDatasetTypeProperties struct {
	// REQUIRED; The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// DynamicsAXSource - A copy activity Dynamics AX source.
type DynamicsAXSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:05:00. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type DynamicsAXSource.
func (d *DynamicsAXSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type DynamicsAXSource.
func (d *DynamicsAXSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             d.QueryTimeout,
		AdditionalColumns:        d.AdditionalColumns,
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAXSource.
func (d DynamicsAXSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", d.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "query", d.Query)
	populate(objectMap, "queryTimeout", d.QueryTimeout)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DynamicsAXSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAXSource.
func (d *DynamicsAXSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &d.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &d.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &d.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsCrmEntityDataset - The Dynamics CRM entity dataset.
type DynamicsCrmEntityDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Dynamics CRM entity dataset properties.
	TypeProperties *DynamicsCrmEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type DynamicsCrmEntityDataset.
func (d *DynamicsCrmEntityDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmEntityDataset.
func (d DynamicsCrmEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "DynamicsCrmEntity"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmEntityDataset.
func (d *DynamicsCrmEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsCrmEntityDatasetTypeProperties - Dynamics CRM entity dataset properties.
type DynamicsCrmEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName map[string]interface{} `json:"entityName,omitempty"`
}

// DynamicsCrmLinkedService - Dynamics CRM linked service.
type DynamicsCrmLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dynamics CRM linked service properties.
	TypeProperties *DynamicsCrmLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type DynamicsCrmLinkedService.
func (d *DynamicsCrmLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 d.Type,
		ConnectVia:           d.ConnectVia,
		Description:          d.Description,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmLinkedService.
func (d DynamicsCrmLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "DynamicsCrm"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedService.
func (d *DynamicsCrmLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsCrmLinkedServiceTypeProperties - Dynamics CRM linked service properties.
type DynamicsCrmLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises
	// with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online
	// scenario. Type: string (or Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// REQUIRED; The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for
	// Dynamics CRM on-premises with Ifd. Type: string (or Expression with resultType string).
	DeploymentType map[string]interface{} `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online.
	// Type: string (or Expression with resultType string).
	HostName map[string]interface{} `json:"hostName,omitempty"`

	// The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there
	// are more than one Dynamics CRM instances associated with the user. Type:
	// string (or Expression with resultType string).
	OrganizationName map[string]interface{} `json:"organizationName,omitempty"`

	// Password to access the Dynamics CRM instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is
	// 443. Type: integer (or Expression with resultType integer), minimum: 0.
	Port map[string]interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can
	// only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType map[string]interface{} `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string
	// (or Expression with resultType string).
	ServiceURI map[string]interface{} `json:"serviceUri,omitempty"`

	// User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmLinkedServiceTypeProperties.
func (d DynamicsCrmLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", d.AuthenticationType)
	populate(objectMap, "deploymentType", d.DeploymentType)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populate(objectMap, "hostName", d.HostName)
	populate(objectMap, "organizationName", d.OrganizationName)
	populate(objectMap, "password", d.Password)
	populate(objectMap, "port", d.Port)
	populate(objectMap, "servicePrincipalCredential", d.ServicePrincipalCredential)
	populate(objectMap, "servicePrincipalCredentialType", d.ServicePrincipalCredentialType)
	populate(objectMap, "servicePrincipalId", d.ServicePrincipalID)
	populate(objectMap, "serviceUri", d.ServiceURI)
	populate(objectMap, "username", d.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedServiceTypeProperties.
func (d *DynamicsCrmLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &d.AuthenticationType)
			delete(rawMsg, key)
		case "deploymentType":
			err = unpopulate(val, &d.DeploymentType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &d.EncryptedCredential)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &d.HostName)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, &d.OrganizationName)
			delete(rawMsg, key)
		case "password":
			d.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &d.Port)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, &d.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &d.ServicePrincipalID)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, &d.ServiceURI)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &d.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsCrmSink - A copy activity Dynamics CRM sink.
type DynamicsCrmSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; The write behavior for the operation.
	WriteBehavior *DynamicsSinkWriteBehavior `json:"writeBehavior,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType
	// string).
	AlternateKeyName map[string]interface{} `json:"alternateKeyName,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default
	// is false. Type: boolean (or Expression with resultType boolean).
	IgnoreNullValues map[string]interface{} `json:"ignoreNullValues,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type DynamicsCrmSink.
func (d *DynamicsCrmSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     d.Type,
		WriteBatchSize:           d.WriteBatchSize,
		WriteBatchTimeout:        d.WriteBatchTimeout,
		SinkRetryCount:           d.SinkRetryCount,
		SinkRetryWait:            d.SinkRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmSink.
func (d DynamicsCrmSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateKeyName", d.AlternateKeyName)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "ignoreNullValues", d.IgnoreNullValues)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", d.SinkRetryWait)
	objectMap["type"] = "DynamicsCrmSink"
	populate(objectMap, "writeBatchSize", d.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", d.WriteBehavior)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmSink.
func (d *DynamicsCrmSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			err = unpopulate(val, &d.AlternateKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, &d.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &d.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &d.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &d.WriteBehavior)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsCrmSource - A copy activity Dynamics CRM source.
type DynamicsCrmSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// FetchXML is a proprietary query language that is used in Microsoft Dynamics CRM (online & on-premises). Type: string (or
	// Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type DynamicsCrmSource.
func (d *DynamicsCrmSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmSource.
func (d DynamicsCrmSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "query", d.Query)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DynamicsCrmSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmSource.
func (d *DynamicsCrmSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &d.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsEntityDataset - The Dynamics entity dataset.
type DynamicsEntityDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Dynamics entity dataset properties.
	TypeProperties *DynamicsEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type DynamicsEntityDataset.
func (d *DynamicsEntityDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 d.Type,
		Description:          d.Description,
		Structure:            d.Structure,
		Schema:               d.Schema,
		LinkedServiceName:    d.LinkedServiceName,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		Folder:               d.Folder,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsEntityDataset.
func (d DynamicsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "folder", d.Folder)
	populate(objectMap, "linkedServiceName", d.LinkedServiceName)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "schema", d.Schema)
	populate(objectMap, "structure", d.Structure)
	objectMap["type"] = "DynamicsEntity"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsEntityDataset.
func (d *DynamicsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &d.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &d.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &d.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &d.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsEntityDatasetTypeProperties - Dynamics entity dataset properties.
type DynamicsEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName map[string]interface{} `json:"entityName,omitempty"`
}

// DynamicsLinkedService - Dynamics linked service.
type DynamicsLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dynamics linked service properties.
	TypeProperties *DynamicsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type DynamicsLinkedService.
func (d *DynamicsLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 d.Type,
		ConnectVia:           d.ConnectVia,
		Description:          d.Description,
		Parameters:           d.Parameters,
		Annotations:          d.Annotations,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsLinkedService.
func (d DynamicsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "connectVia", d.ConnectVia)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "parameters", d.Parameters)
	objectMap["type"] = "Dynamics"
	populate(objectMap, "typeProperties", d.TypeProperties)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedService.
func (d *DynamicsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &d.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &d.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &d.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &d.TypeProperties)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsLinkedServiceTypeProperties - Dynamics linked service properties.
type DynamicsLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises
	// with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online
	// scenario. Type: string (or Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// REQUIRED; The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics
	// on-premises with Ifd. Type: string (or Expression with resultType string).
	DeploymentType map[string]interface{} `json:"deploymentType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type:
	// string (or Expression with resultType string).
	HostName map[string]interface{} `json:"hostName,omitempty"`

	// The organization name of the Dynamics instance. The property is required for on-prem and required for online when there
	// are more than one Dynamics instances associated with the user. Type: string (or
	// Expression with resultType string).
	OrganizationName map[string]interface{} `json:"organizationName,omitempty"`

	// Password to access the Dynamics instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443.
	// Type: integer (or Expression with resultType integer), minimum: 0.
	Port map[string]interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can
	// only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType map[string]interface{} `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string
	// (or Expression with resultType string).
	ServiceURI map[string]interface{} `json:"serviceUri,omitempty"`

	// User name to access the Dynamics instance. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsLinkedServiceTypeProperties.
func (d DynamicsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", d.AuthenticationType)
	populate(objectMap, "credential", d.Credential)
	populate(objectMap, "deploymentType", d.DeploymentType)
	populate(objectMap, "encryptedCredential", d.EncryptedCredential)
	populate(objectMap, "hostName", d.HostName)
	populate(objectMap, "organizationName", d.OrganizationName)
	populate(objectMap, "password", d.Password)
	populate(objectMap, "port", d.Port)
	populate(objectMap, "servicePrincipalCredential", d.ServicePrincipalCredential)
	populate(objectMap, "servicePrincipalCredentialType", d.ServicePrincipalCredentialType)
	populate(objectMap, "servicePrincipalId", d.ServicePrincipalID)
	populate(objectMap, "serviceUri", d.ServiceURI)
	populate(objectMap, "username", d.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedServiceTypeProperties.
func (d *DynamicsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &d.AuthenticationType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &d.Credential)
			delete(rawMsg, key)
		case "deploymentType":
			err = unpopulate(val, &d.DeploymentType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &d.EncryptedCredential)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &d.HostName)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, &d.OrganizationName)
			delete(rawMsg, key)
		case "password":
			d.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &d.Port)
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			err = unpopulate(val, &d.ServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &d.ServicePrincipalID)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, &d.ServiceURI)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &d.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsSink - A copy activity Dynamics sink.
type DynamicsSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; The write behavior for the operation.
	WriteBehavior *DynamicsSinkWriteBehavior `json:"writeBehavior,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType
	// string).
	AlternateKeyName map[string]interface{} `json:"alternateKeyName,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The flag indicating whether ignore null values from input dataset (except key fields) during write operation. Default is
	// false. Type: boolean (or Expression with resultType boolean).
	IgnoreNullValues map[string]interface{} `json:"ignoreNullValues,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type DynamicsSink.
func (d *DynamicsSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     d.Type,
		WriteBatchSize:           d.WriteBatchSize,
		WriteBatchTimeout:        d.WriteBatchTimeout,
		SinkRetryCount:           d.SinkRetryCount,
		SinkRetryWait:            d.SinkRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsSink.
func (d DynamicsSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateKeyName", d.AlternateKeyName)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "ignoreNullValues", d.IgnoreNullValues)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", d.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", d.SinkRetryWait)
	objectMap["type"] = "DynamicsSink"
	populate(objectMap, "writeBatchSize", d.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", d.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", d.WriteBehavior)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsSink.
func (d *DynamicsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			err = unpopulate(val, &d.AlternateKeyName)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, &d.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &d.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &d.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &d.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &d.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &d.WriteBehavior)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicsSource - A copy activity Dynamics source.
type DynamicsSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// FetchXML is a proprietary query language that is used in Microsoft Dynamics (online & on-premises). Type: string (or Expression
	// with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type DynamicsSource.
func (d *DynamicsSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     d.Type,
		SourceRetryCount:         d.SourceRetryCount,
		SourceRetryWait:          d.SourceRetryWait,
		MaxConcurrentConnections: d.MaxConcurrentConnections,
		DisableMetricsCollection: d.DisableMetricsCollection,
		AdditionalProperties:     d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsSource.
func (d DynamicsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", d.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", d.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", d.MaxConcurrentConnections)
	populate(objectMap, "query", d.Query)
	populate(objectMap, "sourceRetryCount", d.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", d.SourceRetryWait)
	objectMap["type"] = "DynamicsSource"
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsSource.
func (d *DynamicsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &d.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &d.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &d.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &d.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &d.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &d.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EloquaLinkedService - Eloqua server linked service.
type EloquaLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Eloqua server linked service properties.
	TypeProperties *EloquaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type EloquaLinkedService.
func (e *EloquaLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 e.Type,
		ConnectVia:           e.ConnectVia,
		Description:          e.Description,
		Parameters:           e.Parameters,
		Annotations:          e.Annotations,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EloquaLinkedService.
func (e EloquaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", e.Annotations)
	populate(objectMap, "connectVia", e.ConnectVia)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "parameters", e.Parameters)
	objectMap["type"] = "Eloqua"
	populate(objectMap, "typeProperties", e.TypeProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedService.
func (e *EloquaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &e.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &e.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &e.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EloquaLinkedServiceTypeProperties - Eloqua server linked service properties.
type EloquaLinkedServiceTypeProperties struct {
	// REQUIRED; The endpoint of the Eloqua server. (i.e. eloqua.example.com)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// REQUIRED; The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
	Username map[string]interface{} `json:"username,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EloquaLinkedServiceTypeProperties.
func (e EloquaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", e.EncryptedCredential)
	populate(objectMap, "endpoint", e.Endpoint)
	populate(objectMap, "password", e.Password)
	populate(objectMap, "useEncryptedEndpoints", e.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", e.UseHostVerification)
	populate(objectMap, "usePeerVerification", e.UsePeerVerification)
	populate(objectMap, "username", e.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedServiceTypeProperties.
func (e *EloquaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &e.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &e.Endpoint)
			delete(rawMsg, key)
		case "password":
			e.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &e.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &e.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &e.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &e.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EloquaObjectDataset - Eloqua server dataset.
type EloquaObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type EloquaObjectDataset.
func (e *EloquaObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 e.Type,
		Description:          e.Description,
		Structure:            e.Structure,
		Schema:               e.Schema,
		LinkedServiceName:    e.LinkedServiceName,
		Parameters:           e.Parameters,
		Annotations:          e.Annotations,
		Folder:               e.Folder,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EloquaObjectDataset.
func (e EloquaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", e.Annotations)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "folder", e.Folder)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "parameters", e.Parameters)
	populate(objectMap, "schema", e.Schema)
	populate(objectMap, "structure", e.Structure)
	objectMap["type"] = "EloquaObject"
	populate(objectMap, "typeProperties", e.TypeProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaObjectDataset.
func (e *EloquaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &e.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &e.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &e.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &e.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &e.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &e.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EloquaSource - A copy activity Eloqua server source.
type EloquaSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type EloquaSource.
func (e *EloquaSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     e.Type,
		SourceRetryCount:         e.SourceRetryCount,
		SourceRetryWait:          e.SourceRetryWait,
		MaxConcurrentConnections: e.MaxConcurrentConnections,
		DisableMetricsCollection: e.DisableMetricsCollection,
		AdditionalProperties:     e.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type EloquaSource.
func (e *EloquaSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             e.QueryTimeout,
		AdditionalColumns:        e.AdditionalColumns,
		Type:                     e.Type,
		SourceRetryCount:         e.SourceRetryCount,
		SourceRetryWait:          e.SourceRetryWait,
		MaxConcurrentConnections: e.MaxConcurrentConnections,
		DisableMetricsCollection: e.DisableMetricsCollection,
		AdditionalProperties:     e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EloquaSource.
func (e EloquaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", e.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", e.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", e.MaxConcurrentConnections)
	populate(objectMap, "query", e.Query)
	populate(objectMap, "queryTimeout", e.QueryTimeout)
	populate(objectMap, "sourceRetryCount", e.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", e.SourceRetryWait)
	objectMap["type"] = "EloquaSource"
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaSource.
func (e *EloquaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &e.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &e.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &e.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &e.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &e.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &e.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &e.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EncryptionConfiguration - Definition of CMK for the factory.
type EncryptionConfiguration struct {
	// REQUIRED; The name of the key in Azure Key Vault to use as Customer Managed Key.
	KeyName *string `json:"keyName,omitempty"`

	// REQUIRED; The url of the Azure Key Vault used for CMK.
	VaultBaseURL *string `json:"vaultBaseUrl,omitempty"`

	// User assigned identity to use to authenticate to customer's key vault. If not provided Managed Service Identity will be
	// used.
	Identity *CMKIdentityDefinition `json:"identity,omitempty"`

	// The version of the key used for CMK. If not provided, latest version will be used.
	KeyVersion *string `json:"keyVersion,omitempty"`
}

// EntityReference - The entity reference.
type EntityReference struct {
	// The name of this referenced entity.
	ReferenceName *string `json:"referenceName,omitempty"`

	// The type of this referenced entity.
	Type *IntegrationRuntimeEntityReferenceType `json:"type,omitempty"`
}

// EnvironmentVariableSetup - The custom setup of setting environment variable.
type EnvironmentVariableSetup struct {
	// REQUIRED; The type of custom setup.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Add environment variable type properties.
	TypeProperties *EnvironmentVariableSetupTypeProperties `json:"typeProperties,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type EnvironmentVariableSetup.
func (e *EnvironmentVariableSetup) GetCustomSetupBase() *CustomSetupBase {
	return &CustomSetupBase{
		Type: e.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableSetup.
func (e EnvironmentVariableSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = "EnvironmentVariableSetup"
	populate(objectMap, "typeProperties", e.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableSetup.
func (e *EnvironmentVariableSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EnvironmentVariableSetupTypeProperties - Environment variable custom setup type properties.
type EnvironmentVariableSetupTypeProperties struct {
	// REQUIRED; The name of the environment variable.
	VariableName *string `json:"variableName,omitempty"`

	// REQUIRED; The value of the environment variable.
	VariableValue *string `json:"variableValue,omitempty"`
}

// ExcelDataset - Excel dataset.
type ExcelDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Excel dataset properties.
	TypeProperties *ExcelDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ExcelDataset.
func (e *ExcelDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 e.Type,
		Description:          e.Description,
		Structure:            e.Structure,
		Schema:               e.Schema,
		LinkedServiceName:    e.LinkedServiceName,
		Parameters:           e.Parameters,
		Annotations:          e.Annotations,
		Folder:               e.Folder,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExcelDataset.
func (e ExcelDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", e.Annotations)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "folder", e.Folder)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "parameters", e.Parameters)
	populate(objectMap, "schema", e.Schema)
	populate(objectMap, "structure", e.Structure)
	objectMap["type"] = "Excel"
	populate(objectMap, "typeProperties", e.TypeProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExcelDataset.
func (e *ExcelDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &e.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &e.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &e.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &e.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &e.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &e.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExcelDatasetTypeProperties - Excel dataset properties.
type ExcelDatasetTypeProperties struct {
	// REQUIRED; The location of the excel storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data compression method used for the json dataset.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the
	// first row of data. The default value is false. Type: boolean (or Expression
	// with resultType boolean).
	FirstRowAsHeader map[string]interface{} `json:"firstRowAsHeader,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue map[string]interface{} `json:"nullValue,omitempty"`

	// The partial data of one sheet. Type: string (or Expression with resultType string).
	Range map[string]interface{} `json:"range,omitempty"`

	// The sheet index of excel file and default value is 0. Type: integer (or Expression with resultType integer)
	SheetIndex map[string]interface{} `json:"sheetIndex,omitempty"`

	// The sheet name of excel file. Type: string (or Expression with resultType string).
	SheetName map[string]interface{} `json:"sheetName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExcelDatasetTypeProperties.
func (e ExcelDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", e.Compression)
	populate(objectMap, "firstRowAsHeader", e.FirstRowAsHeader)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "nullValue", e.NullValue)
	populate(objectMap, "range", e.Range)
	populate(objectMap, "sheetIndex", e.SheetIndex)
	populate(objectMap, "sheetName", e.SheetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExcelDatasetTypeProperties.
func (e *ExcelDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &e.Compression)
			delete(rawMsg, key)
		case "firstRowAsHeader":
			err = unpopulate(val, &e.FirstRowAsHeader)
			delete(rawMsg, key)
		case "location":
			e.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, &e.NullValue)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &e.Range)
			delete(rawMsg, key)
		case "sheetIndex":
			err = unpopulate(val, &e.SheetIndex)
			delete(rawMsg, key)
		case "sheetName":
			err = unpopulate(val, &e.SheetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExcelSource - A copy activity excel source.
type ExcelSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Excel store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ExcelSource.
func (e *ExcelSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     e.Type,
		SourceRetryCount:         e.SourceRetryCount,
		SourceRetryWait:          e.SourceRetryWait,
		MaxConcurrentConnections: e.MaxConcurrentConnections,
		DisableMetricsCollection: e.DisableMetricsCollection,
		AdditionalProperties:     e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExcelSource.
func (e ExcelSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", e.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", e.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", e.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", e.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", e.SourceRetryWait)
	populate(objectMap, "storeSettings", e.StoreSettings)
	objectMap["type"] = "ExcelSource"
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExcelSource.
func (e *ExcelSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &e.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &e.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &e.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &e.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &e.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			e.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExecuteDataFlowActivity - Execute data flow activity.
type ExecuteDataFlowActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Execute data flow activity properties.
	TypeProperties *ExecuteDataFlowActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ExecuteDataFlowActivity.
func (e *ExecuteDataFlowActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type ExecuteDataFlowActivity.
func (e *ExecuteDataFlowActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    e.LinkedServiceName,
		Policy:               e.Policy,
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteDataFlowActivity.
func (e ExecuteDataFlowActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "policy", e.Policy)
	objectMap["type"] = "ExecuteDataFlow"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteDataFlowActivity.
func (e *ExecuteDataFlowActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &e.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &e.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExecuteDataFlowActivityTypeProperties - Execute data flow activity properties.
type ExecuteDataFlowActivityTypeProperties struct {
	// REQUIRED; Data flow reference.
	DataFlow *DataFlowReference `json:"dataFlow,omitempty"`

	// Compute properties for data flow activity.
	Compute *ExecuteDataFlowActivityTypePropertiesCompute `json:"compute,omitempty"`

	// Continue on error setting used for data flow execution. Enables processing to continue if a sink fails. Type: boolean (or
	// Expression with resultType boolean)
	ContinueOnError map[string]interface{} `json:"continueOnError,omitempty"`

	// The integration runtime reference.
	IntegrationRuntime *IntegrationRuntimeReference `json:"integrationRuntime,omitempty"`

	// Concurrent run setting used for data flow execution. Allows sinks with the same save order to be processed concurrently.
	// Type: boolean (or Expression with resultType boolean)
	RunConcurrently map[string]interface{} `json:"runConcurrently,omitempty"`

	// Staging info for execute data flow activity.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`

	// Trace level setting used for data flow monitoring output. Supported values are: 'coarse', 'fine', and 'none'. Type: string
	// (or Expression with resultType string)
	TraceLevel map[string]interface{} `json:"traceLevel,omitempty"`
}

// ExecuteDataFlowActivityTypePropertiesCompute - Compute properties for data flow activity.
type ExecuteDataFlowActivityTypePropertiesCompute struct {
	// Compute type of the cluster which will execute data flow job. Possible values include: 'General', 'MemoryOptimized', 'ComputeOptimized'.
	// Type: string (or Expression with resultType string)
	ComputeType map[string]interface{} `json:"computeType,omitempty"`

	// Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272. Type:
	// integer (or Expression with resultType integer)
	CoreCount map[string]interface{} `json:"coreCount,omitempty"`
}

// ExecutePipelineActivity - Execute pipeline activity.
type ExecutePipelineActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Execute pipeline activity properties.
	TypeProperties *ExecutePipelineActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ExecutePipelineActivity.
func (e *ExecutePipelineActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type ExecutePipelineActivity.
func (e *ExecutePipelineActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivity.
func (e ExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "name", e.Name)
	objectMap["type"] = "ExecutePipeline"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePipelineActivity.
func (e *ExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExecutePipelineActivityTypeProperties - Execute pipeline activity properties.
type ExecutePipelineActivityTypeProperties struct {
	// REQUIRED; Pipeline reference.
	Pipeline *PipelineReference `json:"pipeline,omitempty"`

	// Pipeline parameters.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`

	// Defines whether activity execution will wait for the dependent pipeline execution to finish. Default is false.
	WaitOnCompletion *bool `json:"waitOnCompletion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivityTypeProperties.
func (e ExecutePipelineActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parameters", e.Parameters)
	populate(objectMap, "pipeline", e.Pipeline)
	populate(objectMap, "waitOnCompletion", e.WaitOnCompletion)
	return json.Marshal(objectMap)
}

// ExecutePowerQueryActivityTypeProperties - Execute power query data flow activity properties.
type ExecutePowerQueryActivityTypeProperties struct {
	// REQUIRED; Data flow reference.
	DataFlow *DataFlowReference `json:"dataFlow,omitempty"`

	// Compute properties for data flow activity.
	Compute *ExecuteDataFlowActivityTypePropertiesCompute `json:"compute,omitempty"`

	// Continue on error setting used for data flow execution. Enables processing to continue if a sink fails. Type: boolean (or
	// Expression with resultType boolean)
	ContinueOnError map[string]interface{} `json:"continueOnError,omitempty"`

	// The integration runtime reference.
	IntegrationRuntime *IntegrationRuntimeReference `json:"integrationRuntime,omitempty"`

	// List of mapping for Power Query mashup query to sink dataset(s).
	Queries []*PowerQuerySinkMapping `json:"queries,omitempty"`

	// Concurrent run setting used for data flow execution. Allows sinks with the same save order to be processed concurrently.
	// Type: boolean (or Expression with resultType boolean)
	RunConcurrently map[string]interface{} `json:"runConcurrently,omitempty"`

	// (Deprecated. Please use Queries). List of Power Query activity sinks mapped to a queryName.
	Sinks map[string]*PowerQuerySink `json:"sinks,omitempty"`

	// Staging info for execute data flow activity.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`

	// Trace level setting used for data flow monitoring output. Supported values are: 'coarse', 'fine', and 'none'. Type: string
	// (or Expression with resultType string)
	TraceLevel map[string]interface{} `json:"traceLevel,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePowerQueryActivityTypeProperties.
func (e ExecutePowerQueryActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compute", e.Compute)
	populate(objectMap, "continueOnError", e.ContinueOnError)
	populate(objectMap, "dataFlow", e.DataFlow)
	populate(objectMap, "integrationRuntime", e.IntegrationRuntime)
	populate(objectMap, "queries", e.Queries)
	populate(objectMap, "runConcurrently", e.RunConcurrently)
	populate(objectMap, "sinks", e.Sinks)
	populate(objectMap, "staging", e.Staging)
	populate(objectMap, "traceLevel", e.TraceLevel)
	return json.Marshal(objectMap)
}

// ExecuteSSISPackageActivity - Execute SSIS package activity.
type ExecuteSSISPackageActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Execute SSIS package activity properties.
	TypeProperties *ExecuteSSISPackageActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ExecuteSSISPackageActivity.
func (e *ExecuteSSISPackageActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type ExecuteSSISPackageActivity.
func (e *ExecuteSSISPackageActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    e.LinkedServiceName,
		Policy:               e.Policy,
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteSSISPackageActivity.
func (e ExecuteSSISPackageActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "policy", e.Policy)
	objectMap["type"] = "ExecuteSSISPackage"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteSSISPackageActivity.
func (e *ExecuteSSISPackageActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &e.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &e.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExecuteSSISPackageActivityTypeProperties - Execute SSIS package activity properties.
type ExecuteSSISPackageActivityTypeProperties struct {
	// REQUIRED; The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// REQUIRED; SSIS package location.
	PackageLocation *SSISPackageLocation `json:"packageLocation,omitempty"`

	// The environment path to execute the SSIS package. Type: string (or Expression with resultType string).
	EnvironmentPath map[string]interface{} `json:"environmentPath,omitempty"`

	// The package execution credential.
	ExecutionCredential *SSISExecutionCredential `json:"executionCredential,omitempty"`

	// SSIS package execution log location.
	LogLocation *SSISLogLocation `json:"logLocation,omitempty"`

	// The logging level of SSIS package execution. Type: string (or Expression with resultType string).
	LoggingLevel map[string]interface{} `json:"loggingLevel,omitempty"`

	// The package level connection managers to execute the SSIS package.
	PackageConnectionManagers map[string]map[string]*SSISExecutionParameter `json:"packageConnectionManagers,omitempty"`

	// The package level parameters to execute the SSIS package.
	PackageParameters map[string]*SSISExecutionParameter `json:"packageParameters,omitempty"`

	// The project level connection managers to execute the SSIS package.
	ProjectConnectionManagers map[string]map[string]*SSISExecutionParameter `json:"projectConnectionManagers,omitempty"`

	// The project level parameters to execute the SSIS package.
	ProjectParameters map[string]*SSISExecutionParameter `json:"projectParameters,omitempty"`

	// The property overrides to execute the SSIS package.
	PropertyOverrides map[string]*SSISPropertyOverride `json:"propertyOverrides,omitempty"`

	// Specifies the runtime to execute SSIS package. The value should be "x86" or "x64". Type: string (or Expression with resultType
	// string).
	Runtime map[string]interface{} `json:"runtime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteSSISPackageActivityTypeProperties.
func (e ExecuteSSISPackageActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectVia", e.ConnectVia)
	populate(objectMap, "environmentPath", e.EnvironmentPath)
	populate(objectMap, "executionCredential", e.ExecutionCredential)
	populate(objectMap, "logLocation", e.LogLocation)
	populate(objectMap, "loggingLevel", e.LoggingLevel)
	populate(objectMap, "packageConnectionManagers", e.PackageConnectionManagers)
	populate(objectMap, "packageLocation", e.PackageLocation)
	populate(objectMap, "packageParameters", e.PackageParameters)
	populate(objectMap, "projectConnectionManagers", e.ProjectConnectionManagers)
	populate(objectMap, "projectParameters", e.ProjectParameters)
	populate(objectMap, "propertyOverrides", e.PropertyOverrides)
	populate(objectMap, "runtime", e.Runtime)
	return json.Marshal(objectMap)
}

// ExecuteWranglingDataflowActivity - Execute power query activity.
type ExecuteWranglingDataflowActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Execute power query activity properties.
	TypeProperties *ExecutePowerQueryActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ExecuteWranglingDataflowActivity.
func (e *ExecuteWranglingDataflowActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteWranglingDataflowActivity.
func (e ExecuteWranglingDataflowActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "policy", e.Policy)
	objectMap["type"] = "ExecuteWranglingDataflow"
	populate(objectMap, "typeProperties", e.TypeProperties)
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteWranglingDataflowActivity.
func (e *ExecuteWranglingDataflowActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &e.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExecutionActivityClassification provides polymorphic access to related types.
// Call the interface's GetExecutionActivity() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureDataExplorerCommandActivity, *AzureFunctionActivity, *AzureMLBatchExecutionActivity, *AzureMLExecutePipelineActivity,
// - *AzureMLUpdateResourceActivity, *CopyActivity, *CustomActivity, *DataLakeAnalyticsUSQLActivity, *DatabricksNotebookActivity,
// - *DatabricksSparkJarActivity, *DatabricksSparkPythonActivity, *DeleteActivity, *ExecuteDataFlowActivity, *ExecuteSSISPackageActivity,
// - *ExecutionActivity, *GetMetadataActivity, *HDInsightHiveActivity, *HDInsightMapReduceActivity, *HDInsightPigActivity,
// - *HDInsightSparkActivity, *HDInsightStreamingActivity, *LookupActivity, *SQLServerStoredProcedureActivity, *WebActivity
type ExecutionActivityClassification interface {
	ActivityClassification
	// GetExecutionActivity returns the ExecutionActivity content of the underlying type.
	GetExecutionActivity() *ExecutionActivity
}

// ExecutionActivity - Base class for all execution activities.
type ExecutionActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ExecutionActivity.
func (e *ExecutionActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 e.Name,
		Type:                 e.Type,
		Description:          e.Description,
		DependsOn:            e.DependsOn,
		UserProperties:       e.UserProperties,
		AdditionalProperties: e.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type ExecutionActivity.
func (e *ExecutionActivity) GetExecutionActivity() *ExecutionActivity { return e }

// MarshalJSON implements the json.Marshaller interface for type ExecutionActivity.
func (e ExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", e.DependsOn)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "linkedServiceName", e.LinkedServiceName)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "policy", e.Policy)
	objectMap["type"] = "Execution"
	populate(objectMap, "userProperties", e.UserProperties)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutionActivity.
func (e *ExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &e.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &e.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &e.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &e.UserProperties)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExportSettingsClassification provides polymorphic access to related types.
// Call the interface's GetExportSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureDatabricksDeltaLakeExportCommand, *ExportSettings, *SnowflakeExportCopyCommand
type ExportSettingsClassification interface {
	// GetExportSettings returns the ExportSettings content of the underlying type.
	GetExportSettings() *ExportSettings
}

// ExportSettings - Export command settings.
type ExportSettings struct {
	// REQUIRED; The export setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetExportSettings implements the ExportSettingsClassification interface for type ExportSettings.
func (e *ExportSettings) GetExportSettings() *ExportSettings { return e }

// MarshalJSON implements the json.Marshaller interface for type ExportSettings.
func (e ExportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = e.Type
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportSettings.
func (e *ExportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExposureControlBatchRequest - A list of exposure control features.
type ExposureControlBatchRequest struct {
	// REQUIRED; List of exposure control features.
	ExposureControlRequests []*ExposureControlRequest `json:"exposureControlRequests,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExposureControlBatchRequest.
func (e ExposureControlBatchRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "exposureControlRequests", e.ExposureControlRequests)
	return json.Marshal(objectMap)
}

// ExposureControlBatchResponse - A list of exposure control feature values.
type ExposureControlBatchResponse struct {
	// REQUIRED; List of exposure control feature values.
	ExposureControlResponses []*ExposureControlResponse `json:"exposureControlResponses,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExposureControlBatchResponse.
func (e ExposureControlBatchResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "exposureControlResponses", e.ExposureControlResponses)
	return json.Marshal(objectMap)
}

// ExposureControlClientGetFeatureValueByFactoryOptions contains the optional parameters for the ExposureControlClient.GetFeatureValueByFactory
// method.
type ExposureControlClientGetFeatureValueByFactoryOptions struct {
	// placeholder for future optional parameters
}

// ExposureControlClientGetFeatureValueOptions contains the optional parameters for the ExposureControlClient.GetFeatureValue
// method.
type ExposureControlClientGetFeatureValueOptions struct {
	// placeholder for future optional parameters
}

// ExposureControlClientQueryFeatureValuesByFactoryOptions contains the optional parameters for the ExposureControlClient.QueryFeatureValuesByFactory
// method.
type ExposureControlClientQueryFeatureValuesByFactoryOptions struct {
	// placeholder for future optional parameters
}

// ExposureControlRequest - The exposure control request.
type ExposureControlRequest struct {
	// The feature name.
	FeatureName *string `json:"featureName,omitempty"`

	// The feature type.
	FeatureType *string `json:"featureType,omitempty"`
}

// ExposureControlResponse - The exposure control response.
type ExposureControlResponse struct {
	// READ-ONLY; The feature name.
	FeatureName *string `json:"featureName,omitempty" azure:"ro"`

	// READ-ONLY; The feature value.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// Expression - Azure Data Factory expression definition.
type Expression struct {
	// REQUIRED; Expression type.
	Type *ExpressionType `json:"type,omitempty"`

	// REQUIRED; Expression value.
	Value *string `json:"value,omitempty"`
}

// FactoriesClientConfigureFactoryRepoOptions contains the optional parameters for the FactoriesClient.ConfigureFactoryRepo
// method.
type FactoriesClientConfigureFactoryRepoOptions struct {
	// placeholder for future optional parameters
}

// FactoriesClientCreateOrUpdateOptions contains the optional parameters for the FactoriesClient.CreateOrUpdate method.
type FactoriesClientCreateOrUpdateOptions struct {
	// ETag of the factory entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// FactoriesClientDeleteOptions contains the optional parameters for the FactoriesClient.Delete method.
type FactoriesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// FactoriesClientGetDataPlaneAccessOptions contains the optional parameters for the FactoriesClient.GetDataPlaneAccess method.
type FactoriesClientGetDataPlaneAccessOptions struct {
	// placeholder for future optional parameters
}

// FactoriesClientGetGitHubAccessTokenOptions contains the optional parameters for the FactoriesClient.GetGitHubAccessToken
// method.
type FactoriesClientGetGitHubAccessTokenOptions struct {
	// placeholder for future optional parameters
}

// FactoriesClientGetOptions contains the optional parameters for the FactoriesClient.Get method.
type FactoriesClientGetOptions struct {
	// ETag of the factory entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// FactoriesClientListByResourceGroupOptions contains the optional parameters for the FactoriesClient.ListByResourceGroup
// method.
type FactoriesClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// FactoriesClientListOptions contains the optional parameters for the FactoriesClient.List method.
type FactoriesClientListOptions struct {
	// placeholder for future optional parameters
}

// FactoriesClientUpdateOptions contains the optional parameters for the FactoriesClient.Update method.
type FactoriesClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// Factory resource type.
type Factory struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Managed service identity of the factory.
	Identity *FactoryIdentity `json:"identity,omitempty"`

	// The resource location.
	Location *string `json:"location,omitempty"`

	// Properties of the factory.
	Properties *FactoryProperties `json:"properties,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Factory.
func (f Factory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", f.ETag)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "identity", f.Identity)
	populate(objectMap, "location", f.Location)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "tags", f.Tags)
	populate(objectMap, "type", f.Type)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Factory.
func (f *Factory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, &f.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &f.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &f.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &f.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &f.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FactoryGitHubConfiguration - Factory's GitHub repo information.
type FactoryGitHubConfiguration struct {
	// REQUIRED; Account name.
	AccountName *string `json:"accountName,omitempty"`

	// REQUIRED; Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// REQUIRED; Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// REQUIRED; Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// REQUIRED; Type of repo configuration.
	Type *string `json:"type,omitempty"`

	// GitHub bring your own app client id.
	ClientID *string `json:"clientId,omitempty"`

	// GitHub bring your own app client secret information.
	ClientSecret *GitHubClientSecret `json:"clientSecret,omitempty"`

	// GitHub Enterprise host name. For example: https://github.mydomain.com
	HostName *string `json:"hostName,omitempty"`

	// Last commit id.
	LastCommitID *string `json:"lastCommitId,omitempty"`
}

// GetFactoryRepoConfiguration implements the FactoryRepoConfigurationClassification interface for type FactoryGitHubConfiguration.
func (f *FactoryGitHubConfiguration) GetFactoryRepoConfiguration() *FactoryRepoConfiguration {
	return &FactoryRepoConfiguration{
		Type:                f.Type,
		AccountName:         f.AccountName,
		RepositoryName:      f.RepositoryName,
		CollaborationBranch: f.CollaborationBranch,
		RootFolder:          f.RootFolder,
		LastCommitID:        f.LastCommitID,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FactoryGitHubConfiguration.
func (f FactoryGitHubConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", f.AccountName)
	populate(objectMap, "clientId", f.ClientID)
	populate(objectMap, "clientSecret", f.ClientSecret)
	populate(objectMap, "collaborationBranch", f.CollaborationBranch)
	populate(objectMap, "hostName", f.HostName)
	populate(objectMap, "lastCommitId", f.LastCommitID)
	populate(objectMap, "repositoryName", f.RepositoryName)
	populate(objectMap, "rootFolder", f.RootFolder)
	objectMap["type"] = "FactoryGitHubConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryGitHubConfiguration.
func (f *FactoryGitHubConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &f.AccountName)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, &f.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			err = unpopulate(val, &f.ClientSecret)
			delete(rawMsg, key)
		case "collaborationBranch":
			err = unpopulate(val, &f.CollaborationBranch)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &f.HostName)
			delete(rawMsg, key)
		case "lastCommitId":
			err = unpopulate(val, &f.LastCommitID)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, &f.RepositoryName)
			delete(rawMsg, key)
		case "rootFolder":
			err = unpopulate(val, &f.RootFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FactoryIdentity - Identity properties of the factory resource.
type FactoryIdentity struct {
	// REQUIRED; The identity type.
	Type *FactoryIdentityType `json:"type,omitempty"`

	// List of user assigned identities for the factory.
	UserAssignedIdentities map[string]map[string]interface{} `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal id of the identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The client tenant id of the identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FactoryIdentity.
func (f FactoryIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", f.PrincipalID)
	populate(objectMap, "tenantId", f.TenantID)
	populate(objectMap, "type", f.Type)
	populate(objectMap, "userAssignedIdentities", f.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// FactoryListResponse - A list of factory resources.
type FactoryListResponse struct {
	// REQUIRED; List of factories.
	Value []*Factory `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FactoryListResponse.
func (f FactoryListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FactoryProperties - Factory resource properties.
type FactoryProperties struct {
	// Properties to enable Customer Managed Key for the factory.
	Encryption *EncryptionConfiguration `json:"encryption,omitempty"`

	// List of parameters for factory.
	GlobalParameters map[string]*GlobalParameterSpecification `json:"globalParameters,omitempty"`

	// Whether or not public network access is allowed for the data factory.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Git repo information of the factory.
	RepoConfiguration FactoryRepoConfigurationClassification `json:"repoConfiguration,omitempty"`

	// READ-ONLY; Time the factory was created in ISO8601 format.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; Factory provisioning state, example Succeeded.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Version of the factory.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FactoryProperties.
func (f FactoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createTime", f.CreateTime)
	populate(objectMap, "encryption", f.Encryption)
	populate(objectMap, "globalParameters", f.GlobalParameters)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", f.PublicNetworkAccess)
	populate(objectMap, "repoConfiguration", f.RepoConfiguration)
	populate(objectMap, "version", f.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryProperties.
func (f *FactoryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateTimeRFC3339(val, &f.CreateTime)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &f.Encryption)
			delete(rawMsg, key)
		case "globalParameters":
			err = unpopulate(val, &f.GlobalParameters)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &f.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &f.PublicNetworkAccess)
			delete(rawMsg, key)
		case "repoConfiguration":
			f.RepoConfiguration, err = unmarshalFactoryRepoConfigurationClassification(val)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &f.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FactoryRepoConfigurationClassification provides polymorphic access to related types.
// Call the interface's GetFactoryRepoConfiguration() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FactoryGitHubConfiguration, *FactoryRepoConfiguration, *FactoryVSTSConfiguration
type FactoryRepoConfigurationClassification interface {
	// GetFactoryRepoConfiguration returns the FactoryRepoConfiguration content of the underlying type.
	GetFactoryRepoConfiguration() *FactoryRepoConfiguration
}

// FactoryRepoConfiguration - Factory's git repo information.
type FactoryRepoConfiguration struct {
	// REQUIRED; Account name.
	AccountName *string `json:"accountName,omitempty"`

	// REQUIRED; Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// REQUIRED; Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// REQUIRED; Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// REQUIRED; Type of repo configuration.
	Type *string `json:"type,omitempty"`

	// Last commit id.
	LastCommitID *string `json:"lastCommitId,omitempty"`
}

// GetFactoryRepoConfiguration implements the FactoryRepoConfigurationClassification interface for type FactoryRepoConfiguration.
func (f *FactoryRepoConfiguration) GetFactoryRepoConfiguration() *FactoryRepoConfiguration { return f }

// FactoryRepoUpdate - Factory's git repo information.
type FactoryRepoUpdate struct {
	// The factory resource id.
	FactoryResourceID *string `json:"factoryResourceId,omitempty"`

	// Git repo information of the factory.
	RepoConfiguration FactoryRepoConfigurationClassification `json:"repoConfiguration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FactoryRepoUpdate.
func (f FactoryRepoUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "factoryResourceId", f.FactoryResourceID)
	populate(objectMap, "repoConfiguration", f.RepoConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryRepoUpdate.
func (f *FactoryRepoUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "factoryResourceId":
			err = unpopulate(val, &f.FactoryResourceID)
			delete(rawMsg, key)
		case "repoConfiguration":
			f.RepoConfiguration, err = unmarshalFactoryRepoConfigurationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FactoryUpdateParameters - Parameters for updating a factory resource.
type FactoryUpdateParameters struct {
	// Managed service identity of the factory.
	Identity *FactoryIdentity `json:"identity,omitempty"`

	// Whether or not public network access is allowed for the data factory.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FactoryUpdateParameters.
func (f FactoryUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", f.Identity)
	populate(objectMap, "publicNetworkAccess", f.PublicNetworkAccess)
	populate(objectMap, "tags", f.Tags)
	return json.Marshal(objectMap)
}

// FactoryVSTSConfiguration - Factory's VSTS repo information.
type FactoryVSTSConfiguration struct {
	// REQUIRED; Account name.
	AccountName *string `json:"accountName,omitempty"`

	// REQUIRED; Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// REQUIRED; VSTS project name.
	ProjectName *string `json:"projectName,omitempty"`

	// REQUIRED; Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// REQUIRED; Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// REQUIRED; Type of repo configuration.
	Type *string `json:"type,omitempty"`

	// Last commit id.
	LastCommitID *string `json:"lastCommitId,omitempty"`

	// VSTS tenant id.
	TenantID *string `json:"tenantId,omitempty"`
}

// GetFactoryRepoConfiguration implements the FactoryRepoConfigurationClassification interface for type FactoryVSTSConfiguration.
func (f *FactoryVSTSConfiguration) GetFactoryRepoConfiguration() *FactoryRepoConfiguration {
	return &FactoryRepoConfiguration{
		Type:                f.Type,
		AccountName:         f.AccountName,
		RepositoryName:      f.RepositoryName,
		CollaborationBranch: f.CollaborationBranch,
		RootFolder:          f.RootFolder,
		LastCommitID:        f.LastCommitID,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FactoryVSTSConfiguration.
func (f FactoryVSTSConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", f.AccountName)
	populate(objectMap, "collaborationBranch", f.CollaborationBranch)
	populate(objectMap, "lastCommitId", f.LastCommitID)
	populate(objectMap, "projectName", f.ProjectName)
	populate(objectMap, "repositoryName", f.RepositoryName)
	populate(objectMap, "rootFolder", f.RootFolder)
	populate(objectMap, "tenantId", f.TenantID)
	objectMap["type"] = "FactoryVSTSConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FactoryVSTSConfiguration.
func (f *FactoryVSTSConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, &f.AccountName)
			delete(rawMsg, key)
		case "collaborationBranch":
			err = unpopulate(val, &f.CollaborationBranch)
			delete(rawMsg, key)
		case "lastCommitId":
			err = unpopulate(val, &f.LastCommitID)
			delete(rawMsg, key)
		case "projectName":
			err = unpopulate(val, &f.ProjectName)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, &f.RepositoryName)
			delete(rawMsg, key)
		case "rootFolder":
			err = unpopulate(val, &f.RootFolder)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &f.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FailActivity - This activity will fail within its own scope and output a custom error message and error code. The error
// message and code can provided either as a string literal or as an expression that can be
// evaluated to a string at runtime. The activity scope can be the whole pipeline or a control activity (e.g. foreach, switch,
// until), if the fail activity is contained in it.
type FailActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Fail activity properties.
	TypeProperties *FailActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type FailActivity.
func (f *FailActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 f.Name,
		Type:                 f.Type,
		Description:          f.Description,
		DependsOn:            f.DependsOn,
		UserProperties:       f.UserProperties,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type FailActivity.
func (f *FailActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 f.Name,
		Type:                 f.Type,
		Description:          f.Description,
		DependsOn:            f.DependsOn,
		UserProperties:       f.UserProperties,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FailActivity.
func (f FailActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", f.DependsOn)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	objectMap["type"] = "Fail"
	populate(objectMap, "typeProperties", f.TypeProperties)
	populate(objectMap, "userProperties", f.UserProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FailActivity.
func (f *FailActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &f.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &f.UserProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FailActivityTypeProperties - Fail activity properties.
type FailActivityTypeProperties struct {
	// REQUIRED; The error code that categorizes the error type of the Fail activity. It can be dynamic content that's evaluated
	// to a non empty/blank string at runtime. Type: string (or Expression with resultType
	// string).
	ErrorCode map[string]interface{} `json:"errorCode,omitempty"`

	// REQUIRED; The error message that surfaced in the Fail activity. It can be dynamic content that's evaluated to a non empty/blank
	// string at runtime. Type: string (or Expression with resultType string).
	Message map[string]interface{} `json:"message,omitempty"`
}

// FileServerLinkedService - File system linked service.
type FileServerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; File system linked service properties.
	TypeProperties *FileServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type FileServerLinkedService.
func (f *FileServerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 f.Type,
		ConnectVia:           f.ConnectVia,
		Description:          f.Description,
		Parameters:           f.Parameters,
		Annotations:          f.Annotations,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLinkedService.
func (f FileServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "connectVia", f.ConnectVia)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "parameters", f.Parameters)
	objectMap["type"] = "FileServer"
	populate(objectMap, "typeProperties", f.TypeProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedService.
func (f *FileServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &f.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &f.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &f.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileServerLinkedServiceTypeProperties - File system linked service properties.
type FileServerLinkedServiceTypeProperties struct {
	// REQUIRED; Host name of the server. Type: string (or Expression with resultType string).
	Host map[string]interface{} `json:"host,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password to logon the server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User ID to logon the server. Type: string (or Expression with resultType string).
	UserID map[string]interface{} `json:"userId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLinkedServiceTypeProperties.
func (f FileServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", f.EncryptedCredential)
	populate(objectMap, "host", f.Host)
	populate(objectMap, "password", f.Password)
	populate(objectMap, "userId", f.UserID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedServiceTypeProperties.
func (f *FileServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &f.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &f.Host)
			delete(rawMsg, key)
		case "password":
			f.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userId":
			err = unpopulate(val, &f.UserID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileServerLocation - The location of file server dataset.
type FileServerLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type FileServerLocation.
func (f *FileServerLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 f.Type,
		FolderPath:           f.FolderPath,
		FileName:             f.FileName,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLocation.
func (f FileServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", f.FileName)
	populate(objectMap, "folderPath", f.FolderPath)
	objectMap["type"] = "FileServerLocation"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLocation.
func (f *FileServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &f.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &f.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileServerReadSettings - File server read settings.
type FileServerReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression
	// with resultType string).
	FileFilter map[string]interface{} `json:"fileFilter,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// FileServer wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// FileServer wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type FileServerReadSettings.
func (f *FileServerReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     f.Type,
		MaxConcurrentConnections: f.MaxConcurrentConnections,
		DisableMetricsCollection: f.DisableMetricsCollection,
		AdditionalProperties:     f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileServerReadSettings.
func (f FileServerReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", f.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", f.EnablePartitionDiscovery)
	populate(objectMap, "fileFilter", f.FileFilter)
	populate(objectMap, "fileListPath", f.FileListPath)
	populate(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", f.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", f.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", f.PartitionRootPath)
	populate(objectMap, "recursive", f.Recursive)
	objectMap["type"] = "FileServerReadSettings"
	populate(objectMap, "wildcardFileName", f.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", f.WildcardFolderPath)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerReadSettings.
func (f *FileServerReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &f.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &f.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileFilter":
			err = unpopulate(val, &f.FileFilter)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &f.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &f.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &f.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &f.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &f.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &f.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &f.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileServerWriteSettings - File server write settings.
type FileServerWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type FileServerWriteSettings.
func (f *FileServerWriteSettings) GetStoreWriteSettings() *StoreWriteSettings {
	return &StoreWriteSettings{
		Type:                     f.Type,
		MaxConcurrentConnections: f.MaxConcurrentConnections,
		DisableMetricsCollection: f.DisableMetricsCollection,
		CopyBehavior:             f.CopyBehavior,
		AdditionalProperties:     f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileServerWriteSettings.
func (f FileServerWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", f.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	objectMap["type"] = "FileServerWriteSettings"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerWriteSettings.
func (f *FileServerWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &f.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileShareDataset - An on-premises file system dataset.
type FileShareDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// On-premises file system dataset properties.
	TypeProperties *FileShareDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type FileShareDataset.
func (f *FileShareDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 f.Type,
		Description:          f.Description,
		Structure:            f.Structure,
		Schema:               f.Schema,
		LinkedServiceName:    f.LinkedServiceName,
		Parameters:           f.Parameters,
		Annotations:          f.Annotations,
		Folder:               f.Folder,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileShareDataset.
func (f FileShareDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "folder", f.Folder)
	populate(objectMap, "linkedServiceName", f.LinkedServiceName)
	populate(objectMap, "parameters", f.Parameters)
	populate(objectMap, "schema", f.Schema)
	populate(objectMap, "structure", f.Structure)
	objectMap["type"] = "FileShare"
	populate(objectMap, "typeProperties", f.TypeProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileShareDataset.
func (f *FileShareDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &f.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &f.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &f.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &f.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &f.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &f.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileShareDatasetTypeProperties - On-premises file system dataset properties.
type FileShareDatasetTypeProperties struct {
	// The data compression method used for the file system.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression
	// with resultType string).
	FileFilter map[string]interface{} `json:"fileFilter,omitempty"`

	// The name of the on-premises file system. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// The path of the on-premises file system. Type: string (or Expression with resultType string).
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// The format of the files.
	Format DatasetStorageFormatClassification `json:"format,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileShareDatasetTypeProperties.
func (f FileShareDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", f.Compression)
	populate(objectMap, "fileFilter", f.FileFilter)
	populate(objectMap, "fileName", f.FileName)
	populate(objectMap, "folderPath", f.FolderPath)
	populate(objectMap, "format", f.Format)
	populate(objectMap, "modifiedDatetimeEnd", f.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", f.ModifiedDatetimeStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileShareDatasetTypeProperties.
func (f *FileShareDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &f.Compression)
			delete(rawMsg, key)
		case "fileFilter":
			err = unpopulate(val, &f.FileFilter)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &f.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &f.FolderPath)
			delete(rawMsg, key)
		case "format":
			f.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &f.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &f.ModifiedDatetimeStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileSystemSink - A copy activity file system sink.
type FileSystemSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type FileSystemSink.
func (f *FileSystemSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     f.Type,
		WriteBatchSize:           f.WriteBatchSize,
		WriteBatchTimeout:        f.WriteBatchTimeout,
		SinkRetryCount:           f.SinkRetryCount,
		SinkRetryWait:            f.SinkRetryWait,
		MaxConcurrentConnections: f.MaxConcurrentConnections,
		DisableMetricsCollection: f.DisableMetricsCollection,
		AdditionalProperties:     f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemSink.
func (f FileSystemSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", f.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", f.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", f.SinkRetryWait)
	objectMap["type"] = "FileSystemSink"
	populate(objectMap, "writeBatchSize", f.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", f.WriteBatchTimeout)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemSink.
func (f *FileSystemSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &f.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &f.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &f.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &f.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &f.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileSystemSource - A copy activity file system source.
type FileSystemSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type FileSystemSource.
func (f *FileSystemSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     f.Type,
		SourceRetryCount:         f.SourceRetryCount,
		SourceRetryWait:          f.SourceRetryWait,
		MaxConcurrentConnections: f.MaxConcurrentConnections,
		DisableMetricsCollection: f.DisableMetricsCollection,
		AdditionalProperties:     f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemSource.
func (f FileSystemSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", f.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populate(objectMap, "recursive", f.Recursive)
	populate(objectMap, "sourceRetryCount", f.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", f.SourceRetryWait)
	objectMap["type"] = "FileSystemSource"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemSource.
func (f *FileSystemSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &f.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &f.Recursive)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &f.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &f.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FilterActivity - Filter and return results from input array based on the conditions.
type FilterActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Filter activity properties.
	TypeProperties *FilterActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type FilterActivity.
func (f *FilterActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 f.Name,
		Type:                 f.Type,
		Description:          f.Description,
		DependsOn:            f.DependsOn,
		UserProperties:       f.UserProperties,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type FilterActivity.
func (f *FilterActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 f.Name,
		Type:                 f.Type,
		Description:          f.Description,
		DependsOn:            f.DependsOn,
		UserProperties:       f.UserProperties,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FilterActivity.
func (f FilterActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", f.DependsOn)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	objectMap["type"] = "Filter"
	populate(objectMap, "typeProperties", f.TypeProperties)
	populate(objectMap, "userProperties", f.UserProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FilterActivity.
func (f *FilterActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &f.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &f.UserProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FilterActivityTypeProperties - Filter activity properties.
type FilterActivityTypeProperties struct {
	// REQUIRED; Condition to be used for filtering the input.
	Condition *Expression `json:"condition,omitempty"`

	// REQUIRED; Input array on which filter should be applied.
	Items *Expression `json:"items,omitempty"`
}

// Flowlet - Data flow flowlet
type Flowlet struct {
	// REQUIRED; Type of data flow.
	Type *string `json:"type,omitempty"`

	// List of tags that can be used for describing the data flow.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The description of the data flow.
	Description *string `json:"description,omitempty"`

	// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
	Folder *DataFlowFolder `json:"folder,omitempty"`

	// Flowlet type properties.
	TypeProperties *FlowletTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataFlow implements the DataFlowClassification interface for type Flowlet.
func (f *Flowlet) GetDataFlow() *DataFlow {
	return &DataFlow{
		Type:        f.Type,
		Description: f.Description,
		Annotations: f.Annotations,
		Folder:      f.Folder,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Flowlet.
func (f Flowlet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "folder", f.Folder)
	objectMap["type"] = "Flowlet"
	populate(objectMap, "typeProperties", f.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Flowlet.
func (f *Flowlet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &f.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &f.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FlowletTypeProperties - Flowlet type properties.
type FlowletTypeProperties struct {
	// Flowlet script.
	Script *string `json:"script,omitempty"`

	// Flowlet script lines.
	ScriptLines []*string `json:"scriptLines,omitempty"`

	// List of sinks in Flowlet.
	Sinks []*DataFlowSink `json:"sinks,omitempty"`

	// List of sources in Flowlet.
	Sources []*DataFlowSource `json:"sources,omitempty"`

	// List of transformations in Flowlet.
	Transformations []*Transformation `json:"transformations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FlowletTypeProperties.
func (f FlowletTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "script", f.Script)
	populate(objectMap, "scriptLines", f.ScriptLines)
	populate(objectMap, "sinks", f.Sinks)
	populate(objectMap, "sources", f.Sources)
	populate(objectMap, "transformations", f.Transformations)
	return json.Marshal(objectMap)
}

// ForEachActivity - This activity is used for iterating over a collection and execute given activities.
type ForEachActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; ForEach activity properties.
	TypeProperties *ForEachActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ForEachActivity.
func (f *ForEachActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 f.Name,
		Type:                 f.Type,
		Description:          f.Description,
		DependsOn:            f.DependsOn,
		UserProperties:       f.UserProperties,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type ForEachActivity.
func (f *ForEachActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 f.Name,
		Type:                 f.Type,
		Description:          f.Description,
		DependsOn:            f.DependsOn,
		UserProperties:       f.UserProperties,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ForEachActivity.
func (f ForEachActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", f.DependsOn)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	objectMap["type"] = "ForEach"
	populate(objectMap, "typeProperties", f.TypeProperties)
	populate(objectMap, "userProperties", f.UserProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivity.
func (f *ForEachActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &f.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &f.UserProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ForEachActivityTypeProperties - ForEach activity properties.
type ForEachActivityTypeProperties struct {
	// REQUIRED; List of activities to execute .
	Activities []ActivityClassification `json:"activities,omitempty"`

	// REQUIRED; Collection to iterate.
	Items *Expression `json:"items,omitempty"`

	// Batch count to be used for controlling the number of parallel execution (when isSequential is set to false).
	BatchCount *int32 `json:"batchCount,omitempty"`

	// Should the loop be executed in sequence or in parallel (max 50)
	IsSequential *bool `json:"isSequential,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ForEachActivityTypeProperties.
func (f ForEachActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activities", f.Activities)
	populate(objectMap, "batchCount", f.BatchCount)
	populate(objectMap, "isSequential", f.IsSequential)
	populate(objectMap, "items", f.Items)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivityTypeProperties.
func (f *ForEachActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			f.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "batchCount":
			err = unpopulate(val, &f.BatchCount)
			delete(rawMsg, key)
		case "isSequential":
			err = unpopulate(val, &f.IsSequential)
			delete(rawMsg, key)
		case "items":
			err = unpopulate(val, &f.Items)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FormatReadSettingsClassification provides polymorphic access to related types.
// Call the interface's GetFormatReadSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *BinaryReadSettings, *DelimitedTextReadSettings, *FormatReadSettings, *JSONReadSettings, *XMLReadSettings
type FormatReadSettingsClassification interface {
	// GetFormatReadSettings returns the FormatReadSettings content of the underlying type.
	GetFormatReadSettings() *FormatReadSettings
}

// FormatReadSettings - Format read settings.
type FormatReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetFormatReadSettings implements the FormatReadSettingsClassification interface for type FormatReadSettings.
func (f *FormatReadSettings) GetFormatReadSettings() *FormatReadSettings { return f }

// MarshalJSON implements the json.Marshaller interface for type FormatReadSettings.
func (f FormatReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = f.Type
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FormatReadSettings.
func (f *FormatReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FormatWriteSettingsClassification provides polymorphic access to related types.
// Call the interface's GetFormatWriteSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AvroWriteSettings, *DelimitedTextWriteSettings, *FormatWriteSettings, *JSONWriteSettings, *OrcWriteSettings, *ParquetWriteSettings
type FormatWriteSettingsClassification interface {
	// GetFormatWriteSettings returns the FormatWriteSettings content of the underlying type.
	GetFormatWriteSettings() *FormatWriteSettings
}

// FormatWriteSettings - Format write settings.
type FormatWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type FormatWriteSettings.
func (f *FormatWriteSettings) GetFormatWriteSettings() *FormatWriteSettings { return f }

// MarshalJSON implements the json.Marshaller interface for type FormatWriteSettings.
func (f FormatWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = f.Type
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FormatWriteSettings.
func (f *FormatWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FtpReadSettings - Ftp read settings.
type FtpReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable parallel reading within each file. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableChunking map[string]interface{} `json:"disableChunking,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Specify whether to use binary transfer mode for FTP stores.
	UseBinaryTransfer *bool `json:"useBinaryTransfer,omitempty"`

	// Ftp wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Ftp wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type FtpReadSettings.
func (f *FtpReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     f.Type,
		MaxConcurrentConnections: f.MaxConcurrentConnections,
		DisableMetricsCollection: f.DisableMetricsCollection,
		AdditionalProperties:     f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FtpReadSettings.
func (f FtpReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", f.DeleteFilesAfterCompletion)
	populate(objectMap, "disableChunking", f.DisableChunking)
	populate(objectMap, "disableMetricsCollection", f.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", f.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", f.FileListPath)
	populate(objectMap, "maxConcurrentConnections", f.MaxConcurrentConnections)
	populate(objectMap, "partitionRootPath", f.PartitionRootPath)
	populate(objectMap, "recursive", f.Recursive)
	objectMap["type"] = "FtpReadSettings"
	populate(objectMap, "useBinaryTransfer", f.UseBinaryTransfer)
	populate(objectMap, "wildcardFileName", f.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", f.WildcardFolderPath)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpReadSettings.
func (f *FtpReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &f.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableChunking":
			err = unpopulate(val, &f.DisableChunking)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &f.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &f.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &f.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &f.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &f.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &f.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "useBinaryTransfer":
			err = unpopulate(val, &f.UseBinaryTransfer)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &f.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &f.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FtpServerLinkedService - A FTP server Linked Service.
type FtpServerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this linked service type.
	TypeProperties *FtpServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type FtpServerLinkedService.
func (f *FtpServerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 f.Type,
		ConnectVia:           f.ConnectVia,
		Description:          f.Description,
		Parameters:           f.Parameters,
		Annotations:          f.Annotations,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLinkedService.
func (f FtpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", f.Annotations)
	populate(objectMap, "connectVia", f.ConnectVia)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "parameters", f.Parameters)
	objectMap["type"] = "FtpServer"
	populate(objectMap, "typeProperties", f.TypeProperties)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedService.
func (f *FtpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &f.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &f.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &f.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &f.TypeProperties)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FtpServerLinkedServiceTypeProperties - Properties specific to this linked service type.
type FtpServerLinkedServiceTypeProperties struct {
	// REQUIRED; Host name of the FTP server. Type: string (or Expression with resultType string).
	Host map[string]interface{} `json:"host,omitempty"`

	// The authentication type to be used to connect to the FTP server.
	AuthenticationType *FtpAuthenticationType `json:"authenticationType,omitempty"`

	// If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType
	// boolean).
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean
	// (or Expression with resultType boolean).
	EnableServerCertificateValidation map[string]interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password to logon the FTP server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression
	// with resultType integer), minimum: 0.
	Port map[string]interface{} `json:"port,omitempty"`

	// Username to logon the FTP server. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLinkedServiceTypeProperties.
func (f FtpServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", f.AuthenticationType)
	populate(objectMap, "enableSsl", f.EnableSSL)
	populate(objectMap, "enableServerCertificateValidation", f.EnableServerCertificateValidation)
	populate(objectMap, "encryptedCredential", f.EncryptedCredential)
	populate(objectMap, "host", f.Host)
	populate(objectMap, "password", f.Password)
	populate(objectMap, "port", f.Port)
	populate(objectMap, "userName", f.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedServiceTypeProperties.
func (f *FtpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &f.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &f.EnableSSL)
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			err = unpopulate(val, &f.EnableServerCertificateValidation)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &f.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &f.Host)
			delete(rawMsg, key)
		case "password":
			f.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &f.Port)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &f.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FtpServerLocation - The location of ftp server dataset.
type FtpServerLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type FtpServerLocation.
func (f *FtpServerLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 f.Type,
		FolderPath:           f.FolderPath,
		FileName:             f.FileName,
		AdditionalProperties: f.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLocation.
func (f FtpServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", f.FileName)
	populate(objectMap, "folderPath", f.FolderPath)
	objectMap["type"] = "FtpServerLocation"
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLocation.
func (f *FtpServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &f.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &f.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GenericDatasetTypeProperties - Properties specific to this dataset type.
type GenericDatasetTypeProperties struct {
	// The table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// GetDataFactoryOperationStatusResponse - Response body structure for get data factory operation status.
type GetDataFactoryOperationStatusResponse struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Status of the operation.
	Status *string `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetDataFactoryOperationStatusResponse.
func (g GetDataFactoryOperationStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "status", g.Status)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetDataFactoryOperationStatusResponse.
func (g *GetDataFactoryOperationStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, &g.Status)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetMetadataActivity - Activity to get metadata of dataset
type GetMetadataActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; GetMetadata activity properties.
	TypeProperties *GetMetadataActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type GetMetadataActivity.
func (g *GetMetadataActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 g.Name,
		Type:                 g.Type,
		Description:          g.Description,
		DependsOn:            g.DependsOn,
		UserProperties:       g.UserProperties,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type GetMetadataActivity.
func (g *GetMetadataActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    g.LinkedServiceName,
		Policy:               g.Policy,
		Name:                 g.Name,
		Type:                 g.Type,
		Description:          g.Description,
		DependsOn:            g.DependsOn,
		UserProperties:       g.UserProperties,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetMetadataActivity.
func (g GetMetadataActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", g.DependsOn)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "policy", g.Policy)
	objectMap["type"] = "GetMetadata"
	populate(objectMap, "typeProperties", g.TypeProperties)
	populate(objectMap, "userProperties", g.UserProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetMetadataActivity.
func (g *GetMetadataActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &g.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &g.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &g.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &g.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &g.UserProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetMetadataActivityTypeProperties - GetMetadata activity properties.
type GetMetadataActivityTypeProperties struct {
	// REQUIRED; GetMetadata activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Fields of metadata to get from dataset.
	FieldList []map[string]interface{} `json:"fieldList,omitempty"`

	// GetMetadata activity format settings.
	FormatSettings FormatReadSettingsClassification `json:"formatSettings,omitempty"`

	// GetMetadata activity store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetMetadataActivityTypeProperties.
func (g GetMetadataActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataset", g.Dataset)
	populate(objectMap, "fieldList", g.FieldList)
	populate(objectMap, "formatSettings", g.FormatSettings)
	populate(objectMap, "storeSettings", g.StoreSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetMetadataActivityTypeProperties.
func (g *GetMetadataActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, &g.Dataset)
			delete(rawMsg, key)
		case "fieldList":
			err = unpopulate(val, &g.FieldList)
			delete(rawMsg, key)
		case "formatSettings":
			g.FormatSettings, err = unmarshalFormatReadSettingsClassification(val)
			delete(rawMsg, key)
		case "storeSettings":
			g.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSsisObjectMetadataRequest - The request payload of get SSIS object metadata.
type GetSsisObjectMetadataRequest struct {
	// Metadata path.
	MetadataPath *string `json:"metadataPath,omitempty"`
}

// GitHubAccessTokenRequest - Get GitHub access token request definition.
type GitHubAccessTokenRequest struct {
	// REQUIRED; GitHub access code.
	GitHubAccessCode *string `json:"gitHubAccessCode,omitempty"`

	// REQUIRED; GitHub access token base URL.
	GitHubAccessTokenBaseURL *string `json:"gitHubAccessTokenBaseUrl,omitempty"`

	// GitHub application client ID.
	GitHubClientID *string `json:"gitHubClientId,omitempty"`

	// GitHub bring your own app client secret information.
	GitHubClientSecret *GitHubClientSecret `json:"gitHubClientSecret,omitempty"`
}

// GitHubAccessTokenResponse - Get GitHub access token response definition.
type GitHubAccessTokenResponse struct {
	// GitHub access token.
	GitHubAccessToken *string `json:"gitHubAccessToken,omitempty"`
}

// GitHubClientSecret - Client secret information for factory's bring your own app repository configuration.
type GitHubClientSecret struct {
	// Bring your own app client secret AKV URL.
	ByoaSecretAkvURL *string `json:"byoaSecretAkvUrl,omitempty"`

	// Bring your own app client secret name in AKV.
	ByoaSecretName *string `json:"byoaSecretName,omitempty"`
}

// GlobalParameterSpecification - Definition of a single parameter for an entity.
type GlobalParameterSpecification struct {
	// REQUIRED; Global Parameter type.
	Type *GlobalParameterType `json:"type,omitempty"`

	// REQUIRED; Value of parameter.
	Value map[string]interface{} `json:"value,omitempty"`
}

// GoogleAdWordsLinkedService - Google AdWords service linked service.
type GoogleAdWordsLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Google AdWords service linked service properties.
	TypeProperties *GoogleAdWordsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type GoogleAdWordsLinkedService.
func (g *GoogleAdWordsLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 g.Type,
		ConnectVia:           g.ConnectVia,
		Description:          g.Description,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsLinkedService.
func (g GoogleAdWordsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleAdWords"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedService.
func (g *GoogleAdWordsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleAdWordsLinkedServiceTypeProperties - Google AdWords service linked service properties.
type GoogleAdWordsLinkedServiceTypeProperties struct {
	// The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
	AuthenticationType *GoogleAdWordsAuthenticationType `json:"authenticationType,omitempty"`

	// The Client customer ID of the AdWords account that you want to fetch report data for.
	ClientCustomerID map[string]interface{} `json:"clientCustomerID,omitempty"`

	// The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType
	// string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The client secret of the google application used to acquire the refresh token.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// Properties used to connect to GoogleAds. It is mutually exclusive with any other properties in the linked service. Type:
	// object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The developer token associated with the manager account that you use to grant access to the AdWords API.
	DeveloperToken SecretBaseClassification `json:"developerToken,omitempty"`

	// The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
	Email map[string]interface{} `json:"email,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The full path to the .p12 key file that is used to authenticate the service account email address and can only be used
	// on self-hosted IR.
	KeyFilePath map[string]interface{} `json:"keyFilePath,omitempty"`

	// The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsLinkedServiceTypeProperties.
func (g GoogleAdWordsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", g.AuthenticationType)
	populate(objectMap, "clientCustomerID", g.ClientCustomerID)
	populate(objectMap, "clientId", g.ClientID)
	populate(objectMap, "clientSecret", g.ClientSecret)
	populate(objectMap, "connectionProperties", g.ConnectionProperties)
	populate(objectMap, "developerToken", g.DeveloperToken)
	populate(objectMap, "email", g.Email)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populate(objectMap, "keyFilePath", g.KeyFilePath)
	populate(objectMap, "refreshToken", g.RefreshToken)
	populate(objectMap, "trustedCertPath", g.TrustedCertPath)
	populate(objectMap, "useSystemTrustStore", g.UseSystemTrustStore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedServiceTypeProperties.
func (g *GoogleAdWordsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &g.AuthenticationType)
			delete(rawMsg, key)
		case "clientCustomerID":
			err = unpopulate(val, &g.ClientCustomerID)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, &g.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			g.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, &g.ConnectionProperties)
			delete(rawMsg, key)
		case "developerToken":
			g.DeveloperToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "email":
			err = unpopulate(val, &g.Email)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &g.EncryptedCredential)
			delete(rawMsg, key)
		case "keyFilePath":
			err = unpopulate(val, &g.KeyFilePath)
			delete(rawMsg, key)
		case "refreshToken":
			g.RefreshToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &g.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &g.UseSystemTrustStore)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleAdWordsObjectDataset - Google AdWords service dataset.
type GoogleAdWordsObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type GoogleAdWordsObjectDataset.
func (g *GoogleAdWordsObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 g.Type,
		Description:          g.Description,
		Structure:            g.Structure,
		Schema:               g.Schema,
		LinkedServiceName:    g.LinkedServiceName,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		Folder:               g.Folder,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsObjectDataset.
func (g GoogleAdWordsObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "folder", g.Folder)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "parameters", g.Parameters)
	populate(objectMap, "schema", g.Schema)
	populate(objectMap, "structure", g.Structure)
	objectMap["type"] = "GoogleAdWordsObject"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsObjectDataset.
func (g *GoogleAdWordsObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &g.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &g.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &g.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &g.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleAdWordsSource - A copy activity Google AdWords service source.
type GoogleAdWordsSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type GoogleAdWordsSource.
func (g *GoogleAdWordsSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     g.Type,
		SourceRetryCount:         g.SourceRetryCount,
		SourceRetryWait:          g.SourceRetryWait,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type GoogleAdWordsSource.
func (g *GoogleAdWordsSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             g.QueryTimeout,
		AdditionalColumns:        g.AdditionalColumns,
		Type:                     g.Type,
		SourceRetryCount:         g.SourceRetryCount,
		SourceRetryWait:          g.SourceRetryWait,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsSource.
func (g GoogleAdWordsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", g.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populate(objectMap, "query", g.Query)
	populate(objectMap, "queryTimeout", g.QueryTimeout)
	populate(objectMap, "sourceRetryCount", g.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", g.SourceRetryWait)
	objectMap["type"] = "GoogleAdWordsSource"
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsSource.
func (g *GoogleAdWordsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &g.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &g.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &g.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &g.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &g.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleBigQueryDatasetTypeProperties - Google BigQuery Dataset Properties
type GoogleBigQueryDatasetTypeProperties struct {
	// The database name of the Google BigQuery. Type: string (or Expression with resultType string).
	Dataset map[string]interface{} `json:"dataset,omitempty"`

	// The table name of the Google BigQuery. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using database + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// GoogleBigQueryLinkedService - Google BigQuery service linked service.
type GoogleBigQueryLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Google BigQuery service linked service properties.
	TypeProperties *GoogleBigQueryLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type GoogleBigQueryLinkedService.
func (g *GoogleBigQueryLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 g.Type,
		ConnectVia:           g.ConnectVia,
		Description:          g.Description,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryLinkedService.
func (g GoogleBigQueryLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleBigQuery"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedService.
func (g *GoogleBigQueryLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleBigQueryLinkedServiceTypeProperties - Google BigQuery service linked service properties.
type GoogleBigQueryLinkedServiceTypeProperties struct {
	// REQUIRED; The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted
	// IR.
	AuthenticationType *GoogleBigQueryAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The default BigQuery project to query against.
	Project map[string]interface{} `json:"project,omitempty"`

	// A comma-separated list of public BigQuery projects to access.
	AdditionalProjects map[string]interface{} `json:"additionalProjects,omitempty"`

	// The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType
	// string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The client secret of the google application used to acquire the refresh token.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
	Email map[string]interface{} `json:"email,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The full path to the .p12 key file that is used to authenticate the service account email address and can only be used
	// on self-hosted IR.
	KeyFilePath map[string]interface{} `json:"keyFilePath,omitempty"`

	// The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine
	// BigQuery data with data from Google Drive. The default value is false.
	RequestGoogleDriveScope map[string]interface{} `json:"requestGoogleDriveScope,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryLinkedServiceTypeProperties.
func (g GoogleBigQueryLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProjects", g.AdditionalProjects)
	populate(objectMap, "authenticationType", g.AuthenticationType)
	populate(objectMap, "clientId", g.ClientID)
	populate(objectMap, "clientSecret", g.ClientSecret)
	populate(objectMap, "email", g.Email)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populate(objectMap, "keyFilePath", g.KeyFilePath)
	populate(objectMap, "project", g.Project)
	populate(objectMap, "refreshToken", g.RefreshToken)
	populate(objectMap, "requestGoogleDriveScope", g.RequestGoogleDriveScope)
	populate(objectMap, "trustedCertPath", g.TrustedCertPath)
	populate(objectMap, "useSystemTrustStore", g.UseSystemTrustStore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedServiceTypeProperties.
func (g *GoogleBigQueryLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProjects":
			err = unpopulate(val, &g.AdditionalProjects)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &g.AuthenticationType)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, &g.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			g.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "email":
			err = unpopulate(val, &g.Email)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &g.EncryptedCredential)
			delete(rawMsg, key)
		case "keyFilePath":
			err = unpopulate(val, &g.KeyFilePath)
			delete(rawMsg, key)
		case "project":
			err = unpopulate(val, &g.Project)
			delete(rawMsg, key)
		case "refreshToken":
			g.RefreshToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "requestGoogleDriveScope":
			err = unpopulate(val, &g.RequestGoogleDriveScope)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &g.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &g.UseSystemTrustStore)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleBigQueryObjectDataset - Google BigQuery service dataset.
type GoogleBigQueryObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GoogleBigQueryDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type GoogleBigQueryObjectDataset.
func (g *GoogleBigQueryObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 g.Type,
		Description:          g.Description,
		Structure:            g.Structure,
		Schema:               g.Schema,
		LinkedServiceName:    g.LinkedServiceName,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		Folder:               g.Folder,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryObjectDataset.
func (g GoogleBigQueryObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "folder", g.Folder)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "parameters", g.Parameters)
	populate(objectMap, "schema", g.Schema)
	populate(objectMap, "structure", g.Structure)
	objectMap["type"] = "GoogleBigQueryObject"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryObjectDataset.
func (g *GoogleBigQueryObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &g.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &g.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &g.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &g.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleBigQuerySource - A copy activity Google BigQuery service source.
type GoogleBigQuerySource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type GoogleBigQuerySource.
func (g *GoogleBigQuerySource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     g.Type,
		SourceRetryCount:         g.SourceRetryCount,
		SourceRetryWait:          g.SourceRetryWait,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type GoogleBigQuerySource.
func (g *GoogleBigQuerySource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             g.QueryTimeout,
		AdditionalColumns:        g.AdditionalColumns,
		Type:                     g.Type,
		SourceRetryCount:         g.SourceRetryCount,
		SourceRetryWait:          g.SourceRetryWait,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQuerySource.
func (g GoogleBigQuerySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", g.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populate(objectMap, "query", g.Query)
	populate(objectMap, "queryTimeout", g.QueryTimeout)
	populate(objectMap, "sourceRetryCount", g.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", g.SourceRetryWait)
	objectMap["type"] = "GoogleBigQuerySource"
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQuerySource.
func (g *GoogleBigQuerySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &g.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &g.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &g.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &g.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &g.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleCloudStorageLinkedService - Linked service for Google Cloud Storage.
type GoogleCloudStorageLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Google Cloud Storage linked service properties.
	TypeProperties *GoogleCloudStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type GoogleCloudStorageLinkedService.
func (g *GoogleCloudStorageLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 g.Type,
		ConnectVia:           g.ConnectVia,
		Description:          g.Description,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLinkedService.
func (g GoogleCloudStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "GoogleCloudStorage"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedService.
func (g *GoogleCloudStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleCloudStorageLinkedServiceTypeProperties - Google Cloud Storage linked service properties.
type GoogleCloudStorageLinkedServiceTypeProperties struct {
	// The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression
	// with resultType string).
	AccessKeyID map[string]interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change
	// it only if you want to try a different service endpoint or want to switch
	// between https and http. Type: string (or Expression with resultType string).
	ServiceURL map[string]interface{} `json:"serviceUrl,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLinkedServiceTypeProperties.
func (g GoogleCloudStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessKeyId", g.AccessKeyID)
	populate(objectMap, "encryptedCredential", g.EncryptedCredential)
	populate(objectMap, "secretAccessKey", g.SecretAccessKey)
	populate(objectMap, "serviceUrl", g.ServiceURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedServiceTypeProperties.
func (g *GoogleCloudStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, &g.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &g.EncryptedCredential)
			delete(rawMsg, key)
		case "secretAccessKey":
			g.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, &g.ServiceURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleCloudStorageLocation - The location of Google Cloud Storage dataset.
type GoogleCloudStorageLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the bucketName of Google Cloud Storage. Type: string (or Expression with resultType string)
	BucketName map[string]interface{} `json:"bucketName,omitempty"`

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Specify the version of Google Cloud Storage. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type GoogleCloudStorageLocation.
func (g *GoogleCloudStorageLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 g.Type,
		FolderPath:           g.FolderPath,
		FileName:             g.FileName,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLocation.
func (g GoogleCloudStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bucketName", g.BucketName)
	populate(objectMap, "fileName", g.FileName)
	populate(objectMap, "folderPath", g.FolderPath)
	objectMap["type"] = "GoogleCloudStorageLocation"
	populate(objectMap, "version", g.Version)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLocation.
func (g *GoogleCloudStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, &g.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &g.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &g.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &g.Version)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GoogleCloudStorageReadSettings - Google Cloud Storage read settings.
type GoogleCloudStorageReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The prefix filter for the Google Cloud Storage object name. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Google Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Google Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type GoogleCloudStorageReadSettings.
func (g *GoogleCloudStorageReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     g.Type,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageReadSettings.
func (g GoogleCloudStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", g.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", g.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", g.FileListPath)
	populate(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", g.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", g.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", g.PartitionRootPath)
	populate(objectMap, "prefix", g.Prefix)
	populate(objectMap, "recursive", g.Recursive)
	objectMap["type"] = "GoogleCloudStorageReadSettings"
	populate(objectMap, "wildcardFileName", g.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", g.WildcardFolderPath)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageReadSettings.
func (g *GoogleCloudStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &g.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &g.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &g.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &g.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &g.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &g.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &g.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &g.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &g.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &g.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GreenplumDatasetTypeProperties - Greenplum Dataset Properties
type GreenplumDatasetTypeProperties struct {
	// The schema name of Greenplum. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of Greenplum. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// GreenplumLinkedService - Greenplum Database linked service.
type GreenplumLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Greenplum Database linked service properties.
	TypeProperties *GreenplumLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type GreenplumLinkedService.
func (g *GreenplumLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 g.Type,
		ConnectVia:           g.ConnectVia,
		Description:          g.Description,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumLinkedService.
func (g GreenplumLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "connectVia", g.ConnectVia)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "parameters", g.Parameters)
	objectMap["type"] = "Greenplum"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumLinkedService.
func (g *GreenplumLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &g.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GreenplumLinkedServiceTypeProperties - Greenplum Database linked service properties.
type GreenplumLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// GreenplumSource - A copy activity Greenplum Database source.
type GreenplumSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type GreenplumSource.
func (g *GreenplumSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     g.Type,
		SourceRetryCount:         g.SourceRetryCount,
		SourceRetryWait:          g.SourceRetryWait,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type GreenplumSource.
func (g *GreenplumSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             g.QueryTimeout,
		AdditionalColumns:        g.AdditionalColumns,
		Type:                     g.Type,
		SourceRetryCount:         g.SourceRetryCount,
		SourceRetryWait:          g.SourceRetryWait,
		MaxConcurrentConnections: g.MaxConcurrentConnections,
		DisableMetricsCollection: g.DisableMetricsCollection,
		AdditionalProperties:     g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumSource.
func (g GreenplumSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", g.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", g.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", g.MaxConcurrentConnections)
	populate(objectMap, "query", g.Query)
	populate(objectMap, "queryTimeout", g.QueryTimeout)
	populate(objectMap, "sourceRetryCount", g.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", g.SourceRetryWait)
	objectMap["type"] = "GreenplumSource"
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumSource.
func (g *GreenplumSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &g.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &g.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &g.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &g.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &g.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &g.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &g.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GreenplumTableDataset - Greenplum Database dataset.
type GreenplumTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GreenplumDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type GreenplumTableDataset.
func (g *GreenplumTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 g.Type,
		Description:          g.Description,
		Structure:            g.Structure,
		Schema:               g.Schema,
		LinkedServiceName:    g.LinkedServiceName,
		Parameters:           g.Parameters,
		Annotations:          g.Annotations,
		Folder:               g.Folder,
		AdditionalProperties: g.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumTableDataset.
func (g GreenplumTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", g.Annotations)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "folder", g.Folder)
	populate(objectMap, "linkedServiceName", g.LinkedServiceName)
	populate(objectMap, "parameters", g.Parameters)
	populate(objectMap, "schema", g.Schema)
	populate(objectMap, "structure", g.Structure)
	objectMap["type"] = "GreenplumTable"
	populate(objectMap, "typeProperties", g.TypeProperties)
	if g.AdditionalProperties != nil {
		for key, val := range g.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumTableDataset.
func (g *GreenplumTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &g.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &g.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &g.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &g.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &g.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &g.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &g.TypeProperties)
			delete(rawMsg, key)
		default:
			if g.AdditionalProperties == nil {
				g.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				g.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HBaseLinkedService - HBase server linked service.
type HBaseLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HBase server linked service properties.
	TypeProperties *HBaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HBaseLinkedService.
func (h *HBaseLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HBaseLinkedService.
func (h HBaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HBase"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedService.
func (h *HBaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HBaseLinkedServiceTypeProperties - HBase server linked service properties.
type HBaseLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication mechanism to use to connect to the HBase server.
	AuthenticationType *HBaseAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The IP address or host name of the HBase server. (i.e. 192.168.222.160)
	Host map[string]interface{} `json:"host,omitempty"`

	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCNMismatch map[string]interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
	HTTPPath map[string]interface{} `json:"httpPath,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
	Port map[string]interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// The user name used to connect to the HBase instance.
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HBaseLinkedServiceTypeProperties.
func (h HBaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowHostNameCNMismatch", h.AllowHostNameCNMismatch)
	populate(objectMap, "allowSelfSignedServerCert", h.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populate(objectMap, "enableSsl", h.EnableSSL)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "httpPath", h.HTTPPath)
	populate(objectMap, "host", h.Host)
	populate(objectMap, "password", h.Password)
	populate(objectMap, "port", h.Port)
	populate(objectMap, "trustedCertPath", h.TrustedCertPath)
	populate(objectMap, "username", h.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedServiceTypeProperties.
func (h *HBaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, &h.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &h.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &h.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &h.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, &h.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &h.Host)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &h.Port)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &h.TrustedCertPath)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &h.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HBaseObjectDataset - HBase server dataset.
type HBaseObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type HBaseObjectDataset.
func (h *HBaseObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 h.Type,
		Description:          h.Description,
		Structure:            h.Structure,
		Schema:               h.Schema,
		LinkedServiceName:    h.LinkedServiceName,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		Folder:               h.Folder,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HBaseObjectDataset.
func (h HBaseObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populate(objectMap, "schema", h.Schema)
	populate(objectMap, "structure", h.Structure)
	objectMap["type"] = "HBaseObject"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseObjectDataset.
func (h *HBaseObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HBaseSource - A copy activity HBase server source.
type HBaseSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type HBaseSource.
func (h *HBaseSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type HBaseSource.
func (h *HBaseSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             h.QueryTimeout,
		AdditionalColumns:        h.AdditionalColumns,
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HBaseSource.
func (h HBaseSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", h.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "query", h.Query)
	populate(objectMap, "queryTimeout", h.QueryTimeout)
	populate(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HBaseSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseSource.
func (h *HBaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &h.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &h.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &h.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightHiveActivity - HDInsight Hive activity type.
type HDInsightHiveActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight Hive activity properties.
	TypeProperties *HDInsightHiveActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type HDInsightHiveActivity.
func (h *HDInsightHiveActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type HDInsightHiveActivity.
func (h *HDInsightHiveActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    h.LinkedServiceName,
		Policy:               h.Policy,
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightHiveActivity.
func (h HDInsightHiveActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "policy", h.Policy)
	objectMap["type"] = "HDInsightHive"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightHiveActivity.
func (h *HDInsightHiveActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &h.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightHiveActivityTypeProperties - HDInsight Hive activity properties.
type HDInsightHiveActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments []map[string]interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for Hive job request.
	Defines map[string]map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Query timeout value (in minutes). Effective when the HDInsight cluster is with ESP (Enterprise Security Package)
	QueryTimeout *int32 `json:"queryTimeout,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Script path. Type: string (or Expression with resultType string).
	ScriptPath map[string]interface{} `json:"scriptPath,omitempty"`

	// Storage linked service references.
	StorageLinkedServices []*LinkedServiceReference `json:"storageLinkedServices,omitempty"`

	// User specified arguments under hivevar namespace.
	Variables []map[string]interface{} `json:"variables,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightHiveActivityTypeProperties.
func (h HDInsightHiveActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "queryTimeout", h.QueryTimeout)
	populate(objectMap, "scriptLinkedService", h.ScriptLinkedService)
	populate(objectMap, "scriptPath", h.ScriptPath)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	populate(objectMap, "variables", h.Variables)
	return json.Marshal(objectMap)
}

// HDInsightLinkedService - HDInsight linked service.
type HDInsightLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight linked service properties.
	TypeProperties *HDInsightLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HDInsightLinkedService.
func (h *HDInsightLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightLinkedService.
func (h HDInsightLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HDInsight"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightLinkedService.
func (h *HDInsightLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightLinkedServiceTypeProperties - HDInsight linked service properties.
type HDInsightLinkedServiceTypeProperties struct {
	// REQUIRED; HDInsight cluster URI. Type: string (or Expression with resultType string).
	ClusterURI map[string]interface{} `json:"clusterUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType
	// string).
	FileSystem map[string]interface{} `json:"fileSystem,omitempty"`

	// A reference to the Azure SQL linked service that points to the HCatalog database.
	HcatalogLinkedServiceName *LinkedServiceReference `json:"hcatalogLinkedServiceName,omitempty"`

	// Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
	IsEspEnabled map[string]interface{} `json:"isEspEnabled,omitempty"`

	// The Azure Storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// HDInsight cluster password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// HDInsight cluster user name. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightLinkedServiceTypeProperties.
func (h HDInsightLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterUri", h.ClusterURI)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "fileSystem", h.FileSystem)
	populate(objectMap, "hcatalogLinkedServiceName", h.HcatalogLinkedServiceName)
	populate(objectMap, "isEspEnabled", h.IsEspEnabled)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "password", h.Password)
	populate(objectMap, "userName", h.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightLinkedServiceTypeProperties.
func (h *HDInsightLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterUri":
			err = unpopulate(val, &h.ClusterURI)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "fileSystem":
			err = unpopulate(val, &h.FileSystem)
			delete(rawMsg, key)
		case "hcatalogLinkedServiceName":
			err = unpopulate(val, &h.HcatalogLinkedServiceName)
			delete(rawMsg, key)
		case "isEspEnabled":
			err = unpopulate(val, &h.IsEspEnabled)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &h.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightMapReduceActivity - HDInsight MapReduce activity type.
type HDInsightMapReduceActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight MapReduce activity properties.
	TypeProperties *HDInsightMapReduceActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type HDInsightMapReduceActivity.
func (h *HDInsightMapReduceActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type HDInsightMapReduceActivity.
func (h *HDInsightMapReduceActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    h.LinkedServiceName,
		Policy:               h.Policy,
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightMapReduceActivity.
func (h HDInsightMapReduceActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "policy", h.Policy)
	objectMap["type"] = "HDInsightMapReduce"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightMapReduceActivity.
func (h *HDInsightMapReduceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &h.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightMapReduceActivityTypeProperties - HDInsight MapReduce activity properties.
type HDInsightMapReduceActivityTypeProperties struct {
	// REQUIRED; Class name. Type: string (or Expression with resultType string).
	ClassName map[string]interface{} `json:"className,omitempty"`

	// REQUIRED; Jar path. Type: string (or Expression with resultType string).
	JarFilePath map[string]interface{} `json:"jarFilePath,omitempty"`

	// User specified arguments to HDInsightActivity.
	Arguments []map[string]interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for the MapReduce job request.
	Defines map[string]map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Jar libs.
	JarLibs []map[string]interface{} `json:"jarLibs,omitempty"`

	// Jar linked service reference.
	JarLinkedService *LinkedServiceReference `json:"jarLinkedService,omitempty"`

	// Storage linked service references.
	StorageLinkedServices []*LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightMapReduceActivityTypeProperties.
func (h HDInsightMapReduceActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "className", h.ClassName)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "jarFilePath", h.JarFilePath)
	populate(objectMap, "jarLibs", h.JarLibs)
	populate(objectMap, "jarLinkedService", h.JarLinkedService)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	return json.Marshal(objectMap)
}

// HDInsightOnDemandLinkedService - HDInsight ondemand linked service.
type HDInsightOnDemandLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight ondemand linked service properties.
	TypeProperties *HDInsightOnDemandLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HDInsightOnDemandLinkedService.
func (h *HDInsightOnDemandLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightOnDemandLinkedService.
func (h HDInsightOnDemandLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HDInsightOnDemand"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightOnDemandLinkedService.
func (h *HDInsightOnDemandLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightOnDemandLinkedServiceTypeProperties - HDInsight ondemand linked service properties.
type HDInsightOnDemandLinkedServiceTypeProperties struct {
	// REQUIRED; The resource group where the cluster belongs. Type: string (or Expression with resultType string).
	ClusterResourceGroup map[string]interface{} `json:"clusterResourceGroup,omitempty"`

	// REQUIRED; Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType
	// string).
	ClusterSize map[string]interface{} `json:"clusterSize,omitempty"`

	// REQUIRED; The customers subscription to host the cluster. Type: string (or Expression with resultType string).
	HostSubscriptionID map[string]interface{} `json:"hostSubscriptionId,omitempty"`

	// REQUIRED; Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`

	// REQUIRED; The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster
	// stays alive after completion of an activity run if there are no other active jobs in the
	// cluster. The minimum value is 5 mins. Type: string (or Expression with resultType string).
	TimeToLive map[string]interface{} `json:"timeToLive,omitempty"`

	// REQUIRED; Version of the HDInsight cluster. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`

	// Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them
	// on your behalf.
	AdditionalLinkedServiceNames []*LinkedServiceReference `json:"additionalLinkedServiceNames,omitempty"`

	// The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
	ClusterNamePrefix map[string]interface{} `json:"clusterNamePrefix,omitempty"`

	// The password to access the cluster.
	ClusterPassword SecretBaseClassification `json:"clusterPassword,omitempty"`

	// The password to SSH remotely connect clusters node (for Linux).
	ClusterSSHPassword SecretBaseClassification `json:"clusterSshPassword,omitempty"`

	// The username to SSH remotely connect to clusters node (for Linux). Type: string (or Expression with resultType string).
	ClusterSSHUserName map[string]interface{} `json:"clusterSshUserName,omitempty"`

	// The cluster type. Type: string (or Expression with resultType string).
	ClusterType map[string]interface{} `json:"clusterType,omitempty"`

	// The username to access the cluster. Type: string (or Expression with resultType string).
	ClusterUserName map[string]interface{} `json:"clusterUserName,omitempty"`

	// Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
	CoreConfiguration map[string]interface{} `json:"coreConfiguration,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// Specifies the size of the data node for the HDInsight cluster.
	DataNodeSize map[string]interface{} `json:"dataNodeSize,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
	HBaseConfiguration map[string]interface{} `json:"hBaseConfiguration,omitempty"`

	// The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by
	// using the Azure SQL database as the metastore.
	HcatalogLinkedServiceName *LinkedServiceReference `json:"hcatalogLinkedServiceName,omitempty"`

	// Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
	HdfsConfiguration map[string]interface{} `json:"hdfsConfiguration,omitempty"`

	// Specifies the size of the head node for the HDInsight cluster.
	HeadNodeSize map[string]interface{} `json:"headNodeSize,omitempty"`

	// Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
	HiveConfiguration map[string]interface{} `json:"hiveConfiguration,omitempty"`

	// Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
	MapReduceConfiguration map[string]interface{} `json:"mapReduceConfiguration,omitempty"`

	// Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
	OozieConfiguration map[string]interface{} `json:"oozieConfiguration,omitempty"`

	// Custom script actions to run on HDI ondemand cluster once it's up. Please refer to
	// https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
	ScriptActions []*ScriptAction `json:"scriptActions,omitempty"`

	// The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key for the service principal id.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
	SparkVersion map[string]interface{} `json:"sparkVersion,omitempty"`

	// Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
	StormConfiguration map[string]interface{} `json:"stormConfiguration,omitempty"`

	// The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type:
	// string (or Expression with resultType string).
	SubnetName map[string]interface{} `json:"subnetName,omitempty"`

	// The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with
	// resultType string).
	VirtualNetworkID map[string]interface{} `json:"virtualNetworkId,omitempty"`

	// Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
	YarnConfiguration map[string]interface{} `json:"yarnConfiguration,omitempty"`

	// Specifies the size of the Zoo Keeper node for the HDInsight cluster.
	ZookeeperNodeSize map[string]interface{} `json:"zookeeperNodeSize,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightOnDemandLinkedServiceTypeProperties.
func (h HDInsightOnDemandLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalLinkedServiceNames", h.AdditionalLinkedServiceNames)
	populate(objectMap, "clusterNamePrefix", h.ClusterNamePrefix)
	populate(objectMap, "clusterPassword", h.ClusterPassword)
	populate(objectMap, "clusterResourceGroup", h.ClusterResourceGroup)
	populate(objectMap, "clusterSshPassword", h.ClusterSSHPassword)
	populate(objectMap, "clusterSshUserName", h.ClusterSSHUserName)
	populate(objectMap, "clusterSize", h.ClusterSize)
	populate(objectMap, "clusterType", h.ClusterType)
	populate(objectMap, "clusterUserName", h.ClusterUserName)
	populate(objectMap, "coreConfiguration", h.CoreConfiguration)
	populate(objectMap, "credential", h.Credential)
	populate(objectMap, "dataNodeSize", h.DataNodeSize)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "hBaseConfiguration", h.HBaseConfiguration)
	populate(objectMap, "hcatalogLinkedServiceName", h.HcatalogLinkedServiceName)
	populate(objectMap, "hdfsConfiguration", h.HdfsConfiguration)
	populate(objectMap, "headNodeSize", h.HeadNodeSize)
	populate(objectMap, "hiveConfiguration", h.HiveConfiguration)
	populate(objectMap, "hostSubscriptionId", h.HostSubscriptionID)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "mapReduceConfiguration", h.MapReduceConfiguration)
	populate(objectMap, "oozieConfiguration", h.OozieConfiguration)
	populate(objectMap, "scriptActions", h.ScriptActions)
	populate(objectMap, "servicePrincipalId", h.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", h.ServicePrincipalKey)
	populate(objectMap, "sparkVersion", h.SparkVersion)
	populate(objectMap, "stormConfiguration", h.StormConfiguration)
	populate(objectMap, "subnetName", h.SubnetName)
	populate(objectMap, "tenant", h.Tenant)
	populate(objectMap, "timeToLive", h.TimeToLive)
	populate(objectMap, "version", h.Version)
	populate(objectMap, "virtualNetworkId", h.VirtualNetworkID)
	populate(objectMap, "yarnConfiguration", h.YarnConfiguration)
	populate(objectMap, "zookeeperNodeSize", h.ZookeeperNodeSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightOnDemandLinkedServiceTypeProperties.
func (h *HDInsightOnDemandLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalLinkedServiceNames":
			err = unpopulate(val, &h.AdditionalLinkedServiceNames)
			delete(rawMsg, key)
		case "clusterNamePrefix":
			err = unpopulate(val, &h.ClusterNamePrefix)
			delete(rawMsg, key)
		case "clusterPassword":
			h.ClusterPassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clusterResourceGroup":
			err = unpopulate(val, &h.ClusterResourceGroup)
			delete(rawMsg, key)
		case "clusterSshPassword":
			h.ClusterSSHPassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clusterSshUserName":
			err = unpopulate(val, &h.ClusterSSHUserName)
			delete(rawMsg, key)
		case "clusterSize":
			err = unpopulate(val, &h.ClusterSize)
			delete(rawMsg, key)
		case "clusterType":
			err = unpopulate(val, &h.ClusterType)
			delete(rawMsg, key)
		case "clusterUserName":
			err = unpopulate(val, &h.ClusterUserName)
			delete(rawMsg, key)
		case "coreConfiguration":
			err = unpopulate(val, &h.CoreConfiguration)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &h.Credential)
			delete(rawMsg, key)
		case "dataNodeSize":
			err = unpopulate(val, &h.DataNodeSize)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "hBaseConfiguration":
			err = unpopulate(val, &h.HBaseConfiguration)
			delete(rawMsg, key)
		case "hcatalogLinkedServiceName":
			err = unpopulate(val, &h.HcatalogLinkedServiceName)
			delete(rawMsg, key)
		case "hdfsConfiguration":
			err = unpopulate(val, &h.HdfsConfiguration)
			delete(rawMsg, key)
		case "headNodeSize":
			err = unpopulate(val, &h.HeadNodeSize)
			delete(rawMsg, key)
		case "hiveConfiguration":
			err = unpopulate(val, &h.HiveConfiguration)
			delete(rawMsg, key)
		case "hostSubscriptionId":
			err = unpopulate(val, &h.HostSubscriptionID)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "mapReduceConfiguration":
			err = unpopulate(val, &h.MapReduceConfiguration)
			delete(rawMsg, key)
		case "oozieConfiguration":
			err = unpopulate(val, &h.OozieConfiguration)
			delete(rawMsg, key)
		case "scriptActions":
			err = unpopulate(val, &h.ScriptActions)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &h.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			h.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "sparkVersion":
			err = unpopulate(val, &h.SparkVersion)
			delete(rawMsg, key)
		case "stormConfiguration":
			err = unpopulate(val, &h.StormConfiguration)
			delete(rawMsg, key)
		case "subnetName":
			err = unpopulate(val, &h.SubnetName)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &h.Tenant)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, &h.TimeToLive)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &h.Version)
			delete(rawMsg, key)
		case "virtualNetworkId":
			err = unpopulate(val, &h.VirtualNetworkID)
			delete(rawMsg, key)
		case "yarnConfiguration":
			err = unpopulate(val, &h.YarnConfiguration)
			delete(rawMsg, key)
		case "zookeeperNodeSize":
			err = unpopulate(val, &h.ZookeeperNodeSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightPigActivity - HDInsight Pig activity type.
type HDInsightPigActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight Pig activity properties.
	TypeProperties *HDInsightPigActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type HDInsightPigActivity.
func (h *HDInsightPigActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type HDInsightPigActivity.
func (h *HDInsightPigActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    h.LinkedServiceName,
		Policy:               h.Policy,
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightPigActivity.
func (h HDInsightPigActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "policy", h.Policy)
	objectMap["type"] = "HDInsightPig"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightPigActivity.
func (h *HDInsightPigActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &h.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightPigActivityTypeProperties - HDInsight Pig activity properties.
type HDInsightPigActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity. Type: array (or Expression with resultType array).
	Arguments map[string]interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for Pig job request.
	Defines map[string]map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Script path. Type: string (or Expression with resultType string).
	ScriptPath map[string]interface{} `json:"scriptPath,omitempty"`

	// Storage linked service references.
	StorageLinkedServices []*LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightPigActivityTypeProperties.
func (h HDInsightPigActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "scriptLinkedService", h.ScriptLinkedService)
	populate(objectMap, "scriptPath", h.ScriptPath)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	return json.Marshal(objectMap)
}

// HDInsightSparkActivity - HDInsight Spark activity.
type HDInsightSparkActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight spark activity properties.
	TypeProperties *HDInsightSparkActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type HDInsightSparkActivity.
func (h *HDInsightSparkActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type HDInsightSparkActivity.
func (h *HDInsightSparkActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    h.LinkedServiceName,
		Policy:               h.Policy,
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightSparkActivity.
func (h HDInsightSparkActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "policy", h.Policy)
	objectMap["type"] = "HDInsightSpark"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightSparkActivity.
func (h *HDInsightSparkActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &h.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightSparkActivityTypeProperties - HDInsight spark activity properties.
type HDInsightSparkActivityTypeProperties struct {
	// REQUIRED; The relative path to the root folder of the code/package to be executed. Type: string (or Expression with resultType
	// string).
	EntryFilePath map[string]interface{} `json:"entryFilePath,omitempty"`

	// REQUIRED; The root path in 'sparkJobLinkedService' for all the jobs files. Type: string (or Expression with resultType
	// string).
	RootPath map[string]interface{} `json:"rootPath,omitempty"`

	// The user-specified arguments to HDInsightSparkActivity.
	Arguments []map[string]interface{} `json:"arguments,omitempty"`

	// The application's Java/Spark main class.
	ClassName *string `json:"className,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// The user to impersonate that will execute the job. Type: string (or Expression with resultType string).
	ProxyUser map[string]interface{} `json:"proxyUser,omitempty"`

	// Spark configuration property.
	SparkConfig map[string]map[string]interface{} `json:"sparkConfig,omitempty"`

	// The storage linked service for uploading the entry file and dependencies, and for receiving logs.
	SparkJobLinkedService *LinkedServiceReference `json:"sparkJobLinkedService,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightSparkActivityTypeProperties.
func (h HDInsightSparkActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "className", h.ClassName)
	populate(objectMap, "entryFilePath", h.EntryFilePath)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "proxyUser", h.ProxyUser)
	populate(objectMap, "rootPath", h.RootPath)
	populate(objectMap, "sparkConfig", h.SparkConfig)
	populate(objectMap, "sparkJobLinkedService", h.SparkJobLinkedService)
	return json.Marshal(objectMap)
}

// HDInsightStreamingActivity - HDInsight streaming activity type.
type HDInsightStreamingActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDInsight streaming activity properties.
	TypeProperties *HDInsightStreamingActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type HDInsightStreamingActivity.
func (h *HDInsightStreamingActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type HDInsightStreamingActivity.
func (h *HDInsightStreamingActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    h.LinkedServiceName,
		Policy:               h.Policy,
		Name:                 h.Name,
		Type:                 h.Type,
		Description:          h.Description,
		DependsOn:            h.DependsOn,
		UserProperties:       h.UserProperties,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightStreamingActivity.
func (h HDInsightStreamingActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", h.DependsOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "policy", h.Policy)
	objectMap["type"] = "HDInsightStreaming"
	populate(objectMap, "typeProperties", h.TypeProperties)
	populate(objectMap, "userProperties", h.UserProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsightStreamingActivity.
func (h *HDInsightStreamingActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &h.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &h.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &h.UserProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsightStreamingActivityTypeProperties - HDInsight streaming activity properties.
type HDInsightStreamingActivityTypeProperties struct {
	// REQUIRED; Paths to streaming job files. Can be directories.
	FilePaths []map[string]interface{} `json:"filePaths,omitempty"`

	// REQUIRED; Input blob path. Type: string (or Expression with resultType string).
	Input map[string]interface{} `json:"input,omitempty"`

	// REQUIRED; Mapper executable name. Type: string (or Expression with resultType string).
	Mapper map[string]interface{} `json:"mapper,omitempty"`

	// REQUIRED; Output blob path. Type: string (or Expression with resultType string).
	Output map[string]interface{} `json:"output,omitempty"`

	// REQUIRED; Reducer executable name. Type: string (or Expression with resultType string).
	Reducer map[string]interface{} `json:"reducer,omitempty"`

	// User specified arguments to HDInsightActivity.
	Arguments []map[string]interface{} `json:"arguments,omitempty"`

	// Combiner executable name. Type: string (or Expression with resultType string).
	Combiner map[string]interface{} `json:"combiner,omitempty"`

	// Command line environment values.
	CommandEnvironment []map[string]interface{} `json:"commandEnvironment,omitempty"`

	// Allows user to specify defines for streaming job request.
	Defines map[string]map[string]interface{} `json:"defines,omitempty"`

	// Linked service reference where the files are located.
	FileLinkedService *LinkedServiceReference `json:"fileLinkedService,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Storage linked service references.
	StorageLinkedServices []*LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsightStreamingActivityTypeProperties.
func (h HDInsightStreamingActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arguments", h.Arguments)
	populate(objectMap, "combiner", h.Combiner)
	populate(objectMap, "commandEnvironment", h.CommandEnvironment)
	populate(objectMap, "defines", h.Defines)
	populate(objectMap, "fileLinkedService", h.FileLinkedService)
	populate(objectMap, "filePaths", h.FilePaths)
	populate(objectMap, "getDebugInfo", h.GetDebugInfo)
	populate(objectMap, "input", h.Input)
	populate(objectMap, "mapper", h.Mapper)
	populate(objectMap, "output", h.Output)
	populate(objectMap, "reducer", h.Reducer)
	populate(objectMap, "storageLinkedServices", h.StorageLinkedServices)
	return json.Marshal(objectMap)
}

// HTTPDataset - A file in an HTTP web server.
type HTTPDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *HTTPDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type HTTPDataset.
func (h *HTTPDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 h.Type,
		Description:          h.Description,
		Structure:            h.Structure,
		Schema:               h.Schema,
		LinkedServiceName:    h.LinkedServiceName,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		Folder:               h.Folder,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HTTPDataset.
func (h HTTPDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populate(objectMap, "schema", h.Schema)
	populate(objectMap, "structure", h.Structure)
	objectMap["type"] = "HttpFile"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPDataset.
func (h *HTTPDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPDatasetTypeProperties - Properties specific to this dataset type.
type HTTPDatasetTypeProperties struct {
	// The headers for the HTTP Request. e.g. request-header-name-1:request-header-value-1  request-header-name-n:request-header-value-n
	// Type: string (or Expression with resultType string).
	AdditionalHeaders map[string]interface{} `json:"additionalHeaders,omitempty"`

	// The data compression method used on files.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The format of files.
	Format DatasetStorageFormatClassification `json:"format,omitempty"`

	// The relative URL based on the URL in the HttpLinkedService refers to an HTTP file Type: string (or Expression with resultType
	// string).
	RelativeURL map[string]interface{} `json:"relativeUrl,omitempty"`

	// The body for the HTTP request. Type: string (or Expression with resultType string).
	RequestBody map[string]interface{} `json:"requestBody,omitempty"`

	// The HTTP method for the HTTP request. Type: string (or Expression with resultType string).
	RequestMethod map[string]interface{} `json:"requestMethod,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPDatasetTypeProperties.
func (h HTTPDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalHeaders", h.AdditionalHeaders)
	populate(objectMap, "compression", h.Compression)
	populate(objectMap, "format", h.Format)
	populate(objectMap, "relativeUrl", h.RelativeURL)
	populate(objectMap, "requestBody", h.RequestBody)
	populate(objectMap, "requestMethod", h.RequestMethod)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPDatasetTypeProperties.
func (h *HTTPDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			err = unpopulate(val, &h.AdditionalHeaders)
			delete(rawMsg, key)
		case "compression":
			err = unpopulate(val, &h.Compression)
			delete(rawMsg, key)
		case "format":
			h.Format, err = unmarshalDatasetStorageFormatClassification(val)
			delete(rawMsg, key)
		case "relativeUrl":
			err = unpopulate(val, &h.RelativeURL)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, &h.RequestBody)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, &h.RequestMethod)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPLinkedService - Linked service for an HTTP source.
type HTTPLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this linked service type.
	TypeProperties *HTTPLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HTTPLinkedService.
func (h *HTTPLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HTTPLinkedService.
func (h HTTPLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "HttpServer"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedService.
func (h *HTTPLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPLinkedServiceTypeProperties - Properties specific to this linked service type.
type HTTPLinkedServiceTypeProperties struct {
	// REQUIRED; The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType
	// string).
	URL map[string]interface{} `json:"url,omitempty"`

	// The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType
	// object).
	AuthHeaders map[string]interface{} `json:"authHeaders,omitempty"`

	// The authentication type to be used to connect to the HTTP server.
	AuthenticationType *HTTPAuthenticationType `json:"authenticationType,omitempty"`

	// Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with
	// ClientCertificate authentication, either CertThumbprint or
	// EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
	CertThumbprint map[string]interface{} `json:"certThumbprint,omitempty"`

	// Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication,
	// either CertThumbprint or EmbeddedCertData/Password should be
	// specified. Type: string (or Expression with resultType string).
	EmbeddedCertData map[string]interface{} `json:"embeddedCertData,omitempty"`

	// If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType
	// boolean).
	EnableServerCertificateValidation map[string]interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPLinkedServiceTypeProperties.
func (h HTTPLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authHeaders", h.AuthHeaders)
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populate(objectMap, "certThumbprint", h.CertThumbprint)
	populate(objectMap, "embeddedCertData", h.EmbeddedCertData)
	populate(objectMap, "enableServerCertificateValidation", h.EnableServerCertificateValidation)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "password", h.Password)
	populate(objectMap, "url", h.URL)
	populate(objectMap, "userName", h.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedServiceTypeProperties.
func (h *HTTPLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authHeaders":
			err = unpopulate(val, &h.AuthHeaders)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &h.AuthenticationType)
			delete(rawMsg, key)
		case "certThumbprint":
			err = unpopulate(val, &h.CertThumbprint)
			delete(rawMsg, key)
		case "embeddedCertData":
			err = unpopulate(val, &h.EmbeddedCertData)
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			err = unpopulate(val, &h.EnableServerCertificateValidation)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &h.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &h.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPReadSettings - Sftp read settings.
type HTTPReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders map[string]interface{} `json:"additionalHeaders,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody map[string]interface{} `json:"requestBody,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod map[string]interface{} `json:"requestMethod,omitempty"`

	// Specifies the timeout for a HTTP client to get HTTP response from HTTP server.
	RequestTimeout map[string]interface{} `json:"requestTimeout,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type HTTPReadSettings.
func (h *HTTPReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     h.Type,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HTTPReadSettings.
func (h HTTPReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalHeaders", h.AdditionalHeaders)
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", h.EnablePartitionDiscovery)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "partitionRootPath", h.PartitionRootPath)
	populate(objectMap, "requestBody", h.RequestBody)
	populate(objectMap, "requestMethod", h.RequestMethod)
	populate(objectMap, "requestTimeout", h.RequestTimeout)
	objectMap["type"] = "HttpReadSettings"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPReadSettings.
func (h *HTTPReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			err = unpopulate(val, &h.AdditionalHeaders)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &h.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &h.PartitionRootPath)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, &h.RequestBody)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, &h.RequestMethod)
			delete(rawMsg, key)
		case "requestTimeout":
			err = unpopulate(val, &h.RequestTimeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPServerLocation - The location of http server.
type HTTPServerLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Specify the relativeUrl of http server. Type: string (or Expression with resultType string)
	RelativeURL map[string]interface{} `json:"relativeUrl,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type HTTPServerLocation.
func (h *HTTPServerLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 h.Type,
		FolderPath:           h.FolderPath,
		FileName:             h.FileName,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HTTPServerLocation.
func (h HTTPServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", h.FileName)
	populate(objectMap, "folderPath", h.FolderPath)
	populate(objectMap, "relativeUrl", h.RelativeURL)
	objectMap["type"] = "HttpServerLocation"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPServerLocation.
func (h *HTTPServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &h.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &h.FolderPath)
			delete(rawMsg, key)
		case "relativeUrl":
			err = unpopulate(val, &h.RelativeURL)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPSource - A copy activity source for an HTTP file.
type HTTPSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies the timeout for a HTTP client to get HTTP response from HTTP server. The default value is equivalent to System.Net.HttpWebRequest.Timeout.
	// Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type HTTPSource.
func (h *HTTPSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HTTPSource.
func (h HTTPSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", h.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HttpSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPSource.
func (h *HTTPSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &h.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HdfsLinkedService - Hadoop Distributed File System (HDFS) linked service.
type HdfsLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; HDFS linked service properties.
	TypeProperties *HdfsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HdfsLinkedService.
func (h *HdfsLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLinkedService.
func (h HdfsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "Hdfs"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedService.
func (h *HdfsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HdfsLinkedServiceTypeProperties - HDFS linked service properties.
type HdfsLinkedServiceTypeProperties struct {
	// REQUIRED; The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with
	// resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression
	// with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for Windows authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Windows authentication. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLinkedServiceTypeProperties.
func (h HdfsLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "password", h.Password)
	populate(objectMap, "url", h.URL)
	populate(objectMap, "userName", h.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedServiceTypeProperties.
func (h *HdfsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &h.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &h.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &h.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HdfsLocation - The location of HDFS.
type HdfsLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type HdfsLocation.
func (h *HdfsLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 h.Type,
		FolderPath:           h.FolderPath,
		FileName:             h.FileName,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLocation.
func (h HdfsLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", h.FileName)
	populate(objectMap, "folderPath", h.FolderPath)
	objectMap["type"] = "HdfsLocation"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLocation.
func (h *HdfsLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &h.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &h.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HdfsReadSettings - HDFS read settings.
type HdfsReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies Distcp-related settings.
	DistcpSettings *DistcpSettings `json:"distcpSettings,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// HDFS wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// HDFS wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type HdfsReadSettings.
func (h *HdfsReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     h.Type,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HdfsReadSettings.
func (h HdfsReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", h.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "distcpSettings", h.DistcpSettings)
	populate(objectMap, "enablePartitionDiscovery", h.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", h.FileListPath)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", h.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", h.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", h.PartitionRootPath)
	populate(objectMap, "recursive", h.Recursive)
	objectMap["type"] = "HdfsReadSettings"
	populate(objectMap, "wildcardFileName", h.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", h.WildcardFolderPath)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsReadSettings.
func (h *HdfsReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &h.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "distcpSettings":
			err = unpopulate(val, &h.DistcpSettings)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &h.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &h.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &h.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &h.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &h.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &h.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &h.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &h.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HdfsSource - A copy activity HDFS source.
type HdfsSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies Distcp-related settings.
	DistcpSettings *DistcpSettings `json:"distcpSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type HdfsSource.
func (h *HdfsSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HdfsSource.
func (h HdfsSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "distcpSettings", h.DistcpSettings)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "recursive", h.Recursive)
	populate(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HdfsSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsSource.
func (h *HdfsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "distcpSettings":
			err = unpopulate(val, &h.DistcpSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &h.Recursive)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HiveDatasetTypeProperties - Hive Properties
type HiveDatasetTypeProperties struct {
	// The schema name of the Hive. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Hive. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// HiveLinkedService - Hive Server linked service.
type HiveLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Hive Server linked service properties.
	TypeProperties *HiveLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HiveLinkedService.
func (h *HiveLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HiveLinkedService.
func (h HiveLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "Hive"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedService.
func (h *HiveLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HiveLinkedServiceTypeProperties - Hive Server linked service properties.
type HiveLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication method used to access the Hive server.
	AuthenticationType *HiveAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode
	// is enable).
	Host map[string]interface{} `json:"host,omitempty"`

	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCNMismatch map[string]interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Hive server.
	HTTPPath map[string]interface{} `json:"httpPath,omitempty"`

	// The password corresponding to the user name that you provided in the Username field
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Hive server uses to listen for client connections.
	Port map[string]interface{} `json:"port,omitempty"`

	// The type of Hive server.
	ServerType *HiveServerType `json:"serverType,omitempty"`

	// true to indicate using the ZooKeeper service, false not.
	ServiceDiscoveryMode map[string]interface{} `json:"serviceDiscoveryMode,omitempty"`

	// The transport protocol to use in the Thrift layer.
	ThriftTransportProtocol *HiveThriftTransportProtocol `json:"thriftTransportProtocol,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
	UseNativeQuery map[string]interface{} `json:"useNativeQuery,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name that you use to access Hive Server.
	Username map[string]interface{} `json:"username,omitempty"`

	// The namespace on ZooKeeper under which Hive Server 2 nodes are added.
	ZooKeeperNameSpace map[string]interface{} `json:"zooKeeperNameSpace,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveLinkedServiceTypeProperties.
func (h HiveLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowHostNameCNMismatch", h.AllowHostNameCNMismatch)
	populate(objectMap, "allowSelfSignedServerCert", h.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", h.AuthenticationType)
	populate(objectMap, "enableSsl", h.EnableSSL)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "httpPath", h.HTTPPath)
	populate(objectMap, "host", h.Host)
	populate(objectMap, "password", h.Password)
	populate(objectMap, "port", h.Port)
	populate(objectMap, "serverType", h.ServerType)
	populate(objectMap, "serviceDiscoveryMode", h.ServiceDiscoveryMode)
	populate(objectMap, "thriftTransportProtocol", h.ThriftTransportProtocol)
	populate(objectMap, "trustedCertPath", h.TrustedCertPath)
	populate(objectMap, "useNativeQuery", h.UseNativeQuery)
	populate(objectMap, "useSystemTrustStore", h.UseSystemTrustStore)
	populate(objectMap, "username", h.Username)
	populate(objectMap, "zooKeeperNameSpace", h.ZooKeeperNameSpace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedServiceTypeProperties.
func (h *HiveLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, &h.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &h.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &h.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &h.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, &h.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &h.Host)
			delete(rawMsg, key)
		case "password":
			h.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &h.Port)
			delete(rawMsg, key)
		case "serverType":
			err = unpopulate(val, &h.ServerType)
			delete(rawMsg, key)
		case "serviceDiscoveryMode":
			err = unpopulate(val, &h.ServiceDiscoveryMode)
			delete(rawMsg, key)
		case "thriftTransportProtocol":
			err = unpopulate(val, &h.ThriftTransportProtocol)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &h.TrustedCertPath)
			delete(rawMsg, key)
		case "useNativeQuery":
			err = unpopulate(val, &h.UseNativeQuery)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &h.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &h.Username)
			delete(rawMsg, key)
		case "zooKeeperNameSpace":
			err = unpopulate(val, &h.ZooKeeperNameSpace)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HiveObjectDataset - Hive Server dataset.
type HiveObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *HiveDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type HiveObjectDataset.
func (h *HiveObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 h.Type,
		Description:          h.Description,
		Structure:            h.Structure,
		Schema:               h.Schema,
		LinkedServiceName:    h.LinkedServiceName,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		Folder:               h.Folder,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HiveObjectDataset.
func (h HiveObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populate(objectMap, "schema", h.Schema)
	populate(objectMap, "structure", h.Structure)
	objectMap["type"] = "HiveObject"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveObjectDataset.
func (h *HiveObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HiveSource - A copy activity Hive Server source.
type HiveSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type HiveSource.
func (h *HiveSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type HiveSource.
func (h *HiveSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             h.QueryTimeout,
		AdditionalColumns:        h.AdditionalColumns,
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HiveSource.
func (h HiveSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", h.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "query", h.Query)
	populate(objectMap, "queryTimeout", h.QueryTimeout)
	populate(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HiveSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveSource.
func (h *HiveSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &h.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &h.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &h.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HubspotLinkedService - Hubspot Service linked service.
type HubspotLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Hubspot Service linked service properties.
	TypeProperties *HubspotLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type HubspotLinkedService.
func (h *HubspotLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 h.Type,
		ConnectVia:           h.ConnectVia,
		Description:          h.Description,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HubspotLinkedService.
func (h HubspotLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "connectVia", h.ConnectVia)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "parameters", h.Parameters)
	objectMap["type"] = "Hubspot"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedService.
func (h *HubspotLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &h.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HubspotLinkedServiceTypeProperties - Hubspot Service linked service properties.
type HubspotLinkedServiceTypeProperties struct {
	// REQUIRED; The client ID associated with your Hubspot application.
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The access token obtained when initially authenticating your OAuth integration.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The client secret associated with your Hubspot application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The refresh token obtained when initially authenticating your OAuth integration.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HubspotLinkedServiceTypeProperties.
func (h HubspotLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", h.AccessToken)
	populate(objectMap, "clientId", h.ClientID)
	populate(objectMap, "clientSecret", h.ClientSecret)
	populate(objectMap, "encryptedCredential", h.EncryptedCredential)
	populate(objectMap, "refreshToken", h.RefreshToken)
	populate(objectMap, "useEncryptedEndpoints", h.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", h.UseHostVerification)
	populate(objectMap, "usePeerVerification", h.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedServiceTypeProperties.
func (h *HubspotLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			h.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, &h.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			h.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &h.EncryptedCredential)
			delete(rawMsg, key)
		case "refreshToken":
			h.RefreshToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &h.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &h.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &h.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HubspotObjectDataset - Hubspot Service dataset.
type HubspotObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type HubspotObjectDataset.
func (h *HubspotObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 h.Type,
		Description:          h.Description,
		Structure:            h.Structure,
		Schema:               h.Schema,
		LinkedServiceName:    h.LinkedServiceName,
		Parameters:           h.Parameters,
		Annotations:          h.Annotations,
		Folder:               h.Folder,
		AdditionalProperties: h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HubspotObjectDataset.
func (h HubspotObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", h.Annotations)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "folder", h.Folder)
	populate(objectMap, "linkedServiceName", h.LinkedServiceName)
	populate(objectMap, "parameters", h.Parameters)
	populate(objectMap, "schema", h.Schema)
	populate(objectMap, "structure", h.Structure)
	objectMap["type"] = "HubspotObject"
	populate(objectMap, "typeProperties", h.TypeProperties)
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotObjectDataset.
func (h *HubspotObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &h.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &h.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &h.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &h.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &h.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &h.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &h.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &h.TypeProperties)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HubspotSource - A copy activity Hubspot Service source.
type HubspotSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type HubspotSource.
func (h *HubspotSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type HubspotSource.
func (h *HubspotSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             h.QueryTimeout,
		AdditionalColumns:        h.AdditionalColumns,
		Type:                     h.Type,
		SourceRetryCount:         h.SourceRetryCount,
		SourceRetryWait:          h.SourceRetryWait,
		MaxConcurrentConnections: h.MaxConcurrentConnections,
		DisableMetricsCollection: h.DisableMetricsCollection,
		AdditionalProperties:     h.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HubspotSource.
func (h HubspotSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", h.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", h.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", h.MaxConcurrentConnections)
	populate(objectMap, "query", h.Query)
	populate(objectMap, "queryTimeout", h.QueryTimeout)
	populate(objectMap, "sourceRetryCount", h.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", h.SourceRetryWait)
	objectMap["type"] = "HubspotSource"
	if h.AdditionalProperties != nil {
		for key, val := range h.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotSource.
func (h *HubspotSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &h.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &h.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &h.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &h.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &h.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &h.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &h.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		default:
			if h.AdditionalProperties == nil {
				h.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				h.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IfConditionActivity - This activity evaluates a boolean expression and executes either the activities under the ifTrueActivities
// property or the ifFalseActivities property depending on the result of the expression.
type IfConditionActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; IfCondition activity properties.
	TypeProperties *IfConditionActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type IfConditionActivity.
func (i *IfConditionActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 i.Name,
		Type:                 i.Type,
		Description:          i.Description,
		DependsOn:            i.DependsOn,
		UserProperties:       i.UserProperties,
		AdditionalProperties: i.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type IfConditionActivity.
func (i *IfConditionActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 i.Name,
		Type:                 i.Type,
		Description:          i.Description,
		DependsOn:            i.DependsOn,
		UserProperties:       i.UserProperties,
		AdditionalProperties: i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IfConditionActivity.
func (i IfConditionActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", i.DependsOn)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "name", i.Name)
	objectMap["type"] = "IfCondition"
	populate(objectMap, "typeProperties", i.TypeProperties)
	populate(objectMap, "userProperties", i.UserProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivity.
func (i *IfConditionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &i.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &i.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &i.UserProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IfConditionActivityTypeProperties - IfCondition activity properties.
type IfConditionActivityTypeProperties struct {
	// REQUIRED; An expression that would evaluate to Boolean. This is used to determine the block of activities (ifTrueActivities
	// or ifFalseActivities) that will be executed.
	Expression *Expression `json:"expression,omitempty"`

	// List of activities to execute if expression is evaluated to false. This is an optional property and if not provided, the
	// activity will exit without any action.
	IfFalseActivities []ActivityClassification `json:"ifFalseActivities,omitempty"`

	// List of activities to execute if expression is evaluated to true. This is an optional property and if not provided, the
	// activity will exit without any action.
	IfTrueActivities []ActivityClassification `json:"ifTrueActivities,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IfConditionActivityTypeProperties.
func (i IfConditionActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expression", i.Expression)
	populate(objectMap, "ifFalseActivities", i.IfFalseActivities)
	populate(objectMap, "ifTrueActivities", i.IfTrueActivities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivityTypeProperties.
func (i *IfConditionActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expression":
			err = unpopulate(val, &i.Expression)
			delete(rawMsg, key)
		case "ifFalseActivities":
			i.IfFalseActivities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "ifTrueActivities":
			i.IfTrueActivities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ImpalaDatasetTypeProperties - Impala Dataset Properties
type ImpalaDatasetTypeProperties struct {
	// The schema name of the Impala. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Impala. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// ImpalaLinkedService - Impala server linked service.
type ImpalaLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Impala server linked service properties.
	TypeProperties *ImpalaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ImpalaLinkedService.
func (i *ImpalaLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 i.Type,
		ConnectVia:           i.ConnectVia,
		Description:          i.Description,
		Parameters:           i.Parameters,
		Annotations:          i.Annotations,
		AdditionalProperties: i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaLinkedService.
func (i ImpalaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "connectVia", i.ConnectVia)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "parameters", i.Parameters)
	objectMap["type"] = "Impala"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedService.
func (i *ImpalaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &i.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &i.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &i.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ImpalaLinkedServiceTypeProperties - Impala server linked service properties.
type ImpalaLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication type to use.
	AuthenticationType *ImpalaAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The IP address or host name of the Impala server. (i.e. 192.168.222.160)
	Host map[string]interface{} `json:"host,omitempty"`

	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCNMismatch map[string]interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name when using UsernameAndPassword.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
	Port map[string]interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaLinkedServiceTypeProperties.
func (i ImpalaLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowHostNameCNMismatch", i.AllowHostNameCNMismatch)
	populate(objectMap, "allowSelfSignedServerCert", i.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", i.AuthenticationType)
	populate(objectMap, "enableSsl", i.EnableSSL)
	populate(objectMap, "encryptedCredential", i.EncryptedCredential)
	populate(objectMap, "host", i.Host)
	populate(objectMap, "password", i.Password)
	populate(objectMap, "port", i.Port)
	populate(objectMap, "trustedCertPath", i.TrustedCertPath)
	populate(objectMap, "useSystemTrustStore", i.UseSystemTrustStore)
	populate(objectMap, "username", i.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedServiceTypeProperties.
func (i *ImpalaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, &i.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &i.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &i.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &i.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &i.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &i.Host)
			delete(rawMsg, key)
		case "password":
			i.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &i.Port)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &i.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &i.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &i.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ImpalaObjectDataset - Impala server dataset.
type ImpalaObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *ImpalaDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ImpalaObjectDataset.
func (i *ImpalaObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 i.Type,
		Description:          i.Description,
		Structure:            i.Structure,
		Schema:               i.Schema,
		LinkedServiceName:    i.LinkedServiceName,
		Parameters:           i.Parameters,
		Annotations:          i.Annotations,
		Folder:               i.Folder,
		AdditionalProperties: i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaObjectDataset.
func (i ImpalaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "folder", i.Folder)
	populate(objectMap, "linkedServiceName", i.LinkedServiceName)
	populate(objectMap, "parameters", i.Parameters)
	populate(objectMap, "schema", i.Schema)
	populate(objectMap, "structure", i.Structure)
	objectMap["type"] = "ImpalaObject"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaObjectDataset.
func (i *ImpalaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &i.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &i.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &i.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &i.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &i.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &i.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ImpalaSource - A copy activity Impala server source.
type ImpalaSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ImpalaSource.
func (i *ImpalaSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     i.Type,
		SourceRetryCount:         i.SourceRetryCount,
		SourceRetryWait:          i.SourceRetryWait,
		MaxConcurrentConnections: i.MaxConcurrentConnections,
		DisableMetricsCollection: i.DisableMetricsCollection,
		AdditionalProperties:     i.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type ImpalaSource.
func (i *ImpalaSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             i.QueryTimeout,
		AdditionalColumns:        i.AdditionalColumns,
		Type:                     i.Type,
		SourceRetryCount:         i.SourceRetryCount,
		SourceRetryWait:          i.SourceRetryWait,
		MaxConcurrentConnections: i.MaxConcurrentConnections,
		DisableMetricsCollection: i.DisableMetricsCollection,
		AdditionalProperties:     i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaSource.
func (i ImpalaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", i.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", i.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", i.MaxConcurrentConnections)
	populate(objectMap, "query", i.Query)
	populate(objectMap, "queryTimeout", i.QueryTimeout)
	populate(objectMap, "sourceRetryCount", i.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", i.SourceRetryWait)
	objectMap["type"] = "ImpalaSource"
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaSource.
func (i *ImpalaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &i.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &i.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &i.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &i.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &i.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &i.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &i.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ImportSettingsClassification provides polymorphic access to related types.
// Call the interface's GetImportSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureDatabricksDeltaLakeImportCommand, *ImportSettings, *SnowflakeImportCopyCommand
type ImportSettingsClassification interface {
	// GetImportSettings returns the ImportSettings content of the underlying type.
	GetImportSettings() *ImportSettings
}

// ImportSettings - Import command settings.
type ImportSettings struct {
	// REQUIRED; The import setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetImportSettings implements the ImportSettingsClassification interface for type ImportSettings.
func (i *ImportSettings) GetImportSettings() *ImportSettings { return i }

// MarshalJSON implements the json.Marshaller interface for type ImportSettings.
func (i ImportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImportSettings.
func (i *ImportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InformixLinkedService - Informix linked service.
type InformixLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Informix linked service properties.
	TypeProperties *InformixLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type InformixLinkedService.
func (i *InformixLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 i.Type,
		ConnectVia:           i.ConnectVia,
		Description:          i.Description,
		Parameters:           i.Parameters,
		Annotations:          i.Annotations,
		AdditionalProperties: i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InformixLinkedService.
func (i InformixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "connectVia", i.ConnectVia)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "parameters", i.Parameters)
	objectMap["type"] = "Informix"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedService.
func (i *InformixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &i.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &i.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &i.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InformixLinkedServiceTypeProperties - Informix linked service properties.
type InformixLinkedServiceTypeProperties struct {
	// REQUIRED; The non-access credential portion of the connection string as well as an optional encrypted credential. Type:
	// string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type:
	// string (or Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixLinkedServiceTypeProperties.
func (i InformixLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", i.AuthenticationType)
	populate(objectMap, "connectionString", i.ConnectionString)
	populate(objectMap, "credential", i.Credential)
	populate(objectMap, "encryptedCredential", i.EncryptedCredential)
	populate(objectMap, "password", i.Password)
	populate(objectMap, "userName", i.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedServiceTypeProperties.
func (i *InformixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &i.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &i.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			i.Credential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &i.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			i.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &i.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InformixSink - A copy activity Informix sink.
type InformixSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type InformixSink.
func (i *InformixSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     i.Type,
		WriteBatchSize:           i.WriteBatchSize,
		WriteBatchTimeout:        i.WriteBatchTimeout,
		SinkRetryCount:           i.SinkRetryCount,
		SinkRetryWait:            i.SinkRetryWait,
		MaxConcurrentConnections: i.MaxConcurrentConnections,
		DisableMetricsCollection: i.DisableMetricsCollection,
		AdditionalProperties:     i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InformixSink.
func (i InformixSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", i.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", i.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", i.PreCopyScript)
	populate(objectMap, "sinkRetryCount", i.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", i.SinkRetryWait)
	objectMap["type"] = "InformixSink"
	populate(objectMap, "writeBatchSize", i.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", i.WriteBatchTimeout)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixSink.
func (i *InformixSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &i.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &i.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &i.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &i.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &i.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &i.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &i.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InformixSource - A copy activity source for Informix.
type InformixSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type InformixSource.
func (i *InformixSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     i.Type,
		SourceRetryCount:         i.SourceRetryCount,
		SourceRetryWait:          i.SourceRetryWait,
		MaxConcurrentConnections: i.MaxConcurrentConnections,
		DisableMetricsCollection: i.DisableMetricsCollection,
		AdditionalProperties:     i.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type InformixSource.
func (i *InformixSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             i.QueryTimeout,
		AdditionalColumns:        i.AdditionalColumns,
		Type:                     i.Type,
		SourceRetryCount:         i.SourceRetryCount,
		SourceRetryWait:          i.SourceRetryWait,
		MaxConcurrentConnections: i.MaxConcurrentConnections,
		DisableMetricsCollection: i.DisableMetricsCollection,
		AdditionalProperties:     i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InformixSource.
func (i InformixSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", i.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", i.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", i.MaxConcurrentConnections)
	populate(objectMap, "query", i.Query)
	populate(objectMap, "queryTimeout", i.QueryTimeout)
	populate(objectMap, "sourceRetryCount", i.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", i.SourceRetryWait)
	objectMap["type"] = "InformixSource"
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixSource.
func (i *InformixSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &i.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &i.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &i.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &i.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &i.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &i.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &i.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InformixTableDataset - The Informix table dataset.
type InformixTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Informix table dataset properties.
	TypeProperties *InformixTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type InformixTableDataset.
func (i *InformixTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 i.Type,
		Description:          i.Description,
		Structure:            i.Structure,
		Schema:               i.Schema,
		LinkedServiceName:    i.LinkedServiceName,
		Parameters:           i.Parameters,
		Annotations:          i.Annotations,
		Folder:               i.Folder,
		AdditionalProperties: i.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InformixTableDataset.
func (i InformixTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", i.Annotations)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "folder", i.Folder)
	populate(objectMap, "linkedServiceName", i.LinkedServiceName)
	populate(objectMap, "parameters", i.Parameters)
	populate(objectMap, "schema", i.Schema)
	populate(objectMap, "structure", i.Structure)
	objectMap["type"] = "InformixTable"
	populate(objectMap, "typeProperties", i.TypeProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixTableDataset.
func (i *InformixTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &i.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &i.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &i.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &i.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &i.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &i.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &i.TypeProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InformixTableDatasetTypeProperties - Informix table dataset properties.
type InformixTableDatasetTypeProperties struct {
	// The Informix table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// IntegrationRuntimeClassification provides polymorphic access to related types.
// Call the interface's GetIntegrationRuntime() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *IntegrationRuntime, *ManagedIntegrationRuntime, *SelfHostedIntegrationRuntime
type IntegrationRuntimeClassification interface {
	// GetIntegrationRuntime returns the IntegrationRuntime content of the underlying type.
	GetIntegrationRuntime() *IntegrationRuntime
}

// IntegrationRuntime - Azure Data Factory nested object which serves as a compute resource for activities.
type IntegrationRuntime struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Integration runtime description.
	Description *string `json:"description,omitempty"`
}

// GetIntegrationRuntime implements the IntegrationRuntimeClassification interface for type IntegrationRuntime.
func (i *IntegrationRuntime) GetIntegrationRuntime() *IntegrationRuntime { return i }

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntime.
func (i IntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", i.Description)
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntime.
func (i *IntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeAuthKeys - The integration runtime authentication keys.
type IntegrationRuntimeAuthKeys struct {
	// The primary integration runtime authentication key.
	AuthKey1 *string `json:"authKey1,omitempty"`

	// The secondary integration runtime authentication key.
	AuthKey2 *string `json:"authKey2,omitempty"`
}

// IntegrationRuntimeComputeProperties - The compute resource properties for managed integration runtime.
type IntegrationRuntimeComputeProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Data flow properties for managed integration runtime.
	DataFlowProperties *IntegrationRuntimeDataFlowProperties `json:"dataFlowProperties,omitempty"`

	// The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
	Location *string `json:"location,omitempty"`

	// Maximum parallel executions count per node for managed integration runtime.
	MaxParallelExecutionsPerNode *int32 `json:"maxParallelExecutionsPerNode,omitempty"`

	// The node size requirement to managed integration runtime.
	NodeSize *string `json:"nodeSize,omitempty"`

	// The required number of nodes for managed integration runtime.
	NumberOfNodes *int32 `json:"numberOfNodes,omitempty"`

	// VNet properties for managed integration runtime.
	VNetProperties *IntegrationRuntimeVNetProperties `json:"vNetProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeComputeProperties.
func (i IntegrationRuntimeComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataFlowProperties", i.DataFlowProperties)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "maxParallelExecutionsPerNode", i.MaxParallelExecutionsPerNode)
	populate(objectMap, "nodeSize", i.NodeSize)
	populate(objectMap, "numberOfNodes", i.NumberOfNodes)
	populate(objectMap, "vNetProperties", i.VNetProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeComputeProperties.
func (i *IntegrationRuntimeComputeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlowProperties":
			err = unpopulate(val, &i.DataFlowProperties)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &i.Location)
			delete(rawMsg, key)
		case "maxParallelExecutionsPerNode":
			err = unpopulate(val, &i.MaxParallelExecutionsPerNode)
			delete(rawMsg, key)
		case "nodeSize":
			err = unpopulate(val, &i.NodeSize)
			delete(rawMsg, key)
		case "numberOfNodes":
			err = unpopulate(val, &i.NumberOfNodes)
			delete(rawMsg, key)
		case "vNetProperties":
			err = unpopulate(val, &i.VNetProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeConnectionInfo - Connection information for encrypting the on-premises data source credentials.
type IntegrationRuntimeConnectionInfo struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The on-premises integration runtime host URL.
	HostServiceURI *string `json:"hostServiceUri,omitempty" azure:"ro"`

	// READ-ONLY; The integration runtime SSL certificate thumbprint. Click-Once application uses it to do server validation.
	IdentityCertThumbprint *string `json:"identityCertThumbprint,omitempty" azure:"ro"`

	// READ-ONLY; Whether the identity certificate is expired.
	IsIdentityCertExprired *bool `json:"isIdentityCertExprired,omitempty" azure:"ro"`

	// READ-ONLY; The public key for encrypting a credential when transferring the credential to the integration runtime.
	PublicKey *string `json:"publicKey,omitempty" azure:"ro"`

	// READ-ONLY; The token generated in service. Callers use this token to authenticate to integration runtime.
	ServiceToken *string `json:"serviceToken,omitempty" azure:"ro"`

	// READ-ONLY; The integration runtime version.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeConnectionInfo.
func (i IntegrationRuntimeConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hostServiceUri", i.HostServiceURI)
	populate(objectMap, "identityCertThumbprint", i.IdentityCertThumbprint)
	populate(objectMap, "isIdentityCertExprired", i.IsIdentityCertExprired)
	populate(objectMap, "publicKey", i.PublicKey)
	populate(objectMap, "serviceToken", i.ServiceToken)
	populate(objectMap, "version", i.Version)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeConnectionInfo.
func (i *IntegrationRuntimeConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostServiceUri":
			err = unpopulate(val, &i.HostServiceURI)
			delete(rawMsg, key)
		case "identityCertThumbprint":
			err = unpopulate(val, &i.IdentityCertThumbprint)
			delete(rawMsg, key)
		case "isIdentityCertExprired":
			err = unpopulate(val, &i.IsIdentityCertExprired)
			delete(rawMsg, key)
		case "publicKey":
			err = unpopulate(val, &i.PublicKey)
			delete(rawMsg, key)
		case "serviceToken":
			err = unpopulate(val, &i.ServiceToken)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &i.Version)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeCustomSetupScriptProperties - Custom setup script properties for a managed dedicated integration runtime.
type IntegrationRuntimeCustomSetupScriptProperties struct {
	// The URI of the Azure blob container that contains the custom setup script.
	BlobContainerURI *string `json:"blobContainerUri,omitempty"`

	// The SAS token of the Azure blob container.
	SasToken *SecureString `json:"sasToken,omitempty"`
}

// IntegrationRuntimeCustomerVirtualNetwork - The definition and properties of virtual network to which Azure-SSIS integration
// runtime will join.
type IntegrationRuntimeCustomerVirtualNetwork struct {
	// The ID of subnet to which Azure-SSIS integration runtime will join.
	SubnetID *string `json:"subnetId,omitempty"`
}

// IntegrationRuntimeDataFlowProperties - Data flow properties for managed integration runtime.
type IntegrationRuntimeDataFlowProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if
	// this is set as false. Default is true.
	Cleanup *bool `json:"cleanup,omitempty"`

	// Compute type of the cluster which will execute data flow job.
	ComputeType *DataFlowComputeType `json:"computeType,omitempty"`

	// Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// Time to live (in minutes) setting of the cluster which will execute data flow job.
	TimeToLive *int32 `json:"timeToLive,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i IntegrationRuntimeDataFlowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cleanup", i.Cleanup)
	populate(objectMap, "computeType", i.ComputeType)
	populate(objectMap, "coreCount", i.CoreCount)
	populate(objectMap, "timeToLive", i.TimeToLive)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i *IntegrationRuntimeDataFlowProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cleanup":
			err = unpopulate(val, &i.Cleanup)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, &i.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, &i.CoreCount)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, &i.TimeToLive)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeDataProxyProperties - Data proxy properties for a managed dedicated integration runtime.
type IntegrationRuntimeDataProxyProperties struct {
	// The self-hosted integration runtime reference.
	ConnectVia *EntityReference `json:"connectVia,omitempty"`

	// The path to contain the staged data in the Blob storage.
	Path *string `json:"path,omitempty"`

	// The staging linked service reference.
	StagingLinkedService *EntityReference `json:"stagingLinkedService,omitempty"`
}

// IntegrationRuntimeDebugResource - Integration runtime debug resource.
type IntegrationRuntimeDebugResource struct {
	// REQUIRED; Integration runtime properties.
	Properties IntegrationRuntimeClassification `json:"properties,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDebugResource.
func (i IntegrationRuntimeDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDebugResource.
func (i *IntegrationRuntimeDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeListResponse - A list of integration runtime resources.
type IntegrationRuntimeListResponse struct {
	// REQUIRED; List of integration runtimes.
	Value []*IntegrationRuntimeResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeListResponse.
func (i IntegrationRuntimeListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeMonitoringData - Get monitoring data response.
type IntegrationRuntimeMonitoringData struct {
	// Integration runtime name.
	Name *string `json:"name,omitempty"`

	// Integration runtime node monitoring data.
	Nodes []*IntegrationRuntimeNodeMonitoringData `json:"nodes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeMonitoringData.
func (i IntegrationRuntimeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", i.Name)
	populate(objectMap, "nodes", i.Nodes)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeNodeIPAddress - The IP address of self-hosted integration runtime node.
type IntegrationRuntimeNodeIPAddress struct {
	// READ-ONLY; The IP address of self-hosted integration runtime node.
	IPAddress *string `json:"ipAddress,omitempty" azure:"ro"`
}

// IntegrationRuntimeNodeMonitoringData - Monitoring data for integration runtime node.
type IntegrationRuntimeNodeMonitoringData struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Available memory (MB) on the integration runtime node.
	AvailableMemoryInMB *int32 `json:"availableMemoryInMB,omitempty" azure:"ro"`

	// READ-ONLY; CPU percentage on the integration runtime node.
	CPUUtilization *int32 `json:"cpuUtilization,omitempty" azure:"ro"`

	// READ-ONLY; Maximum concurrent jobs on the integration runtime node.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty" azure:"ro"`

	// READ-ONLY; The number of jobs currently running on the integration runtime node.
	ConcurrentJobsRunning *int32 `json:"concurrentJobsRunning,omitempty" azure:"ro"`

	// READ-ONLY; The maximum concurrent jobs in this integration runtime.
	MaxConcurrentJobs *int32 `json:"maxConcurrentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Name of the integration runtime node.
	NodeName *string `json:"nodeName,omitempty" azure:"ro"`

	// READ-ONLY; Received bytes on the integration runtime node.
	ReceivedBytes *float32 `json:"receivedBytes,omitempty" azure:"ro"`

	// READ-ONLY; Sent bytes on the integration runtime node.
	SentBytes *float32 `json:"sentBytes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeNodeMonitoringData.
func (i IntegrationRuntimeNodeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availableMemoryInMB", i.AvailableMemoryInMB)
	populate(objectMap, "cpuUtilization", i.CPUUtilization)
	populate(objectMap, "concurrentJobsLimit", i.ConcurrentJobsLimit)
	populate(objectMap, "concurrentJobsRunning", i.ConcurrentJobsRunning)
	populate(objectMap, "maxConcurrentJobs", i.MaxConcurrentJobs)
	populate(objectMap, "nodeName", i.NodeName)
	populate(objectMap, "receivedBytes", i.ReceivedBytes)
	populate(objectMap, "sentBytes", i.SentBytes)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeNodeMonitoringData.
func (i *IntegrationRuntimeNodeMonitoringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableMemoryInMB":
			err = unpopulate(val, &i.AvailableMemoryInMB)
			delete(rawMsg, key)
		case "cpuUtilization":
			err = unpopulate(val, &i.CPUUtilization)
			delete(rawMsg, key)
		case "concurrentJobsLimit":
			err = unpopulate(val, &i.ConcurrentJobsLimit)
			delete(rawMsg, key)
		case "concurrentJobsRunning":
			err = unpopulate(val, &i.ConcurrentJobsRunning)
			delete(rawMsg, key)
		case "maxConcurrentJobs":
			err = unpopulate(val, &i.MaxConcurrentJobs)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, &i.NodeName)
			delete(rawMsg, key)
		case "receivedBytes":
			err = unpopulate(val, &i.ReceivedBytes)
			delete(rawMsg, key)
		case "sentBytes":
			err = unpopulate(val, &i.SentBytes)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeNodesClientDeleteOptions contains the optional parameters for the IntegrationRuntimeNodesClient.Delete
// method.
type IntegrationRuntimeNodesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodesClientGetIPAddressOptions contains the optional parameters for the IntegrationRuntimeNodesClient.GetIPAddress
// method.
type IntegrationRuntimeNodesClientGetIPAddressOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodesClientGetOptions contains the optional parameters for the IntegrationRuntimeNodesClient.Get method.
type IntegrationRuntimeNodesClientGetOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodesClientUpdateOptions contains the optional parameters for the IntegrationRuntimeNodesClient.Update
// method.
type IntegrationRuntimeNodesClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeObjectMetadataClientBeginRefreshOptions contains the optional parameters for the IntegrationRuntimeObjectMetadataClient.BeginRefresh
// method.
type IntegrationRuntimeObjectMetadataClientBeginRefreshOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeObjectMetadataClientGetOptions contains the optional parameters for the IntegrationRuntimeObjectMetadataClient.Get
// method.
type IntegrationRuntimeObjectMetadataClientGetOptions struct {
	// The parameters for getting a SSIS object metadata.
	GetMetadataRequest *GetSsisObjectMetadataRequest
}

// IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint - Azure-SSIS integration runtime outbound network dependency
// endpoints for one category.
type IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint struct {
	// The category of outbound network dependency.
	Category *string `json:"category,omitempty"`

	// The endpoints for outbound network dependency.
	Endpoints []*IntegrationRuntimeOutboundNetworkDependenciesEndpoint `json:"endpoints,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint.
func (i IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", i.Category)
	populate(objectMap, "endpoints", i.Endpoints)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeOutboundNetworkDependenciesEndpoint - The endpoint for Azure-SSIS integration runtime outbound network
// dependency.
type IntegrationRuntimeOutboundNetworkDependenciesEndpoint struct {
	// The domain name of endpoint.
	DomainName *string `json:"domainName,omitempty"`

	// The details of endpoint.
	EndpointDetails []*IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails `json:"endpointDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpoint.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "domainName", i.DomainName)
	populate(objectMap, "endpointDetails", i.EndpointDetails)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails - The details of Azure-SSIS integration runtime outbound network
// dependency endpoint.
type IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails struct {
	// The port of endpoint.
	Port *int32 `json:"port,omitempty"`
}

// IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse - Azure-SSIS integration runtime outbound network dependency
// endpoints.
type IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse struct {
	// The list of outbound network dependency endpoints.
	Value []*IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeReference - Integration runtime reference type.
type IntegrationRuntimeReference struct {
	// REQUIRED; Reference integration runtime name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeReferenceType `json:"type,omitempty"`

	// Arguments for integration runtime.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeReference.
func (i IntegrationRuntimeReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parameters", i.Parameters)
	populate(objectMap, "referenceName", i.ReferenceName)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeRegenerateKeyParameters - Parameters to regenerate the authentication key.
type IntegrationRuntimeRegenerateKeyParameters struct {
	// The name of the authentication key to regenerate.
	KeyName *IntegrationRuntimeAuthKeyName `json:"keyName,omitempty"`
}

// IntegrationRuntimeResource - Integration runtime resource type.
type IntegrationRuntimeResource struct {
	// REQUIRED; Integration runtime properties.
	Properties IntegrationRuntimeClassification `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeResource.
func (i IntegrationRuntimeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", i.Etag)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeResource.
func (i *IntegrationRuntimeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &i.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeSsisCatalogInfo - Catalog information for managed dedicated integration runtime.
type IntegrationRuntimeSsisCatalogInfo struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The password of the administrator user account of the catalog database.
	CatalogAdminPassword *SecureString `json:"catalogAdminPassword,omitempty"`

	// The administrator user name of catalog database.
	CatalogAdminUserName *string `json:"catalogAdminUserName,omitempty"`

	// The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
	CatalogPricingTier *IntegrationRuntimeSsisCatalogPricingTier `json:"catalogPricingTier,omitempty"`

	// The catalog database server URL.
	CatalogServerEndpoint *string `json:"catalogServerEndpoint,omitempty"`

	// The dual standby pair name of Azure-SSIS Integration Runtimes to support SSISDB failover.
	DualStandbyPairName *string `json:"dualStandbyPairName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i IntegrationRuntimeSsisCatalogInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "catalogAdminPassword", i.CatalogAdminPassword)
	populate(objectMap, "catalogAdminUserName", i.CatalogAdminUserName)
	populate(objectMap, "catalogPricingTier", i.CatalogPricingTier)
	populate(objectMap, "catalogServerEndpoint", i.CatalogServerEndpoint)
	populate(objectMap, "dualStandbyPairName", i.DualStandbyPairName)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i *IntegrationRuntimeSsisCatalogInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogAdminPassword":
			err = unpopulate(val, &i.CatalogAdminPassword)
			delete(rawMsg, key)
		case "catalogAdminUserName":
			err = unpopulate(val, &i.CatalogAdminUserName)
			delete(rawMsg, key)
		case "catalogPricingTier":
			err = unpopulate(val, &i.CatalogPricingTier)
			delete(rawMsg, key)
		case "catalogServerEndpoint":
			err = unpopulate(val, &i.CatalogServerEndpoint)
			delete(rawMsg, key)
		case "dualStandbyPairName":
			err = unpopulate(val, &i.DualStandbyPairName)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeSsisProperties - SSIS properties for managed integration runtime.
type IntegrationRuntimeSsisProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Catalog information for managed dedicated integration runtime.
	CatalogInfo *IntegrationRuntimeSsisCatalogInfo `json:"catalogInfo,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// Custom setup script properties for a managed dedicated integration runtime.
	CustomSetupScriptProperties *IntegrationRuntimeCustomSetupScriptProperties `json:"customSetupScriptProperties,omitempty"`

	// Data proxy properties for a managed dedicated integration runtime.
	DataProxyProperties *IntegrationRuntimeDataProxyProperties `json:"dataProxyProperties,omitempty"`

	// The edition for the SSIS Integration Runtime
	Edition *IntegrationRuntimeEdition `json:"edition,omitempty"`

	// Custom setup without script properties for a SSIS integration runtime.
	ExpressCustomSetupProperties []CustomSetupBaseClassification `json:"expressCustomSetupProperties,omitempty"`

	// License type for bringing your own license scenario.
	LicenseType *IntegrationRuntimeLicenseType `json:"licenseType,omitempty"`

	// Package stores for the SSIS Integration Runtime.
	PackageStores []*PackageStore `json:"packageStores,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisProperties.
func (i IntegrationRuntimeSsisProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "catalogInfo", i.CatalogInfo)
	populate(objectMap, "credential", i.Credential)
	populate(objectMap, "customSetupScriptProperties", i.CustomSetupScriptProperties)
	populate(objectMap, "dataProxyProperties", i.DataProxyProperties)
	populate(objectMap, "edition", i.Edition)
	populate(objectMap, "expressCustomSetupProperties", i.ExpressCustomSetupProperties)
	populate(objectMap, "licenseType", i.LicenseType)
	populate(objectMap, "packageStores", i.PackageStores)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisProperties.
func (i *IntegrationRuntimeSsisProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogInfo":
			err = unpopulate(val, &i.CatalogInfo)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &i.Credential)
			delete(rawMsg, key)
		case "customSetupScriptProperties":
			err = unpopulate(val, &i.CustomSetupScriptProperties)
			delete(rawMsg, key)
		case "dataProxyProperties":
			err = unpopulate(val, &i.DataProxyProperties)
			delete(rawMsg, key)
		case "edition":
			err = unpopulate(val, &i.Edition)
			delete(rawMsg, key)
		case "expressCustomSetupProperties":
			i.ExpressCustomSetupProperties, err = unmarshalCustomSetupBaseClassificationArray(val)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, &i.LicenseType)
			delete(rawMsg, key)
		case "packageStores":
			err = unpopulate(val, &i.PackageStores)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeStatusClassification provides polymorphic access to related types.
// Call the interface's GetIntegrationRuntimeStatus() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *IntegrationRuntimeStatus, *ManagedIntegrationRuntimeStatus, *SelfHostedIntegrationRuntimeStatus
type IntegrationRuntimeStatusClassification interface {
	// GetIntegrationRuntimeStatus returns the IntegrationRuntimeStatus content of the underlying type.
	GetIntegrationRuntimeStatus() *IntegrationRuntimeStatus
}

// IntegrationRuntimeStatus - Integration runtime status.
type IntegrationRuntimeStatus struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The data factory name which the integration runtime belong to.
	DataFactoryName *string `json:"dataFactoryName,omitempty" azure:"ro"`

	// READ-ONLY; The state of integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`
}

// GetIntegrationRuntimeStatus implements the IntegrationRuntimeStatusClassification interface for type IntegrationRuntimeStatus.
func (i *IntegrationRuntimeStatus) GetIntegrationRuntimeStatus() *IntegrationRuntimeStatus { return i }

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeStatus.
func (i IntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataFactoryName", i.DataFactoryName)
	populate(objectMap, "state", i.State)
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeStatus.
func (i *IntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, &i.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &i.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeStatusListResponse - A list of integration runtime status.
type IntegrationRuntimeStatusListResponse struct {
	// REQUIRED; List of integration runtime status.
	Value []*IntegrationRuntimeStatusResponse `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeStatusListResponse.
func (i IntegrationRuntimeStatusListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeStatusResponse - Integration runtime status response.
type IntegrationRuntimeStatusResponse struct {
	// REQUIRED; Integration runtime properties.
	Properties IntegrationRuntimeStatusClassification `json:"properties,omitempty"`

	// READ-ONLY; The integration runtime name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeStatusResponse.
func (i IntegrationRuntimeStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeStatusResponse.
func (i *IntegrationRuntimeStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeStatusClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeVNetProperties - VNet properties for managed integration runtime.
type IntegrationRuntimeVNetProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Resource IDs of the public IP addresses that this integration runtime will use.
	PublicIPs []*string `json:"publicIPs,omitempty"`

	// The name of the subnet this integration runtime will join.
	Subnet *string `json:"subnet,omitempty"`

	// The ID of subnet, to which this Azure-SSIS integration runtime will be joined.
	SubnetID *string `json:"subnetId,omitempty"`

	// The ID of the VNet that this integration runtime will join.
	VNetID *string `json:"vNetId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeVNetProperties.
func (i IntegrationRuntimeVNetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "publicIPs", i.PublicIPs)
	populate(objectMap, "subnet", i.Subnet)
	populate(objectMap, "subnetId", i.SubnetID)
	populate(objectMap, "vNetId", i.VNetID)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeVNetProperties.
func (i *IntegrationRuntimeVNetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "publicIPs":
			err = unpopulate(val, &i.PublicIPs)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, &i.Subnet)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, &i.SubnetID)
			delete(rawMsg, key)
		case "vNetId":
			err = unpopulate(val, &i.VNetID)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimesClientBeginStartOptions contains the optional parameters for the IntegrationRuntimesClient.BeginStart
// method.
type IntegrationRuntimesClientBeginStartOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientBeginStopOptions contains the optional parameters for the IntegrationRuntimesClient.BeginStop
// method.
type IntegrationRuntimesClientBeginStopOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientCreateLinkedIntegrationRuntimeOptions contains the optional parameters for the IntegrationRuntimesClient.CreateLinkedIntegrationRuntime
// method.
type IntegrationRuntimesClientCreateLinkedIntegrationRuntimeOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientCreateOrUpdateOptions contains the optional parameters for the IntegrationRuntimesClient.CreateOrUpdate
// method.
type IntegrationRuntimesClientCreateOrUpdateOptions struct {
	// ETag of the integration runtime entity. Should only be specified for update, for which it should match existing entity
	// or can be * for unconditional update.
	IfMatch *string
}

// IntegrationRuntimesClientDeleteOptions contains the optional parameters for the IntegrationRuntimesClient.Delete method.
type IntegrationRuntimesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientGetConnectionInfoOptions contains the optional parameters for the IntegrationRuntimesClient.GetConnectionInfo
// method.
type IntegrationRuntimesClientGetConnectionInfoOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientGetMonitoringDataOptions contains the optional parameters for the IntegrationRuntimesClient.GetMonitoringData
// method.
type IntegrationRuntimesClientGetMonitoringDataOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientGetOptions contains the optional parameters for the IntegrationRuntimesClient.Get method.
type IntegrationRuntimesClientGetOptions struct {
	// ETag of the integration runtime entity. Should only be specified for get. If the ETag matches the existing entity tag,
	// or if * was provided, then no content will be returned.
	IfNoneMatch *string
}

// IntegrationRuntimesClientGetStatusOptions contains the optional parameters for the IntegrationRuntimesClient.GetStatus
// method.
type IntegrationRuntimesClientGetStatusOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientListAuthKeysOptions contains the optional parameters for the IntegrationRuntimesClient.ListAuthKeys
// method.
type IntegrationRuntimesClientListAuthKeysOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientListByFactoryOptions contains the optional parameters for the IntegrationRuntimesClient.ListByFactory
// method.
type IntegrationRuntimesClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientListOutboundNetworkDependenciesEndpointsOptions contains the optional parameters for the IntegrationRuntimesClient.ListOutboundNetworkDependenciesEndpoints
// method.
type IntegrationRuntimesClientListOutboundNetworkDependenciesEndpointsOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientRegenerateAuthKeyOptions contains the optional parameters for the IntegrationRuntimesClient.RegenerateAuthKey
// method.
type IntegrationRuntimesClientRegenerateAuthKeyOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientRemoveLinksOptions contains the optional parameters for the IntegrationRuntimesClient.RemoveLinks
// method.
type IntegrationRuntimesClientRemoveLinksOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientSyncCredentialsOptions contains the optional parameters for the IntegrationRuntimesClient.SyncCredentials
// method.
type IntegrationRuntimesClientSyncCredentialsOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientUpdateOptions contains the optional parameters for the IntegrationRuntimesClient.Update method.
type IntegrationRuntimesClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesClientUpgradeOptions contains the optional parameters for the IntegrationRuntimesClient.Upgrade method.
type IntegrationRuntimesClientUpgradeOptions struct {
	// placeholder for future optional parameters
}

// JSONDataset - Json dataset.
type JSONDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Json dataset properties.
	TypeProperties *JSONDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type JSONDataset.
func (j *JSONDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 j.Type,
		Description:          j.Description,
		Structure:            j.Structure,
		Schema:               j.Schema,
		LinkedServiceName:    j.LinkedServiceName,
		Parameters:           j.Parameters,
		Annotations:          j.Annotations,
		Folder:               j.Folder,
		AdditionalProperties: j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONDataset.
func (j JSONDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", j.Annotations)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "folder", j.Folder)
	populate(objectMap, "linkedServiceName", j.LinkedServiceName)
	populate(objectMap, "parameters", j.Parameters)
	populate(objectMap, "schema", j.Schema)
	populate(objectMap, "structure", j.Structure)
	objectMap["type"] = "Json"
	populate(objectMap, "typeProperties", j.TypeProperties)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDataset.
func (j *JSONDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &j.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &j.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &j.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &j.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &j.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &j.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &j.TypeProperties)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONDatasetTypeProperties - Json dataset properties.
type JSONDatasetTypeProperties struct {
	// REQUIRED; The location of the json data storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data compression method used for the json dataset.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another
	// Unicode encoding. Refer to the name column of the table in the following link to
	// set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType
	// string).
	EncodingName map[string]interface{} `json:"encodingName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONDatasetTypeProperties.
func (j JSONDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", j.Compression)
	populate(objectMap, "encodingName", j.EncodingName)
	populate(objectMap, "location", j.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDatasetTypeProperties.
func (j *JSONDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &j.Compression)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, &j.EncodingName)
			delete(rawMsg, key)
		case "location":
			j.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONFormat - The data stored in JSON format.
type JSONFormat struct {
	// REQUIRED; Type of dataset storage format.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer map[string]interface{} `json:"deserializer,omitempty"`

	// The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark
	// (BOM) denotes another Unicode encoding. The full list of supported values can be
	// found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078.
	// Type: string (or Expression with resultType string).
	EncodingName map[string]interface{} `json:"encodingName,omitempty"`

	// File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'.
	// It is case-sensitive.
	FilePattern map[string]interface{} `json:"filePattern,omitempty"`

	// The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType
	// string).
	JSONNodeReference map[string]interface{} `json:"jsonNodeReference,omitempty"`

	// The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields
	// under root object, start with "$"; for fields inside the array chosen by
	// jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}.
	// Type: object (or Expression with resultType object).
	JSONPathDefinition map[string]interface{} `json:"jsonPathDefinition,omitempty"`

	// The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType
	// string).
	NestingSeparator map[string]interface{} `json:"nestingSeparator,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer map[string]interface{} `json:"serializer,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type JSONFormat.
func (j *JSONFormat) GetDatasetStorageFormat() *DatasetStorageFormat {
	return &DatasetStorageFormat{
		Type:                 j.Type,
		Serializer:           j.Serializer,
		Deserializer:         j.Deserializer,
		AdditionalProperties: j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONFormat.
func (j JSONFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deserializer", j.Deserializer)
	populate(objectMap, "encodingName", j.EncodingName)
	populate(objectMap, "filePattern", j.FilePattern)
	populate(objectMap, "jsonNodeReference", j.JSONNodeReference)
	populate(objectMap, "jsonPathDefinition", j.JSONPathDefinition)
	populate(objectMap, "nestingSeparator", j.NestingSeparator)
	populate(objectMap, "serializer", j.Serializer)
	objectMap["type"] = "JsonFormat"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONFormat.
func (j *JSONFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, &j.Deserializer)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, &j.EncodingName)
			delete(rawMsg, key)
		case "filePattern":
			err = unpopulate(val, &j.FilePattern)
			delete(rawMsg, key)
		case "jsonNodeReference":
			err = unpopulate(val, &j.JSONNodeReference)
			delete(rawMsg, key)
		case "jsonPathDefinition":
			err = unpopulate(val, &j.JSONPathDefinition)
			delete(rawMsg, key)
		case "nestingSeparator":
			err = unpopulate(val, &j.NestingSeparator)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, &j.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONReadSettings - Json read settings.
type JSONReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Compression settings.
	CompressionProperties CompressionReadSettingsClassification `json:"compressionProperties,omitempty"`
}

// GetFormatReadSettings implements the FormatReadSettingsClassification interface for type JSONReadSettings.
func (j *JSONReadSettings) GetFormatReadSettings() *FormatReadSettings {
	return &FormatReadSettings{
		Type:                 j.Type,
		AdditionalProperties: j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONReadSettings.
func (j JSONReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compressionProperties", j.CompressionProperties)
	objectMap["type"] = "JsonReadSettings"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONReadSettings.
func (j *JSONReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			j.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONSink - A copy activity Json sink.
type JSONSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Json format settings.
	FormatSettings *JSONWriteSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Json store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type JSONSink.
func (j *JSONSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     j.Type,
		WriteBatchSize:           j.WriteBatchSize,
		WriteBatchTimeout:        j.WriteBatchTimeout,
		SinkRetryCount:           j.SinkRetryCount,
		SinkRetryWait:            j.SinkRetryWait,
		MaxConcurrentConnections: j.MaxConcurrentConnections,
		DisableMetricsCollection: j.DisableMetricsCollection,
		AdditionalProperties:     j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONSink.
func (j JSONSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", j.DisableMetricsCollection)
	populate(objectMap, "formatSettings", j.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", j.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", j.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", j.SinkRetryWait)
	populate(objectMap, "storeSettings", j.StoreSettings)
	objectMap["type"] = "JsonSink"
	populate(objectMap, "writeBatchSize", j.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", j.WriteBatchTimeout)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSink.
func (j *JSONSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &j.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &j.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &j.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &j.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &j.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			j.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &j.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &j.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONSource - A copy activity Json source.
type JSONSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Json format settings.
	FormatSettings *JSONReadSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Json store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type JSONSource.
func (j *JSONSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     j.Type,
		SourceRetryCount:         j.SourceRetryCount,
		SourceRetryWait:          j.SourceRetryWait,
		MaxConcurrentConnections: j.MaxConcurrentConnections,
		DisableMetricsCollection: j.DisableMetricsCollection,
		AdditionalProperties:     j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONSource.
func (j JSONSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", j.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", j.DisableMetricsCollection)
	populate(objectMap, "formatSettings", j.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", j.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", j.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", j.SourceRetryWait)
	populate(objectMap, "storeSettings", j.StoreSettings)
	objectMap["type"] = "JsonSource"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSource.
func (j *JSONSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &j.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &j.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &j.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &j.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &j.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &j.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			j.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONWriteSettings - Json write settings.
type JSONWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// File pattern of JSON. This setting controls the way a collection of JSON objects will be treated. The default value is
	// 'setOfObjects'. It is case-sensitive.
	FilePattern map[string]interface{} `json:"filePattern,omitempty"`
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type JSONWriteSettings.
func (j *JSONWriteSettings) GetFormatWriteSettings() *FormatWriteSettings {
	return &FormatWriteSettings{
		Type:                 j.Type,
		AdditionalProperties: j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONWriteSettings.
func (j JSONWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filePattern", j.FilePattern)
	objectMap["type"] = "JsonWriteSettings"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONWriteSettings.
func (j *JSONWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filePattern":
			err = unpopulate(val, &j.FilePattern)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JiraLinkedService - Jira Service linked service.
type JiraLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Jira Service linked service properties.
	TypeProperties *JiraLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type JiraLinkedService.
func (j *JiraLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 j.Type,
		ConnectVia:           j.ConnectVia,
		Description:          j.Description,
		Parameters:           j.Parameters,
		Annotations:          j.Annotations,
		AdditionalProperties: j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JiraLinkedService.
func (j JiraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", j.Annotations)
	populate(objectMap, "connectVia", j.ConnectVia)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "parameters", j.Parameters)
	objectMap["type"] = "Jira"
	populate(objectMap, "typeProperties", j.TypeProperties)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedService.
func (j *JiraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &j.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &j.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &j.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &j.TypeProperties)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JiraLinkedServiceTypeProperties - Jira Service linked service properties.
type JiraLinkedServiceTypeProperties struct {
	// REQUIRED; The IP address or host name of the Jira service. (e.g. jira.example.com)
	Host map[string]interface{} `json:"host,omitempty"`

	// REQUIRED; The user name that you use to access Jira Service.
	Username map[string]interface{} `json:"username,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name that you provided in the username field.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through
	// HTTPS, or 8080 if connecting through HTTP.
	Port map[string]interface{} `json:"port,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JiraLinkedServiceTypeProperties.
func (j JiraLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", j.EncryptedCredential)
	populate(objectMap, "host", j.Host)
	populate(objectMap, "password", j.Password)
	populate(objectMap, "port", j.Port)
	populate(objectMap, "useEncryptedEndpoints", j.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", j.UseHostVerification)
	populate(objectMap, "usePeerVerification", j.UsePeerVerification)
	populate(objectMap, "username", j.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedServiceTypeProperties.
func (j *JiraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &j.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &j.Host)
			delete(rawMsg, key)
		case "password":
			j.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &j.Port)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &j.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &j.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &j.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &j.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JiraObjectDataset - Jira Service dataset.
type JiraObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type JiraObjectDataset.
func (j *JiraObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 j.Type,
		Description:          j.Description,
		Structure:            j.Structure,
		Schema:               j.Schema,
		LinkedServiceName:    j.LinkedServiceName,
		Parameters:           j.Parameters,
		Annotations:          j.Annotations,
		Folder:               j.Folder,
		AdditionalProperties: j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JiraObjectDataset.
func (j JiraObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", j.Annotations)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "folder", j.Folder)
	populate(objectMap, "linkedServiceName", j.LinkedServiceName)
	populate(objectMap, "parameters", j.Parameters)
	populate(objectMap, "schema", j.Schema)
	populate(objectMap, "structure", j.Structure)
	objectMap["type"] = "JiraObject"
	populate(objectMap, "typeProperties", j.TypeProperties)
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraObjectDataset.
func (j *JiraObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &j.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &j.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &j.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &j.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &j.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &j.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &j.TypeProperties)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JiraSource - A copy activity Jira Service source.
type JiraSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type JiraSource.
func (j *JiraSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     j.Type,
		SourceRetryCount:         j.SourceRetryCount,
		SourceRetryWait:          j.SourceRetryWait,
		MaxConcurrentConnections: j.MaxConcurrentConnections,
		DisableMetricsCollection: j.DisableMetricsCollection,
		AdditionalProperties:     j.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type JiraSource.
func (j *JiraSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             j.QueryTimeout,
		AdditionalColumns:        j.AdditionalColumns,
		Type:                     j.Type,
		SourceRetryCount:         j.SourceRetryCount,
		SourceRetryWait:          j.SourceRetryWait,
		MaxConcurrentConnections: j.MaxConcurrentConnections,
		DisableMetricsCollection: j.DisableMetricsCollection,
		AdditionalProperties:     j.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JiraSource.
func (j JiraSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", j.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", j.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", j.MaxConcurrentConnections)
	populate(objectMap, "query", j.Query)
	populate(objectMap, "queryTimeout", j.QueryTimeout)
	populate(objectMap, "sourceRetryCount", j.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", j.SourceRetryWait)
	objectMap["type"] = "JiraSource"
	if j.AdditionalProperties != nil {
		for key, val := range j.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraSource.
func (j *JiraSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &j.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &j.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &j.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &j.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &j.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &j.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &j.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		default:
			if j.AdditionalProperties == nil {
				j.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				j.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LicensedComponentSetupTypeProperties - Installation of licensed component setup type properties.
type LicensedComponentSetupTypeProperties struct {
	// REQUIRED; The name of the 3rd party component.
	ComponentName *string `json:"componentName,omitempty"`

	// The license key to activate the component.
	LicenseKey SecretBaseClassification `json:"licenseKey,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LicensedComponentSetupTypeProperties.
func (l LicensedComponentSetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "componentName", l.ComponentName)
	populate(objectMap, "licenseKey", l.LicenseKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LicensedComponentSetupTypeProperties.
func (l *LicensedComponentSetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "componentName":
			err = unpopulate(val, &l.ComponentName)
			delete(rawMsg, key)
		case "licenseKey":
			l.LicenseKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedIntegrationRuntime - The linked integration runtime information.
type LinkedIntegrationRuntime struct {
	// READ-ONLY; The creating time of the linked integration runtime.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; The location of the data factory for which the linked integration runtime belong to.
	DataFactoryLocation *string `json:"dataFactoryLocation,omitempty" azure:"ro"`

	// READ-ONLY; The name of the data factory for which the linked integration runtime belong to.
	DataFactoryName *string `json:"dataFactoryName,omitempty" azure:"ro"`

	// READ-ONLY; The name of the linked integration runtime.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The subscription ID for which the linked integration runtime belong to.
	SubscriptionID *string `json:"subscriptionId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntime.
func (l LinkedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createTime", l.CreateTime)
	populate(objectMap, "dataFactoryLocation", l.DataFactoryLocation)
	populate(objectMap, "dataFactoryName", l.DataFactoryName)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "subscriptionId", l.SubscriptionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntime.
func (l *LinkedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateTimeRFC3339(val, &l.CreateTime)
			delete(rawMsg, key)
		case "dataFactoryLocation":
			err = unpopulate(val, &l.DataFactoryLocation)
			delete(rawMsg, key)
		case "dataFactoryName":
			err = unpopulate(val, &l.DataFactoryName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &l.SubscriptionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedIntegrationRuntimeKeyAuthorization - The key authorization type integration runtime.
type LinkedIntegrationRuntimeKeyAuthorization struct {
	// REQUIRED; The authorization type for integration runtime sharing.
	AuthorizationType *string `json:"authorizationType,omitempty"`

	// REQUIRED; The key used for authorization.
	Key *SecureString `json:"key,omitempty"`
}

// GetLinkedIntegrationRuntimeType implements the LinkedIntegrationRuntimeTypeClassification interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l *LinkedIntegrationRuntimeKeyAuthorization) GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType {
	return &LinkedIntegrationRuntimeType{
		AuthorizationType: l.AuthorizationType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l LinkedIntegrationRuntimeKeyAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authorizationType"] = "Key"
	populate(objectMap, "key", l.Key)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l *LinkedIntegrationRuntimeKeyAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			err = unpopulate(val, &l.AuthorizationType)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, &l.Key)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedIntegrationRuntimeRbacAuthorization - The role based access control (RBAC) authorization type integration runtime.
type LinkedIntegrationRuntimeRbacAuthorization struct {
	// REQUIRED; The authorization type for integration runtime sharing.
	AuthorizationType *string `json:"authorizationType,omitempty"`

	// REQUIRED; The resource identifier of the integration runtime to be shared.
	ResourceID *string `json:"resourceId,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`
}

// GetLinkedIntegrationRuntimeType implements the LinkedIntegrationRuntimeTypeClassification interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l *LinkedIntegrationRuntimeRbacAuthorization) GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType {
	return &LinkedIntegrationRuntimeType{
		AuthorizationType: l.AuthorizationType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l LinkedIntegrationRuntimeRbacAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authorizationType"] = "RBAC"
	populate(objectMap, "credential", l.Credential)
	populate(objectMap, "resourceId", l.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l *LinkedIntegrationRuntimeRbacAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			err = unpopulate(val, &l.AuthorizationType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &l.Credential)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &l.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedIntegrationRuntimeRequest - Data factory name for linked integration runtime request.
type LinkedIntegrationRuntimeRequest struct {
	// REQUIRED; The data factory name for linked integration runtime.
	LinkedFactoryName *string `json:"factoryName,omitempty"`
}

// LinkedIntegrationRuntimeTypeClassification provides polymorphic access to related types.
// Call the interface's GetLinkedIntegrationRuntimeType() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *LinkedIntegrationRuntimeKeyAuthorization, *LinkedIntegrationRuntimeRbacAuthorization, *LinkedIntegrationRuntimeType
type LinkedIntegrationRuntimeTypeClassification interface {
	// GetLinkedIntegrationRuntimeType returns the LinkedIntegrationRuntimeType content of the underlying type.
	GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType
}

// LinkedIntegrationRuntimeType - The base definition of a linked integration runtime.
type LinkedIntegrationRuntimeType struct {
	// REQUIRED; The authorization type for integration runtime sharing.
	AuthorizationType *string `json:"authorizationType,omitempty"`
}

// GetLinkedIntegrationRuntimeType implements the LinkedIntegrationRuntimeTypeClassification interface for type LinkedIntegrationRuntimeType.
func (l *LinkedIntegrationRuntimeType) GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType {
	return l
}

// LinkedServiceClassification provides polymorphic access to related types.
// Call the interface's GetLinkedService() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AmazonMWSLinkedService, *AmazonRdsForOracleLinkedService, *AmazonRdsForSQLServerLinkedService, *AmazonRedshiftLinkedService,
// - *AmazonS3CompatibleLinkedService, *AmazonS3LinkedService, *AzureBatchLinkedService, *AzureBlobFSLinkedService, *AzureBlobStorageLinkedService,
// - *AzureDataExplorerLinkedService, *AzureDataLakeAnalyticsLinkedService, *AzureDataLakeStoreLinkedService, *AzureDatabricksDeltaLakeLinkedService,
// - *AzureDatabricksLinkedService, *AzureFileStorageLinkedService, *AzureFunctionLinkedService, *AzureKeyVaultLinkedService,
// - *AzureMLLinkedService, *AzureMLServiceLinkedService, *AzureMariaDBLinkedService, *AzureMySQLLinkedService, *AzurePostgreSQLLinkedService,
// - *AzureSQLDWLinkedService, *AzureSQLDatabaseLinkedService, *AzureSQLMILinkedService, *AzureSearchLinkedService, *AzureStorageLinkedService,
// - *AzureTableStorageLinkedService, *CassandraLinkedService, *CommonDataServiceForAppsLinkedService, *ConcurLinkedService,
// - *CosmosDbLinkedService, *CosmosDbMongoDbAPILinkedService, *CouchbaseLinkedService, *CustomDataSourceLinkedService, *Db2LinkedService,
// - *DrillLinkedService, *DynamicsAXLinkedService, *DynamicsCrmLinkedService, *DynamicsLinkedService, *EloquaLinkedService,
// - *FileServerLinkedService, *FtpServerLinkedService, *GoogleAdWordsLinkedService, *GoogleBigQueryLinkedService, *GoogleCloudStorageLinkedService,
// - *GreenplumLinkedService, *HBaseLinkedService, *HDInsightLinkedService, *HDInsightOnDemandLinkedService, *HTTPLinkedService,
// - *HdfsLinkedService, *HiveLinkedService, *HubspotLinkedService, *ImpalaLinkedService, *InformixLinkedService, *JiraLinkedService,
// - *LinkedService, *MagentoLinkedService, *MariaDBLinkedService, *MarketoLinkedService, *MicrosoftAccessLinkedService, *MongoDbAtlasLinkedService,
// - *MongoDbLinkedService, *MongoDbV2LinkedService, *MySQLLinkedService, *NetezzaLinkedService, *ODataLinkedService, *OdbcLinkedService,
// - *Office365LinkedService, *OracleCloudStorageLinkedService, *OracleLinkedService, *OracleServiceCloudLinkedService, *PaypalLinkedService,
// - *PhoenixLinkedService, *PostgreSQLLinkedService, *PrestoLinkedService, *QuickBooksLinkedService, *ResponsysLinkedService,
// - *RestServiceLinkedService, *SQLServerLinkedService, *SalesforceLinkedService, *SalesforceMarketingCloudLinkedService,
// - *SalesforceServiceCloudLinkedService, *SapBWLinkedService, *SapCloudForCustomerLinkedService, *SapEccLinkedService, *SapHanaLinkedService,
// - *SapOpenHubLinkedService, *SapTableLinkedService, *ServiceNowLinkedService, *SftpServerLinkedService, *SharePointOnlineListLinkedService,
// - *ShopifyLinkedService, *SnowflakeLinkedService, *SparkLinkedService, *SquareLinkedService, *SybaseLinkedService, *TeradataLinkedService,
// - *VerticaLinkedService, *WebLinkedService, *XeroLinkedService, *ZohoLinkedService
type LinkedServiceClassification interface {
	// GetLinkedService returns the LinkedService content of the underlying type.
	GetLinkedService() *LinkedService
}

// LinkedService - The Azure Data Factory nested object which contains the information and credential which can be used to
// connect with related store or compute resource.
type LinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type LinkedService.
func (l *LinkedService) GetLinkedService() *LinkedService { return l }

// MarshalJSON implements the json.Marshaller interface for type LinkedService.
func (l LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", l.Annotations)
	populate(objectMap, "connectVia", l.ConnectVia)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "parameters", l.Parameters)
	objectMap["type"] = l.Type
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedService.
func (l *LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &l.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &l.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &l.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedServiceDebugResource - Linked service debug resource.
type LinkedServiceDebugResource struct {
	// REQUIRED; Properties of linked service.
	Properties LinkedServiceClassification `json:"properties,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceDebugResource.
func (l LinkedServiceDebugResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceDebugResource.
func (l *LinkedServiceDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "properties":
			l.Properties, err = unmarshalLinkedServiceClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedServiceListResponse - A list of linked service resources.
type LinkedServiceListResponse struct {
	// REQUIRED; List of linked services.
	Value []*LinkedServiceResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceListResponse.
func (l LinkedServiceListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LinkedServiceReference - Linked service reference type.
type LinkedServiceReference struct {
	// REQUIRED; Reference LinkedService name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Linked service reference type.
	Type *LinkedServiceReferenceType `json:"type,omitempty"`

	// Arguments for LinkedService.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceReference.
func (l LinkedServiceReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parameters", l.Parameters)
	populate(objectMap, "referenceName", l.ReferenceName)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// LinkedServiceResource - Linked service resource type.
type LinkedServiceResource struct {
	// REQUIRED; Properties of linked service.
	Properties LinkedServiceClassification `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedServiceResource.
func (l LinkedServiceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceResource.
func (l *LinkedServiceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &l.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &l.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "properties":
			l.Properties, err = unmarshalLinkedServiceClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedServicesClientCreateOrUpdateOptions contains the optional parameters for the LinkedServicesClient.CreateOrUpdate
// method.
type LinkedServicesClientCreateOrUpdateOptions struct {
	// ETag of the linkedService entity. Should only be specified for update, for which it should match existing entity or can
	// be * for unconditional update.
	IfMatch *string
}

// LinkedServicesClientDeleteOptions contains the optional parameters for the LinkedServicesClient.Delete method.
type LinkedServicesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// LinkedServicesClientGetOptions contains the optional parameters for the LinkedServicesClient.Get method.
type LinkedServicesClientGetOptions struct {
	// ETag of the linked service entity. Should only be specified for get. If the ETag matches the existing entity tag, or if
	// * was provided, then no content will be returned.
	IfNoneMatch *string
}

// LinkedServicesClientListByFactoryOptions contains the optional parameters for the LinkedServicesClient.ListByFactory method.
type LinkedServicesClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// LogLocationSettings - Log location settings.
type LogLocationSettings struct {
	// REQUIRED; Log storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// LogSettings - Log settings.
type LogSettings struct {
	// REQUIRED; Log location settings customer needs to provide when enabling log.
	LogLocationSettings *LogLocationSettings `json:"logLocationSettings,omitempty"`

	// Specifies settings for copy activity log.
	CopyActivityLogSettings *CopyActivityLogSettings `json:"copyActivityLogSettings,omitempty"`

	// Specifies whether to enable copy activity log. Type: boolean (or Expression with resultType boolean).
	EnableCopyActivityLog map[string]interface{} `json:"enableCopyActivityLog,omitempty"`
}

// LogStorageSettings - (Deprecated. Please use LogSettings) Log storage settings.
type LogStorageSettings struct {
	// REQUIRED; Log storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies whether to enable reliable logging. Type: boolean (or Expression with resultType boolean).
	EnableReliableLogging map[string]interface{} `json:"enableReliableLogging,omitempty"`

	// Gets or sets the log level, support: Info, Warning. Type: string (or Expression with resultType string).
	LogLevel map[string]interface{} `json:"logLevel,omitempty"`

	// The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LogStorageSettings.
func (l LogStorageSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enableReliableLogging", l.EnableReliableLogging)
	populate(objectMap, "linkedServiceName", l.LinkedServiceName)
	populate(objectMap, "logLevel", l.LogLevel)
	populate(objectMap, "path", l.Path)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogStorageSettings.
func (l *LogStorageSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableReliableLogging":
			err = unpopulate(val, &l.EnableReliableLogging)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &l.LinkedServiceName)
			delete(rawMsg, key)
		case "logLevel":
			err = unpopulate(val, &l.LogLevel)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, &l.Path)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LookupActivity - Lookup activity.
type LookupActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Lookup activity properties.
	TypeProperties *LookupActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type LookupActivity.
func (l *LookupActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 l.Name,
		Type:                 l.Type,
		Description:          l.Description,
		DependsOn:            l.DependsOn,
		UserProperties:       l.UserProperties,
		AdditionalProperties: l.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type LookupActivity.
func (l *LookupActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    l.LinkedServiceName,
		Policy:               l.Policy,
		Name:                 l.Name,
		Type:                 l.Type,
		Description:          l.Description,
		DependsOn:            l.DependsOn,
		UserProperties:       l.UserProperties,
		AdditionalProperties: l.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LookupActivity.
func (l LookupActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", l.DependsOn)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "linkedServiceName", l.LinkedServiceName)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "policy", l.Policy)
	objectMap["type"] = "Lookup"
	populate(objectMap, "typeProperties", l.TypeProperties)
	populate(objectMap, "userProperties", l.UserProperties)
	if l.AdditionalProperties != nil {
		for key, val := range l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivity.
func (l *LookupActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &l.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &l.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &l.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &l.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &l.UserProperties)
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				l.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LookupActivityTypeProperties - Lookup activity properties.
type LookupActivityTypeProperties struct {
	// REQUIRED; Lookup activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// REQUIRED; Dataset-specific source properties, same as copy activity source.
	Source CopySourceClassification `json:"source,omitempty"`

	// Whether to return first row or all rows. Default value is true. Type: boolean (or Expression with resultType boolean).
	FirstRowOnly map[string]interface{} `json:"firstRowOnly,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LookupActivityTypeProperties.
func (l LookupActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataset", l.Dataset)
	populate(objectMap, "firstRowOnly", l.FirstRowOnly)
	populate(objectMap, "source", l.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivityTypeProperties.
func (l *LookupActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			err = unpopulate(val, &l.Dataset)
			delete(rawMsg, key)
		case "firstRowOnly":
			err = unpopulate(val, &l.FirstRowOnly)
			delete(rawMsg, key)
		case "source":
			l.Source, err = unmarshalCopySourceClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MagentoLinkedService - Magento server linked service.
type MagentoLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Magento server linked service properties.
	TypeProperties *MagentoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MagentoLinkedService.
func (m *MagentoLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MagentoLinkedService.
func (m MagentoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "Magento"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedService.
func (m *MagentoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MagentoLinkedServiceTypeProperties - Magento server linked service properties.
type MagentoLinkedServiceTypeProperties struct {
	// REQUIRED; The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
	Host map[string]interface{} `json:"host,omitempty"`

	// The access token from Magento.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MagentoLinkedServiceTypeProperties.
func (m MagentoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", m.AccessToken)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "host", m.Host)
	populate(objectMap, "useEncryptedEndpoints", m.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", m.UseHostVerification)
	populate(objectMap, "usePeerVerification", m.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedServiceTypeProperties.
func (m *MagentoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			m.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &m.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &m.Host)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &m.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &m.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &m.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MagentoObjectDataset - Magento server dataset.
type MagentoObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MagentoObjectDataset.
func (m *MagentoObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MagentoObjectDataset.
func (m MagentoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MagentoObject"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoObjectDataset.
func (m *MagentoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MagentoSource - A copy activity Magento server source.
type MagentoSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MagentoSource.
func (m *MagentoSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type MagentoSource.
func (m *MagentoSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             m.QueryTimeout,
		AdditionalColumns:        m.AdditionalColumns,
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MagentoSource.
func (m MagentoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "query", m.Query)
	populate(objectMap, "queryTimeout", m.QueryTimeout)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MagentoSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoSource.
func (m *MagentoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIdentityCredential - Managed identity credential.
type ManagedIdentityCredential struct {
	// REQUIRED; Type of credential.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Credential.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Credential description.
	Description *string `json:"description,omitempty"`

	// Managed identity credential properties.
	TypeProperties *ManagedIdentityTypeProperties `json:"typeProperties,omitempty"`
}

// GetCredential implements the CredentialClassification interface for type ManagedIdentityCredential.
func (m *ManagedIdentityCredential) GetCredential() *Credential {
	return &Credential{
		Type:                 m.Type,
		Description:          m.Description,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentityCredential.
func (m ManagedIdentityCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	objectMap["type"] = "ManagedIdentity"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentityCredential.
func (m *ManagedIdentityCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIdentityTypeProperties - Managed identity type properties.
type ManagedIdentityTypeProperties struct {
	// The resource id of user assigned managed identity
	ResourceID *string `json:"resourceId,omitempty"`
}

// ManagedIntegrationRuntime - Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
type ManagedIntegrationRuntime struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// REQUIRED; Managed integration runtime properties.
	TypeProperties *ManagedIntegrationRuntimeTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Integration runtime description.
	Description *string `json:"description,omitempty"`

	// Managed Virtual Network reference.
	ManagedVirtualNetwork *ManagedVirtualNetworkReference `json:"managedVirtualNetwork,omitempty"`

	// READ-ONLY; Integration runtime state, only valid for managed dedicated integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`
}

// GetIntegrationRuntime implements the IntegrationRuntimeClassification interface for type ManagedIntegrationRuntime.
func (m *ManagedIntegrationRuntime) GetIntegrationRuntime() *IntegrationRuntime {
	return &IntegrationRuntime{
		Type:                 m.Type,
		Description:          m.Description,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntime.
func (m ManagedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "managedVirtualNetwork", m.ManagedVirtualNetwork)
	populate(objectMap, "state", m.State)
	objectMap["type"] = IntegrationRuntimeTypeManaged
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntime.
func (m *ManagedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "managedVirtualNetwork":
			err = unpopulate(val, &m.ManagedVirtualNetwork)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeError - Error definition for managed integration runtime.
type ManagedIntegrationRuntimeError struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Managed integration runtime error parameters.
	Parameters []*string `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; The time when the error occurred.
	Time *time.Time `json:"time,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeError.
func (m ManagedIntegrationRuntimeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", m.Code)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "parameters", m.Parameters)
	populateTimeRFC3339(objectMap, "time", m.Time)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeError.
func (m *ManagedIntegrationRuntimeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, &m.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &m.Time)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeNode - Properties of integration runtime node.
type ManagedIntegrationRuntimeNode struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The errors that occurred on this integration runtime node.
	Errors []*ManagedIntegrationRuntimeError `json:"errors,omitempty"`

	// READ-ONLY; The managed integration runtime node id.
	NodeID *string `json:"nodeId,omitempty" azure:"ro"`

	// READ-ONLY; The managed integration runtime node status.
	Status *ManagedIntegrationRuntimeNodeStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeNode.
func (m ManagedIntegrationRuntimeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "nodeId", m.NodeID)
	populate(objectMap, "status", m.Status)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeNode.
func (m *ManagedIntegrationRuntimeNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "nodeId":
			err = unpopulate(val, &m.NodeID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeOperationResult - Properties of managed integration runtime operation result.
type ManagedIntegrationRuntimeOperationResult struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The activity id for the operation request.
	ActivityID *string `json:"activityId,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	ErrorCode *string `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; Managed integration runtime error parameters.
	Parameters []*string `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; The operation result.
	Result *string `json:"result,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the operation.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The operation type. Could be start or stop.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeOperationResult.
func (m ManagedIntegrationRuntimeOperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activityId", m.ActivityID)
	populate(objectMap, "errorCode", m.ErrorCode)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "result", m.Result)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "type", m.Type)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeOperationResult.
func (m *ManagedIntegrationRuntimeOperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, &m.ActivityID)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, &m.ErrorCode)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, &m.Result)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &m.StartTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeStatus - Managed integration runtime status.
type ManagedIntegrationRuntimeStatus struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// REQUIRED; Managed integration runtime status type properties.
	TypeProperties *ManagedIntegrationRuntimeStatusTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The data factory name which the integration runtime belong to.
	DataFactoryName *string `json:"dataFactoryName,omitempty" azure:"ro"`

	// READ-ONLY; The state of integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`
}

// GetIntegrationRuntimeStatus implements the IntegrationRuntimeStatusClassification interface for type ManagedIntegrationRuntimeStatus.
func (m *ManagedIntegrationRuntimeStatus) GetIntegrationRuntimeStatus() *IntegrationRuntimeStatus {
	return &IntegrationRuntimeStatus{
		Type:                 m.Type,
		DataFactoryName:      m.DataFactoryName,
		State:                m.State,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeStatus.
func (m ManagedIntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataFactoryName", m.DataFactoryName)
	populate(objectMap, "state", m.State)
	objectMap["type"] = IntegrationRuntimeTypeManaged
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeStatus.
func (m *ManagedIntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, &m.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeStatusTypeProperties - Managed integration runtime status type properties.
type ManagedIntegrationRuntimeStatusTypeProperties struct {
	// READ-ONLY; The time at which the integration runtime was created, in ISO8601 format.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; The last operation result that occurred on this integration runtime.
	LastOperation *ManagedIntegrationRuntimeOperationResult `json:"lastOperation,omitempty" azure:"ro"`

	// READ-ONLY; The list of nodes for managed integration runtime.
	Nodes []*ManagedIntegrationRuntimeNode `json:"nodes,omitempty" azure:"ro"`

	// READ-ONLY; The errors that occurred on this integration runtime.
	OtherErrors []*ManagedIntegrationRuntimeError `json:"otherErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeStatusTypeProperties.
func (m ManagedIntegrationRuntimeStatusTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createTime", m.CreateTime)
	populate(objectMap, "lastOperation", m.LastOperation)
	populate(objectMap, "nodes", m.Nodes)
	populate(objectMap, "otherErrors", m.OtherErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeStatusTypeProperties.
func (m *ManagedIntegrationRuntimeStatusTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateTimeRFC3339(val, &m.CreateTime)
			delete(rawMsg, key)
		case "lastOperation":
			err = unpopulate(val, &m.LastOperation)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, &m.Nodes)
			delete(rawMsg, key)
		case "otherErrors":
			err = unpopulate(val, &m.OtherErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeTypeProperties - Managed integration runtime type properties.
type ManagedIntegrationRuntimeTypeProperties struct {
	// The compute resource for managed integration runtime.
	ComputeProperties *IntegrationRuntimeComputeProperties `json:"computeProperties,omitempty"`

	// The name of virtual network to which Azure-SSIS integration runtime will join
	CustomerVirtualNetwork *IntegrationRuntimeCustomerVirtualNetwork `json:"customerVirtualNetwork,omitempty"`

	// SSIS properties for managed integration runtime.
	SsisProperties *IntegrationRuntimeSsisProperties `json:"ssisProperties,omitempty"`
}

// ManagedPrivateEndpoint - Properties of a managed private endpoint
type ManagedPrivateEndpoint struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The managed private endpoint connection state
	ConnectionState *ConnectionStateProperties `json:"connectionState,omitempty"`

	// Fully qualified domain names
	Fqdns []*string `json:"fqdns,omitempty"`

	// The groupId to which the managed private endpoint is created
	GroupID *string `json:"groupId,omitempty"`

	// The ARM resource ID of the resource to which the managed private endpoint is created
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`

	// READ-ONLY; Denotes whether the managed private endpoint is reserved
	IsReserved *bool `json:"isReserved,omitempty" azure:"ro"`

	// READ-ONLY; The managed private endpoint provisioning state
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpoint.
func (m ManagedPrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionState", m.ConnectionState)
	populate(objectMap, "fqdns", m.Fqdns)
	populate(objectMap, "groupId", m.GroupID)
	populate(objectMap, "isReserved", m.IsReserved)
	populate(objectMap, "privateLinkResourceId", m.PrivateLinkResourceID)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedPrivateEndpoint.
func (m *ManagedPrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionState":
			err = unpopulate(val, &m.ConnectionState)
			delete(rawMsg, key)
		case "fqdns":
			err = unpopulate(val, &m.Fqdns)
			delete(rawMsg, key)
		case "groupId":
			err = unpopulate(val, &m.GroupID)
			delete(rawMsg, key)
		case "isReserved":
			err = unpopulate(val, &m.IsReserved)
			delete(rawMsg, key)
		case "privateLinkResourceId":
			err = unpopulate(val, &m.PrivateLinkResourceID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &m.ProvisioningState)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedPrivateEndpointListResponse - A list of managed private endpoint resources.
type ManagedPrivateEndpointListResponse struct {
	// REQUIRED; List of managed private endpoints.
	Value []*ManagedPrivateEndpointResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpointListResponse.
func (m ManagedPrivateEndpointListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// ManagedPrivateEndpointResource - Managed private endpoint resource type.
type ManagedPrivateEndpointResource struct {
	// REQUIRED; Managed private endpoint properties.
	Properties *ManagedPrivateEndpoint `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ManagedPrivateEndpointsClientCreateOrUpdateOptions contains the optional parameters for the ManagedPrivateEndpointsClient.CreateOrUpdate
// method.
type ManagedPrivateEndpointsClientCreateOrUpdateOptions struct {
	// ETag of the managed private endpoint entity. Should only be specified for update, for which it should match existing entity
	// or can be * for unconditional update.
	IfMatch *string
}

// ManagedPrivateEndpointsClientDeleteOptions contains the optional parameters for the ManagedPrivateEndpointsClient.Delete
// method.
type ManagedPrivateEndpointsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ManagedPrivateEndpointsClientGetOptions contains the optional parameters for the ManagedPrivateEndpointsClient.Get method.
type ManagedPrivateEndpointsClientGetOptions struct {
	// ETag of the managed private endpoint entity. Should only be specified for get. If the ETag matches the existing entity
	// tag, or if * was provided, then no content will be returned.
	IfNoneMatch *string
}

// ManagedPrivateEndpointsClientListByFactoryOptions contains the optional parameters for the ManagedPrivateEndpointsClient.ListByFactory
// method.
type ManagedPrivateEndpointsClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// ManagedVirtualNetwork - A managed Virtual Network associated with the Azure Data Factory
type ManagedVirtualNetwork struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Managed Virtual Network alias.
	Alias *string `json:"alias,omitempty" azure:"ro"`

	// READ-ONLY; Managed Virtual Network ID.
	VNetID *string `json:"vNetId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetwork.
func (m ManagedVirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alias", m.Alias)
	populate(objectMap, "vNetId", m.VNetID)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVirtualNetwork.
func (m *ManagedVirtualNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
			err = unpopulate(val, &m.Alias)
			delete(rawMsg, key)
		case "vNetId":
			err = unpopulate(val, &m.VNetID)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedVirtualNetworkListResponse - A list of managed Virtual Network resources.
type ManagedVirtualNetworkListResponse struct {
	// REQUIRED; List of managed Virtual Networks.
	Value []*ManagedVirtualNetworkResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetworkListResponse.
func (m ManagedVirtualNetworkListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// ManagedVirtualNetworkReference - Managed Virtual Network reference type.
type ManagedVirtualNetworkReference struct {
	// REQUIRED; Reference ManagedVirtualNetwork name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Managed Virtual Network reference type.
	Type *ManagedVirtualNetworkReferenceType `json:"type,omitempty"`
}

// ManagedVirtualNetworkResource - Managed Virtual Network resource type.
type ManagedVirtualNetworkResource struct {
	// REQUIRED; Managed Virtual Network properties.
	Properties *ManagedVirtualNetwork `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ManagedVirtualNetworksClientCreateOrUpdateOptions contains the optional parameters for the ManagedVirtualNetworksClient.CreateOrUpdate
// method.
type ManagedVirtualNetworksClientCreateOrUpdateOptions struct {
	// ETag of the managed Virtual Network entity. Should only be specified for update, for which it should match existing entity
	// or can be * for unconditional update.
	IfMatch *string
}

// ManagedVirtualNetworksClientGetOptions contains the optional parameters for the ManagedVirtualNetworksClient.Get method.
type ManagedVirtualNetworksClientGetOptions struct {
	// ETag of the managed Virtual Network entity. Should only be specified for get. If the ETag matches the existing entity tag,
	// or if * was provided, then no content will be returned.
	IfNoneMatch *string
}

// ManagedVirtualNetworksClientListByFactoryOptions contains the optional parameters for the ManagedVirtualNetworksClient.ListByFactory
// method.
type ManagedVirtualNetworksClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// MappingDataFlow - Mapping data flow.
type MappingDataFlow struct {
	// REQUIRED; Type of data flow.
	Type *string `json:"type,omitempty"`

	// List of tags that can be used for describing the data flow.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The description of the data flow.
	Description *string `json:"description,omitempty"`

	// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
	Folder *DataFlowFolder `json:"folder,omitempty"`

	// Mapping data flow type properties.
	TypeProperties *MappingDataFlowTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataFlow implements the DataFlowClassification interface for type MappingDataFlow.
func (m *MappingDataFlow) GetDataFlow() *DataFlow {
	return &DataFlow{
		Type:        m.Type,
		Description: m.Description,
		Annotations: m.Annotations,
		Folder:      m.Folder,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MappingDataFlow.
func (m MappingDataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	objectMap["type"] = "MappingDataFlow"
	populate(objectMap, "typeProperties", m.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MappingDataFlow.
func (m *MappingDataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MappingDataFlowTypeProperties - Mapping data flow type properties.
type MappingDataFlowTypeProperties struct {
	// DataFlow script.
	Script *string `json:"script,omitempty"`

	// Data flow script lines.
	ScriptLines []*string `json:"scriptLines,omitempty"`

	// List of sinks in data flow.
	Sinks []*DataFlowSink `json:"sinks,omitempty"`

	// List of sources in data flow.
	Sources []*DataFlowSource `json:"sources,omitempty"`

	// List of transformations in data flow.
	Transformations []*Transformation `json:"transformations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MappingDataFlowTypeProperties.
func (m MappingDataFlowTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "script", m.Script)
	populate(objectMap, "scriptLines", m.ScriptLines)
	populate(objectMap, "sinks", m.Sinks)
	populate(objectMap, "sources", m.Sources)
	populate(objectMap, "transformations", m.Transformations)
	return json.Marshal(objectMap)
}

// MariaDBLinkedService - MariaDB server linked service.
type MariaDBLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MariaDB server linked service properties.
	TypeProperties *MariaDBLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MariaDBLinkedService.
func (m *MariaDBLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBLinkedService.
func (m MariaDBLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MariaDB"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBLinkedService.
func (m *MariaDBLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MariaDBLinkedServiceTypeProperties - MariaDB server linked service properties.
type MariaDBLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// MariaDBSource - A copy activity MariaDB server source.
type MariaDBSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MariaDBSource.
func (m *MariaDBSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type MariaDBSource.
func (m *MariaDBSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             m.QueryTimeout,
		AdditionalColumns:        m.AdditionalColumns,
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBSource.
func (m MariaDBSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "query", m.Query)
	populate(objectMap, "queryTimeout", m.QueryTimeout)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MariaDBSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBSource.
func (m *MariaDBSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MariaDBTableDataset - MariaDB server dataset.
type MariaDBTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MariaDBTableDataset.
func (m *MariaDBTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MariaDBTableDataset.
func (m MariaDBTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MariaDBTable"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDBTableDataset.
func (m *MariaDBTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarketoLinkedService - Marketo server linked service.
type MarketoLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Marketo server linked service properties.
	TypeProperties *MarketoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MarketoLinkedService.
func (m *MarketoLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MarketoLinkedService.
func (m MarketoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "Marketo"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedService.
func (m *MarketoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarketoLinkedServiceTypeProperties - Marketo server linked service properties.
type MarketoLinkedServiceTypeProperties struct {
	// REQUIRED; The client Id of your Marketo service.
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// REQUIRED; The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// The client secret of your Marketo service.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketoLinkedServiceTypeProperties.
func (m MarketoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", m.ClientID)
	populate(objectMap, "clientSecret", m.ClientSecret)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "endpoint", m.Endpoint)
	populate(objectMap, "useEncryptedEndpoints", m.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", m.UseHostVerification)
	populate(objectMap, "usePeerVerification", m.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedServiceTypeProperties.
func (m *MarketoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &m.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			m.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &m.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &m.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &m.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &m.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &m.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarketoObjectDataset - Marketo server dataset.
type MarketoObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MarketoObjectDataset.
func (m *MarketoObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MarketoObjectDataset.
func (m MarketoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MarketoObject"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoObjectDataset.
func (m *MarketoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarketoSource - A copy activity Marketo server source.
type MarketoSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MarketoSource.
func (m *MarketoSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type MarketoSource.
func (m *MarketoSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             m.QueryTimeout,
		AdditionalColumns:        m.AdditionalColumns,
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MarketoSource.
func (m MarketoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "query", m.Query)
	populate(objectMap, "queryTimeout", m.QueryTimeout)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MarketoSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoSource.
func (m *MarketoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MetadataItem - Specify the name and value of custom metadata item.
type MetadataItem struct {
	// Metadata item key name. Type: string (or Expression with resultType string).
	Name map[string]interface{} `json:"name,omitempty"`

	// Metadata item value. Type: string (or Expression with resultType string).
	Value map[string]interface{} `json:"value,omitempty"`
}

// MicrosoftAccessLinkedService - Microsoft Access linked service.
type MicrosoftAccessLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Microsoft Access linked service properties.
	TypeProperties *MicrosoftAccessLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MicrosoftAccessLinkedService.
func (m *MicrosoftAccessLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessLinkedService.
func (m MicrosoftAccessLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MicrosoftAccess"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedService.
func (m *MicrosoftAccessLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MicrosoftAccessLinkedServiceTypeProperties - Microsoft Access linked service properties.
type MicrosoftAccessLinkedServiceTypeProperties struct {
	// REQUIRED; The non-access credential portion of the connection string as well as an optional encrypted credential. Type:
	// string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic.
	// Type: string (or Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessLinkedServiceTypeProperties.
func (m MicrosoftAccessLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", m.AuthenticationType)
	populate(objectMap, "connectionString", m.ConnectionString)
	populate(objectMap, "credential", m.Credential)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "password", m.Password)
	populate(objectMap, "userName", m.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedServiceTypeProperties.
func (m *MicrosoftAccessLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &m.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &m.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			m.Credential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &m.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			m.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &m.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MicrosoftAccessSink - A copy activity Microsoft Access sink.
type MicrosoftAccessSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type MicrosoftAccessSink.
func (m *MicrosoftAccessSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     m.Type,
		WriteBatchSize:           m.WriteBatchSize,
		WriteBatchTimeout:        m.WriteBatchTimeout,
		SinkRetryCount:           m.SinkRetryCount,
		SinkRetryWait:            m.SinkRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessSink.
func (m MicrosoftAccessSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", m.PreCopyScript)
	populate(objectMap, "sinkRetryCount", m.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", m.SinkRetryWait)
	objectMap["type"] = "MicrosoftAccessSink"
	populate(objectMap, "writeBatchSize", m.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", m.WriteBatchTimeout)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessSink.
func (m *MicrosoftAccessSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &m.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &m.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &m.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &m.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &m.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MicrosoftAccessSource - A copy activity source for Microsoft Access.
type MicrosoftAccessSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MicrosoftAccessSource.
func (m *MicrosoftAccessSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessSource.
func (m MicrosoftAccessSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "query", m.Query)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MicrosoftAccessSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessSource.
func (m *MicrosoftAccessSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MicrosoftAccessTableDataset - The Microsoft Access table dataset.
type MicrosoftAccessTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Microsoft Access table dataset properties.
	TypeProperties *MicrosoftAccessTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MicrosoftAccessTableDataset.
func (m *MicrosoftAccessTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessTableDataset.
func (m MicrosoftAccessTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MicrosoftAccessTable"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessTableDataset.
func (m *MicrosoftAccessTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MicrosoftAccessTableDatasetTypeProperties - Microsoft Access table dataset properties.
type MicrosoftAccessTableDatasetTypeProperties struct {
	// The Microsoft Access table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// MongoDbAtlasCollectionDataset - The MongoDB Atlas database dataset.
type MongoDbAtlasCollectionDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MongoDB Atlas database dataset properties.
	TypeProperties *MongoDbAtlasCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MongoDbAtlasCollectionDataset.
func (m *MongoDbAtlasCollectionDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasCollectionDataset.
func (m MongoDbAtlasCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MongoDbAtlasCollection"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasCollectionDataset.
func (m *MongoDbAtlasCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbAtlasCollectionDatasetTypeProperties - MongoDB Atlas database dataset properties.
type MongoDbAtlasCollectionDatasetTypeProperties struct {
	// REQUIRED; The collection name of the MongoDB Atlas database. Type: string (or Expression with resultType string).
	Collection map[string]interface{} `json:"collection,omitempty"`
}

// MongoDbAtlasLinkedService - Linked service for MongoDB Atlas data source.
type MongoDbAtlasLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MongoDB Atlas linked service properties.
	TypeProperties *MongoDbAtlasLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MongoDbAtlasLinkedService.
func (m *MongoDbAtlasLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasLinkedService.
func (m MongoDbAtlasLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MongoDbAtlas"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasLinkedService.
func (m *MongoDbAtlasLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbAtlasLinkedServiceTypeProperties - MongoDB Atlas linked service properties.
type MongoDbAtlasLinkedServiceTypeProperties struct {
	// REQUIRED; The MongoDB Atlas connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string,
	// SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// REQUIRED; The name of the MongoDB Atlas database that you want to access. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`
}

// MongoDbAtlasSink - A copy activity MongoDB Atlas sink.
type MongoDbAtlasSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default
	// value is "insert". Type: string (or Expression with resultType string). Type:
	// string (or Expression with resultType string).
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type MongoDbAtlasSink.
func (m *MongoDbAtlasSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     m.Type,
		WriteBatchSize:           m.WriteBatchSize,
		WriteBatchTimeout:        m.WriteBatchTimeout,
		SinkRetryCount:           m.SinkRetryCount,
		SinkRetryWait:            m.SinkRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasSink.
func (m MongoDbAtlasSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", m.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", m.SinkRetryWait)
	objectMap["type"] = "MongoDbAtlasSink"
	populate(objectMap, "writeBatchSize", m.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", m.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", m.WriteBehavior)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasSink.
func (m *MongoDbAtlasSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &m.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &m.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &m.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &m.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &m.WriteBehavior)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbAtlasSource - A copy activity source for a MongoDB Atlas database.
type MongoDbAtlasSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the number of documents to return in each batch of the response from MongoDB Atlas instance. In most cases, modifying
	// the batch size will not affect the user or the application. This
	// property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
	BatchSize map[string]interface{} `json:"batchSize,omitempty"`

	// Cursor methods for Mongodb query
	CursorMethods *MongoDbCursorMethodsProperties `json:"cursorMethods,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass
	// an empty document ({}). Type: string (or Expression with resultType string).
	Filter map[string]interface{} `json:"filter,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MongoDbAtlasSource.
func (m *MongoDbAtlasSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbAtlasSource.
func (m MongoDbAtlasSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "batchSize", m.BatchSize)
	populate(objectMap, "cursorMethods", m.CursorMethods)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "filter", m.Filter)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "queryTimeout", m.QueryTimeout)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MongoDbAtlasSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbAtlasSource.
func (m *MongoDbAtlasSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, &m.BatchSize)
			delete(rawMsg, key)
		case "cursorMethods":
			err = unpopulate(val, &m.CursorMethods)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &m.Filter)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbCollectionDataset - The MongoDB database dataset.
type MongoDbCollectionDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MongoDB database dataset properties.
	TypeProperties *MongoDbCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MongoDbCollectionDataset.
func (m *MongoDbCollectionDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionDataset.
func (m MongoDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MongoDbCollection"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCollectionDataset.
func (m *MongoDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbCollectionDatasetTypeProperties - MongoDB database dataset properties.
type MongoDbCollectionDatasetTypeProperties struct {
	// REQUIRED; The table name of the MongoDB database. Type: string (or Expression with resultType string).
	CollectionName map[string]interface{} `json:"collectionName,omitempty"`
}

// MongoDbCursorMethodsProperties - Cursor methods for Mongodb query
type MongoDbCursorMethodsProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the maximum number of documents the server returns. limit() is analogous to the LIMIT statement in a SQL database.
	// Type: integer (or Expression with resultType integer).
	Limit map[string]interface{} `json:"limit,omitempty"`

	// Specifies the fields to return in the documents that match the query filter. To return all fields in the matching documents,
	// omit this parameter. Type: string (or Expression with resultType string).
	Project map[string]interface{} `json:"project,omitempty"`

	// Specifies the how many documents skipped and where MongoDB begins returning results. This approach may be useful in implementing
	// paginated results. Type: integer (or Expression with resultType
	// integer).
	Skip map[string]interface{} `json:"skip,omitempty"`

	// Specifies the order in which the query returns matching documents. Type: string (or Expression with resultType string).
	// Type: string (or Expression with resultType string).
	Sort map[string]interface{} `json:"sort,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCursorMethodsProperties.
func (m MongoDbCursorMethodsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "limit", m.Limit)
	populate(objectMap, "project", m.Project)
	populate(objectMap, "skip", m.Skip)
	populate(objectMap, "sort", m.Sort)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCursorMethodsProperties.
func (m *MongoDbCursorMethodsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "limit":
			err = unpopulate(val, &m.Limit)
			delete(rawMsg, key)
		case "project":
			err = unpopulate(val, &m.Project)
			delete(rawMsg, key)
		case "skip":
			err = unpopulate(val, &m.Skip)
			delete(rawMsg, key)
		case "sort":
			err = unpopulate(val, &m.Sort)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbLinkedService - Linked service for MongoDb data source.
type MongoDbLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MongoDB linked service properties.
	TypeProperties *MongoDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MongoDbLinkedService.
func (m *MongoDbLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbLinkedService.
func (m MongoDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MongoDb"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedService.
func (m *MongoDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbLinkedServiceTypeProperties - MongoDB linked service properties.
type MongoDbLinkedServiceTypeProperties struct {
	// REQUIRED; The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
	DatabaseName map[string]interface{} `json:"databaseName,omitempty"`

	// REQUIRED; The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression
	// with resultType boolean).
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Database to verify the username and password. Type: string (or Expression with resultType string).
	AuthSource map[string]interface{} `json:"authSource,omitempty"`

	// The authentication type to be used to connect to the MongoDB database.
	AuthenticationType *MongoDbAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or
	// Expression with resultType boolean).
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer
	// (or Expression with resultType integer), minimum: 0.
	Port map[string]interface{} `json:"port,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbLinkedServiceTypeProperties.
func (m MongoDbLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowSelfSignedServerCert", m.AllowSelfSignedServerCert)
	populate(objectMap, "authSource", m.AuthSource)
	populate(objectMap, "authenticationType", m.AuthenticationType)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "enableSsl", m.EnableSSL)
	populate(objectMap, "encryptedCredential", m.EncryptedCredential)
	populate(objectMap, "password", m.Password)
	populate(objectMap, "port", m.Port)
	populate(objectMap, "server", m.Server)
	populate(objectMap, "username", m.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedServiceTypeProperties.
func (m *MongoDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &m.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authSource":
			err = unpopulate(val, &m.AuthSource)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &m.AuthenticationType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &m.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &m.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			m.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &m.Port)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &m.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &m.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbSource - A copy activity source for a MongoDB database.
type MongoDbSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Should be a SQL-92 query expression. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MongoDbSource.
func (m *MongoDbSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbSource.
func (m MongoDbSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "query", m.Query)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MongoDbSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbSource.
func (m *MongoDbSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbV2CollectionDataset - The MongoDB database dataset.
type MongoDbV2CollectionDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MongoDB database dataset properties.
	TypeProperties *MongoDbV2CollectionDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MongoDbV2CollectionDataset.
func (m *MongoDbV2CollectionDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2CollectionDataset.
func (m MongoDbV2CollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MongoDbV2Collection"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2CollectionDataset.
func (m *MongoDbV2CollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbV2CollectionDatasetTypeProperties - MongoDB database dataset properties.
type MongoDbV2CollectionDatasetTypeProperties struct {
	// REQUIRED; The collection name of the MongoDB database. Type: string (or Expression with resultType string).
	Collection map[string]interface{} `json:"collection,omitempty"`
}

// MongoDbV2LinkedService - Linked service for MongoDB data source.
type MongoDbV2LinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MongoDB linked service properties.
	TypeProperties *MongoDbV2LinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MongoDbV2LinkedService.
func (m *MongoDbV2LinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2LinkedService.
func (m MongoDbV2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MongoDbV2"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2LinkedService.
func (m *MongoDbV2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbV2LinkedServiceTypeProperties - MongoDB linked service properties.
type MongoDbV2LinkedServiceTypeProperties struct {
	// REQUIRED; The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// REQUIRED; The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`
}

// MongoDbV2Sink - A copy activity MongoDB sink.
type MongoDbV2Sink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default
	// value is "insert". Type: string (or Expression with resultType string). Type:
	// string (or Expression with resultType string).
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type MongoDbV2Sink.
func (m *MongoDbV2Sink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     m.Type,
		WriteBatchSize:           m.WriteBatchSize,
		WriteBatchTimeout:        m.WriteBatchTimeout,
		SinkRetryCount:           m.SinkRetryCount,
		SinkRetryWait:            m.SinkRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2Sink.
func (m MongoDbV2Sink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", m.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", m.SinkRetryWait)
	objectMap["type"] = "MongoDbV2Sink"
	populate(objectMap, "writeBatchSize", m.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", m.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", m.WriteBehavior)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2Sink.
func (m *MongoDbV2Sink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &m.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &m.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &m.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &m.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &m.WriteBehavior)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbV2Source - A copy activity source for a MongoDB database.
type MongoDbV2Source struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying
	// the batch size will not affect the user or the application. This property's
	// main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
	BatchSize map[string]interface{} `json:"batchSize,omitempty"`

	// Cursor methods for Mongodb query
	CursorMethods *MongoDbCursorMethodsProperties `json:"cursorMethods,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass
	// an empty document ({}). Type: string (or Expression with resultType string).
	Filter map[string]interface{} `json:"filter,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MongoDbV2Source.
func (m *MongoDbV2Source) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2Source.
func (m MongoDbV2Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "batchSize", m.BatchSize)
	populate(objectMap, "cursorMethods", m.CursorMethods)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "filter", m.Filter)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "queryTimeout", m.QueryTimeout)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MongoDbV2Source"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2Source.
func (m *MongoDbV2Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, &m.BatchSize)
			delete(rawMsg, key)
		case "cursorMethods":
			err = unpopulate(val, &m.CursorMethods)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &m.Filter)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MultiplePipelineTriggerClassification provides polymorphic access to related types.
// Call the interface's GetMultiplePipelineTrigger() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *BlobEventsTrigger, *BlobTrigger, *CustomEventsTrigger, *MultiplePipelineTrigger, *ScheduleTrigger
type MultiplePipelineTriggerClassification interface {
	TriggerClassification
	// GetMultiplePipelineTrigger returns the MultiplePipelineTrigger content of the underlying type.
	GetMultiplePipelineTrigger() *MultiplePipelineTrigger
}

// MultiplePipelineTrigger - Base class for all triggers that support one to many model for trigger to pipeline.
type MultiplePipelineTrigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Pipelines that need to be started.
	Pipelines []*TriggerPipelineReference `json:"pipelines,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetMultiplePipelineTrigger implements the MultiplePipelineTriggerClassification interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) GetMultiplePipelineTrigger() *MultiplePipelineTrigger { return m }

// GetTrigger implements the TriggerClassification interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 m.Type,
		Description:          m.Description,
		RuntimeState:         m.RuntimeState,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MultiplePipelineTrigger.
func (m MultiplePipelineTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "pipelines", m.Pipelines)
	populate(objectMap, "runtimeState", m.RuntimeState)
	objectMap["type"] = "MultiplePipelineTrigger"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, &m.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &m.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MySQLLinkedService - Linked service for MySQL data source.
type MySQLLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; MySQL linked service properties.
	TypeProperties *MySQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type MySQLLinkedService.
func (m *MySQLLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 m.Type,
		ConnectVia:           m.ConnectVia,
		Description:          m.Description,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MySQLLinkedService.
func (m MySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "connectVia", m.ConnectVia)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "parameters", m.Parameters)
	objectMap["type"] = "MySql"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLLinkedService.
func (m *MySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &m.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MySQLLinkedServiceTypeProperties - MySQL linked service properties.
type MySQLLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// MySQLSource - A copy activity source for MySQL databases.
type MySQLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type MySQLSource.
func (m *MySQLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type MySQLSource.
func (m *MySQLSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             m.QueryTimeout,
		AdditionalColumns:        m.AdditionalColumns,
		Type:                     m.Type,
		SourceRetryCount:         m.SourceRetryCount,
		SourceRetryWait:          m.SourceRetryWait,
		MaxConcurrentConnections: m.MaxConcurrentConnections,
		DisableMetricsCollection: m.DisableMetricsCollection,
		AdditionalProperties:     m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MySQLSource.
func (m MySQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", m.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", m.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", m.MaxConcurrentConnections)
	populate(objectMap, "query", m.Query)
	populate(objectMap, "queryTimeout", m.QueryTimeout)
	populate(objectMap, "sourceRetryCount", m.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", m.SourceRetryWait)
	objectMap["type"] = "MySqlSource"
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLSource.
func (m *MySQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &m.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &m.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &m.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &m.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &m.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &m.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MySQLTableDataset - The MySQL table dataset.
type MySQLTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// MySQL table dataset properties.
	TypeProperties *MySQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type MySQLTableDataset.
func (m *MySQLTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 m.Type,
		Description:          m.Description,
		Structure:            m.Structure,
		Schema:               m.Schema,
		LinkedServiceName:    m.LinkedServiceName,
		Parameters:           m.Parameters,
		Annotations:          m.Annotations,
		Folder:               m.Folder,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MySQLTableDataset.
func (m MySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "folder", m.Folder)
	populate(objectMap, "linkedServiceName", m.LinkedServiceName)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "schema", m.Schema)
	populate(objectMap, "structure", m.Structure)
	objectMap["type"] = "MySqlTable"
	populate(objectMap, "typeProperties", m.TypeProperties)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLTableDataset.
func (m *MySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &m.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &m.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &m.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &m.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &m.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MySQLTableDatasetTypeProperties - MySql table dataset properties.
type MySQLTableDatasetTypeProperties struct {
	// The MySQL table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// NetezzaLinkedService - Netezza linked service.
type NetezzaLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Netezza linked service properties.
	TypeProperties *NetezzaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type NetezzaLinkedService.
func (n *NetezzaLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 n.Type,
		ConnectVia:           n.ConnectVia,
		Description:          n.Description,
		Parameters:           n.Parameters,
		Annotations:          n.Annotations,
		AdditionalProperties: n.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaLinkedService.
func (n NetezzaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", n.Annotations)
	populate(objectMap, "connectVia", n.ConnectVia)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "parameters", n.Parameters)
	objectMap["type"] = "Netezza"
	populate(objectMap, "typeProperties", n.TypeProperties)
	if n.AdditionalProperties != nil {
		for key, val := range n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaLinkedService.
func (n *NetezzaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &n.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &n.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &n.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &n.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &n.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &n.TypeProperties)
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				n.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NetezzaLinkedServiceTypeProperties - Netezza linked service properties.
type NetezzaLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// NetezzaPartitionSettings - The settings that will be leveraged for Netezza source partitioning.
type NetezzaPartitionSettings struct {
	// The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression
	// with resultType string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionLowerBound map[string]interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionUpperBound map[string]interface{} `json:"partitionUpperBound,omitempty"`
}

// NetezzaSource - A copy activity Netezza source.
type NetezzaSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Netezza read in parallel. Possible values include: "None", "DataSlice", "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Netezza source partitioning.
	PartitionSettings *NetezzaPartitionSettings `json:"partitionSettings,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type NetezzaSource.
func (n *NetezzaSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     n.Type,
		SourceRetryCount:         n.SourceRetryCount,
		SourceRetryWait:          n.SourceRetryWait,
		MaxConcurrentConnections: n.MaxConcurrentConnections,
		DisableMetricsCollection: n.DisableMetricsCollection,
		AdditionalProperties:     n.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type NetezzaSource.
func (n *NetezzaSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             n.QueryTimeout,
		AdditionalColumns:        n.AdditionalColumns,
		Type:                     n.Type,
		SourceRetryCount:         n.SourceRetryCount,
		SourceRetryWait:          n.SourceRetryWait,
		MaxConcurrentConnections: n.MaxConcurrentConnections,
		DisableMetricsCollection: n.DisableMetricsCollection,
		AdditionalProperties:     n.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaSource.
func (n NetezzaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", n.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", n.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", n.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", n.PartitionOption)
	populate(objectMap, "partitionSettings", n.PartitionSettings)
	populate(objectMap, "query", n.Query)
	populate(objectMap, "queryTimeout", n.QueryTimeout)
	populate(objectMap, "sourceRetryCount", n.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", n.SourceRetryWait)
	objectMap["type"] = "NetezzaSource"
	if n.AdditionalProperties != nil {
		for key, val := range n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaSource.
func (n *NetezzaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &n.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &n.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &n.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &n.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &n.PartitionSettings)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &n.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &n.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &n.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &n.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &n.Type)
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				n.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NetezzaTableDataset - Netezza dataset.
type NetezzaTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *NetezzaTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type NetezzaTableDataset.
func (n *NetezzaTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 n.Type,
		Description:          n.Description,
		Structure:            n.Structure,
		Schema:               n.Schema,
		LinkedServiceName:    n.LinkedServiceName,
		Parameters:           n.Parameters,
		Annotations:          n.Annotations,
		Folder:               n.Folder,
		AdditionalProperties: n.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaTableDataset.
func (n NetezzaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", n.Annotations)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "folder", n.Folder)
	populate(objectMap, "linkedServiceName", n.LinkedServiceName)
	populate(objectMap, "parameters", n.Parameters)
	populate(objectMap, "schema", n.Schema)
	populate(objectMap, "structure", n.Structure)
	objectMap["type"] = "NetezzaTable"
	populate(objectMap, "typeProperties", n.TypeProperties)
	if n.AdditionalProperties != nil {
		for key, val := range n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaTableDataset.
func (n *NetezzaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &n.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &n.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &n.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &n.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &n.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &n.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &n.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &n.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &n.TypeProperties)
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				n.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NetezzaTableDatasetTypeProperties - Netezza dataset properties.
type NetezzaTableDatasetTypeProperties struct {
	// The schema name of the Netezza. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Netezza. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// ODataLinkedService - Open Data Protocol (OData) linked service.
type ODataLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; OData linked service properties.
	TypeProperties *ODataLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ODataLinkedService.
func (o *ODataLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 o.Type,
		ConnectVia:           o.ConnectVia,
		Description:          o.Description,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ODataLinkedService.
func (o ODataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "OData"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedService.
func (o *ODataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ODataLinkedServiceTypeProperties - OData linked service properties.
type ODataLinkedServiceTypeProperties struct {
	// REQUIRED; The URL of the OData service endpoint. Type: string (or Expression with resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
	AADResourceID map[string]interface{} `json:"aadResourceId,omitempty"`

	// Specify the credential type (key or cert) is used for service principal.
	AADServicePrincipalCredentialType *ODataAADServicePrincipalCredentialType `json:"aadServicePrincipalCredentialType,omitempty"`

	// The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType
	// object).
	AuthHeaders map[string]interface{} `json:"authHeaders,omitempty"`

	// Type of authentication used to connect to the OData service.
	AuthenticationType *ODataAuthenticationType `json:"authenticationType,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password of the OData service.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression
	// with resultType string).
	ServicePrincipalEmbeddedCert SecretBaseClassification `json:"servicePrincipalEmbeddedCert,omitempty"`

	// Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication.
	// Type: string (or Expression with resultType string).
	ServicePrincipalEmbeddedCertPassword SecretBaseClassification `json:"servicePrincipalEmbeddedCertPassword,omitempty"`

	// Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType
	// string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression
	// with resultType string).
	Tenant map[string]interface{} `json:"tenant,omitempty"`

	// User name of the OData service. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataLinkedServiceTypeProperties.
func (o ODataLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aadResourceId", o.AADResourceID)
	populate(objectMap, "aadServicePrincipalCredentialType", o.AADServicePrincipalCredentialType)
	populate(objectMap, "authHeaders", o.AuthHeaders)
	populate(objectMap, "authenticationType", o.AuthenticationType)
	populate(objectMap, "azureCloudType", o.AzureCloudType)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "password", o.Password)
	populate(objectMap, "servicePrincipalEmbeddedCert", o.ServicePrincipalEmbeddedCert)
	populate(objectMap, "servicePrincipalEmbeddedCertPassword", o.ServicePrincipalEmbeddedCertPassword)
	populate(objectMap, "servicePrincipalId", o.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", o.ServicePrincipalKey)
	populate(objectMap, "tenant", o.Tenant)
	populate(objectMap, "url", o.URL)
	populate(objectMap, "userName", o.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedServiceTypeProperties.
func (o *ODataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			err = unpopulate(val, &o.AADResourceID)
			delete(rawMsg, key)
		case "aadServicePrincipalCredentialType":
			err = unpopulate(val, &o.AADServicePrincipalCredentialType)
			delete(rawMsg, key)
		case "authHeaders":
			err = unpopulate(val, &o.AuthHeaders)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &o.AuthenticationType)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &o.AzureCloudType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &o.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			o.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalEmbeddedCert":
			o.ServicePrincipalEmbeddedCert, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalEmbeddedCertPassword":
			o.ServicePrincipalEmbeddedCertPassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &o.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &o.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &o.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &o.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ODataResourceDataset - The Open Data Protocol (OData) resource dataset.
type ODataResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// OData dataset properties.
	TypeProperties *ODataResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ODataResourceDataset.
func (o *ODataResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 o.Type,
		Description:          o.Description,
		Structure:            o.Structure,
		Schema:               o.Schema,
		LinkedServiceName:    o.LinkedServiceName,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		Folder:               o.Folder,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ODataResourceDataset.
func (o ODataResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populate(objectMap, "schema", o.Schema)
	populate(objectMap, "structure", o.Structure)
	objectMap["type"] = "ODataResource"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataResourceDataset.
func (o *ODataResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ODataResourceDatasetTypeProperties - OData dataset properties.
type ODataResourceDatasetTypeProperties struct {
	// The OData resource path. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// ODataSource - A copy activity source for OData source.
type ODataSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:05:00. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// OData query. For example, "$top=1". Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ODataSource.
func (o *ODataSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ODataSource.
func (o ODataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", o.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", o.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "query", o.Query)
	populate(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "ODataSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataSource.
func (o *ODataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &o.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &o.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OdbcLinkedService - Open Database Connectivity (ODBC) linked service.
type OdbcLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; ODBC linked service properties.
	TypeProperties *OdbcLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type OdbcLinkedService.
func (o *OdbcLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 o.Type,
		ConnectVia:           o.ConnectVia,
		Description:          o.Description,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OdbcLinkedService.
func (o OdbcLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "Odbc"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedService.
func (o *OdbcLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OdbcLinkedServiceTypeProperties - ODBC linked service properties.
type OdbcLinkedServiceTypeProperties struct {
	// REQUIRED; The non-access credential portion of the connection string as well as an optional encrypted credential. Type:
	// string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or
	// Expression with resultType string).
	AuthenticationType map[string]interface{} `json:"authenticationType,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcLinkedServiceTypeProperties.
func (o OdbcLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", o.AuthenticationType)
	populate(objectMap, "connectionString", o.ConnectionString)
	populate(objectMap, "credential", o.Credential)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "password", o.Password)
	populate(objectMap, "userName", o.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedServiceTypeProperties.
func (o *OdbcLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &o.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &o.ConnectionString)
			delete(rawMsg, key)
		case "credential":
			o.Credential, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &o.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			o.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &o.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OdbcSink - A copy activity ODBC sink.
type OdbcSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type OdbcSink.
func (o *OdbcSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     o.Type,
		WriteBatchSize:           o.WriteBatchSize,
		WriteBatchTimeout:        o.WriteBatchTimeout,
		SinkRetryCount:           o.SinkRetryCount,
		SinkRetryWait:            o.SinkRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OdbcSink.
func (o OdbcSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", o.PreCopyScript)
	populate(objectMap, "sinkRetryCount", o.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", o.SinkRetryWait)
	objectMap["type"] = "OdbcSink"
	populate(objectMap, "writeBatchSize", o.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", o.WriteBatchTimeout)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcSink.
func (o *OdbcSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &o.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &o.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &o.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &o.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &o.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OdbcSource - A copy activity source for ODBC databases.
type OdbcSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type OdbcSource.
func (o *OdbcSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type OdbcSource.
func (o *OdbcSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             o.QueryTimeout,
		AdditionalColumns:        o.AdditionalColumns,
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OdbcSource.
func (o OdbcSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", o.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "query", o.Query)
	populate(objectMap, "queryTimeout", o.QueryTimeout)
	populate(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "OdbcSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcSource.
func (o *OdbcSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &o.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &o.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OdbcTableDataset - The ODBC table dataset.
type OdbcTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// ODBC table dataset properties.
	TypeProperties *OdbcTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type OdbcTableDataset.
func (o *OdbcTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 o.Type,
		Description:          o.Description,
		Structure:            o.Structure,
		Schema:               o.Schema,
		LinkedServiceName:    o.LinkedServiceName,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		Folder:               o.Folder,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OdbcTableDataset.
func (o OdbcTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populate(objectMap, "schema", o.Schema)
	populate(objectMap, "structure", o.Structure)
	objectMap["type"] = "OdbcTable"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcTableDataset.
func (o *OdbcTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OdbcTableDatasetTypeProperties - ODBC table dataset properties.
type OdbcTableDatasetTypeProperties struct {
	// The ODBC table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// Office365Dataset - The Office365 account.
type Office365Dataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Office365 dataset properties.
	TypeProperties *Office365DatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type Office365Dataset.
func (o *Office365Dataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 o.Type,
		Description:          o.Description,
		Structure:            o.Structure,
		Schema:               o.Schema,
		LinkedServiceName:    o.LinkedServiceName,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		Folder:               o.Folder,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Office365Dataset.
func (o Office365Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populate(objectMap, "schema", o.Schema)
	populate(objectMap, "structure", o.Structure)
	objectMap["type"] = "Office365Table"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Dataset.
func (o *Office365Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Office365DatasetTypeProperties - Office365 dataset properties.
type Office365DatasetTypeProperties struct {
	// REQUIRED; Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`

	// A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression
	// with resultType string).
	Predicate map[string]interface{} `json:"predicate,omitempty"`
}

// Office365LinkedService - Office365 linked service.
type Office365LinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Office365 linked service properties.
	TypeProperties *Office365LinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type Office365LinkedService.
func (o *Office365LinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 o.Type,
		ConnectVia:           o.ConnectVia,
		Description:          o.Description,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Office365LinkedService.
func (o Office365LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "Office365"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedService.
func (o *Office365LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Office365LinkedServiceTypeProperties - Office365 linked service properties.
type Office365LinkedServiceTypeProperties struct {
	// REQUIRED; Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
	Office365TenantID map[string]interface{} `json:"office365TenantId,omitempty"`

	// REQUIRED; Specify the application's client ID. Type: string (or Expression with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// REQUIRED; Specify the application's key.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// REQUIRED; Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression
	// with resultType string).
	ServicePrincipalTenantID map[string]interface{} `json:"servicePrincipalTenantId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Office365LinkedServiceTypeProperties.
func (o Office365LinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "office365TenantId", o.Office365TenantID)
	populate(objectMap, "servicePrincipalId", o.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", o.ServicePrincipalKey)
	populate(objectMap, "servicePrincipalTenantId", o.ServicePrincipalTenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedServiceTypeProperties.
func (o *Office365LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &o.EncryptedCredential)
			delete(rawMsg, key)
		case "office365TenantId":
			err = unpopulate(val, &o.Office365TenantID)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &o.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalTenantId":
			err = unpopulate(val, &o.ServicePrincipalTenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Office365Source - A copy activity source for an Office 365 service.
type Office365Source struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The groups containing all the users. Type: array of strings (or Expression with resultType array of strings).
	AllowedGroups map[string]interface{} `json:"allowedGroups,omitempty"`

	// The Column to apply the and . Type: string (or Expression with resultType string).
	DateFilterColumn map[string]interface{} `json:"dateFilterColumn,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// End time of the requested range for this dataset. Type: string (or Expression with resultType string).
	EndTime map[string]interface{} `json:"endTime,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The columns to be read out from the Office 365 table. Type: array of objects (or Expression with resultType array of objects).
	// Example: [ { "name": "Id" }, { "name": "CreatedDateTime" } ]
	OutputColumns map[string]interface{} `json:"outputColumns,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Start time of the requested range for this dataset. Type: string (or Expression with resultType string).
	StartTime map[string]interface{} `json:"startTime,omitempty"`

	// The user scope uri. Type: string (or Expression with resultType string).
	UserScopeFilterURI map[string]interface{} `json:"userScopeFilterUri,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type Office365Source.
func (o *Office365Source) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Office365Source.
func (o Office365Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedGroups", o.AllowedGroups)
	populate(objectMap, "dateFilterColumn", o.DateFilterColumn)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "endTime", o.EndTime)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "outputColumns", o.OutputColumns)
	populate(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", o.SourceRetryWait)
	populate(objectMap, "startTime", o.StartTime)
	objectMap["type"] = "Office365Source"
	populate(objectMap, "userScopeFilterUri", o.UserScopeFilterURI)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Source.
func (o *Office365Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedGroups":
			err = unpopulate(val, &o.AllowedGroups)
			delete(rawMsg, key)
		case "dateFilterColumn":
			err = unpopulate(val, &o.DateFilterColumn)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulate(val, &o.EndTime)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "outputColumns":
			err = unpopulate(val, &o.OutputColumns)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &o.SourceRetryWait)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, &o.StartTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "userScopeFilterUri":
			err = unpopulate(val, &o.UserScopeFilterURI)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Operation - Azure Data Factory API operation definition.
type Operation struct {
	// Metadata associated with the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`

	// The intended executor of the operation.
	Origin *string `json:"origin,omitempty"`

	// Additional details about the operation.
	Properties *OperationProperties `json:"properties,omitempty"`
}

// OperationDisplay - Metadata associated with the operation.
type OperationDisplay struct {
	// The description of the operation.
	Description *string `json:"description,omitempty"`

	// The type of operation: get, read, delete, etc.
	Operation *string `json:"operation,omitempty"`

	// The name of the provider.
	Provider *string `json:"provider,omitempty"`

	// The name of the resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationListResponse - A list of operations that can be performed by the Data Factory service.
type OperationListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of Data Factory operations supported by the Data Factory resource provider.
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResponse.
func (o OperationListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationLogSpecification - Details about an operation related to logs.
type OperationLogSpecification struct {
	// Blobs created in the customer storage account, per hour.
	BlobDuration *string `json:"blobDuration,omitempty"`

	// Localized display name.
	DisplayName *string `json:"displayName,omitempty"`

	// The name of the log category.
	Name *string `json:"name,omitempty"`
}

// OperationMetricAvailability - Defines how often data for a metric becomes available.
type OperationMetricAvailability struct {
	// Blob created in the customer storage account, per hour.
	BlobDuration *string `json:"blobDuration,omitempty"`

	// The granularity for the metric.
	TimeGrain *string `json:"timeGrain,omitempty"`
}

// OperationMetricDimension - Defines the metric dimension.
type OperationMetricDimension struct {
	// The display name of the metric dimension.
	DisplayName *string `json:"displayName,omitempty"`

	// The name of the dimension for the metric.
	Name *string `json:"name,omitempty"`

	// Whether the dimension should be exported to Azure Monitor.
	ToBeExportedForShoebox *bool `json:"toBeExportedForShoebox,omitempty"`
}

// OperationMetricSpecification - Details about an operation related to metrics.
type OperationMetricSpecification struct {
	// The type of metric aggregation.
	AggregationType *string `json:"aggregationType,omitempty"`

	// Defines how often data for metrics becomes available.
	Availabilities []*OperationMetricAvailability `json:"availabilities,omitempty"`

	// Defines the metric dimension.
	Dimensions []*OperationMetricDimension `json:"dimensions,omitempty"`

	// The description of the metric.
	DisplayDescription *string `json:"displayDescription,omitempty"`

	// Localized display name of the metric.
	DisplayName *string `json:"displayName,omitempty"`

	// Whether or not the service is using regional MDM accounts.
	EnableRegionalMdmAccount *string `json:"enableRegionalMdmAccount,omitempty"`

	// The name of the metric.
	Name *string `json:"name,omitempty"`

	// The name of the MDM account.
	SourceMdmAccount *string `json:"sourceMdmAccount,omitempty"`

	// The name of the MDM namespace.
	SourceMdmNamespace *string `json:"sourceMdmNamespace,omitempty"`

	// The unit that the metric is measured in.
	Unit *string `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetricSpecification.
func (o OperationMetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", o.AggregationType)
	populate(objectMap, "availabilities", o.Availabilities)
	populate(objectMap, "dimensions", o.Dimensions)
	populate(objectMap, "displayDescription", o.DisplayDescription)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", o.EnableRegionalMdmAccount)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "sourceMdmAccount", o.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", o.SourceMdmNamespace)
	populate(objectMap, "unit", o.Unit)
	return json.Marshal(objectMap)
}

// OperationProperties - Additional details about an operation.
type OperationProperties struct {
	// Details about a service operation.
	ServiceSpecification *OperationServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationServiceSpecification - Details about a service operation.
type OperationServiceSpecification struct {
	// Details about operations related to logs.
	LogSpecifications []*OperationLogSpecification `json:"logSpecifications,omitempty"`

	// Details about operations related to metrics.
	MetricSpecifications []*OperationMetricSpecification `json:"metricSpecifications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationServiceSpecification.
func (o OperationServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", o.LogSpecifications)
	populate(objectMap, "metricSpecifications", o.MetricSpecifications)
	return json.Marshal(objectMap)
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// OracleCloudStorageLinkedService - Linked service for Oracle Cloud Storage.
type OracleCloudStorageLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Oracle Cloud Storage linked service properties.
	TypeProperties *OracleCloudStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type OracleCloudStorageLinkedService.
func (o *OracleCloudStorageLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 o.Type,
		ConnectVia:           o.ConnectVia,
		Description:          o.Description,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageLinkedService.
func (o OracleCloudStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "OracleCloudStorage"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageLinkedService.
func (o *OracleCloudStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleCloudStorageLinkedServiceTypeProperties - Oracle Cloud Storage linked service properties.
type OracleCloudStorageLinkedServiceTypeProperties struct {
	// The access key identifier of the Oracle Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression
	// with resultType string).
	AccessKeyID map[string]interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Oracle Cloud Storage Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the Oracle Cloud Storage Connector. This is an optional property; change
	// it only if you want to try a different service endpoint or want to switch
	// between https and http. Type: string (or Expression with resultType string).
	ServiceURL map[string]interface{} `json:"serviceUrl,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageLinkedServiceTypeProperties.
func (o OracleCloudStorageLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessKeyId", o.AccessKeyID)
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "secretAccessKey", o.SecretAccessKey)
	populate(objectMap, "serviceUrl", o.ServiceURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageLinkedServiceTypeProperties.
func (o *OracleCloudStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			err = unpopulate(val, &o.AccessKeyID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &o.EncryptedCredential)
			delete(rawMsg, key)
		case "secretAccessKey":
			o.SecretAccessKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "serviceUrl":
			err = unpopulate(val, &o.ServiceURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleCloudStorageLocation - The location of Oracle Cloud Storage dataset.
type OracleCloudStorageLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the bucketName of Oracle Cloud Storage. Type: string (or Expression with resultType string)
	BucketName map[string]interface{} `json:"bucketName,omitempty"`

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`

	// Specify the version of Oracle Cloud Storage. Type: string (or Expression with resultType string).
	Version map[string]interface{} `json:"version,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type OracleCloudStorageLocation.
func (o *OracleCloudStorageLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 o.Type,
		FolderPath:           o.FolderPath,
		FileName:             o.FileName,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageLocation.
func (o OracleCloudStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bucketName", o.BucketName)
	populate(objectMap, "fileName", o.FileName)
	populate(objectMap, "folderPath", o.FolderPath)
	objectMap["type"] = "OracleCloudStorageLocation"
	populate(objectMap, "version", o.Version)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageLocation.
func (o *OracleCloudStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			err = unpopulate(val, &o.BucketName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &o.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &o.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &o.Version)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleCloudStorageReadSettings - Oracle Cloud Storage read settings.
type OracleCloudStorageReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// The prefix filter for the Oracle Cloud Storage object name. Type: string (or Expression with resultType string).
	Prefix map[string]interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Oracle Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Oracle Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type OracleCloudStorageReadSettings.
func (o *OracleCloudStorageReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     o.Type,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleCloudStorageReadSettings.
func (o OracleCloudStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", o.DeleteFilesAfterCompletion)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", o.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", o.FileListPath)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", o.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", o.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", o.PartitionRootPath)
	populate(objectMap, "prefix", o.Prefix)
	populate(objectMap, "recursive", o.Recursive)
	objectMap["type"] = "OracleCloudStorageReadSettings"
	populate(objectMap, "wildcardFileName", o.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", o.WildcardFolderPath)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleCloudStorageReadSettings.
func (o *OracleCloudStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &o.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &o.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &o.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &o.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &o.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &o.PartitionRootPath)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, &o.Prefix)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &o.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &o.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &o.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleLinkedService - Oracle database.
type OracleLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Oracle database linked service properties.
	TypeProperties *OracleLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type OracleLinkedService.
func (o *OracleLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 o.Type,
		ConnectVia:           o.ConnectVia,
		Description:          o.Description,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleLinkedService.
func (o OracleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "Oracle"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleLinkedService.
func (o *OracleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleLinkedServiceTypeProperties - Oracle database linked service properties.
type OracleLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// OraclePartitionSettings - The settings that will be leveraged for Oracle source partitioning.
type OraclePartitionSettings struct {
	// The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression
	// with resultType string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionLowerBound map[string]interface{} `json:"partitionLowerBound,omitempty"`

	// Names of the physical partitions of Oracle table.
	PartitionNames map[string]interface{} `json:"partitionNames,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionUpperBound map[string]interface{} `json:"partitionUpperBound,omitempty"`
}

// OracleServiceCloudLinkedService - Oracle Service Cloud linked service.
type OracleServiceCloudLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Oracle Service Cloud linked service properties.
	TypeProperties *OracleServiceCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type OracleServiceCloudLinkedService.
func (o *OracleServiceCloudLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 o.Type,
		ConnectVia:           o.ConnectVia,
		Description:          o.Description,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudLinkedService.
func (o OracleServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "connectVia", o.ConnectVia)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "parameters", o.Parameters)
	objectMap["type"] = "OracleServiceCloud"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedService.
func (o *OracleServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &o.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleServiceCloudLinkedServiceTypeProperties - Oracle Service Cloud linked service properties.
type OracleServiceCloudLinkedServiceTypeProperties struct {
	// REQUIRED; The URL of the Oracle Service Cloud instance.
	Host map[string]interface{} `json:"host,omitempty"`

	// REQUIRED; The password corresponding to the user name that you provided in the username key.
	Password SecretBaseClassification `json:"password,omitempty"`

	// REQUIRED; The user name that you use to access Oracle Service Cloud server.
	Username map[string]interface{} `json:"username,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
	// with resultType boolean).
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true. Type: boolean (or Expression with
	// resultType boolean).
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudLinkedServiceTypeProperties.
func (o OracleServiceCloudLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", o.EncryptedCredential)
	populate(objectMap, "host", o.Host)
	populate(objectMap, "password", o.Password)
	populate(objectMap, "useEncryptedEndpoints", o.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", o.UseHostVerification)
	populate(objectMap, "usePeerVerification", o.UsePeerVerification)
	populate(objectMap, "username", o.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedServiceTypeProperties.
func (o *OracleServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &o.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &o.Host)
			delete(rawMsg, key)
		case "password":
			o.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &o.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &o.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &o.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &o.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleServiceCloudObjectDataset - Oracle Service Cloud dataset.
type OracleServiceCloudObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type OracleServiceCloudObjectDataset.
func (o *OracleServiceCloudObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 o.Type,
		Description:          o.Description,
		Structure:            o.Structure,
		Schema:               o.Schema,
		LinkedServiceName:    o.LinkedServiceName,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		Folder:               o.Folder,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudObjectDataset.
func (o OracleServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populate(objectMap, "schema", o.Schema)
	populate(objectMap, "structure", o.Structure)
	objectMap["type"] = "OracleServiceCloudObject"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudObjectDataset.
func (o *OracleServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleServiceCloudSource - A copy activity Oracle Service Cloud source.
type OracleServiceCloudSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type OracleServiceCloudSource.
func (o *OracleServiceCloudSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type OracleServiceCloudSource.
func (o *OracleServiceCloudSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             o.QueryTimeout,
		AdditionalColumns:        o.AdditionalColumns,
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudSource.
func (o OracleServiceCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", o.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "query", o.Query)
	populate(objectMap, "queryTimeout", o.QueryTimeout)
	populate(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "OracleServiceCloudSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudSource.
func (o *OracleServiceCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &o.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &o.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleSink - A copy activity Oracle sink.
type OracleSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type OracleSink.
func (o *OracleSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     o.Type,
		WriteBatchSize:           o.WriteBatchSize,
		WriteBatchTimeout:        o.WriteBatchTimeout,
		SinkRetryCount:           o.SinkRetryCount,
		SinkRetryWait:            o.SinkRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleSink.
func (o OracleSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", o.PreCopyScript)
	populate(objectMap, "sinkRetryCount", o.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", o.SinkRetryWait)
	objectMap["type"] = "OracleSink"
	populate(objectMap, "writeBatchSize", o.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", o.WriteBatchTimeout)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSink.
func (o *OracleSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &o.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &o.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &o.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &o.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &o.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleSource - A copy activity Oracle source.
type OracleSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Oracle reader query. Type: string (or Expression with resultType string).
	OracleReaderQuery map[string]interface{} `json:"oracleReaderQuery,omitempty"`

	// The partition mechanism that will be used for Oracle read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Oracle source partitioning.
	PartitionSettings *OraclePartitionSettings `json:"partitionSettings,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type OracleSource.
func (o *OracleSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleSource.
func (o OracleSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", o.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "oracleReaderQuery", o.OracleReaderQuery)
	populate(objectMap, "partitionOption", o.PartitionOption)
	populate(objectMap, "partitionSettings", o.PartitionSettings)
	populate(objectMap, "queryTimeout", o.QueryTimeout)
	populate(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", o.SourceRetryWait)
	objectMap["type"] = "OracleSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSource.
func (o *OracleSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "oracleReaderQuery":
			err = unpopulate(val, &o.OracleReaderQuery)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &o.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &o.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &o.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &o.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleTableDataset - The on-premises Oracle database dataset.
type OracleTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// On-premises Oracle dataset properties.
	TypeProperties *OracleTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type OracleTableDataset.
func (o *OracleTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 o.Type,
		Description:          o.Description,
		Structure:            o.Structure,
		Schema:               o.Schema,
		LinkedServiceName:    o.LinkedServiceName,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		Folder:               o.Folder,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleTableDataset.
func (o OracleTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populate(objectMap, "schema", o.Schema)
	populate(objectMap, "structure", o.Structure)
	objectMap["type"] = "OracleTable"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleTableDataset.
func (o *OracleTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleTableDatasetTypeProperties - On-premises Oracle dataset properties.
type OracleTableDatasetTypeProperties struct {
	// The schema name of the on-premises Oracle database. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// OrcDataset - ORC dataset.
type OrcDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// ORC dataset properties.
	TypeProperties *OrcDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type OrcDataset.
func (o *OrcDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 o.Type,
		Description:          o.Description,
		Structure:            o.Structure,
		Schema:               o.Schema,
		LinkedServiceName:    o.LinkedServiceName,
		Parameters:           o.Parameters,
		Annotations:          o.Annotations,
		Folder:               o.Folder,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OrcDataset.
func (o OrcDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "folder", o.Folder)
	populate(objectMap, "linkedServiceName", o.LinkedServiceName)
	populate(objectMap, "parameters", o.Parameters)
	populate(objectMap, "schema", o.Schema)
	populate(objectMap, "structure", o.Structure)
	objectMap["type"] = "Orc"
	populate(objectMap, "typeProperties", o.TypeProperties)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDataset.
func (o *OrcDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &o.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &o.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &o.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &o.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &o.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &o.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &o.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &o.TypeProperties)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OrcDatasetTypeProperties - ORC dataset properties.
type OrcDatasetTypeProperties struct {
	// REQUIRED; The location of the ORC data storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data orcCompressionCodec. Type: string (or Expression with resultType string).
	OrcCompressionCodec map[string]interface{} `json:"orcCompressionCodec,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OrcDatasetTypeProperties.
func (o OrcDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", o.Location)
	populate(objectMap, "orcCompressionCodec", o.OrcCompressionCodec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDatasetTypeProperties.
func (o *OrcDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			o.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "orcCompressionCodec":
			err = unpopulate(val, &o.OrcCompressionCodec)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OrcFormat - The data stored in Optimized Row Columnar (ORC) format.
type OrcFormat struct {
	// REQUIRED; Type of dataset storage format.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer map[string]interface{} `json:"deserializer,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer map[string]interface{} `json:"serializer,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type OrcFormat.
func (o *OrcFormat) GetDatasetStorageFormat() *DatasetStorageFormat {
	return &DatasetStorageFormat{
		Type:                 o.Type,
		Serializer:           o.Serializer,
		Deserializer:         o.Deserializer,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OrcFormat.
func (o OrcFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deserializer", o.Deserializer)
	populate(objectMap, "serializer", o.Serializer)
	objectMap["type"] = "OrcFormat"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcFormat.
func (o *OrcFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, &o.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, &o.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OrcSink - A copy activity ORC sink.
type OrcSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// ORC format settings.
	FormatSettings *OrcWriteSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// ORC store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type OrcSink.
func (o *OrcSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     o.Type,
		WriteBatchSize:           o.WriteBatchSize,
		WriteBatchTimeout:        o.WriteBatchTimeout,
		SinkRetryCount:           o.SinkRetryCount,
		SinkRetryWait:            o.SinkRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OrcSink.
func (o OrcSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "formatSettings", o.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", o.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", o.SinkRetryWait)
	populate(objectMap, "storeSettings", o.StoreSettings)
	objectMap["type"] = "OrcSink"
	populate(objectMap, "writeBatchSize", o.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", o.WriteBatchTimeout)
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcSink.
func (o *OrcSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &o.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &o.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &o.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			o.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &o.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &o.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OrcSource - A copy activity ORC source.
type OrcSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// ORC store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type OrcSource.
func (o *OrcSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     o.Type,
		SourceRetryCount:         o.SourceRetryCount,
		SourceRetryWait:          o.SourceRetryWait,
		MaxConcurrentConnections: o.MaxConcurrentConnections,
		DisableMetricsCollection: o.DisableMetricsCollection,
		AdditionalProperties:     o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OrcSource.
func (o OrcSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", o.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", o.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", o.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", o.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", o.SourceRetryWait)
	populate(objectMap, "storeSettings", o.StoreSettings)
	objectMap["type"] = "OrcSource"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcSource.
func (o *OrcSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &o.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &o.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &o.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &o.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &o.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			o.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OrcWriteSettings - Orc write settings.
type OrcWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the file name pattern _. when copy from non-file based store without partitionOptions. Type: string (or Expression
	// with resultType string).
	FileNamePrefix map[string]interface{} `json:"fileNamePrefix,omitempty"`

	// Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with
	// resultType integer).
	MaxRowsPerFile map[string]interface{} `json:"maxRowsPerFile,omitempty"`
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type OrcWriteSettings.
func (o *OrcWriteSettings) GetFormatWriteSettings() *FormatWriteSettings {
	return &FormatWriteSettings{
		Type:                 o.Type,
		AdditionalProperties: o.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OrcWriteSettings.
func (o OrcWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileNamePrefix", o.FileNamePrefix)
	populate(objectMap, "maxRowsPerFile", o.MaxRowsPerFile)
	objectMap["type"] = "OrcWriteSettings"
	if o.AdditionalProperties != nil {
		for key, val := range o.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcWriteSettings.
func (o *OrcWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileNamePrefix":
			err = unpopulate(val, &o.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, &o.MaxRowsPerFile)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		default:
			if o.AdditionalProperties == nil {
				o.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				o.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PackageStore - Package store for the SSIS integration runtime.
type PackageStore struct {
	// REQUIRED; The name of the package store
	Name *string `json:"name,omitempty"`

	// REQUIRED; The package store linked service reference.
	PackageStoreLinkedService *EntityReference `json:"packageStoreLinkedService,omitempty"`
}

// ParameterSpecification - Definition of a single parameter for an entity.
type ParameterSpecification struct {
	// REQUIRED; Parameter type.
	Type *ParameterType `json:"type,omitempty"`

	// Default value of parameter.
	DefaultValue map[string]interface{} `json:"defaultValue,omitempty"`
}

// ParquetDataset - Parquet dataset.
type ParquetDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Parquet dataset properties.
	TypeProperties *ParquetDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ParquetDataset.
func (p *ParquetDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 p.Type,
		Description:          p.Description,
		Structure:            p.Structure,
		Schema:               p.Schema,
		LinkedServiceName:    p.LinkedServiceName,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		Folder:               p.Folder,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ParquetDataset.
func (p ParquetDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "schema", p.Schema)
	populate(objectMap, "structure", p.Structure)
	objectMap["type"] = "Parquet"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDataset.
func (p *ParquetDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ParquetDatasetTypeProperties - Parquet dataset properties.
type ParquetDatasetTypeProperties struct {
	// REQUIRED; The location of the parquet storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data compressionCodec. Type: string (or Expression with resultType string).
	CompressionCodec map[string]interface{} `json:"compressionCodec,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParquetDatasetTypeProperties.
func (p ParquetDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compressionCodec", p.CompressionCodec)
	populate(objectMap, "location", p.Location)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDatasetTypeProperties.
func (p *ParquetDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionCodec":
			err = unpopulate(val, &p.CompressionCodec)
			delete(rawMsg, key)
		case "location":
			p.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ParquetFormat - The data stored in Parquet format.
type ParquetFormat struct {
	// REQUIRED; Type of dataset storage format.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer map[string]interface{} `json:"deserializer,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer map[string]interface{} `json:"serializer,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type ParquetFormat.
func (p *ParquetFormat) GetDatasetStorageFormat() *DatasetStorageFormat {
	return &DatasetStorageFormat{
		Type:                 p.Type,
		Serializer:           p.Serializer,
		Deserializer:         p.Deserializer,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ParquetFormat.
func (p ParquetFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deserializer", p.Deserializer)
	populate(objectMap, "serializer", p.Serializer)
	objectMap["type"] = "ParquetFormat"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetFormat.
func (p *ParquetFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			err = unpopulate(val, &p.Deserializer)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, &p.Serializer)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ParquetSink - A copy activity Parquet sink.
type ParquetSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Parquet format settings.
	FormatSettings *ParquetWriteSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Parquet store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type ParquetSink.
func (p *ParquetSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     p.Type,
		WriteBatchSize:           p.WriteBatchSize,
		WriteBatchTimeout:        p.WriteBatchTimeout,
		SinkRetryCount:           p.SinkRetryCount,
		SinkRetryWait:            p.SinkRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSink.
func (p ParquetSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "formatSettings", p.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", p.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", p.SinkRetryWait)
	populate(objectMap, "storeSettings", p.StoreSettings)
	objectMap["type"] = "ParquetSink"
	populate(objectMap, "writeBatchSize", p.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", p.WriteBatchTimeout)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSink.
func (p *ParquetSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &p.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &p.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &p.SinkRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			p.StoreSettings, err = unmarshalStoreWriteSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &p.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &p.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ParquetSource - A copy activity Parquet source.
type ParquetSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Parquet store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ParquetSource.
func (p *ParquetSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSource.
func (p ParquetSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", p.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", p.SourceRetryWait)
	populate(objectMap, "storeSettings", p.StoreSettings)
	objectMap["type"] = "ParquetSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSource.
func (p *ParquetSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &p.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			p.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ParquetWriteSettings - Parquet write settings.
type ParquetWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the file name pattern _. when copy from non-file based store without partitionOptions. Type: string (or Expression
	// with resultType string).
	FileNamePrefix map[string]interface{} `json:"fileNamePrefix,omitempty"`

	// Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with
	// resultType integer).
	MaxRowsPerFile map[string]interface{} `json:"maxRowsPerFile,omitempty"`
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type ParquetWriteSettings.
func (p *ParquetWriteSettings) GetFormatWriteSettings() *FormatWriteSettings {
	return &FormatWriteSettings{
		Type:                 p.Type,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ParquetWriteSettings.
func (p ParquetWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileNamePrefix", p.FileNamePrefix)
	populate(objectMap, "maxRowsPerFile", p.MaxRowsPerFile)
	objectMap["type"] = "ParquetWriteSettings"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetWriteSettings.
func (p *ParquetWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileNamePrefix":
			err = unpopulate(val, &p.FileNamePrefix)
			delete(rawMsg, key)
		case "maxRowsPerFile":
			err = unpopulate(val, &p.MaxRowsPerFile)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PaypalLinkedService - Paypal Service linked service.
type PaypalLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Paypal Service linked service properties.
	TypeProperties *PaypalLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type PaypalLinkedService.
func (p *PaypalLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 p.Type,
		ConnectVia:           p.ConnectVia,
		Description:          p.Description,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PaypalLinkedService.
func (p PaypalLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "Paypal"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedService.
func (p *PaypalLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PaypalLinkedServiceTypeProperties - Paypal Service linked service properties.
type PaypalLinkedServiceTypeProperties struct {
	// REQUIRED; The client ID associated with your PayPal application.
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// REQUIRED; The URL of the PayPal instance. (i.e. api.sandbox.paypal.com)
	Host map[string]interface{} `json:"host,omitempty"`

	// The client secret associated with your PayPal application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaypalLinkedServiceTypeProperties.
func (p PaypalLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", p.ClientID)
	populate(objectMap, "clientSecret", p.ClientSecret)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populate(objectMap, "host", p.Host)
	populate(objectMap, "useEncryptedEndpoints", p.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", p.UseHostVerification)
	populate(objectMap, "usePeerVerification", p.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedServiceTypeProperties.
func (p *PaypalLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &p.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			p.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &p.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &p.Host)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &p.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &p.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &p.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PaypalObjectDataset - Paypal Service dataset.
type PaypalObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type PaypalObjectDataset.
func (p *PaypalObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 p.Type,
		Description:          p.Description,
		Structure:            p.Structure,
		Schema:               p.Schema,
		LinkedServiceName:    p.LinkedServiceName,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		Folder:               p.Folder,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PaypalObjectDataset.
func (p PaypalObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "schema", p.Schema)
	populate(objectMap, "structure", p.Structure)
	objectMap["type"] = "PaypalObject"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalObjectDataset.
func (p *PaypalObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PaypalSource - A copy activity Paypal Service source.
type PaypalSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type PaypalSource.
func (p *PaypalSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type PaypalSource.
func (p *PaypalSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             p.QueryTimeout,
		AdditionalColumns:        p.AdditionalColumns,
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PaypalSource.
func (p PaypalSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", p.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populate(objectMap, "query", p.Query)
	populate(objectMap, "queryTimeout", p.QueryTimeout)
	populate(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PaypalSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalSource.
func (p *PaypalSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PhoenixDatasetTypeProperties - Phoenix Dataset Properties
type PhoenixDatasetTypeProperties struct {
	// The schema name of the Phoenix. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Phoenix. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// PhoenixLinkedService - Phoenix server linked service.
type PhoenixLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Phoenix server linked service properties.
	TypeProperties *PhoenixLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type PhoenixLinkedService.
func (p *PhoenixLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 p.Type,
		ConnectVia:           p.ConnectVia,
		Description:          p.Description,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixLinkedService.
func (p PhoenixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "Phoenix"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedService.
func (p *PhoenixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PhoenixLinkedServiceTypeProperties - Phoenix server linked service properties.
type PhoenixLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication mechanism used to connect to the Phoenix server.
	AuthenticationType *PhoenixAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
	Host map[string]interface{} `json:"host,omitempty"`

	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCNMismatch map[string]interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix
	// if using WindowsAzureHDInsightService.
	HTTPPath map[string]interface{} `json:"httpPath,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
	Port map[string]interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to connect to the Phoenix server.
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixLinkedServiceTypeProperties.
func (p PhoenixLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowHostNameCNMismatch", p.AllowHostNameCNMismatch)
	populate(objectMap, "allowSelfSignedServerCert", p.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", p.AuthenticationType)
	populate(objectMap, "enableSsl", p.EnableSSL)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populate(objectMap, "httpPath", p.HTTPPath)
	populate(objectMap, "host", p.Host)
	populate(objectMap, "password", p.Password)
	populate(objectMap, "port", p.Port)
	populate(objectMap, "trustedCertPath", p.TrustedCertPath)
	populate(objectMap, "useSystemTrustStore", p.UseSystemTrustStore)
	populate(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedServiceTypeProperties.
func (p *PhoenixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, &p.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &p.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &p.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &p.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &p.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, &p.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &p.Host)
			delete(rawMsg, key)
		case "password":
			p.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &p.Port)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &p.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &p.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PhoenixObjectDataset - Phoenix server dataset.
type PhoenixObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *PhoenixDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type PhoenixObjectDataset.
func (p *PhoenixObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 p.Type,
		Description:          p.Description,
		Structure:            p.Structure,
		Schema:               p.Schema,
		LinkedServiceName:    p.LinkedServiceName,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		Folder:               p.Folder,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixObjectDataset.
func (p PhoenixObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "schema", p.Schema)
	populate(objectMap, "structure", p.Structure)
	objectMap["type"] = "PhoenixObject"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixObjectDataset.
func (p *PhoenixObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PhoenixSource - A copy activity Phoenix server source.
type PhoenixSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type PhoenixSource.
func (p *PhoenixSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type PhoenixSource.
func (p *PhoenixSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             p.QueryTimeout,
		AdditionalColumns:        p.AdditionalColumns,
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixSource.
func (p PhoenixSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", p.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populate(objectMap, "query", p.Query)
	populate(objectMap, "queryTimeout", p.QueryTimeout)
	populate(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PhoenixSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixSource.
func (p *PhoenixSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Pipeline - A data factory pipeline.
type Pipeline struct {
	// List of activities in pipeline.
	Activities []ActivityClassification `json:"activities,omitempty"`

	// List of tags that can be used for describing the Pipeline.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The max number of concurrent runs for the pipeline.
	Concurrency *int32 `json:"concurrency,omitempty"`

	// The description of the pipeline.
	Description *string `json:"description,omitempty"`

	// The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
	Folder *PipelineFolder `json:"folder,omitempty"`

	// List of parameters for pipeline.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Pipeline Policy.
	Policy *PipelinePolicy `json:"policy,omitempty"`

	// Dimensions emitted by Pipeline.
	RunDimensions map[string]map[string]interface{} `json:"runDimensions,omitempty"`

	// List of variables for pipeline.
	Variables map[string]*VariableSpecification `json:"variables,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Pipeline.
func (p Pipeline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activities", p.Activities)
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "concurrency", p.Concurrency)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "policy", p.Policy)
	populate(objectMap, "runDimensions", p.RunDimensions)
	populate(objectMap, "variables", p.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Pipeline.
func (p *Pipeline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			p.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "concurrency":
			err = unpopulate(val, &p.Concurrency)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &p.Folder)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &p.Policy)
			delete(rawMsg, key)
		case "runDimensions":
			err = unpopulate(val, &p.RunDimensions)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, &p.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineElapsedTimeMetricPolicy - Pipeline ElapsedTime Metric Policy.
type PipelineElapsedTimeMetricPolicy struct {
	// TimeSpan value, after which an Azure Monitoring Metric is fired.
	Duration map[string]interface{} `json:"duration,omitempty"`
}

// PipelineFolder - The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
type PipelineFolder struct {
	// The name of the folder that this Pipeline is in.
	Name *string `json:"name,omitempty"`
}

// PipelineListResponse - A list of pipeline resources.
type PipelineListResponse struct {
	// REQUIRED; List of pipelines.
	Value []*PipelineResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineListResponse.
func (p PipelineListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PipelinePolicy - Pipeline Policy.
type PipelinePolicy struct {
	// Pipeline ElapsedTime Metric Policy.
	ElapsedTimeMetric *PipelineElapsedTimeMetricPolicy `json:"elapsedTimeMetric,omitempty"`
}

// PipelineReference - Pipeline reference type.
type PipelineReference struct {
	// REQUIRED; Reference pipeline name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Pipeline reference type.
	Type *PipelineReferenceType `json:"type,omitempty"`

	// Reference name.
	Name *string `json:"name,omitempty"`
}

// PipelineResource - Pipeline resource type.
type PipelineResource struct {
	// REQUIRED; Properties of the pipeline.
	Properties *Pipeline `json:"properties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineResource.
func (p PipelineResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineResource.
func (p *PipelineResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineRun - Information about a pipeline run.
type PipelineRun struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The duration of a pipeline run.
	DurationInMs *int32 `json:"durationInMs,omitempty" azure:"ro"`

	// READ-ONLY; Entity that started the pipeline run.
	InvokedBy *PipelineRunInvokedBy `json:"invokedBy,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if the recovered pipeline run is the latest in its group.
	IsLatest *bool `json:"isLatest,omitempty" azure:"ro"`

	// READ-ONLY; The last updated timestamp for the pipeline run event in ISO8601 format.
	LastUpdated *time.Time `json:"lastUpdated,omitempty" azure:"ro"`

	// READ-ONLY; The message from a pipeline run.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The full or partial list of parameter name, value pair used in the pipeline run.
	Parameters map[string]*string `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; The pipeline name.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// READ-ONLY; Run dimensions emitted by Pipeline run.
	RunDimensions map[string]*string `json:"runDimensions,omitempty" azure:"ro"`

	// READ-ONLY; The end time of a pipeline run in ISO8601 format.
	RunEnd *time.Time `json:"runEnd,omitempty" azure:"ro"`

	// READ-ONLY; Identifier that correlates all the recovery runs of a pipeline run.
	RunGroupID *string `json:"runGroupId,omitempty" azure:"ro"`

	// READ-ONLY; Identifier of a run.
	RunID *string `json:"runId,omitempty" azure:"ro"`

	// READ-ONLY; The start time of a pipeline run in ISO8601 format.
	RunStart *time.Time `json:"runStart,omitempty" azure:"ro"`

	// READ-ONLY; The status of a pipeline run. Possible values: Queued, InProgress, Succeeded, Failed, Canceling, Cancelled
	Status *string `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRun.
func (p PipelineRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "durationInMs", p.DurationInMs)
	populate(objectMap, "invokedBy", p.InvokedBy)
	populate(objectMap, "isLatest", p.IsLatest)
	populateTimeRFC3339(objectMap, "lastUpdated", p.LastUpdated)
	populate(objectMap, "message", p.Message)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "pipelineName", p.PipelineName)
	populate(objectMap, "runDimensions", p.RunDimensions)
	populateTimeRFC3339(objectMap, "runEnd", p.RunEnd)
	populate(objectMap, "runGroupId", p.RunGroupID)
	populate(objectMap, "runId", p.RunID)
	populateTimeRFC3339(objectMap, "runStart", p.RunStart)
	populate(objectMap, "status", p.Status)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRun.
func (p *PipelineRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "durationInMs":
			err = unpopulate(val, &p.DurationInMs)
			delete(rawMsg, key)
		case "invokedBy":
			err = unpopulate(val, &p.InvokedBy)
			delete(rawMsg, key)
		case "isLatest":
			err = unpopulate(val, &p.IsLatest)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateTimeRFC3339(val, &p.LastUpdated)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &p.Message)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "pipelineName":
			err = unpopulate(val, &p.PipelineName)
			delete(rawMsg, key)
		case "runDimensions":
			err = unpopulate(val, &p.RunDimensions)
			delete(rawMsg, key)
		case "runEnd":
			err = unpopulateTimeRFC3339(val, &p.RunEnd)
			delete(rawMsg, key)
		case "runGroupId":
			err = unpopulate(val, &p.RunGroupID)
			delete(rawMsg, key)
		case "runId":
			err = unpopulate(val, &p.RunID)
			delete(rawMsg, key)
		case "runStart":
			err = unpopulateTimeRFC3339(val, &p.RunStart)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &p.Status)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineRunInvokedBy - Provides entity name and id that started the pipeline run.
type PipelineRunInvokedBy struct {
	// READ-ONLY; The ID of the entity that started the run.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The type of the entity that started the run.
	InvokedByType *string `json:"invokedByType,omitempty" azure:"ro"`

	// READ-ONLY; Name of the entity that started the pipeline run.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The name of the pipeline that triggered the run, if any.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// READ-ONLY; The run id of the pipeline that triggered the run, if any.
	PipelineRunID *string `json:"pipelineRunId,omitempty" azure:"ro"`
}

// PipelineRunsClientCancelOptions contains the optional parameters for the PipelineRunsClient.Cancel method.
type PipelineRunsClientCancelOptions struct {
	// If true, cancel all the Child pipelines that are triggered by the current pipeline.
	IsRecursive *bool
}

// PipelineRunsClientGetOptions contains the optional parameters for the PipelineRunsClient.Get method.
type PipelineRunsClientGetOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunsClientQueryByFactoryOptions contains the optional parameters for the PipelineRunsClient.QueryByFactory method.
type PipelineRunsClientQueryByFactoryOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunsQueryResponse - A list pipeline runs.
type PipelineRunsQueryResponse struct {
	// REQUIRED; List of pipeline runs.
	Value []*PipelineRun `json:"value,omitempty"`

	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRunsQueryResponse.
func (p PipelineRunsQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "continuationToken", p.ContinuationToken)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PipelinesClientCreateOrUpdateOptions contains the optional parameters for the PipelinesClient.CreateOrUpdate method.
type PipelinesClientCreateOrUpdateOptions struct {
	// ETag of the pipeline entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// PipelinesClientCreateRunOptions contains the optional parameters for the PipelinesClient.CreateRun method.
type PipelinesClientCreateRunOptions struct {
	// Recovery mode flag. If recovery mode is set to true, the specified referenced pipeline run and the new run will be grouped
	// under the same groupId.
	IsRecovery *bool
	// Parameters of the pipeline run. These parameters will be used only if the runId is not specified.
	Parameters map[string]map[string]interface{}
	// The pipeline run identifier. If run ID is specified the parameters of the specified run will be used to create a new run.
	ReferencePipelineRunID *string
	// In recovery mode, the rerun will start from this activity. If not specified, all activities will run.
	StartActivityName *string
	// In recovery mode, if set to true, the rerun will start from failed activities. The property will be used only if startActivityName
	// is not specified.
	StartFromFailure *bool
}

// PipelinesClientDeleteOptions contains the optional parameters for the PipelinesClient.Delete method.
type PipelinesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// PipelinesClientGetOptions contains the optional parameters for the PipelinesClient.Get method.
type PipelinesClientGetOptions struct {
	// ETag of the pipeline entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// PipelinesClientListByFactoryOptions contains the optional parameters for the PipelinesClient.ListByFactory method.
type PipelinesClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// PolybaseSettings - PolyBase settings.
type PolybaseSettings struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Determines the number of rows to attempt to retrieve before the PolyBase recalculates the percentage of rejected rows.
	// Type: integer (or Expression with resultType integer), minimum: 0.
	RejectSampleValue map[string]interface{} `json:"rejectSampleValue,omitempty"`

	// Reject type.
	RejectType *PolybaseSettingsRejectType `json:"rejectType,omitempty"`

	// Specifies the value or the percentage of rows that can be rejected before the query fails. Type: number (or Expression
	// with resultType number), minimum: 0.
	RejectValue map[string]interface{} `json:"rejectValue,omitempty"`

	// Specifies how to handle missing values in delimited text files when PolyBase retrieves data from the text file. Type: boolean
	// (or Expression with resultType boolean).
	UseTypeDefault map[string]interface{} `json:"useTypeDefault,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolybaseSettings.
func (p PolybaseSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rejectSampleValue", p.RejectSampleValue)
	populate(objectMap, "rejectType", p.RejectType)
	populate(objectMap, "rejectValue", p.RejectValue)
	populate(objectMap, "useTypeDefault", p.UseTypeDefault)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolybaseSettings.
func (p *PolybaseSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rejectSampleValue":
			err = unpopulate(val, &p.RejectSampleValue)
			delete(rawMsg, key)
		case "rejectType":
			err = unpopulate(val, &p.RejectType)
			delete(rawMsg, key)
		case "rejectValue":
			err = unpopulate(val, &p.RejectValue)
			delete(rawMsg, key)
		case "useTypeDefault":
			err = unpopulate(val, &p.UseTypeDefault)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PostgreSQLLinkedService - Linked service for PostgreSQL data source.
type PostgreSQLLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; PostgreSQL linked service properties.
	TypeProperties *PostgreSQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type PostgreSQLLinkedService.
func (p *PostgreSQLLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 p.Type,
		ConnectVia:           p.ConnectVia,
		Description:          p.Description,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLLinkedService.
func (p PostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "PostgreSql"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLLinkedService.
func (p *PostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PostgreSQLLinkedServiceTypeProperties - PostgreSQL linked service properties.
type PostgreSQLLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// PostgreSQLSource - A copy activity source for PostgreSQL databases.
type PostgreSQLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type PostgreSQLSource.
func (p *PostgreSQLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type PostgreSQLSource.
func (p *PostgreSQLSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             p.QueryTimeout,
		AdditionalColumns:        p.AdditionalColumns,
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLSource.
func (p PostgreSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", p.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populate(objectMap, "query", p.Query)
	populate(objectMap, "queryTimeout", p.QueryTimeout)
	populate(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PostgreSqlSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLSource.
func (p *PostgreSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PostgreSQLTableDataset - The PostgreSQL table dataset.
type PostgreSQLTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// PostgreSQL table dataset properties.
	TypeProperties *PostgreSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type PostgreSQLTableDataset.
func (p *PostgreSQLTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 p.Type,
		Description:          p.Description,
		Structure:            p.Structure,
		Schema:               p.Schema,
		LinkedServiceName:    p.LinkedServiceName,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		Folder:               p.Folder,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLTableDataset.
func (p PostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "schema", p.Schema)
	populate(objectMap, "structure", p.Structure)
	objectMap["type"] = "PostgreSqlTable"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLTableDataset.
func (p *PostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PostgreSQLTableDatasetTypeProperties - PostgreSQL table dataset properties.
type PostgreSQLTableDatasetTypeProperties struct {
	// The PostgreSQL schema name. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The PostgreSQL table name. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// PowerQuerySink - Power query sink.
type PowerQuerySink struct {
	// REQUIRED; Transformation name.
	Name *string `json:"name,omitempty"`

	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Flowlet Reference
	Flowlet *DataFlowReference `json:"flowlet,omitempty"`

	// Linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`

	// Schema linked service reference.
	SchemaLinkedService *LinkedServiceReference `json:"schemaLinkedService,omitempty"`

	// sink script.
	Script *string `json:"script,omitempty"`
}

// PowerQuerySinkMapping - Map Power Query mashup query to sink dataset(s).
type PowerQuerySinkMapping struct {
	// List of sinks mapped to Power Query mashup query.
	DataflowSinks []*PowerQuerySink `json:"dataflowSinks,omitempty"`

	// Name of the query in Power Query mashup document.
	QueryName *string `json:"queryName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PowerQuerySinkMapping.
func (p PowerQuerySinkMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataflowSinks", p.DataflowSinks)
	populate(objectMap, "queryName", p.QueryName)
	return json.Marshal(objectMap)
}

// PowerQuerySource - Power query source.
type PowerQuerySource struct {
	// REQUIRED; Transformation name.
	Name *string `json:"name,omitempty"`

	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Flowlet Reference
	Flowlet *DataFlowReference `json:"flowlet,omitempty"`

	// Linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`

	// Schema linked service reference.
	SchemaLinkedService *LinkedServiceReference `json:"schemaLinkedService,omitempty"`

	// source script.
	Script *string `json:"script,omitempty"`
}

// PowerQueryTypeProperties - Power Query data flow type properties.
type PowerQueryTypeProperties struct {
	// Locale of the Power query mashup document.
	DocumentLocale *string `json:"documentLocale,omitempty"`

	// Power query mashup script.
	Script *string `json:"script,omitempty"`

	// List of sources in Power Query.
	Sources []*PowerQuerySource `json:"sources,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PowerQueryTypeProperties.
func (p PowerQueryTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "documentLocale", p.DocumentLocale)
	populate(objectMap, "script", p.Script)
	populate(objectMap, "sources", p.Sources)
	return json.Marshal(objectMap)
}

// PrestoDatasetTypeProperties - Presto Dataset Properties
type PrestoDatasetTypeProperties struct {
	// The schema name of the Presto. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Presto. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// PrestoLinkedService - Presto server linked service.
type PrestoLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Presto server linked service properties.
	TypeProperties *PrestoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type PrestoLinkedService.
func (p *PrestoLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 p.Type,
		ConnectVia:           p.ConnectVia,
		Description:          p.Description,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PrestoLinkedService.
func (p PrestoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "connectVia", p.ConnectVia)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = "Presto"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedService.
func (p *PrestoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &p.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PrestoLinkedServiceTypeProperties - Presto server linked service properties.
type PrestoLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication mechanism used to connect to the Presto server.
	AuthenticationType *PrestoAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The catalog context for all request against the server.
	Catalog map[string]interface{} `json:"catalog,omitempty"`

	// REQUIRED; The IP address or host name of the Presto server. (i.e. 192.168.222.160)
	Host map[string]interface{} `json:"host,omitempty"`

	// REQUIRED; The version of the Presto server. (i.e. 0.148-t)
	ServerVersion map[string]interface{} `json:"serverVersion,omitempty"`

	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCNMismatch map[string]interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
	Port map[string]interface{} `json:"port,omitempty"`

	// The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database.
	// The default value is the system time zone.
	TimeZoneID map[string]interface{} `json:"timeZoneID,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to connect to the Presto server.
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrestoLinkedServiceTypeProperties.
func (p PrestoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowHostNameCNMismatch", p.AllowHostNameCNMismatch)
	populate(objectMap, "allowSelfSignedServerCert", p.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", p.AuthenticationType)
	populate(objectMap, "catalog", p.Catalog)
	populate(objectMap, "enableSsl", p.EnableSSL)
	populate(objectMap, "encryptedCredential", p.EncryptedCredential)
	populate(objectMap, "host", p.Host)
	populate(objectMap, "password", p.Password)
	populate(objectMap, "port", p.Port)
	populate(objectMap, "serverVersion", p.ServerVersion)
	populate(objectMap, "timeZoneID", p.TimeZoneID)
	populate(objectMap, "trustedCertPath", p.TrustedCertPath)
	populate(objectMap, "useSystemTrustStore", p.UseSystemTrustStore)
	populate(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedServiceTypeProperties.
func (p *PrestoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, &p.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &p.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &p.AuthenticationType)
			delete(rawMsg, key)
		case "catalog":
			err = unpopulate(val, &p.Catalog)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &p.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &p.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &p.Host)
			delete(rawMsg, key)
		case "password":
			p.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &p.Port)
			delete(rawMsg, key)
		case "serverVersion":
			err = unpopulate(val, &p.ServerVersion)
			delete(rawMsg, key)
		case "timeZoneID":
			err = unpopulate(val, &p.TimeZoneID)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &p.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &p.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PrestoObjectDataset - Presto server dataset.
type PrestoObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *PrestoDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type PrestoObjectDataset.
func (p *PrestoObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 p.Type,
		Description:          p.Description,
		Structure:            p.Structure,
		Schema:               p.Schema,
		LinkedServiceName:    p.LinkedServiceName,
		Parameters:           p.Parameters,
		Annotations:          p.Annotations,
		Folder:               p.Folder,
		AdditionalProperties: p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PrestoObjectDataset.
func (p PrestoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", p.Annotations)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "folder", p.Folder)
	populate(objectMap, "linkedServiceName", p.LinkedServiceName)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "schema", p.Schema)
	populate(objectMap, "structure", p.Structure)
	objectMap["type"] = "PrestoObject"
	populate(objectMap, "typeProperties", p.TypeProperties)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoObjectDataset.
func (p *PrestoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &p.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &p.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &p.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &p.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &p.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &p.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &p.TypeProperties)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PrestoSource - A copy activity Presto server source.
type PrestoSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type PrestoSource.
func (p *PrestoSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type PrestoSource.
func (p *PrestoSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             p.QueryTimeout,
		AdditionalColumns:        p.AdditionalColumns,
		Type:                     p.Type,
		SourceRetryCount:         p.SourceRetryCount,
		SourceRetryWait:          p.SourceRetryWait,
		MaxConcurrentConnections: p.MaxConcurrentConnections,
		DisableMetricsCollection: p.DisableMetricsCollection,
		AdditionalProperties:     p.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PrestoSource.
func (p PrestoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", p.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", p.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", p.MaxConcurrentConnections)
	populate(objectMap, "query", p.Query)
	populate(objectMap, "queryTimeout", p.QueryTimeout)
	populate(objectMap, "sourceRetryCount", p.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", p.SourceRetryWait)
	objectMap["type"] = "PrestoSource"
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoSource.
func (p *PrestoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &p.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &p.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &p.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &p.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &p.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &p.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &p.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PrivateEndPointConnectionsClientListByFactoryOptions contains the optional parameters for the PrivateEndPointConnectionsClient.ListByFactory
// method.
type PrivateEndPointConnectionsClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionClientCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnectionClient.CreateOrUpdate
// method.
type PrivateEndpointConnectionClientCreateOrUpdateOptions struct {
	// ETag of the private endpoint connection entity. Should only be specified for update, for which it should match existing
	// entity or can be * for unconditional update.
	IfMatch *string
}

// PrivateEndpointConnectionClientDeleteOptions contains the optional parameters for the PrivateEndpointConnectionClient.Delete
// method.
type PrivateEndpointConnectionClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionClientGetOptions contains the optional parameters for the PrivateEndpointConnectionClient.Get
// method.
type PrivateEndpointConnectionClientGetOptions struct {
	// ETag of the private endpoint connection entity. Should only be specified for get. If the ETag matches the existing entity
	// tag, or if * was provided, then no content will be returned.
	IfNoneMatch *string
}

// PrivateEndpointConnectionListResponse - A list of linked service resources.
type PrivateEndpointConnectionListResponse struct {
	// REQUIRED; List of Private Endpoint Connections.
	Value []*PrivateEndpointConnectionResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResponse.
func (p PrivateEndpointConnectionListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionResource - Private Endpoint Connection ARM resource.
type PrivateEndpointConnectionResource struct {
	// Core resource properties
	Properties *RemotePrivateEndpointConnection `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkConnectionApprovalRequest - A request to approve or reject a private endpoint connection
type PrivateLinkConnectionApprovalRequest struct {
	// The state of a private link connection
	PrivateLinkServiceConnectionState *PrivateLinkConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
}

// PrivateLinkConnectionApprovalRequestResource - Private Endpoint Connection Approval ARM resource.
type PrivateLinkConnectionApprovalRequestResource struct {
	// Core resource properties
	Properties *PrivateLinkConnectionApprovalRequest `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkConnectionState - The state of a private link connection
type PrivateLinkConnectionState struct {
	// ActionsRequired for a private link connection
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description of a private link connection
	Description *string `json:"description,omitempty"`

	// Status of a private link connection
	Status *string `json:"status,omitempty"`
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	// Core resource properties
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkResourceProperties - Properties of a private link resource
type PrivateLinkResourceProperties struct {
	// READ-ONLY; GroupId of a private link resource
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; RequiredMembers of a private link resource
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`

	// READ-ONLY; RequiredZoneNames of a private link resource
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesClientGetOptions contains the optional parameters for the PrivateLinkResourcesClient.Get method.
type PrivateLinkResourcesClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesWrapper - Wrapper for a collection of private link resources
type PrivateLinkResourcesWrapper struct {
	// REQUIRED
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourcesWrapper.
func (p PrivateLinkResourcesWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// QueryDataFlowDebugSessionsResponse - A list of active debug sessions.
type QueryDataFlowDebugSessionsResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// Array with all active debug sessions.
	Value []*DataFlowDebugSessionInfo `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryDataFlowDebugSessionsResponse.
func (q QueryDataFlowDebugSessionsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", q.NextLink)
	populate(objectMap, "value", q.Value)
	return json.Marshal(objectMap)
}

// QuickBooksLinkedService - QuickBooks server linked service.
type QuickBooksLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; QuickBooks server linked service properties.
	TypeProperties *QuickBooksLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type QuickBooksLinkedService.
func (q *QuickBooksLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 q.Type,
		ConnectVia:           q.ConnectVia,
		Description:          q.Description,
		Parameters:           q.Parameters,
		Annotations:          q.Annotations,
		AdditionalProperties: q.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksLinkedService.
func (q QuickBooksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", q.Annotations)
	populate(objectMap, "connectVia", q.ConnectVia)
	populate(objectMap, "description", q.Description)
	populate(objectMap, "parameters", q.Parameters)
	objectMap["type"] = "QuickBooks"
	populate(objectMap, "typeProperties", q.TypeProperties)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedService.
func (q *QuickBooksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &q.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &q.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &q.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &q.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &q.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &q.TypeProperties)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QuickBooksLinkedServiceTypeProperties - QuickBooks server linked service properties.
type QuickBooksLinkedServiceTypeProperties struct {
	// The access token for OAuth 1.0 authentication.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The access token secret for OAuth 1.0 authentication.
	AccessTokenSecret SecretBaseClassification `json:"accessTokenSecret,omitempty"`

	// The company ID of the QuickBooks company to authorize.
	CompanyID map[string]interface{} `json:"companyId,omitempty"`

	// Properties used to connect to QuickBooks. It is mutually exclusive with any other properties in the linked service. Type:
	// object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The consumer key for OAuth 1.0 authentication.
	ConsumerKey map[string]interface{} `json:"consumerKey,omitempty"`

	// The consumer secret for OAuth 1.0 authentication.
	ConsumerSecret SecretBaseClassification `json:"consumerSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksLinkedServiceTypeProperties.
func (q QuickBooksLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", q.AccessToken)
	populate(objectMap, "accessTokenSecret", q.AccessTokenSecret)
	populate(objectMap, "companyId", q.CompanyID)
	populate(objectMap, "connectionProperties", q.ConnectionProperties)
	populate(objectMap, "consumerKey", q.ConsumerKey)
	populate(objectMap, "consumerSecret", q.ConsumerSecret)
	populate(objectMap, "encryptedCredential", q.EncryptedCredential)
	populate(objectMap, "endpoint", q.Endpoint)
	populate(objectMap, "useEncryptedEndpoints", q.UseEncryptedEndpoints)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedServiceTypeProperties.
func (q *QuickBooksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			q.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "accessTokenSecret":
			q.AccessTokenSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "companyId":
			err = unpopulate(val, &q.CompanyID)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, &q.ConnectionProperties)
			delete(rawMsg, key)
		case "consumerKey":
			err = unpopulate(val, &q.ConsumerKey)
			delete(rawMsg, key)
		case "consumerSecret":
			q.ConsumerSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &q.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &q.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &q.UseEncryptedEndpoints)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QuickBooksObjectDataset - QuickBooks server dataset.
type QuickBooksObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type QuickBooksObjectDataset.
func (q *QuickBooksObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 q.Type,
		Description:          q.Description,
		Structure:            q.Structure,
		Schema:               q.Schema,
		LinkedServiceName:    q.LinkedServiceName,
		Parameters:           q.Parameters,
		Annotations:          q.Annotations,
		Folder:               q.Folder,
		AdditionalProperties: q.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksObjectDataset.
func (q QuickBooksObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", q.Annotations)
	populate(objectMap, "description", q.Description)
	populate(objectMap, "folder", q.Folder)
	populate(objectMap, "linkedServiceName", q.LinkedServiceName)
	populate(objectMap, "parameters", q.Parameters)
	populate(objectMap, "schema", q.Schema)
	populate(objectMap, "structure", q.Structure)
	objectMap["type"] = "QuickBooksObject"
	populate(objectMap, "typeProperties", q.TypeProperties)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksObjectDataset.
func (q *QuickBooksObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &q.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &q.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &q.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &q.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &q.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &q.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &q.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &q.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &q.TypeProperties)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QuickBooksSource - A copy activity QuickBooks server source.
type QuickBooksSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type QuickBooksSource.
func (q *QuickBooksSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     q.Type,
		SourceRetryCount:         q.SourceRetryCount,
		SourceRetryWait:          q.SourceRetryWait,
		MaxConcurrentConnections: q.MaxConcurrentConnections,
		DisableMetricsCollection: q.DisableMetricsCollection,
		AdditionalProperties:     q.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type QuickBooksSource.
func (q *QuickBooksSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             q.QueryTimeout,
		AdditionalColumns:        q.AdditionalColumns,
		Type:                     q.Type,
		SourceRetryCount:         q.SourceRetryCount,
		SourceRetryWait:          q.SourceRetryWait,
		MaxConcurrentConnections: q.MaxConcurrentConnections,
		DisableMetricsCollection: q.DisableMetricsCollection,
		AdditionalProperties:     q.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksSource.
func (q QuickBooksSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", q.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", q.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", q.MaxConcurrentConnections)
	populate(objectMap, "query", q.Query)
	populate(objectMap, "queryTimeout", q.QueryTimeout)
	populate(objectMap, "sourceRetryCount", q.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", q.SourceRetryWait)
	objectMap["type"] = "QuickBooksSource"
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksSource.
func (q *QuickBooksSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &q.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &q.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &q.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &q.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &q.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &q.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &q.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &q.Type)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RecurrenceSchedule - The recurrence schedule.
type RecurrenceSchedule struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The hours.
	Hours []*int32 `json:"hours,omitempty"`

	// The minutes.
	Minutes []*int32 `json:"minutes,omitempty"`

	// The month days.
	MonthDays []*int32 `json:"monthDays,omitempty"`

	// The monthly occurrences.
	MonthlyOccurrences []*RecurrenceScheduleOccurrence `json:"monthlyOccurrences,omitempty"`

	// The days of the week.
	WeekDays []*DaysOfWeek `json:"weekDays,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecurrenceSchedule.
func (r RecurrenceSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hours", r.Hours)
	populate(objectMap, "minutes", r.Minutes)
	populate(objectMap, "monthDays", r.MonthDays)
	populate(objectMap, "monthlyOccurrences", r.MonthlyOccurrences)
	populate(objectMap, "weekDays", r.WeekDays)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecurrenceSchedule.
func (r *RecurrenceSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hours":
			err = unpopulate(val, &r.Hours)
			delete(rawMsg, key)
		case "minutes":
			err = unpopulate(val, &r.Minutes)
			delete(rawMsg, key)
		case "monthDays":
			err = unpopulate(val, &r.MonthDays)
			delete(rawMsg, key)
		case "monthlyOccurrences":
			err = unpopulate(val, &r.MonthlyOccurrences)
			delete(rawMsg, key)
		case "weekDays":
			err = unpopulate(val, &r.WeekDays)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RecurrenceScheduleOccurrence - The recurrence schedule occurrence.
type RecurrenceScheduleOccurrence struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The day of the week.
	Day *DayOfWeek `json:"day,omitempty"`

	// The occurrence.
	Occurrence *int32 `json:"occurrence,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecurrenceScheduleOccurrence.
func (r RecurrenceScheduleOccurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "day", r.Day)
	populate(objectMap, "occurrence", r.Occurrence)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecurrenceScheduleOccurrence.
func (r *RecurrenceScheduleOccurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "day":
			err = unpopulate(val, &r.Day)
			delete(rawMsg, key)
		case "occurrence":
			err = unpopulate(val, &r.Occurrence)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RedirectIncompatibleRowSettings - Redirect incompatible row settings
type RedirectIncompatibleRowSettings struct {
	// REQUIRED; Name of the Azure Storage, Storage SAS, or Azure Data Lake Store linked service used for redirecting incompatible
	// row. Must be specified if redirectIncompatibleRowSettings is specified. Type: string
	// (or Expression with resultType string).
	LinkedServiceName map[string]interface{} `json:"linkedServiceName,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The path for storing the redirect incompatible row data. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedirectIncompatibleRowSettings.
func (r RedirectIncompatibleRowSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "path", r.Path)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedirectIncompatibleRowSettings.
func (r *RedirectIncompatibleRowSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			err = unpopulate(val, &r.LinkedServiceName)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, &r.Path)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RedshiftUnloadSettings - The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with
// unload. With this, data from Amazon Redshift source will be unloaded into S3 first and then copied into
// the targeted sink from the interim S3.
type RedshiftUnloadSettings struct {
	// REQUIRED; The bucket of the interim Amazon S3 which will be used to store the unloaded data from Amazon Redshift source.
	// The bucket must be in the same region as the Amazon Redshift source. Type: string (or
	// Expression with resultType string).
	BucketName map[string]interface{} `json:"bucketName,omitempty"`

	// REQUIRED; The name of the Amazon S3 linked service which will be used for the unload operation when copying from the Amazon
	// Redshift source.
	S3LinkedServiceName *LinkedServiceReference `json:"s3LinkedServiceName,omitempty"`
}

// RelationalSource - A copy activity source for various relational databases.
type RelationalSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type RelationalSource.
func (r *RelationalSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     r.Type,
		SourceRetryCount:         r.SourceRetryCount,
		SourceRetryWait:          r.SourceRetryWait,
		MaxConcurrentConnections: r.MaxConcurrentConnections,
		DisableMetricsCollection: r.DisableMetricsCollection,
		AdditionalProperties:     r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RelationalSource.
func (r RelationalSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", r.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populate(objectMap, "query", r.Query)
	populate(objectMap, "sourceRetryCount", r.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", r.SourceRetryWait)
	objectMap["type"] = "RelationalSource"
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalSource.
func (r *RelationalSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &r.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &r.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &r.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &r.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RelationalTableDataset - The relational table dataset.
type RelationalTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Relational table dataset properties.
	TypeProperties *RelationalTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type RelationalTableDataset.
func (r *RelationalTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 r.Type,
		Description:          r.Description,
		Structure:            r.Structure,
		Schema:               r.Schema,
		LinkedServiceName:    r.LinkedServiceName,
		Parameters:           r.Parameters,
		Annotations:          r.Annotations,
		Folder:               r.Folder,
		AdditionalProperties: r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RelationalTableDataset.
func (r RelationalTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "folder", r.Folder)
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "parameters", r.Parameters)
	populate(objectMap, "schema", r.Schema)
	populate(objectMap, "structure", r.Structure)
	objectMap["type"] = "RelationalTable"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalTableDataset.
func (r *RelationalTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &r.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &r.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &r.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &r.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &r.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RelationalTableDatasetTypeProperties - Relational table dataset properties.
type RelationalTableDatasetTypeProperties struct {
	// The relational table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// RemotePrivateEndpointConnection - A remote private endpoint connection
type RemotePrivateEndpointConnection struct {
	// PrivateEndpoint of a remote private endpoint connection
	PrivateEndpoint *ArmIDWrapper `json:"privateEndpoint,omitempty"`

	// The state of a private link connection
	PrivateLinkServiceConnectionState *PrivateLinkConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// RerunTumblingWindowTrigger - Trigger that schedules pipeline reruns for all fixed time interval windows from a requested
// start time to requested end time.
type RerunTumblingWindowTrigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Rerun Trigger properties.
	TypeProperties *RerunTumblingWindowTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetTrigger implements the TriggerClassification interface for type RerunTumblingWindowTrigger.
func (r *RerunTumblingWindowTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 r.Type,
		Description:          r.Description,
		RuntimeState:         r.RuntimeState,
		Annotations:          r.Annotations,
		AdditionalProperties: r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTrigger.
func (r RerunTumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "runtimeState", r.RuntimeState)
	objectMap["type"] = "RerunTumblingWindowTrigger"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTrigger.
func (r *RerunTumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &r.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RerunTumblingWindowTriggerTypeProperties - Rerun Trigger properties.
type RerunTumblingWindowTriggerTypeProperties struct {
	// REQUIRED; The parent trigger reference.
	ParentTrigger map[string]interface{} `json:"parentTrigger,omitempty"`

	// REQUIRED; The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
	RequestedEndTime *time.Time `json:"requestedEndTime,omitempty"`

	// REQUIRED; The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
	RequestedStartTime *time.Time `json:"requestedStartTime,omitempty"`

	// REQUIRED; The max number of parallel time windows (ready for execution) for which a rerun is triggered.
	RerunConcurrency *int32 `json:"rerunConcurrency,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r RerunTumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parentTrigger", r.ParentTrigger)
	populateTimeRFC3339(objectMap, "requestedEndTime", r.RequestedEndTime)
	populateTimeRFC3339(objectMap, "requestedStartTime", r.RequestedStartTime)
	populate(objectMap, "rerunConcurrency", r.RerunConcurrency)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r *RerunTumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parentTrigger":
			err = unpopulate(val, &r.ParentTrigger)
			delete(rawMsg, key)
		case "requestedEndTime":
			err = unpopulateTimeRFC3339(val, &r.RequestedEndTime)
			delete(rawMsg, key)
		case "requestedStartTime":
			err = unpopulateTimeRFC3339(val, &r.RequestedStartTime)
			delete(rawMsg, key)
		case "rerunConcurrency":
			err = unpopulate(val, &r.RerunConcurrency)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - Azure Data Factory top-level resource.
type Resource struct {
	// The resource location.
	Location *string `json:"location,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", r.ETag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// ResponsysLinkedService - Responsys linked service.
type ResponsysLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Responsys linked service properties.
	TypeProperties *ResponsysLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ResponsysLinkedService.
func (r *ResponsysLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 r.Type,
		ConnectVia:           r.ConnectVia,
		Description:          r.Description,
		Parameters:           r.Parameters,
		Annotations:          r.Annotations,
		AdditionalProperties: r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysLinkedService.
func (r ResponsysLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "connectVia", r.ConnectVia)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "parameters", r.Parameters)
	objectMap["type"] = "Responsys"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedService.
func (r *ResponsysLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &r.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &r.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &r.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResponsysLinkedServiceTypeProperties - Responsys linked service properties.
type ResponsysLinkedServiceTypeProperties struct {
	// REQUIRED; The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// REQUIRED; The endpoint of the Responsys server.
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
	// with resultType boolean).
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true. Type: boolean (or Expression with
	// resultType boolean).
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysLinkedServiceTypeProperties.
func (r ResponsysLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", r.ClientID)
	populate(objectMap, "clientSecret", r.ClientSecret)
	populate(objectMap, "encryptedCredential", r.EncryptedCredential)
	populate(objectMap, "endpoint", r.Endpoint)
	populate(objectMap, "useEncryptedEndpoints", r.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", r.UseHostVerification)
	populate(objectMap, "usePeerVerification", r.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedServiceTypeProperties.
func (r *ResponsysLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &r.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			r.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &r.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &r.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &r.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &r.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &r.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResponsysObjectDataset - Responsys dataset.
type ResponsysObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ResponsysObjectDataset.
func (r *ResponsysObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 r.Type,
		Description:          r.Description,
		Structure:            r.Structure,
		Schema:               r.Schema,
		LinkedServiceName:    r.LinkedServiceName,
		Parameters:           r.Parameters,
		Annotations:          r.Annotations,
		Folder:               r.Folder,
		AdditionalProperties: r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysObjectDataset.
func (r ResponsysObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "folder", r.Folder)
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "parameters", r.Parameters)
	populate(objectMap, "schema", r.Schema)
	populate(objectMap, "structure", r.Structure)
	objectMap["type"] = "ResponsysObject"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysObjectDataset.
func (r *ResponsysObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &r.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &r.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &r.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &r.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &r.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResponsysSource - A copy activity Responsys source.
type ResponsysSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ResponsysSource.
func (r *ResponsysSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     r.Type,
		SourceRetryCount:         r.SourceRetryCount,
		SourceRetryWait:          r.SourceRetryWait,
		MaxConcurrentConnections: r.MaxConcurrentConnections,
		DisableMetricsCollection: r.DisableMetricsCollection,
		AdditionalProperties:     r.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type ResponsysSource.
func (r *ResponsysSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             r.QueryTimeout,
		AdditionalColumns:        r.AdditionalColumns,
		Type:                     r.Type,
		SourceRetryCount:         r.SourceRetryCount,
		SourceRetryWait:          r.SourceRetryWait,
		MaxConcurrentConnections: r.MaxConcurrentConnections,
		DisableMetricsCollection: r.DisableMetricsCollection,
		AdditionalProperties:     r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysSource.
func (r ResponsysSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", r.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populate(objectMap, "query", r.Query)
	populate(objectMap, "queryTimeout", r.QueryTimeout)
	populate(objectMap, "sourceRetryCount", r.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", r.SourceRetryWait)
	objectMap["type"] = "ResponsysSource"
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysSource.
func (r *ResponsysSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &r.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &r.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &r.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &r.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &r.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RestResourceDataset - A Rest service dataset.
type RestResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *RestResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type RestResourceDataset.
func (r *RestResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 r.Type,
		Description:          r.Description,
		Structure:            r.Structure,
		Schema:               r.Schema,
		LinkedServiceName:    r.LinkedServiceName,
		Parameters:           r.Parameters,
		Annotations:          r.Annotations,
		Folder:               r.Folder,
		AdditionalProperties: r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RestResourceDataset.
func (r RestResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "folder", r.Folder)
	populate(objectMap, "linkedServiceName", r.LinkedServiceName)
	populate(objectMap, "parameters", r.Parameters)
	populate(objectMap, "schema", r.Schema)
	populate(objectMap, "structure", r.Structure)
	objectMap["type"] = "RestResource"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestResourceDataset.
func (r *RestResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &r.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &r.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &r.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &r.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &r.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &r.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RestResourceDatasetTypeProperties - Properties specific to this dataset type.
type RestResourceDatasetTypeProperties struct {
	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders map[string]interface{} `json:"additionalHeaders,omitempty"`

	// The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
	PaginationRules map[string]interface{} `json:"paginationRules,omitempty"`

	// The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
	RelativeURL map[string]interface{} `json:"relativeUrl,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody map[string]interface{} `json:"requestBody,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod map[string]interface{} `json:"requestMethod,omitempty"`
}

// RestServiceLinkedService - Rest Service linked service.
type RestServiceLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Rest Service linked service properties.
	TypeProperties *RestServiceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type RestServiceLinkedService.
func (r *RestServiceLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 r.Type,
		ConnectVia:           r.ConnectVia,
		Description:          r.Description,
		Parameters:           r.Parameters,
		Annotations:          r.Annotations,
		AdditionalProperties: r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RestServiceLinkedService.
func (r RestServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", r.Annotations)
	populate(objectMap, "connectVia", r.ConnectVia)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "parameters", r.Parameters)
	objectMap["type"] = "RestService"
	populate(objectMap, "typeProperties", r.TypeProperties)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedService.
func (r *RestServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &r.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &r.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &r.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &r.TypeProperties)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RestServiceLinkedServiceTypeProperties - Rest Service linked service properties.
type RestServiceLinkedServiceTypeProperties struct {
	// REQUIRED; Type of authentication used to connect to the REST service.
	AuthenticationType *RestServiceAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The base URL of the REST service.
	URL map[string]interface{} `json:"url,omitempty"`

	// The resource you are requesting authorization to use.
	AADResourceID map[string]interface{} `json:"aadResourceId,omitempty"`

	// The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType
	// object).
	AuthHeaders map[string]interface{} `json:"authHeaders,omitempty"`

	// Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment,
	// AzureGermany. Default value is the data factory regions cloud type. Type:
	// string (or Expression with resultType string).
	AzureCloudType map[string]interface{} `json:"azureCloudType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	EnableServerCertificateValidation map[string]interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password used in Basic authentication type.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The application's client ID used in AadServicePrincipal authentication type.
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The application's key used in AadServicePrincipal authentication type.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application
	// resides.
	Tenant map[string]interface{} `json:"tenant,omitempty"`

	// The user name used in Basic authentication type.
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestServiceLinkedServiceTypeProperties.
func (r RestServiceLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aadResourceId", r.AADResourceID)
	populate(objectMap, "authHeaders", r.AuthHeaders)
	populate(objectMap, "authenticationType", r.AuthenticationType)
	populate(objectMap, "azureCloudType", r.AzureCloudType)
	populate(objectMap, "credential", r.Credential)
	populate(objectMap, "enableServerCertificateValidation", r.EnableServerCertificateValidation)
	populate(objectMap, "encryptedCredential", r.EncryptedCredential)
	populate(objectMap, "password", r.Password)
	populate(objectMap, "servicePrincipalId", r.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", r.ServicePrincipalKey)
	populate(objectMap, "tenant", r.Tenant)
	populate(objectMap, "url", r.URL)
	populate(objectMap, "userName", r.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedServiceTypeProperties.
func (r *RestServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			err = unpopulate(val, &r.AADResourceID)
			delete(rawMsg, key)
		case "authHeaders":
			err = unpopulate(val, &r.AuthHeaders)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &r.AuthenticationType)
			delete(rawMsg, key)
		case "azureCloudType":
			err = unpopulate(val, &r.AzureCloudType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &r.Credential)
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			err = unpopulate(val, &r.EnableServerCertificateValidation)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &r.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			r.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &r.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			r.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &r.Tenant)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &r.URL)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &r.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RestSink - A copy activity Rest service Sink.
type RestSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders map[string]interface{} `json:"additionalHeaders,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Http Compression Type to Send data in compressed format with Optimal Compression Level, Default is None. And The Only Supported
	// option is Gzip.
	HTTPCompressionType map[string]interface{} `json:"httpCompressionType,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:01:40. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The time to await before sending next request, in milliseconds
	RequestInterval map[string]interface{} `json:"requestInterval,omitempty"`

	// The HTTP method used to call the RESTful API. The default is POST. Type: string (or Expression with resultType string).
	RequestMethod map[string]interface{} `json:"requestMethod,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type RestSink.
func (r *RestSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     r.Type,
		WriteBatchSize:           r.WriteBatchSize,
		WriteBatchTimeout:        r.WriteBatchTimeout,
		SinkRetryCount:           r.SinkRetryCount,
		SinkRetryWait:            r.SinkRetryWait,
		MaxConcurrentConnections: r.MaxConcurrentConnections,
		DisableMetricsCollection: r.DisableMetricsCollection,
		AdditionalProperties:     r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RestSink.
func (r RestSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalHeaders", r.AdditionalHeaders)
	populate(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populate(objectMap, "httpCompressionType", r.HTTPCompressionType)
	populate(objectMap, "httpRequestTimeout", r.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populate(objectMap, "requestInterval", r.RequestInterval)
	populate(objectMap, "requestMethod", r.RequestMethod)
	populate(objectMap, "sinkRetryCount", r.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", r.SinkRetryWait)
	objectMap["type"] = "RestSink"
	populate(objectMap, "writeBatchSize", r.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", r.WriteBatchTimeout)
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestSink.
func (r *RestSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			err = unpopulate(val, &r.AdditionalHeaders)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpCompressionType":
			err = unpopulate(val, &r.HTTPCompressionType)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &r.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "requestInterval":
			err = unpopulate(val, &r.RequestInterval)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, &r.RequestMethod)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &r.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &r.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &r.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &r.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RestSource - A copy activity Rest service source.
type RestSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders map[string]interface{} `json:"additionalHeaders,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:01:40. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
	PaginationRules map[string]interface{} `json:"paginationRules,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody map[string]interface{} `json:"requestBody,omitempty"`

	// The time to await before sending next page request.
	RequestInterval map[string]interface{} `json:"requestInterval,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod map[string]interface{} `json:"requestMethod,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type RestSource.
func (r *RestSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     r.Type,
		SourceRetryCount:         r.SourceRetryCount,
		SourceRetryWait:          r.SourceRetryWait,
		MaxConcurrentConnections: r.MaxConcurrentConnections,
		DisableMetricsCollection: r.DisableMetricsCollection,
		AdditionalProperties:     r.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RestSource.
func (r RestSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", r.AdditionalColumns)
	populate(objectMap, "additionalHeaders", r.AdditionalHeaders)
	populate(objectMap, "disableMetricsCollection", r.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", r.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", r.MaxConcurrentConnections)
	populate(objectMap, "paginationRules", r.PaginationRules)
	populate(objectMap, "requestBody", r.RequestBody)
	populate(objectMap, "requestInterval", r.RequestInterval)
	populate(objectMap, "requestMethod", r.RequestMethod)
	populate(objectMap, "sourceRetryCount", r.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", r.SourceRetryWait)
	objectMap["type"] = "RestSource"
	if r.AdditionalProperties != nil {
		for key, val := range r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestSource.
func (r *RestSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &r.AdditionalColumns)
			delete(rawMsg, key)
		case "additionalHeaders":
			err = unpopulate(val, &r.AdditionalHeaders)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &r.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &r.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &r.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "paginationRules":
			err = unpopulate(val, &r.PaginationRules)
			delete(rawMsg, key)
		case "requestBody":
			err = unpopulate(val, &r.RequestBody)
			delete(rawMsg, key)
		case "requestInterval":
			err = unpopulate(val, &r.RequestInterval)
			delete(rawMsg, key)
		case "requestMethod":
			err = unpopulate(val, &r.RequestMethod)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &r.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &r.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				r.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RetryPolicy - Execution policy for an activity.
type RetryPolicy struct {
	// Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
	Count map[string]interface{} `json:"count,omitempty"`

	// Interval between retries in seconds. Default is 30.
	IntervalInSeconds *int32 `json:"intervalInSeconds,omitempty"`
}

// RunFilterParameters - Query parameters for listing runs.
type RunFilterParameters struct {
	// REQUIRED; The time at or after which the run event was updated in 'ISO 8601' format.
	LastUpdatedAfter *time.Time `json:"lastUpdatedAfter,omitempty"`

	// REQUIRED; The time at or before which the run event was updated in 'ISO 8601' format.
	LastUpdatedBefore *time.Time `json:"lastUpdatedBefore,omitempty"`

	// The continuation token for getting the next page of results. Null for first page.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of filters.
	Filters []*RunQueryFilter `json:"filters,omitempty"`

	// List of OrderBy option.
	OrderBy []*RunQueryOrderBy `json:"orderBy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunFilterParameters.
func (r RunFilterParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "continuationToken", r.ContinuationToken)
	populate(objectMap, "filters", r.Filters)
	populateTimeRFC3339(objectMap, "lastUpdatedAfter", r.LastUpdatedAfter)
	populateTimeRFC3339(objectMap, "lastUpdatedBefore", r.LastUpdatedBefore)
	populate(objectMap, "orderBy", r.OrderBy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunFilterParameters.
func (r *RunFilterParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, &r.ContinuationToken)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &r.Filters)
			delete(rawMsg, key)
		case "lastUpdatedAfter":
			err = unpopulateTimeRFC3339(val, &r.LastUpdatedAfter)
			delete(rawMsg, key)
		case "lastUpdatedBefore":
			err = unpopulateTimeRFC3339(val, &r.LastUpdatedBefore)
			delete(rawMsg, key)
		case "orderBy":
			err = unpopulate(val, &r.OrderBy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RunQueryFilter - Query filter option for listing runs.
type RunQueryFilter struct {
	// REQUIRED; Parameter name to be used for filter. The allowed operands to query pipeline runs are PipelineName, RunStart,
	// RunEnd and Status; to query activity runs are ActivityName, ActivityRunStart,
	// ActivityRunEnd, ActivityType and Status, and to query trigger runs are TriggerName, TriggerRunTimestamp and Status.
	Operand *RunQueryFilterOperand `json:"operand,omitempty"`

	// REQUIRED; Operator to be used for filter.
	Operator *RunQueryFilterOperator `json:"operator,omitempty"`

	// REQUIRED; List of filter values.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunQueryFilter.
func (r RunQueryFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operand", r.Operand)
	populate(objectMap, "operator", r.Operator)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// RunQueryOrderBy - An object to provide order by options for listing runs.
type RunQueryOrderBy struct {
	// REQUIRED; Sorting order of the parameter.
	Order *RunQueryOrder `json:"order,omitempty"`

	// REQUIRED; Parameter name to be used for order by. The allowed parameters to order by for pipeline runs are PipelineName,
	// RunStart, RunEnd and Status; for activity runs are ActivityName, ActivityRunStart,
	// ActivityRunEnd and Status; for trigger runs are TriggerName, TriggerRunTimestamp and Status.
	OrderBy *RunQueryOrderByField `json:"orderBy,omitempty"`
}

// SQLAlwaysEncryptedProperties - Sql always encrypted properties.
type SQLAlwaysEncryptedProperties struct {
	// REQUIRED; Sql always encrypted AKV authentication type. Type: string (or Expression with resultType string).
	AlwaysEncryptedAkvAuthType *SQLAlwaysEncryptedAkvAuthType `json:"alwaysEncryptedAkvAuthType,omitempty"`

	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// The client ID of the application in Azure Active Directory used for Azure Key Vault authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure Key Vault.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLAlwaysEncryptedProperties.
func (s SQLAlwaysEncryptedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alwaysEncryptedAkvAuthType", s.AlwaysEncryptedAkvAuthType)
	populate(objectMap, "credential", s.Credential)
	populate(objectMap, "servicePrincipalId", s.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", s.ServicePrincipalKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAlwaysEncryptedProperties.
func (s *SQLAlwaysEncryptedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedAkvAuthType":
			err = unpopulate(val, &s.AlwaysEncryptedAkvAuthType)
			delete(rawMsg, key)
		case "credential":
			err = unpopulate(val, &s.Credential)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &s.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			s.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLDWSink - A copy activity SQL Data Warehouse sink.
type SQLDWSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates to use Copy Command to copy data into SQL Data Warehouse. Type: boolean (or Expression with resultType boolean).
	AllowCopyCommand map[string]interface{} `json:"allowCopyCommand,omitempty"`

	// Indicates to use PolyBase to copy data into SQL Data Warehouse when applicable. Type: boolean (or Expression with resultType
	// boolean).
	AllowPolyBase map[string]interface{} `json:"allowPolyBase,omitempty"`

	// Specifies Copy Command related settings when allowCopyCommand is true.
	CopyCommandSettings *DWCopyCommandSettings `json:"copyCommandSettings,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Specifies PolyBase-related settings when allowPolyBase is true.
	PolyBaseSettings *PolybaseSettings `json:"polyBaseSettings,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
	SQLWriterUseTableLock map[string]interface{} `json:"sqlWriterUseTableLock,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression
	// with resultType string).
	TableOption map[string]interface{} `json:"tableOption,omitempty"`

	// SQL DW upsert settings.
	UpsertSettings *SQLDWUpsertSettings `json:"upsertSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Write behavior when copying data into azure SQL DW. Type: SqlDWWriteBehaviorEnum (or Expression with resultType SqlDWWriteBehaviorEnum)
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SQLDWSink.
func (s *SQLDWSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLDWSink.
func (s SQLDWSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowCopyCommand", s.AllowCopyCommand)
	populate(objectMap, "allowPolyBase", s.AllowPolyBase)
	populate(objectMap, "copyCommandSettings", s.CopyCommandSettings)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "polyBaseSettings", s.PolyBaseSettings)
	populate(objectMap, "preCopyScript", s.PreCopyScript)
	populate(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populate(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlDWSink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDWSink.
func (s *SQLDWSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowCopyCommand":
			err = unpopulate(val, &s.AllowCopyCommand)
			delete(rawMsg, key)
		case "allowPolyBase":
			err = unpopulate(val, &s.AllowPolyBase)
			delete(rawMsg, key)
		case "copyCommandSettings":
			err = unpopulate(val, &s.CopyCommandSettings)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "polyBaseSettings":
			err = unpopulate(val, &s.PolyBaseSettings)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLDWSource - A copy activity SQL Data Warehouse source.
type SQLDWSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Sql source partitioning.
	PartitionSettings *SQLPartitionSettings `json:"partitionSettings,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// SQL Data Warehouse reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery map[string]interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Data Warehouse source. This cannot be used at the same time as SqlReaderQuery. Type:
	// string (or Expression with resultType string).
	SQLReaderStoredProcedureName map[string]interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}". Type: object
	// (or Expression with resultType object), itemType: StoredProcedureParameter.
	StoredProcedureParameters map[string]interface{} `json:"storedProcedureParameters,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SQLDWSource.
func (s *SQLDWSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SQLDWSource.
func (s *SQLDWSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLDWSource.
func (s SQLDWSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populate(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlDWSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDWSource.
func (s *SQLDWSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &s.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLDWUpsertSettings - Sql DW upsert option settings
type SQLDWUpsertSettings struct {
	// Schema name for interim table. Type: string (or Expression with resultType string).
	InterimSchemaName map[string]interface{} `json:"interimSchemaName,omitempty"`

	// Key column names for unique row identification. Type: array of strings (or Expression with resultType array of strings).
	Keys map[string]interface{} `json:"keys,omitempty"`
}

// SQLMISink - A copy activity Azure SQL Managed Instance sink.
type SQLMISink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName map[string]interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType map[string]interface{} `json:"sqlWriterTableType,omitempty"`

	// Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
	SQLWriterUseTableLock map[string]interface{} `json:"sqlWriterUseTableLock,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName map[string]interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression
	// with resultType string).
	TableOption map[string]interface{} `json:"tableOption,omitempty"`

	// SQL upsert settings.
	UpsertSettings *SQLUpsertSettings `json:"upsertSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// White behavior when copying data into azure SQL MI. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SQLMISink.
func (s *SQLMISink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLMISink.
func (s SQLMISink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", s.PreCopyScript)
	populate(objectMap, "sqlWriterStoredProcedureName", s.SQLWriterStoredProcedureName)
	populate(objectMap, "sqlWriterTableType", s.SQLWriterTableType)
	populate(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	populate(objectMap, "storedProcedureTableTypeParameterName", s.StoredProcedureTableTypeParameterName)
	populate(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlMISink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMISink.
func (s *SQLMISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, &s.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, &s.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, &s.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLMISource - A copy activity Azure SQL Managed Instance source.
type SQLMISource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Sql source partitioning.
	PartitionSettings *SQLPartitionSettings `json:"partitionSettings,omitempty"`

	// Which additional types to produce.
	ProduceAdditionalTypes map[string]interface{} `json:"produceAdditionalTypes,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery map[string]interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a Azure SQL Managed Instance source. This cannot be used at the same time as SqlReaderQuery.
	// Type: string (or Expression with resultType string).
	SQLReaderStoredProcedureName map[string]interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SQLMISource.
func (s *SQLMISource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SQLMISource.
func (s *SQLMISource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLMISource.
func (s SQLMISource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populate(objectMap, "produceAdditionalTypes", s.ProduceAdditionalTypes)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populate(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlMISource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMISource.
func (s *SQLMISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &s.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, &s.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLPartitionSettings - The settings that will be leveraged for Sql source partitioning.
type SQLPartitionSettings struct {
	// The name of the column in integer or datetime type that will be used for proceeding partitioning. If not specified, the
	// primary key of the table is auto-detected and used as the partition column.
	// Type: string (or Expression with resultType string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of the partition column for partition range splitting. This value is used to decide the partition stride,
	// not for filtering the rows in table. All rows in the table or query result
	// will be partitioned and copied. Type: string (or Expression with resultType string).
	PartitionLowerBound map[string]interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of the partition column for partition range splitting. This value is used to decide the partition stride,
	// not for filtering the rows in table. All rows in the table or query result
	// will be partitioned and copied. Type: string (or Expression with resultType string).
	PartitionUpperBound map[string]interface{} `json:"partitionUpperBound,omitempty"`
}

// SQLServerLinkedService - SQL Server linked service.
type SQLServerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SQL Server linked service properties.
	TypeProperties *SQLServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SQLServerLinkedService.
func (s *SQLServerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLinkedService.
func (s SQLServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SqlServer"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedService.
func (s *SQLServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLServerLinkedServiceTypeProperties - SQL Server linked service properties.
type SQLServerLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// Sql always encrypted properties.
	AlwaysEncryptedSettings *SQLAlwaysEncryptedProperties `json:"alwaysEncryptedSettings,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The on-premises Windows authentication password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLinkedServiceTypeProperties.
func (s SQLServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alwaysEncryptedSettings", s.AlwaysEncryptedSettings)
	populate(objectMap, "connectionString", s.ConnectionString)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedServiceTypeProperties.
func (s *SQLServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alwaysEncryptedSettings":
			err = unpopulate(val, &s.AlwaysEncryptedSettings)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &s.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLServerSink - A copy activity SQL server sink.
type SQLServerSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName map[string]interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType map[string]interface{} `json:"sqlWriterTableType,omitempty"`

	// Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
	SQLWriterUseTableLock map[string]interface{} `json:"sqlWriterUseTableLock,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName map[string]interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression
	// with resultType string).
	TableOption map[string]interface{} `json:"tableOption,omitempty"`

	// SQL upsert settings.
	UpsertSettings *SQLUpsertSettings `json:"upsertSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Write behavior when copying data into sql server. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SQLServerSink.
func (s *SQLServerSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSink.
func (s SQLServerSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", s.PreCopyScript)
	populate(objectMap, "sqlWriterStoredProcedureName", s.SQLWriterStoredProcedureName)
	populate(objectMap, "sqlWriterTableType", s.SQLWriterTableType)
	populate(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	populate(objectMap, "storedProcedureTableTypeParameterName", s.StoredProcedureTableTypeParameterName)
	populate(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlServerSink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSink.
func (s *SQLServerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, &s.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, &s.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, &s.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLServerSource - A copy activity SQL server source.
type SQLServerSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Sql source partitioning.
	PartitionSettings *SQLPartitionSettings `json:"partitionSettings,omitempty"`

	// Which additional types to produce.
	ProduceAdditionalTypes map[string]interface{} `json:"produceAdditionalTypes,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery map[string]interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string
	// (or Expression with resultType string).
	SQLReaderStoredProcedureName map[string]interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SQLServerSource.
func (s *SQLServerSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SQLServerSource.
func (s *SQLServerSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSource.
func (s SQLServerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populate(objectMap, "produceAdditionalTypes", s.ProduceAdditionalTypes)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populate(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlServerSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSource.
func (s *SQLServerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &s.PartitionSettings)
			delete(rawMsg, key)
		case "produceAdditionalTypes":
			err = unpopulate(val, &s.ProduceAdditionalTypes)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLServerStoredProcedureActivity - SQL stored procedure activity type.
type SQLServerStoredProcedureActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SQL stored procedure activity properties.
	TypeProperties *SQLServerStoredProcedureActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type SQLServerStoredProcedureActivity.
func (s *SQLServerStoredProcedureActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 s.Name,
		Type:                 s.Type,
		Description:          s.Description,
		DependsOn:            s.DependsOn,
		UserProperties:       s.UserProperties,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type SQLServerStoredProcedureActivity.
func (s *SQLServerStoredProcedureActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    s.LinkedServiceName,
		Policy:               s.Policy,
		Name:                 s.Name,
		Type:                 s.Type,
		Description:          s.Description,
		DependsOn:            s.DependsOn,
		UserProperties:       s.UserProperties,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerStoredProcedureActivity.
func (s SQLServerStoredProcedureActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "policy", s.Policy)
	objectMap["type"] = "SqlServerStoredProcedure"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerStoredProcedureActivity.
func (s *SQLServerStoredProcedureActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &s.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLServerStoredProcedureActivityTypeProperties - SQL stored procedure activity properties.
type SQLServerStoredProcedureActivityTypeProperties struct {
	// REQUIRED; Stored procedure name. Type: string (or Expression with resultType string).
	StoredProcedureName map[string]interface{} `json:"storedProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerStoredProcedureActivityTypeProperties.
func (s SQLServerStoredProcedureActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "storedProcedureName", s.StoredProcedureName)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	return json.Marshal(objectMap)
}

// SQLServerTableDataset - The on-premises SQL Server dataset.
type SQLServerTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// On-premises SQL Server dataset properties.
	TypeProperties *SQLServerTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SQLServerTableDataset.
func (s *SQLServerTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerTableDataset.
func (s SQLServerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SqlServerTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerTableDataset.
func (s *SQLServerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLServerTableDatasetTypeProperties - On-premises SQL Server dataset properties.
type SQLServerTableDatasetTypeProperties struct {
	// The schema name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// SQLSink - A copy activity SQL sink.
type SQLSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName map[string]interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType map[string]interface{} `json:"sqlWriterTableType,omitempty"`

	// Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
	SQLWriterUseTableLock map[string]interface{} `json:"sqlWriterUseTableLock,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName map[string]interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression
	// with resultType string).
	TableOption map[string]interface{} `json:"tableOption,omitempty"`

	// SQL upsert settings.
	UpsertSettings *SQLUpsertSettings `json:"upsertSettings,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// Write behavior when copying data into sql. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
	WriteBehavior map[string]interface{} `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SQLSink.
func (s *SQLSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLSink.
func (s SQLSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", s.PreCopyScript)
	populate(objectMap, "sqlWriterStoredProcedureName", s.SQLWriterStoredProcedureName)
	populate(objectMap, "sqlWriterTableType", s.SQLWriterTableType)
	populate(objectMap, "sqlWriterUseTableLock", s.SQLWriterUseTableLock)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	populate(objectMap, "storedProcedureTableTypeParameterName", s.StoredProcedureTableTypeParameterName)
	populate(objectMap, "tableOption", s.TableOption)
	objectMap["type"] = "SqlSink"
	populate(objectMap, "upsertSettings", s.UpsertSettings)
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLSink.
func (s *SQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &s.PreCopyScript)
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			err = unpopulate(val, &s.SQLWriterStoredProcedureName)
			delete(rawMsg, key)
		case "sqlWriterTableType":
			err = unpopulate(val, &s.SQLWriterTableType)
			delete(rawMsg, key)
		case "sqlWriterUseTableLock":
			err = unpopulate(val, &s.SQLWriterUseTableLock)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			err = unpopulate(val, &s.StoredProcedureTableTypeParameterName)
			delete(rawMsg, key)
		case "tableOption":
			err = unpopulate(val, &s.TableOption)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "upsertSettings":
			err = unpopulate(val, &s.UpsertSettings)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLSource - A copy activity SQL source.
type SQLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Specifies the transaction locking behavior for the SQL source. Allowed values: ReadCommitted/ReadUncommitted/RepeatableRead/Serializable/Snapshot.
	// The default value is ReadCommitted. Type: string (or
	// Expression with resultType string).
	IsolationLevel map[string]interface{} `json:"isolationLevel,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Sql source partitioning.
	PartitionSettings *SQLPartitionSettings `json:"partitionSettings,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery map[string]interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string
	// (or Expression with resultType string).
	SQLReaderStoredProcedureName map[string]interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters map[string]*StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SQLSource.
func (s *SQLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SQLSource.
func (s *SQLSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLSource.
func (s SQLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "isolationLevel", s.IsolationLevel)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sqlReaderQuery", s.SQLReaderQuery)
	populate(objectMap, "sqlReaderStoredProcedureName", s.SQLReaderStoredProcedureName)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	populate(objectMap, "storedProcedureParameters", s.StoredProcedureParameters)
	objectMap["type"] = "SqlSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLSource.
func (s *SQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "isolationLevel":
			err = unpopulate(val, &s.IsolationLevel)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &s.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sqlReaderQuery":
			err = unpopulate(val, &s.SQLReaderQuery)
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			err = unpopulate(val, &s.SQLReaderStoredProcedureName)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "storedProcedureParameters":
			err = unpopulate(val, &s.StoredProcedureParameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLUpsertSettings - Sql upsert option settings
type SQLUpsertSettings struct {
	// Schema name for interim table. Type: string (or Expression with resultType string).
	InterimSchemaName map[string]interface{} `json:"interimSchemaName,omitempty"`

	// Key column names for unique row identification. Type: array of strings (or Expression with resultType array of strings).
	Keys map[string]interface{} `json:"keys,omitempty"`

	// Specifies whether to use temp db for upsert interim table. Type: boolean (or Expression with resultType boolean).
	UseTempDB map[string]interface{} `json:"useTempDB,omitempty"`
}

// SSISAccessCredential - SSIS access credential.
type SSISAccessCredential struct {
	// REQUIRED; Domain for windows authentication.
	Domain map[string]interface{} `json:"domain,omitempty"`

	// REQUIRED; Password for windows authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// REQUIRED; UseName for windows authentication.
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SSISAccessCredential.
func (s SSISAccessCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "domain", s.Domain)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISAccessCredential.
func (s *SSISAccessCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			err = unpopulate(val, &s.Domain)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SSISChildPackage - SSIS embedded child package.
type SSISChildPackage struct {
	// REQUIRED; Content for embedded child package. Type: string (or Expression with resultType string).
	PackageContent map[string]interface{} `json:"packageContent,omitempty"`

	// REQUIRED; Path for embedded child package. Type: string (or Expression with resultType string).
	PackagePath map[string]interface{} `json:"packagePath,omitempty"`

	// Last modified date for embedded child package.
	PackageLastModifiedDate *string `json:"packageLastModifiedDate,omitempty"`

	// Name for embedded child package.
	PackageName *string `json:"packageName,omitempty"`
}

// SSISExecutionCredential - SSIS package execution credential.
type SSISExecutionCredential struct {
	// REQUIRED; Domain for windows authentication.
	Domain map[string]interface{} `json:"domain,omitempty"`

	// REQUIRED; Password for windows authentication.
	Password *SecureString `json:"password,omitempty"`

	// REQUIRED; UseName for windows authentication.
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// SSISExecutionParameter - SSIS execution parameter.
type SSISExecutionParameter struct {
	// REQUIRED; SSIS package execution parameter value. Type: string (or Expression with resultType string).
	Value map[string]interface{} `json:"value,omitempty"`
}

// SSISLogLocation - SSIS package execution log location
type SSISLogLocation struct {
	// REQUIRED; The SSIS package execution log path. Type: string (or Expression with resultType string).
	LogPath map[string]interface{} `json:"logPath,omitempty"`

	// REQUIRED; The type of SSIS log location.
	Type *SsisLogLocationType `json:"type,omitempty"`

	// REQUIRED; SSIS package execution log location properties.
	TypeProperties *SSISLogLocationTypeProperties `json:"typeProperties,omitempty"`
}

// SSISLogLocationTypeProperties - SSIS package execution log location properties.
type SSISLogLocationTypeProperties struct {
	// The package execution log access credential.
	AccessCredential *SSISAccessCredential `json:"accessCredential,omitempty"`

	// Specifies the interval to refresh log. The default interval is 5 minutes. Type: string (or Expression with resultType string),
	// pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	LogRefreshInterval map[string]interface{} `json:"logRefreshInterval,omitempty"`
}

// SSISPackageLocation - SSIS package location.
type SSISPackageLocation struct {
	// The SSIS package path. Type: string (or Expression with resultType string).
	PackagePath map[string]interface{} `json:"packagePath,omitempty"`

	// The type of SSIS package location.
	Type *SsisPackageLocationType `json:"type,omitempty"`

	// SSIS package location properties.
	TypeProperties *SSISPackageLocationTypeProperties `json:"typeProperties,omitempty"`
}

// SSISPackageLocationTypeProperties - SSIS package location properties.
type SSISPackageLocationTypeProperties struct {
	// The package access credential.
	AccessCredential *SSISAccessCredential `json:"accessCredential,omitempty"`

	// The embedded child package list.
	ChildPackages []*SSISChildPackage `json:"childPackages,omitempty"`

	// The configuration file access credential.
	ConfigurationAccessCredential *SSISAccessCredential `json:"configurationAccessCredential,omitempty"`

	// The configuration file of the package execution. Type: string (or Expression with resultType string).
	ConfigurationPath map[string]interface{} `json:"configurationPath,omitempty"`

	// The embedded package content. Type: string (or Expression with resultType string).
	PackageContent map[string]interface{} `json:"packageContent,omitempty"`

	// The embedded package last modified date.
	PackageLastModifiedDate *string `json:"packageLastModifiedDate,omitempty"`

	// The package name.
	PackageName *string `json:"packageName,omitempty"`

	// Password of the package.
	PackagePassword SecretBaseClassification `json:"packagePassword,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SSISPackageLocationTypeProperties.
func (s SSISPackageLocationTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessCredential", s.AccessCredential)
	populate(objectMap, "childPackages", s.ChildPackages)
	populate(objectMap, "configurationAccessCredential", s.ConfigurationAccessCredential)
	populate(objectMap, "configurationPath", s.ConfigurationPath)
	populate(objectMap, "packageContent", s.PackageContent)
	populate(objectMap, "packageLastModifiedDate", s.PackageLastModifiedDate)
	populate(objectMap, "packageName", s.PackageName)
	populate(objectMap, "packagePassword", s.PackagePassword)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSISPackageLocationTypeProperties.
func (s *SSISPackageLocationTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessCredential":
			err = unpopulate(val, &s.AccessCredential)
			delete(rawMsg, key)
		case "childPackages":
			err = unpopulate(val, &s.ChildPackages)
			delete(rawMsg, key)
		case "configurationAccessCredential":
			err = unpopulate(val, &s.ConfigurationAccessCredential)
			delete(rawMsg, key)
		case "configurationPath":
			err = unpopulate(val, &s.ConfigurationPath)
			delete(rawMsg, key)
		case "packageContent":
			err = unpopulate(val, &s.PackageContent)
			delete(rawMsg, key)
		case "packageLastModifiedDate":
			err = unpopulate(val, &s.PackageLastModifiedDate)
			delete(rawMsg, key)
		case "packageName":
			err = unpopulate(val, &s.PackageName)
			delete(rawMsg, key)
		case "packagePassword":
			s.PackagePassword, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SSISPropertyOverride - SSIS property override.
type SSISPropertyOverride struct {
	// REQUIRED; SSIS package property override value. Type: string (or Expression with resultType string).
	Value map[string]interface{} `json:"value,omitempty"`

	// Whether SSIS package property override value is sensitive data. Value will be encrypted in SSISDB if it is true
	IsSensitive *bool `json:"isSensitive,omitempty"`
}

// SalesforceLinkedService - Linked service for Salesforce.
type SalesforceLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Salesforce linked service properties.
	TypeProperties *SalesforceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SalesforceLinkedService.
func (s *SalesforceLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceLinkedService.
func (s SalesforceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Salesforce"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedService.
func (s *SalesforceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceLinkedServiceTypeProperties - Salesforce linked service properties.
type SalesforceLinkedServiceTypeProperties struct {
	// The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
	APIVersion map[string]interface{} `json:"apiVersion,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'.
	// To copy data from custom domain, specify, for example,
	// 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
	EnvironmentURL map[string]interface{} `json:"environmentUrl,omitempty"`

	// The password for Basic authentication of the Salesforce instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The security token is optional to remotely access Salesforce instance.
	SecurityToken SecretBaseClassification `json:"securityToken,omitempty"`

	// The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceLinkedServiceTypeProperties.
func (s SalesforceLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersion", s.APIVersion)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "environmentUrl", s.EnvironmentURL)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "securityToken", s.SecurityToken)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedServiceTypeProperties.
func (s *SalesforceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersion":
			err = unpopulate(val, &s.APIVersion)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "environmentUrl":
			err = unpopulate(val, &s.EnvironmentURL)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "securityToken":
			s.SecurityToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceMarketingCloudLinkedService - Salesforce Marketing Cloud linked service.
type SalesforceMarketingCloudLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Salesforce Marketing Cloud linked service properties.
	TypeProperties *SalesforceMarketingCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SalesforceMarketingCloudLinkedService.
func (s *SalesforceMarketingCloudLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudLinkedService.
func (s SalesforceMarketingCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SalesforceMarketingCloud"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedService.
func (s *SalesforceMarketingCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceMarketingCloudLinkedServiceTypeProperties - Salesforce Marketing Cloud linked service properties.
type SalesforceMarketingCloudLinkedServiceTypeProperties struct {
	// The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType
	// string).
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// Properties used to connect to Salesforce Marketing Cloud. It is mutually exclusive with any other properties in the linked
	// service. Type: object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
	// with resultType boolean).
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true. Type: boolean (or Expression with
	// resultType boolean).
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudLinkedServiceTypeProperties.
func (s SalesforceMarketingCloudLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", s.ClientID)
	populate(objectMap, "clientSecret", s.ClientSecret)
	populate(objectMap, "connectionProperties", s.ConnectionProperties)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", s.UseHostVerification)
	populate(objectMap, "usePeerVerification", s.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedServiceTypeProperties.
func (s *SalesforceMarketingCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &s.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			s.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, &s.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &s.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceMarketingCloudObjectDataset - Salesforce Marketing Cloud dataset.
type SalesforceMarketingCloudObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SalesforceMarketingCloudObjectDataset.
func (s *SalesforceMarketingCloudObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s SalesforceMarketingCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SalesforceMarketingCloudObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s *SalesforceMarketingCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceMarketingCloudSource - A copy activity Salesforce Marketing Cloud source.
type SalesforceMarketingCloudSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SalesforceMarketingCloudSource.
func (s *SalesforceMarketingCloudSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SalesforceMarketingCloudSource.
func (s *SalesforceMarketingCloudSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudSource.
func (s SalesforceMarketingCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SalesforceMarketingCloudSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudSource.
func (s *SalesforceMarketingCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceObjectDataset - The Salesforce object dataset.
type SalesforceObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Salesforce object dataset properties.
	TypeProperties *SalesforceObjectDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SalesforceObjectDataset.
func (s *SalesforceObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceObjectDataset.
func (s SalesforceObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SalesforceObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceObjectDataset.
func (s *SalesforceObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceObjectDatasetTypeProperties - Salesforce object dataset properties.
type SalesforceObjectDatasetTypeProperties struct {
	// The Salesforce object API name. Type: string (or Expression with resultType string).
	ObjectAPIName map[string]interface{} `json:"objectApiName,omitempty"`
}

// SalesforceServiceCloudLinkedService - Linked service for Salesforce Service Cloud.
type SalesforceServiceCloudLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Salesforce Service Cloud linked service properties.
	TypeProperties *SalesforceServiceCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SalesforceServiceCloudLinkedService.
func (s *SalesforceServiceCloudLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudLinkedService.
func (s SalesforceServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SalesforceServiceCloud"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedService.
func (s *SalesforceServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceServiceCloudLinkedServiceTypeProperties - Salesforce Service Cloud linked service properties.
type SalesforceServiceCloudLinkedServiceTypeProperties struct {
	// The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
	APIVersion map[string]interface{} `json:"apiVersion,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify
	// 'https://test.salesforce.com'. To copy data from custom domain, specify, for
	// example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
	EnvironmentURL map[string]interface{} `json:"environmentUrl,omitempty"`

	// Extended properties appended to the connection string. Type: string (or Expression with resultType string).
	ExtendedProperties map[string]interface{} `json:"extendedProperties,omitempty"`

	// The password for Basic authentication of the Salesforce instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The security token is optional to remotely access Salesforce instance.
	SecurityToken SecretBaseClassification `json:"securityToken,omitempty"`

	// The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudLinkedServiceTypeProperties.
func (s SalesforceServiceCloudLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersion", s.APIVersion)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "environmentUrl", s.EnvironmentURL)
	populate(objectMap, "extendedProperties", s.ExtendedProperties)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "securityToken", s.SecurityToken)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedServiceTypeProperties.
func (s *SalesforceServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersion":
			err = unpopulate(val, &s.APIVersion)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "environmentUrl":
			err = unpopulate(val, &s.EnvironmentURL)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, &s.ExtendedProperties)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "securityToken":
			s.SecurityToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceServiceCloudObjectDataset - The Salesforce Service Cloud object dataset.
type SalesforceServiceCloudObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Salesforce Service Cloud object dataset properties.
	TypeProperties *SalesforceServiceCloudObjectDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SalesforceServiceCloudObjectDataset.
func (s *SalesforceServiceCloudObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudObjectDataset.
func (s SalesforceServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SalesforceServiceCloudObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudObjectDataset.
func (s *SalesforceServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceServiceCloudObjectDatasetTypeProperties - Salesforce Service Cloud object dataset properties.
type SalesforceServiceCloudObjectDatasetTypeProperties struct {
	// The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
	ObjectAPIName map[string]interface{} `json:"objectApiName,omitempty"`
}

// SalesforceServiceCloudSink - A copy activity Salesforce Service Cloud sink.
type SalesforceServiceCloudSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with
	// resultType string).
	ExternalIDFieldName map[string]interface{} `json:"externalIdFieldName,omitempty"`

	// The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation.
	// Default value is false. If set it to true, it means ADF will leave the data in
	// the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert
	// operation, versus ADF will update the data in the destination object to NULL when
	// doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType
	// boolean).
	IgnoreNullValues map[string]interface{} `json:"ignoreNullValues,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// The write behavior for the operation. Default is Insert.
	WriteBehavior *SalesforceSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SalesforceServiceCloudSink.
func (s *SalesforceServiceCloudSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudSink.
func (s SalesforceServiceCloudSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "externalIdFieldName", s.ExternalIDFieldName)
	populate(objectMap, "ignoreNullValues", s.IgnoreNullValues)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SalesforceServiceCloudSink"
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudSink.
func (s *SalesforceServiceCloudSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "externalIdFieldName":
			err = unpopulate(val, &s.ExternalIDFieldName)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, &s.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceServiceCloudSource - A copy activity Salesforce Service Cloud source.
type SalesforceServiceCloudSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// The read behavior for the operation. Default is Query.
	ReadBehavior *SalesforceSourceReadBehavior `json:"readBehavior,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SalesforceServiceCloudSource.
func (s *SalesforceServiceCloudSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudSource.
func (s SalesforceServiceCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "readBehavior", s.ReadBehavior)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SalesforceServiceCloudSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudSource.
func (s *SalesforceServiceCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "readBehavior":
			err = unpopulate(val, &s.ReadBehavior)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceSink - A copy activity Salesforce sink.
type SalesforceSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with
	// resultType string).
	ExternalIDFieldName map[string]interface{} `json:"externalIdFieldName,omitempty"`

	// The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation.
	// Default value is false. If set it to true, it means ADF will leave the data in
	// the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert
	// operation, versus ADF will update the data in the destination object to NULL when
	// doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType
	// boolean).
	IgnoreNullValues map[string]interface{} `json:"ignoreNullValues,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// The write behavior for the operation. Default is Insert.
	WriteBehavior *SalesforceSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SalesforceSink.
func (s *SalesforceSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceSink.
func (s SalesforceSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "externalIdFieldName", s.ExternalIDFieldName)
	populate(objectMap, "ignoreNullValues", s.IgnoreNullValues)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SalesforceSink"
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceSink.
func (s *SalesforceSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "externalIdFieldName":
			err = unpopulate(val, &s.ExternalIDFieldName)
			delete(rawMsg, key)
		case "ignoreNullValues":
			err = unpopulate(val, &s.IgnoreNullValues)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SalesforceSource - A copy activity Salesforce source.
type SalesforceSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// The read behavior for the operation. Default is Query.
	ReadBehavior *SalesforceSourceReadBehavior `json:"readBehavior,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SalesforceSource.
func (s *SalesforceSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SalesforceSource.
func (s *SalesforceSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceSource.
func (s SalesforceSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "readBehavior", s.ReadBehavior)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SalesforceSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceSource.
func (s *SalesforceSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "readBehavior":
			err = unpopulate(val, &s.ReadBehavior)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapBWLinkedService - SAP Business Warehouse Linked Service.
type SapBWLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this linked service type.
	TypeProperties *SapBWLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SapBWLinkedService.
func (s *SapBWLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapBWLinkedService.
func (s SapBWLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapBW"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBWLinkedService.
func (s *SapBWLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapBWLinkedServiceTypeProperties - Properties specific to this linked service type.
type SapBWLinkedServiceTypeProperties struct {
	// REQUIRED; Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type:
	// string (or Expression with resultType string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// REQUIRED; Host name of the SAP BW instance. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// REQUIRED; System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or
	// Expression with resultType string).
	SystemNumber map[string]interface{} `json:"systemNumber,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password to access the SAP BW server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Username to access the SAP BW server. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapBWLinkedServiceTypeProperties.
func (s SapBWLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "server", s.Server)
	populate(objectMap, "systemNumber", s.SystemNumber)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBWLinkedServiceTypeProperties.
func (s *SapBWLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &s.Server)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapBwCubeDataset - The SAP BW cube dataset.
type SapBwCubeDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SapBwCubeDataset.
func (s *SapBwCubeDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapBwCubeDataset.
func (s SapBwCubeDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapBwCube"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwCubeDataset.
func (s *SapBwCubeDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapBwSource - A copy activity source for SapBW server via MDX.
type SapBwSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// MDX query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SapBwSource.
func (s *SapBwSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SapBwSource.
func (s *SapBwSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapBwSource.
func (s SapBwSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapBwSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwSource.
func (s *SapBwSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapCloudForCustomerLinkedService - Linked service for SAP Cloud for Customer.
type SapCloudForCustomerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SAP Cloud for Customer linked service properties.
	TypeProperties *SapCloudForCustomerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SapCloudForCustomerLinkedService.
func (s *SapCloudForCustomerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerLinkedService.
func (s SapCloudForCustomerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapCloudForCustomer"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedService.
func (s *SapCloudForCustomerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapCloudForCustomerLinkedServiceTypeProperties - SAP Cloud for Customer linked service properties.
type SapCloudForCustomerLinkedServiceTypeProperties struct {
	// REQUIRED; The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'.
	// Type: string (or Expression with resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Either encryptedCredential or username/password must be provided. Type:
	// string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The username for Basic authentication. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerLinkedServiceTypeProperties.
func (s SapCloudForCustomerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "url", s.URL)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedServiceTypeProperties.
func (s *SapCloudForCustomerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &s.URL)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapCloudForCustomerResourceDataset - The path of the SAP Cloud for Customer OData entity.
type SapCloudForCustomerResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SAP Cloud For Customer OData resource dataset properties.
	TypeProperties *SapCloudForCustomerResourceDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SapCloudForCustomerResourceDataset.
func (s *SapCloudForCustomerResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerResourceDataset.
func (s SapCloudForCustomerResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapCloudForCustomerResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerResourceDataset.
func (s *SapCloudForCustomerResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapCloudForCustomerResourceDatasetTypeProperties - Sap Cloud For Customer OData resource dataset properties.
type SapCloudForCustomerResourceDatasetTypeProperties struct {
	// REQUIRED; The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// SapCloudForCustomerSink - A copy activity SAP Cloud for Customer sink.
type SapCloudForCustomerSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:05:00. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`

	// The write behavior for the operation. Default is 'Insert'.
	WriteBehavior *SapCloudForCustomerSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SapCloudForCustomerSink.
func (s *SapCloudForCustomerSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerSink.
func (s SapCloudForCustomerSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SapCloudForCustomerSink"
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	populate(objectMap, "writeBehavior", s.WriteBehavior)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerSink.
func (s *SapCloudForCustomerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		case "writeBehavior":
			err = unpopulate(val, &s.WriteBehavior)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapCloudForCustomerSource - A copy activity source for SAP Cloud for Customer source.
type SapCloudForCustomerSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:05:00. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SAP Cloud for Customer OData query. For example, "$top=1". Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SapCloudForCustomerSource.
func (s *SapCloudForCustomerSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SapCloudForCustomerSource.
func (s *SapCloudForCustomerSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerSource.
func (s SapCloudForCustomerSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapCloudForCustomerSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerSource.
func (s *SapCloudForCustomerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapEccLinkedService - Linked service for SAP ERP Central Component(SAP ECC).
type SapEccLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SAP ECC linked service properties.
	TypeProperties *SapEccLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SapEccLinkedService.
func (s *SapEccLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapEccLinkedService.
func (s SapEccLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapEcc"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedService.
func (s *SapEccLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapEccLinkedServiceTypeProperties - SAP ECC linked service properties.
type SapEccLinkedServiceTypeProperties struct {
	// REQUIRED; The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string
	// (or Expression with resultType string).
	URL *string `json:"url,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Either encryptedCredential or username/password must be provided. Type:
	// string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The username for Basic authentication. Type: string (or Expression with resultType string).
	Username *string `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapEccLinkedServiceTypeProperties.
func (s SapEccLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "url", s.URL)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedServiceTypeProperties.
func (s *SapEccLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &s.URL)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapEccResourceDataset - The path of the SAP ECC OData entity.
type SapEccResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SAP ECC OData resource dataset properties.
	TypeProperties *SapEccResourceDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SapEccResourceDataset.
func (s *SapEccResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapEccResourceDataset.
func (s SapEccResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapEccResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccResourceDataset.
func (s *SapEccResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapEccResourceDatasetTypeProperties - Sap ECC OData resource dataset properties.
type SapEccResourceDatasetTypeProperties struct {
	// REQUIRED; The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// SapEccSource - A copy activity source for SAP ECC source.
type SapEccSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data.
	// Default value: 00:05:00. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SAP ECC OData query. For example, "$top=1". Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SapEccSource.
func (s *SapEccSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SapEccSource.
func (s *SapEccSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapEccSource.
func (s SapEccSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapEccSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccSource.
func (s *SapEccSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapHanaLinkedService - SAP HANA Linked Service.
type SapHanaLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this linked service type.
	TypeProperties *SapHanaLinkedServiceProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SapHanaLinkedService.
func (s *SapHanaLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaLinkedService.
func (s SapHanaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapHana"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedService.
func (s *SapHanaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapHanaLinkedServiceProperties - Properties specific to this linked service type.
type SapHanaLinkedServiceProperties struct {
	// The authentication type to be used to connect to the SAP HANA server.
	AuthenticationType *SapHanaAuthenticationType `json:"authenticationType,omitempty"`

	// SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password to access the SAP HANA server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP HANA server. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// Username to access the SAP HANA server. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaLinkedServiceProperties.
func (s SapHanaLinkedServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "connectionString", s.ConnectionString)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "server", s.Server)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedServiceProperties.
func (s *SapHanaLinkedServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &s.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &s.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &s.Server)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapHanaPartitionSettings - The settings that will be leveraged for SAP HANA source partitioning.
type SapHanaPartitionSettings struct {
	// The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`
}

// SapHanaSource - A copy activity source for SAP HANA source.
type SapHanaSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The packet size of data read from SAP HANA. Type: integer(or Expression with resultType integer).
	PacketSize map[string]interface{} `json:"packetSize,omitempty"`

	// The partition mechanism that will be used for SAP HANA read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable",
	// "SapHanaDynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for SAP HANA source partitioning.
	PartitionSettings *SapHanaPartitionSettings `json:"partitionSettings,omitempty"`

	// SAP HANA Sql query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SapHanaSource.
func (s *SapHanaSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SapHanaSource.
func (s *SapHanaSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaSource.
func (s SapHanaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "packetSize", s.PacketSize)
	populate(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapHanaSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaSource.
func (s *SapHanaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "packetSize":
			err = unpopulate(val, &s.PacketSize)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &s.PartitionSettings)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapHanaTableDataset - SAP HANA Table properties.
type SapHanaTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// SAP HANA Table properties.
	TypeProperties *SapHanaTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SapHanaTableDataset.
func (s *SapHanaTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaTableDataset.
func (s SapHanaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapHanaTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaTableDataset.
func (s *SapHanaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapHanaTableDatasetTypeProperties - SAP HANA Table properties.
type SapHanaTableDatasetTypeProperties struct {
	// The schema name of SAP HANA. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of SAP HANA. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// SapOpenHubLinkedService - SAP Business Warehouse Open Hub Destination Linked Service.
type SapOpenHubLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to SAP Business Warehouse Open Hub Destination linked service type.
	TypeProperties *SapOpenHubLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SapOpenHubLinkedService.
func (s *SapOpenHubLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubLinkedService.
func (s SapOpenHubLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapOpenHub"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedService.
func (s *SapOpenHubLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapOpenHubLinkedServiceTypeProperties - Properties specific to SAP Business Warehouse Open Hub Destination linked service
// type.
type SapOpenHubLinkedServiceTypeProperties struct {
	// Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number
	// represented as a string) Type: string (or Expression with resultType string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression
	// with resultType string).
	Language map[string]interface{} `json:"language,omitempty"`

	// The Logon Group for the SAP System. Type: string (or Expression with resultType string).
	LogonGroup map[string]interface{} `json:"logonGroup,omitempty"`

	// The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
	MessageServer map[string]interface{} `json:"messageServer,omitempty"`

	// The service name or port number of the Message Server. Type: string (or Expression with resultType string).
	MessageServerService map[string]interface{} `json:"messageServerService,omitempty"`

	// Password to access the SAP BW server where the open hub destination is located.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType
	// string).
	Server map[string]interface{} `json:"server,omitempty"`

	// SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
	SystemID map[string]interface{} `json:"systemId,omitempty"`

	// System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented
	// as a string.) Type: string (or Expression with resultType string).
	SystemNumber map[string]interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType
	// string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubLinkedServiceTypeProperties.
func (s SapOpenHubLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "language", s.Language)
	populate(objectMap, "logonGroup", s.LogonGroup)
	populate(objectMap, "messageServer", s.MessageServer)
	populate(objectMap, "messageServerService", s.MessageServerService)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "server", s.Server)
	populate(objectMap, "systemId", s.SystemID)
	populate(objectMap, "systemNumber", s.SystemNumber)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedServiceTypeProperties.
func (s *SapOpenHubLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, &s.Language)
			delete(rawMsg, key)
		case "logonGroup":
			err = unpopulate(val, &s.LogonGroup)
			delete(rawMsg, key)
		case "messageServer":
			err = unpopulate(val, &s.MessageServer)
			delete(rawMsg, key)
		case "messageServerService":
			err = unpopulate(val, &s.MessageServerService)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &s.Server)
			delete(rawMsg, key)
		case "systemId":
			err = unpopulate(val, &s.SystemID)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapOpenHubSource - A copy activity source for SAP Business Warehouse Open Hub Destination source.
type SapOpenHubSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will
	// be retrieved. The default value is 0. Type: integer (or Expression with
	// resultType integer ).
	BaseRequestID map[string]interface{} `json:"baseRequestId,omitempty"`

	// Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with
	// resultType string).
	CustomRFCReadTableFunctionModule map[string]interface{} `json:"customRfcReadTableFunctionModule,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	ExcludeLastRequest map[string]interface{} `json:"excludeLastRequest,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// The single character that will be used as delimiter passed to SAP RFC as well as splitting the output data retrieved. Type:
	// string (or Expression with resultType string).
	SapDataColumnDelimiter map[string]interface{} `json:"sapDataColumnDelimiter,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SapOpenHubSource.
func (s *SapOpenHubSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SapOpenHubSource.
func (s *SapOpenHubSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubSource.
func (s SapOpenHubSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "baseRequestId", s.BaseRequestID)
	populate(objectMap, "customRfcReadTableFunctionModule", s.CustomRFCReadTableFunctionModule)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "excludeLastRequest", s.ExcludeLastRequest)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sapDataColumnDelimiter", s.SapDataColumnDelimiter)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapOpenHubSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubSource.
func (s *SapOpenHubSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "baseRequestId":
			err = unpopulate(val, &s.BaseRequestID)
			delete(rawMsg, key)
		case "customRfcReadTableFunctionModule":
			err = unpopulate(val, &s.CustomRFCReadTableFunctionModule)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "excludeLastRequest":
			err = unpopulate(val, &s.ExcludeLastRequest)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sapDataColumnDelimiter":
			err = unpopulate(val, &s.SapDataColumnDelimiter)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapOpenHubTableDataset - Sap Business Warehouse Open Hub Destination Table properties.
type SapOpenHubTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Sap Business Warehouse Open Hub Destination Table properties.
	TypeProperties *SapOpenHubTableDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SapOpenHubTableDataset.
func (s *SapOpenHubTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubTableDataset.
func (s SapOpenHubTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapOpenHubTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubTableDataset.
func (s *SapOpenHubTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapOpenHubTableDatasetTypeProperties - Sap Business Warehouse Open Hub Destination Table properties.
type SapOpenHubTableDatasetTypeProperties struct {
	// REQUIRED; The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with
	// resultType string).
	OpenHubDestinationName map[string]interface{} `json:"openHubDestinationName,omitempty"`

	// The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will
	// be retrieved. The default value is 0. Type: integer (or Expression with
	// resultType integer ).
	BaseRequestID map[string]interface{} `json:"baseRequestId,omitempty"`

	// Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	ExcludeLastRequest map[string]interface{} `json:"excludeLastRequest,omitempty"`
}

// SapTableLinkedService - SAP Table Linked Service.
type SapTableLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this linked service type.
	TypeProperties *SapTableLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SapTableLinkedService.
func (s *SapTableLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapTableLinkedService.
func (s SapTableLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SapTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedService.
func (s *SapTableLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapTableLinkedServiceTypeProperties - Properties specific to this linked service type.
type SapTableLinkedServiceTypeProperties struct {
	// Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented
	// as a string) Type: string (or Expression with resultType string).
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType
	// string).
	Language map[string]interface{} `json:"language,omitempty"`

	// The Logon Group for the SAP System. Type: string (or Expression with resultType string).
	LogonGroup map[string]interface{} `json:"logonGroup,omitempty"`

	// The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
	MessageServer map[string]interface{} `json:"messageServer,omitempty"`

	// The service name or port number of the Message Server. Type: string (or Expression with resultType string).
	MessageServerService map[string]interface{} `json:"messageServerService,omitempty"`

	// Password to access the SAP server where the table is located.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// External security product's library to access the SAP server where the table is located. Type: string (or Expression with
	// resultType string).
	SncLibraryPath map[string]interface{} `json:"sncLibraryPath,omitempty"`

	// SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string
	// (or Expression with resultType string).
	SncMode map[string]interface{} `json:"sncMode,omitempty"`

	// Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	SncMyName map[string]interface{} `json:"sncMyName,omitempty"`

	// Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with
	// resultType string).
	SncPartnerName map[string]interface{} `json:"sncPartnerName,omitempty"`

	// SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
	SncQop map[string]interface{} `json:"sncQop,omitempty"`

	// SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
	SystemID map[string]interface{} `json:"systemId,omitempty"`

	// System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.)
	// Type: string (or Expression with resultType string).
	SystemNumber map[string]interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapTableLinkedServiceTypeProperties.
func (s SapTableLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", s.ClientID)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "language", s.Language)
	populate(objectMap, "logonGroup", s.LogonGroup)
	populate(objectMap, "messageServer", s.MessageServer)
	populate(objectMap, "messageServerService", s.MessageServerService)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "server", s.Server)
	populate(objectMap, "sncLibraryPath", s.SncLibraryPath)
	populate(objectMap, "sncMode", s.SncMode)
	populate(objectMap, "sncMyName", s.SncMyName)
	populate(objectMap, "sncPartnerName", s.SncPartnerName)
	populate(objectMap, "sncQop", s.SncQop)
	populate(objectMap, "systemId", s.SystemID)
	populate(objectMap, "systemNumber", s.SystemNumber)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedServiceTypeProperties.
func (s *SapTableLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &s.ClientID)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, &s.Language)
			delete(rawMsg, key)
		case "logonGroup":
			err = unpopulate(val, &s.LogonGroup)
			delete(rawMsg, key)
		case "messageServer":
			err = unpopulate(val, &s.MessageServer)
			delete(rawMsg, key)
		case "messageServerService":
			err = unpopulate(val, &s.MessageServerService)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &s.Server)
			delete(rawMsg, key)
		case "sncLibraryPath":
			err = unpopulate(val, &s.SncLibraryPath)
			delete(rawMsg, key)
		case "sncMode":
			err = unpopulate(val, &s.SncMode)
			delete(rawMsg, key)
		case "sncMyName":
			err = unpopulate(val, &s.SncMyName)
			delete(rawMsg, key)
		case "sncPartnerName":
			err = unpopulate(val, &s.SncPartnerName)
			delete(rawMsg, key)
		case "sncQop":
			err = unpopulate(val, &s.SncQop)
			delete(rawMsg, key)
		case "systemId":
			err = unpopulate(val, &s.SystemID)
			delete(rawMsg, key)
		case "systemNumber":
			err = unpopulate(val, &s.SystemNumber)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapTablePartitionSettings - The settings that will be leveraged for SAP table source partitioning.
type SapTablePartitionSettings struct {
	// The maximum value of partitions the table will be split into. Type: integer (or Expression with resultType string).
	MaxPartitionsNumber map[string]interface{} `json:"maxPartitionsNumber,omitempty"`

	// The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionLowerBound map[string]interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionUpperBound map[string]interface{} `json:"partitionUpperBound,omitempty"`
}

// SapTableResourceDataset - SAP Table Resource properties.
type SapTableResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SAP Table Resource properties.
	TypeProperties *SapTableResourceDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SapTableResourceDataset.
func (s *SapTableResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapTableResourceDataset.
func (s SapTableResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SapTableResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableResourceDataset.
func (s *SapTableResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SapTableResourceDatasetTypeProperties - SAP Table Resource properties.
type SapTableResourceDatasetTypeProperties struct {
	// REQUIRED; The name of the SAP Table. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// SapTableSource - A copy activity source for SAP Table source.
type SapTableSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies the maximum number of rows that will be retrieved at a time when retrieving data from SAP Table. Type: integer
	// (or Expression with resultType integer).
	BatchSize map[string]interface{} `json:"batchSize,omitempty"`

	// Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with
	// resultType string).
	CustomRFCReadTableFunctionModule map[string]interface{} `json:"customRfcReadTableFunctionModule,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for SAP table read in parallel. Possible values include: "None", "PartitionOnInt",
	// "PartitionOnCalendarYear", "PartitionOnCalendarMonth",
	// "PartitionOnCalendarDate", "PartitionOnTime".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for SAP table source partitioning.
	PartitionSettings *SapTablePartitionSettings `json:"partitionSettings,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// The fields of the SAP table that will be retrieved. For example, column0, column1. Type: string (or Expression with resultType
	// string).
	RFCTableFields map[string]interface{} `json:"rfcTableFields,omitempty"`

	// The options for the filtering of the SAP Table. For example, COLUMN0 EQ SOME VALUE. Type: string (or Expression with resultType
	// string).
	RFCTableOptions map[string]interface{} `json:"rfcTableOptions,omitempty"`

	// The number of rows to be retrieved. Type: integer(or Expression with resultType integer).
	RowCount map[string]interface{} `json:"rowCount,omitempty"`

	// The number of rows that will be skipped. Type: integer (or Expression with resultType integer).
	RowSkips map[string]interface{} `json:"rowSkips,omitempty"`

	// The single character that will be used as delimiter passed to SAP RFC as well as splitting the output data retrieved. Type:
	// string (or Expression with resultType string).
	SapDataColumnDelimiter map[string]interface{} `json:"sapDataColumnDelimiter,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SapTableSource.
func (s *SapTableSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SapTableSource.
func (s *SapTableSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SapTableSource.
func (s SapTableSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "batchSize", s.BatchSize)
	populate(objectMap, "customRfcReadTableFunctionModule", s.CustomRFCReadTableFunctionModule)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", s.PartitionOption)
	populate(objectMap, "partitionSettings", s.PartitionSettings)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "rfcTableFields", s.RFCTableFields)
	populate(objectMap, "rfcTableOptions", s.RFCTableOptions)
	populate(objectMap, "rowCount", s.RowCount)
	populate(objectMap, "rowSkips", s.RowSkips)
	populate(objectMap, "sapDataColumnDelimiter", s.SapDataColumnDelimiter)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SapTableSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableSource.
func (s *SapTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "batchSize":
			err = unpopulate(val, &s.BatchSize)
			delete(rawMsg, key)
		case "customRfcReadTableFunctionModule":
			err = unpopulate(val, &s.CustomRFCReadTableFunctionModule)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &s.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &s.PartitionSettings)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "rfcTableFields":
			err = unpopulate(val, &s.RFCTableFields)
			delete(rawMsg, key)
		case "rfcTableOptions":
			err = unpopulate(val, &s.RFCTableOptions)
			delete(rawMsg, key)
		case "rowCount":
			err = unpopulate(val, &s.RowCount)
			delete(rawMsg, key)
		case "rowSkips":
			err = unpopulate(val, &s.RowSkips)
			delete(rawMsg, key)
		case "sapDataColumnDelimiter":
			err = unpopulate(val, &s.SapDataColumnDelimiter)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ScheduleTrigger - Trigger that creates pipeline runs periodically, on schedule.
type ScheduleTrigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Schedule Trigger properties.
	TypeProperties *ScheduleTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Pipelines that need to be started.
	Pipelines []*TriggerPipelineReference `json:"pipelines,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetMultiplePipelineTrigger implements the MultiplePipelineTriggerClassification interface for type ScheduleTrigger.
func (s *ScheduleTrigger) GetMultiplePipelineTrigger() *MultiplePipelineTrigger {
	return &MultiplePipelineTrigger{
		Pipelines:            s.Pipelines,
		Type:                 s.Type,
		Description:          s.Description,
		RuntimeState:         s.RuntimeState,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// GetTrigger implements the TriggerClassification interface for type ScheduleTrigger.
func (s *ScheduleTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 s.Type,
		Description:          s.Description,
		RuntimeState:         s.RuntimeState,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTrigger.
func (s ScheduleTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "pipelines", s.Pipelines)
	populate(objectMap, "runtimeState", s.RuntimeState)
	objectMap["type"] = "ScheduleTrigger"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTrigger.
func (s *ScheduleTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "pipelines":
			err = unpopulate(val, &s.Pipelines)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &s.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ScheduleTriggerRecurrence - The workflow trigger recurrence.
type ScheduleTriggerRecurrence struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The end time.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The frequency.
	Frequency *RecurrenceFrequency `json:"frequency,omitempty"`

	// The interval.
	Interval *int32 `json:"interval,omitempty"`

	// The recurrence schedule.
	Schedule *RecurrenceSchedule `json:"schedule,omitempty"`

	// The start time.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The time zone.
	TimeZone *string `json:"timeZone,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTriggerRecurrence.
func (s ScheduleTriggerRecurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "frequency", s.Frequency)
	populate(objectMap, "interval", s.Interval)
	populate(objectMap, "schedule", s.Schedule)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "timeZone", s.TimeZone)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTriggerRecurrence.
func (s *ScheduleTriggerRecurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &s.EndTime)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &s.Frequency)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, &s.Interval)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, &s.Schedule)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, &s.TimeZone)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ScheduleTriggerTypeProperties - Schedule Trigger properties.
type ScheduleTriggerTypeProperties struct {
	// REQUIRED; Recurrence schedule configuration.
	Recurrence *ScheduleTriggerRecurrence `json:"recurrence,omitempty"`
}

// ScriptAction - Custom script action to run on HDI ondemand cluster once it's up.
type ScriptAction struct {
	// REQUIRED; The user provided name of the script action.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The node types on which the script action should be executed.
	Roles map[string]interface{} `json:"roles,omitempty"`

	// REQUIRED; The URI for the script action.
	URI *string `json:"uri,omitempty"`

	// The parameters for the script action.
	Parameters *string `json:"parameters,omitempty"`
}

// SecretBaseClassification provides polymorphic access to related types.
// Call the interface's GetSecretBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureKeyVaultSecretReference, *SecretBase, *SecureString
type SecretBaseClassification interface {
	// GetSecretBase returns the SecretBase content of the underlying type.
	GetSecretBase() *SecretBase
}

// SecretBase - The base definition of a secret type.
type SecretBase struct {
	// REQUIRED; Type of the secret.
	Type *string `json:"type,omitempty"`
}

// GetSecretBase implements the SecretBaseClassification interface for type SecretBase.
func (s *SecretBase) GetSecretBase() *SecretBase { return s }

// SecureString - Azure Data Factory secure string definition. The string value will be masked with asterisks '*' during Get
// or List API calls.
type SecureString struct {
	// REQUIRED; Type of the secret.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Value of secure string.
	Value *string `json:"value,omitempty"`
}

// GetSecretBase implements the SecretBaseClassification interface for type SecureString.
func (s *SecureString) GetSecretBase() *SecretBase {
	return &SecretBase{
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SecureString.
func (s SecureString) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["type"] = "SecureString"
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecureString.
func (s *SecureString) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfDependencyTumblingWindowTriggerReference - Self referenced tumbling window trigger dependency.
type SelfDependencyTumblingWindowTriggerReference struct {
	// REQUIRED; Timespan applied to the start time of a tumbling window when evaluating dependency.
	Offset *string `json:"offset,omitempty"`

	// REQUIRED; The type of dependency reference.
	Type *string `json:"type,omitempty"`

	// The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
	Size *string `json:"size,omitempty"`
}

// GetDependencyReference implements the DependencyReferenceClassification interface for type SelfDependencyTumblingWindowTriggerReference.
func (s *SelfDependencyTumblingWindowTriggerReference) GetDependencyReference() *DependencyReference {
	return &DependencyReference{
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelfDependencyTumblingWindowTriggerReference.
func (s SelfDependencyTumblingWindowTriggerReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "offset", s.Offset)
	populate(objectMap, "size", s.Size)
	objectMap["type"] = "SelfDependencyTumblingWindowTriggerReference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfDependencyTumblingWindowTriggerReference.
func (s *SelfDependencyTumblingWindowTriggerReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "offset":
			err = unpopulate(val, &s.Offset)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, &s.Size)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntime - Self-hosted integration runtime.
type SelfHostedIntegrationRuntime struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Integration runtime description.
	Description *string `json:"description,omitempty"`

	// When this property is not null, means this is a linked integration runtime. The property is used to access original integration
	// runtime.
	TypeProperties *SelfHostedIntegrationRuntimeTypeProperties `json:"typeProperties,omitempty"`
}

// GetIntegrationRuntime implements the IntegrationRuntimeClassification interface for type SelfHostedIntegrationRuntime.
func (s *SelfHostedIntegrationRuntime) GetIntegrationRuntime() *IntegrationRuntime {
	return &IntegrationRuntime{
		Type:                 s.Type,
		Description:          s.Description,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntime.
func (s SelfHostedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	objectMap["type"] = IntegrationRuntimeTypeSelfHosted
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntime.
func (s *SelfHostedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntimeNode - Properties of Self-hosted integration runtime node.
type SelfHostedIntegrationRuntimeNode struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The integration runtime capabilities dictionary
	Capabilities map[string]*string `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; Maximum concurrent jobs on the integration runtime node.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the integration runtime will expire in ISO8601 format.
	ExpiryTime *time.Time `json:"expiryTime,omitempty" azure:"ro"`

	// READ-ONLY; URI for the host machine of the integration runtime.
	HostServiceURI *string `json:"hostServiceUri,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether this node is the active dispatcher for integration runtime requests.
	IsActiveDispatcher *bool `json:"isActiveDispatcher,omitempty" azure:"ro"`

	// READ-ONLY; The most recent time at which the integration runtime was connected in ISO8601 format.
	LastConnectTime *time.Time `json:"lastConnectTime,omitempty" azure:"ro"`

	// READ-ONLY; The last time for the integration runtime node update end.
	LastEndUpdateTime *time.Time `json:"lastEndUpdateTime,omitempty" azure:"ro"`

	// READ-ONLY; The time the node last started up.
	LastStartTime *time.Time `json:"lastStartTime,omitempty" azure:"ro"`

	// READ-ONLY; The last time for the integration runtime node update start.
	LastStartUpdateTime *time.Time `json:"lastStartUpdateTime,omitempty" azure:"ro"`

	// READ-ONLY; The integration runtime node last stop time.
	LastStopTime *time.Time `json:"lastStopTime,omitempty" azure:"ro"`

	// READ-ONLY; The result of the last integration runtime node update.
	LastUpdateResult *IntegrationRuntimeUpdateResult `json:"lastUpdateResult,omitempty" azure:"ro"`

	// READ-ONLY; Machine name of the integration runtime node.
	MachineName *string `json:"machineName,omitempty" azure:"ro"`

	// READ-ONLY; The maximum concurrent jobs in this integration runtime.
	MaxConcurrentJobs *int32 `json:"maxConcurrentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Name of the integration runtime node.
	NodeName *string `json:"nodeName,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the integration runtime node was registered in ISO8601 format.
	RegisterTime *time.Time `json:"registerTime,omitempty" azure:"ro"`

	// READ-ONLY; Status of the integration runtime node.
	Status *SelfHostedIntegrationRuntimeNodeStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Version of the integration runtime node.
	Version *string `json:"version,omitempty" azure:"ro"`

	// READ-ONLY; Status of the integration runtime node version.
	VersionStatus *string `json:"versionStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeNode.
func (s SelfHostedIntegrationRuntimeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capabilities", s.Capabilities)
	populate(objectMap, "concurrentJobsLimit", s.ConcurrentJobsLimit)
	populateTimeRFC3339(objectMap, "expiryTime", s.ExpiryTime)
	populate(objectMap, "hostServiceUri", s.HostServiceURI)
	populate(objectMap, "isActiveDispatcher", s.IsActiveDispatcher)
	populateTimeRFC3339(objectMap, "lastConnectTime", s.LastConnectTime)
	populateTimeRFC3339(objectMap, "lastEndUpdateTime", s.LastEndUpdateTime)
	populateTimeRFC3339(objectMap, "lastStartTime", s.LastStartTime)
	populateTimeRFC3339(objectMap, "lastStartUpdateTime", s.LastStartUpdateTime)
	populateTimeRFC3339(objectMap, "lastStopTime", s.LastStopTime)
	populate(objectMap, "lastUpdateResult", s.LastUpdateResult)
	populate(objectMap, "machineName", s.MachineName)
	populate(objectMap, "maxConcurrentJobs", s.MaxConcurrentJobs)
	populate(objectMap, "nodeName", s.NodeName)
	populateTimeRFC3339(objectMap, "registerTime", s.RegisterTime)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "version", s.Version)
	populate(objectMap, "versionStatus", s.VersionStatus)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeNode.
func (s *SelfHostedIntegrationRuntimeNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capabilities":
			err = unpopulate(val, &s.Capabilities)
			delete(rawMsg, key)
		case "concurrentJobsLimit":
			err = unpopulate(val, &s.ConcurrentJobsLimit)
			delete(rawMsg, key)
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, &s.ExpiryTime)
			delete(rawMsg, key)
		case "hostServiceUri":
			err = unpopulate(val, &s.HostServiceURI)
			delete(rawMsg, key)
		case "isActiveDispatcher":
			err = unpopulate(val, &s.IsActiveDispatcher)
			delete(rawMsg, key)
		case "lastConnectTime":
			err = unpopulateTimeRFC3339(val, &s.LastConnectTime)
			delete(rawMsg, key)
		case "lastEndUpdateTime":
			err = unpopulateTimeRFC3339(val, &s.LastEndUpdateTime)
			delete(rawMsg, key)
		case "lastStartTime":
			err = unpopulateTimeRFC3339(val, &s.LastStartTime)
			delete(rawMsg, key)
		case "lastStartUpdateTime":
			err = unpopulateTimeRFC3339(val, &s.LastStartUpdateTime)
			delete(rawMsg, key)
		case "lastStopTime":
			err = unpopulateTimeRFC3339(val, &s.LastStopTime)
			delete(rawMsg, key)
		case "lastUpdateResult":
			err = unpopulate(val, &s.LastUpdateResult)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, &s.MachineName)
			delete(rawMsg, key)
		case "maxConcurrentJobs":
			err = unpopulate(val, &s.MaxConcurrentJobs)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, &s.NodeName)
			delete(rawMsg, key)
		case "registerTime":
			err = unpopulateTimeRFC3339(val, &s.RegisterTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		case "versionStatus":
			err = unpopulate(val, &s.VersionStatus)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntimeStatus - Self-hosted integration runtime status.
type SelfHostedIntegrationRuntimeStatus struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// REQUIRED; Self-hosted integration runtime status type properties.
	TypeProperties *SelfHostedIntegrationRuntimeStatusTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The data factory name which the integration runtime belong to.
	DataFactoryName *string `json:"dataFactoryName,omitempty" azure:"ro"`

	// READ-ONLY; The state of integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`
}

// GetIntegrationRuntimeStatus implements the IntegrationRuntimeStatusClassification interface for type SelfHostedIntegrationRuntimeStatus.
func (s *SelfHostedIntegrationRuntimeStatus) GetIntegrationRuntimeStatus() *IntegrationRuntimeStatus {
	return &IntegrationRuntimeStatus{
		Type:                 s.Type,
		DataFactoryName:      s.DataFactoryName,
		State:                s.State,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeStatus.
func (s SelfHostedIntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataFactoryName", s.DataFactoryName)
	populate(objectMap, "state", s.State)
	objectMap["type"] = IntegrationRuntimeTypeSelfHosted
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeStatus.
func (s *SelfHostedIntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, &s.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &s.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntimeStatusTypeProperties - Self-hosted integration runtime status type properties.
type SelfHostedIntegrationRuntimeStatusTypeProperties struct {
	// The list of linked integration runtimes that are created to share with this integration runtime.
	Links []*LinkedIntegrationRuntime `json:"links,omitempty"`

	// The list of nodes for this integration runtime.
	Nodes []*SelfHostedIntegrationRuntimeNode `json:"nodes,omitempty"`

	// READ-ONLY; Whether Self-hosted integration runtime auto update has been turned on.
	AutoUpdate *IntegrationRuntimeAutoUpdate `json:"autoUpdate,omitempty" azure:"ro"`

	// READ-ONLY; The estimated time when the self-hosted integration runtime will be updated.
	AutoUpdateETA *time.Time `json:"autoUpdateETA,omitempty" azure:"ro"`

	// READ-ONLY; Object with additional information about integration runtime capabilities.
	Capabilities map[string]*string `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the integration runtime was created, in ISO8601 format.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; It is used to set the encryption mode for node-node communication channel (when more than 2 self-hosted integration
	// runtime nodes exist).
	InternalChannelEncryption *IntegrationRuntimeInternalChannelEncryptionMode `json:"internalChannelEncryption,omitempty" azure:"ro"`

	// READ-ONLY; The latest version on download center.
	LatestVersion *string `json:"latestVersion,omitempty" azure:"ro"`

	// READ-ONLY; The local time zone offset in hours.
	LocalTimeZoneOffset *string `json:"localTimeZoneOffset,omitempty" azure:"ro"`

	// READ-ONLY; The version that the integration runtime is going to update to.
	PushedVersion *string `json:"pushedVersion,omitempty" azure:"ro"`

	// READ-ONLY; The date at which the integration runtime will be scheduled to update, in ISO8601 format.
	ScheduledUpdateDate *time.Time `json:"scheduledUpdateDate,omitempty" azure:"ro"`

	// READ-ONLY; The URLs for the services used in integration runtime backend service.
	ServiceUrls []*string `json:"serviceUrls,omitempty" azure:"ro"`

	// READ-ONLY; The task queue id of the integration runtime.
	TaskQueueID *string `json:"taskQueueId,omitempty" azure:"ro"`

	// READ-ONLY; The time in the date scheduled by service to update the integration runtime, e.g., PT03H is 3 hours
	UpdateDelayOffset *string `json:"updateDelayOffset,omitempty" azure:"ro"`

	// READ-ONLY; Version of the integration runtime.
	Version *string `json:"version,omitempty" azure:"ro"`

	// READ-ONLY; Status of the integration runtime version.
	VersionStatus *string `json:"versionStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeStatusTypeProperties.
func (s SelfHostedIntegrationRuntimeStatusTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoUpdate", s.AutoUpdate)
	populateTimeRFC3339(objectMap, "autoUpdateETA", s.AutoUpdateETA)
	populate(objectMap, "capabilities", s.Capabilities)
	populateTimeRFC3339(objectMap, "createTime", s.CreateTime)
	populate(objectMap, "internalChannelEncryption", s.InternalChannelEncryption)
	populate(objectMap, "latestVersion", s.LatestVersion)
	populate(objectMap, "links", s.Links)
	populate(objectMap, "localTimeZoneOffset", s.LocalTimeZoneOffset)
	populate(objectMap, "nodes", s.Nodes)
	populate(objectMap, "pushedVersion", s.PushedVersion)
	populateTimeRFC3339(objectMap, "scheduledUpdateDate", s.ScheduledUpdateDate)
	populate(objectMap, "serviceUrls", s.ServiceUrls)
	populate(objectMap, "taskQueueId", s.TaskQueueID)
	populate(objectMap, "updateDelayOffset", s.UpdateDelayOffset)
	populate(objectMap, "version", s.Version)
	populate(objectMap, "versionStatus", s.VersionStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeStatusTypeProperties.
func (s *SelfHostedIntegrationRuntimeStatusTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpdate":
			err = unpopulate(val, &s.AutoUpdate)
			delete(rawMsg, key)
		case "autoUpdateETA":
			err = unpopulateTimeRFC3339(val, &s.AutoUpdateETA)
			delete(rawMsg, key)
		case "capabilities":
			err = unpopulate(val, &s.Capabilities)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateTimeRFC3339(val, &s.CreateTime)
			delete(rawMsg, key)
		case "internalChannelEncryption":
			err = unpopulate(val, &s.InternalChannelEncryption)
			delete(rawMsg, key)
		case "latestVersion":
			err = unpopulate(val, &s.LatestVersion)
			delete(rawMsg, key)
		case "links":
			err = unpopulate(val, &s.Links)
			delete(rawMsg, key)
		case "localTimeZoneOffset":
			err = unpopulate(val, &s.LocalTimeZoneOffset)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, &s.Nodes)
			delete(rawMsg, key)
		case "pushedVersion":
			err = unpopulate(val, &s.PushedVersion)
			delete(rawMsg, key)
		case "scheduledUpdateDate":
			err = unpopulateTimeRFC3339(val, &s.ScheduledUpdateDate)
			delete(rawMsg, key)
		case "serviceUrls":
			err = unpopulate(val, &s.ServiceUrls)
			delete(rawMsg, key)
		case "taskQueueId":
			err = unpopulate(val, &s.TaskQueueID)
			delete(rawMsg, key)
		case "updateDelayOffset":
			err = unpopulate(val, &s.UpdateDelayOffset)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		case "versionStatus":
			err = unpopulate(val, &s.VersionStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntimeTypeProperties - The self-hosted integration runtime properties.
type SelfHostedIntegrationRuntimeTypeProperties struct {
	// The base definition of a linked integration runtime.
	LinkedInfo LinkedIntegrationRuntimeTypeClassification `json:"linkedInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s SelfHostedIntegrationRuntimeTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "linkedInfo", s.LinkedInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s *SelfHostedIntegrationRuntimeTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedInfo":
			s.LinkedInfo, err = unmarshalLinkedIntegrationRuntimeTypeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNowLinkedService - ServiceNow server linked service.
type ServiceNowLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; ServiceNow server linked service properties.
	TypeProperties *ServiceNowLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ServiceNowLinkedService.
func (s *ServiceNowLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowLinkedService.
func (s ServiceNowLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "ServiceNow"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedService.
func (s *ServiceNowLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNowLinkedServiceTypeProperties - ServiceNow server linked service properties.
type ServiceNowLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication type to use.
	AuthenticationType *ServiceNowAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The endpoint of the ServiceNow server. (i.e. .service-now.com)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// The client id for OAuth2 authentication.
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The client secret for OAuth2 authentication.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name for Basic and OAuth2 authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`

	// The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowLinkedServiceTypeProperties.
func (s ServiceNowLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "clientId", s.ClientID)
	populate(objectMap, "clientSecret", s.ClientSecret)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "endpoint", s.Endpoint)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", s.UseHostVerification)
	populate(objectMap, "usePeerVerification", s.UsePeerVerification)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedServiceTypeProperties.
func (s *ServiceNowLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &s.AuthenticationType)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, &s.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			s.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &s.Endpoint)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &s.UsePeerVerification)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNowObjectDataset - ServiceNow server dataset.
type ServiceNowObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ServiceNowObjectDataset.
func (s *ServiceNowObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowObjectDataset.
func (s ServiceNowObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "ServiceNowObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowObjectDataset.
func (s *ServiceNowObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNowSource - A copy activity ServiceNow server source.
type ServiceNowSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ServiceNowSource.
func (s *ServiceNowSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type ServiceNowSource.
func (s *ServiceNowSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowSource.
func (s ServiceNowSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "ServiceNowSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowSource.
func (s *ServiceNowSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServicePrincipalCredential - Service principal credential.
type ServicePrincipalCredential struct {
	// REQUIRED; Type of credential.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Service Principal credential properties.
	TypeProperties *ServicePrincipalCredentialTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Credential.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Credential description.
	Description *string `json:"description,omitempty"`
}

// GetCredential implements the CredentialClassification interface for type ServicePrincipalCredential.
func (s *ServicePrincipalCredential) GetCredential() *Credential {
	return &Credential{
		Type:                 s.Type,
		Description:          s.Description,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalCredential.
func (s ServicePrincipalCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	objectMap["type"] = "ServicePrincipal"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalCredential.
func (s *ServicePrincipalCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServicePrincipalCredentialTypeProperties - Service Principal credential type properties.
type ServicePrincipalCredentialTypeProperties struct {
	// The app ID of the service principal used to authenticate
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate.
	ServicePrincipalKey *AzureKeyVaultSecretReference `json:"servicePrincipalKey,omitempty"`

	// The ID of the tenant to which the service principal belongs
	Tenant map[string]interface{} `json:"tenant,omitempty"`
}

// SetVariableActivity - Set value for a Variable.
type SetVariableActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Set Variable activity properties.
	TypeProperties *SetVariableActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type SetVariableActivity.
func (s *SetVariableActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 s.Name,
		Type:                 s.Type,
		Description:          s.Description,
		DependsOn:            s.DependsOn,
		UserProperties:       s.UserProperties,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type SetVariableActivity.
func (s *SetVariableActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 s.Name,
		Type:                 s.Type,
		Description:          s.Description,
		DependsOn:            s.DependsOn,
		UserProperties:       s.UserProperties,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SetVariableActivity.
func (s SetVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = "SetVariable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SetVariableActivity.
func (s *SetVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SetVariableActivityTypeProperties - SetVariable activity properties.
type SetVariableActivityTypeProperties struct {
	// Value to be set. Could be a static value or Expression
	Value map[string]interface{} `json:"value,omitempty"`

	// Name of the variable whose value needs to be set.
	VariableName *string `json:"variableName,omitempty"`
}

// SftpLocation - The location of SFTP dataset.
type SftpLocation struct {
	// REQUIRED; Type of dataset storage location.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName map[string]interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath map[string]interface{} `json:"folderPath,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type SftpLocation.
func (s *SftpLocation) GetDatasetLocation() *DatasetLocation {
	return &DatasetLocation{
		Type:                 s.Type,
		FolderPath:           s.FolderPath,
		FileName:             s.FileName,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SftpLocation.
func (s SftpLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileName", s.FileName)
	populate(objectMap, "folderPath", s.FolderPath)
	objectMap["type"] = "SftpLocation"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpLocation.
func (s *SftpLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, &s.FileName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &s.FolderPath)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SftpReadSettings - Sftp read settings.
type SftpReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	DeleteFilesAfterCompletion map[string]interface{} `json:"deleteFilesAfterCompletion,omitempty"`

	// If true, disable parallel reading within each file. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableChunking map[string]interface{} `json:"disableChunking,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy.
	// Type: string (or Expression with resultType string).
	FileListPath map[string]interface{} `json:"fileListPath,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd map[string]interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart map[string]interface{} `json:"modifiedDatetimeStart,omitempty"`

	// Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
	PartitionRootPath map[string]interface{} `json:"partitionRootPath,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType
	// boolean).
	Recursive map[string]interface{} `json:"recursive,omitempty"`

	// Sftp wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName map[string]interface{} `json:"wildcardFileName,omitempty"`

	// Sftp wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath map[string]interface{} `json:"wildcardFolderPath,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type SftpReadSettings.
func (s *SftpReadSettings) GetStoreReadSettings() *StoreReadSettings {
	return &StoreReadSettings{
		Type:                     s.Type,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SftpReadSettings.
func (s SftpReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deleteFilesAfterCompletion", s.DeleteFilesAfterCompletion)
	populate(objectMap, "disableChunking", s.DisableChunking)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "enablePartitionDiscovery", s.EnablePartitionDiscovery)
	populate(objectMap, "fileListPath", s.FileListPath)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "modifiedDatetimeEnd", s.ModifiedDatetimeEnd)
	populate(objectMap, "modifiedDatetimeStart", s.ModifiedDatetimeStart)
	populate(objectMap, "partitionRootPath", s.PartitionRootPath)
	populate(objectMap, "recursive", s.Recursive)
	objectMap["type"] = "SftpReadSettings"
	populate(objectMap, "wildcardFileName", s.WildcardFileName)
	populate(objectMap, "wildcardFolderPath", s.WildcardFolderPath)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpReadSettings.
func (s *SftpReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteFilesAfterCompletion":
			err = unpopulate(val, &s.DeleteFilesAfterCompletion)
			delete(rawMsg, key)
		case "disableChunking":
			err = unpopulate(val, &s.DisableChunking)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			err = unpopulate(val, &s.EnablePartitionDiscovery)
			delete(rawMsg, key)
		case "fileListPath":
			err = unpopulate(val, &s.FileListPath)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			err = unpopulate(val, &s.ModifiedDatetimeEnd)
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			err = unpopulate(val, &s.ModifiedDatetimeStart)
			delete(rawMsg, key)
		case "partitionRootPath":
			err = unpopulate(val, &s.PartitionRootPath)
			delete(rawMsg, key)
		case "recursive":
			err = unpopulate(val, &s.Recursive)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "wildcardFileName":
			err = unpopulate(val, &s.WildcardFileName)
			delete(rawMsg, key)
		case "wildcardFolderPath":
			err = unpopulate(val, &s.WildcardFolderPath)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SftpServerLinkedService - A linked service for an SSH File Transfer Protocol (SFTP) server.
type SftpServerLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Properties specific to this linked service type.
	TypeProperties *SftpServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SftpServerLinkedService.
func (s *SftpServerLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SftpServerLinkedService.
func (s SftpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Sftp"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedService.
func (s *SftpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SftpServerLinkedServiceTypeProperties - Properties specific to this linked service type.
type SftpServerLinkedServiceTypeProperties struct {
	// REQUIRED; The SFTP server host name. Type: string (or Expression with resultType string).
	Host map[string]interface{} `json:"host,omitempty"`

	// The authentication type to be used to connect to the FTP server.
	AuthenticationType *SftpAuthenticationType `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified.
	// Type: string (or Expression with resultType string).
	HostKeyFingerprint map[string]interface{} `json:"hostKeyFingerprint,omitempty"`

	// The password to decrypt the SSH private key if the SSH private key is encrypted.
	PassPhrase SecretBaseClassification `json:"passPhrase,omitempty"`

	// Password to logon the SFTP server for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or
	// Expression with resultType integer), minimum: 0.
	Port map[string]interface{} `json:"port,omitempty"`

	// Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication,
	// either PrivateKeyPath or PrivateKeyContent should be specified. SSH
	// private key should be OpenSSH format.
	PrivateKeyContent SecretBaseClassification `json:"privateKeyContent,omitempty"`

	// The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with
	// SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should
	// be specified. SSH private key should be OpenSSH format. Type: string (or Expression with resultType string).
	PrivateKeyPath map[string]interface{} `json:"privateKeyPath,omitempty"`

	// If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
	SkipHostKeyValidation map[string]interface{} `json:"skipHostKeyValidation,omitempty"`

	// The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SftpServerLinkedServiceTypeProperties.
func (s SftpServerLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "host", s.Host)
	populate(objectMap, "hostKeyFingerprint", s.HostKeyFingerprint)
	populate(objectMap, "passPhrase", s.PassPhrase)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "port", s.Port)
	populate(objectMap, "privateKeyContent", s.PrivateKeyContent)
	populate(objectMap, "privateKeyPath", s.PrivateKeyPath)
	populate(objectMap, "skipHostKeyValidation", s.SkipHostKeyValidation)
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedServiceTypeProperties.
func (s *SftpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &s.AuthenticationType)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &s.Host)
			delete(rawMsg, key)
		case "hostKeyFingerprint":
			err = unpopulate(val, &s.HostKeyFingerprint)
			delete(rawMsg, key)
		case "passPhrase":
			s.PassPhrase, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &s.Port)
			delete(rawMsg, key)
		case "privateKeyContent":
			s.PrivateKeyContent, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "privateKeyPath":
			err = unpopulate(val, &s.PrivateKeyPath)
			delete(rawMsg, key)
		case "skipHostKeyValidation":
			err = unpopulate(val, &s.SkipHostKeyValidation)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SftpWriteSettings - Sftp write settings.
type SftpWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Specifies the timeout for writing each chunk to SFTP server. Default value: 01:00:00 (one hour). Type: string (or Expression
	// with resultType string).
	OperationTimeout map[string]interface{} `json:"operationTimeout,omitempty"`

	// Upload to temporary file(s) and rename. Disable this option if your SFTP server doesn't support rename operation. Type:
	// boolean (or Expression with resultType boolean).
	UseTempFileRename map[string]interface{} `json:"useTempFileRename,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type SftpWriteSettings.
func (s *SftpWriteSettings) GetStoreWriteSettings() *StoreWriteSettings {
	return &StoreWriteSettings{
		Type:                     s.Type,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		CopyBehavior:             s.CopyBehavior,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SftpWriteSettings.
func (s SftpWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", s.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "operationTimeout", s.OperationTimeout)
	objectMap["type"] = "SftpWriteSettings"
	populate(objectMap, "useTempFileRename", s.UseTempFileRename)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpWriteSettings.
func (s *SftpWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &s.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "operationTimeout":
			err = unpopulate(val, &s.OperationTimeout)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "useTempFileRename":
			err = unpopulate(val, &s.UseTempFileRename)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SharePointOnlineListDatasetTypeProperties - Sharepoint online list dataset properties.
type SharePointOnlineListDatasetTypeProperties struct {
	// The name of the SharePoint Online list. Type: string (or Expression with resultType string).
	ListName map[string]interface{} `json:"listName,omitempty"`
}

// SharePointOnlineListLinkedService - SharePoint Online List linked service.
type SharePointOnlineListLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; SharePoint Online List linked service properties.
	TypeProperties *SharePointOnlineListLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SharePointOnlineListLinkedService.
func (s *SharePointOnlineListLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListLinkedService.
func (s SharePointOnlineListLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "SharePointOnlineList"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListLinkedService.
func (s *SharePointOnlineListLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SharePointOnlineListLinkedServiceTypeProperties - SharePoint Online List linked service properties.
type SharePointOnlineListLinkedServiceTypeProperties struct {
	// REQUIRED; The application (client) ID of your application registered in Azure Active Directory. Make sure to grant SharePoint
	// site permission to this application. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID map[string]interface{} `json:"servicePrincipalId,omitempty"`

	// REQUIRED; The client secret of your application registered in Azure Active Directory. Type: string (or Expression with
	// resultType string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// REQUIRED; The URL of the SharePoint Online site. For example, https://contoso.sharepoint.com/sites/siteName. Type: string
	// (or Expression with resultType string).
	SiteURL map[string]interface{} `json:"siteUrl,omitempty"`

	// REQUIRED; The tenant ID under which your application resides. You can find it from Azure portal Active Directory overview
	// page. Type: string (or Expression with resultType string).
	TenantID map[string]interface{} `json:"tenantId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListLinkedServiceTypeProperties.
func (s SharePointOnlineListLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "servicePrincipalId", s.ServicePrincipalID)
	populate(objectMap, "servicePrincipalKey", s.ServicePrincipalKey)
	populate(objectMap, "siteUrl", s.SiteURL)
	populate(objectMap, "tenantId", s.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListLinkedServiceTypeProperties.
func (s *SharePointOnlineListLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, &s.ServicePrincipalID)
			delete(rawMsg, key)
		case "servicePrincipalKey":
			s.ServicePrincipalKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "siteUrl":
			err = unpopulate(val, &s.SiteURL)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &s.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SharePointOnlineListResourceDataset - The sharepoint online list resource dataset.
type SharePointOnlineListResourceDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Sharepoint online list dataset properties.
	TypeProperties *SharePointOnlineListDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SharePointOnlineListResourceDataset.
func (s *SharePointOnlineListResourceDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListResourceDataset.
func (s SharePointOnlineListResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SharePointOnlineListResource"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListResourceDataset.
func (s *SharePointOnlineListResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SharePointOnlineListSource - A copy activity source for sharePoint online list source.
type SharePointOnlineListSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The wait time to get a response from SharePoint Online. Default value is 5 minutes (00:05:00). Type: string (or Expression
	// with resultType string), pattern:
	// ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout map[string]interface{} `json:"httpRequestTimeout,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The OData query to filter the data in SharePoint Online list. For example, "$top=1". Type: string (or Expression with resultType
	// string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SharePointOnlineListSource.
func (s *SharePointOnlineListSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SharePointOnlineListSource.
func (s SharePointOnlineListSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "httpRequestTimeout", s.HTTPRequestTimeout)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SharePointOnlineListSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointOnlineListSource.
func (s *SharePointOnlineListSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "httpRequestTimeout":
			err = unpopulate(val, &s.HTTPRequestTimeout)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ShopifyLinkedService - Shopify Service linked service.
type ShopifyLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Shopify Service linked service properties.
	TypeProperties *ShopifyLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ShopifyLinkedService.
func (s *ShopifyLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyLinkedService.
func (s ShopifyLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Shopify"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedService.
func (s *ShopifyLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ShopifyLinkedServiceTypeProperties - Shopify Service linked service properties.
type ShopifyLinkedServiceTypeProperties struct {
	// REQUIRED; The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
	Host map[string]interface{} `json:"host,omitempty"`

	// The API access token that can be used to access Shopifys data. The token won't expire if it is offline mode.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyLinkedServiceTypeProperties.
func (s ShopifyLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", s.AccessToken)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "host", s.Host)
	populate(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", s.UseHostVerification)
	populate(objectMap, "usePeerVerification", s.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedServiceTypeProperties.
func (s *ShopifyLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			s.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &s.Host)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &s.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ShopifyObjectDataset - Shopify Service dataset.
type ShopifyObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ShopifyObjectDataset.
func (s *ShopifyObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyObjectDataset.
func (s ShopifyObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "ShopifyObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyObjectDataset.
func (s *ShopifyObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ShopifySource - A copy activity Shopify Service source.
type ShopifySource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ShopifySource.
func (s *ShopifySource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type ShopifySource.
func (s *ShopifySource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ShopifySource.
func (s ShopifySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "ShopifySource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifySource.
func (s *ShopifySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SkipErrorFile - Skip error file.
type SkipErrorFile struct {
	// Skip if source/sink file changed by other concurrent write. Default is false. Type: boolean (or Expression with resultType
	// boolean).
	DataInconsistency map[string]interface{} `json:"dataInconsistency,omitempty"`

	// Skip if file is deleted by other client during copy. Default is true. Type: boolean (or Expression with resultType boolean).
	FileMissing map[string]interface{} `json:"fileMissing,omitempty"`
}

// SnowflakeDataset - The snowflake dataset.
type SnowflakeDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Snowflake dataset properties.
	TypeProperties *SnowflakeDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SnowflakeDataset.
func (s *SnowflakeDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeDataset.
func (s SnowflakeDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SnowflakeTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeDataset.
func (s *SnowflakeDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SnowflakeDatasetTypeProperties - Snowflake dataset properties.
type SnowflakeDatasetTypeProperties struct {
	// The schema name of the Snowflake database. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Snowflake database. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// SnowflakeExportCopyCommand - Snowflake export command settings.
type SnowflakeExportCopyCommand struct {
	// REQUIRED; The export setting type.
	Type *string `json:"type,omitempty"`

	// Additional copy options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type)
	// (or Expression with resultType object). Example: "additionalCopyOptions": { "DATE
	// FORMAT": "MM/DD/YYYY", "TIMEFORMAT": "'HH24:MI:SS.FF'" }
	AdditionalCopyOptions map[string]map[string]interface{} `json:"additionalCopyOptions,omitempty"`

	// Additional format options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type)
	// (or Expression with resultType object). Example: "additionalFormatOptions": {
	// "OVERWRITE": "TRUE", "MAXFILESIZE": "'FALSE'" }
	AdditionalFormatOptions map[string]map[string]interface{} `json:"additionalFormatOptions,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetExportSettings implements the ExportSettingsClassification interface for type SnowflakeExportCopyCommand.
func (s *SnowflakeExportCopyCommand) GetExportSettings() *ExportSettings {
	return &ExportSettings{
		Type:                 s.Type,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeExportCopyCommand.
func (s SnowflakeExportCopyCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalCopyOptions", s.AdditionalCopyOptions)
	populate(objectMap, "additionalFormatOptions", s.AdditionalFormatOptions)
	objectMap["type"] = "SnowflakeExportCopyCommand"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeExportCopyCommand.
func (s *SnowflakeExportCopyCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCopyOptions":
			err = unpopulate(val, &s.AdditionalCopyOptions)
			delete(rawMsg, key)
		case "additionalFormatOptions":
			err = unpopulate(val, &s.AdditionalFormatOptions)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SnowflakeImportCopyCommand - Snowflake import command settings.
type SnowflakeImportCopyCommand struct {
	// REQUIRED; The import setting type.
	Type *string `json:"type,omitempty"`

	// Additional copy options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type)
	// (or Expression with resultType object). Example: "additionalCopyOptions": { "DATE
	// FORMAT": "MM/DD/YYYY", "TIMEFORMAT": "'HH24:MI:SS.FF'" }
	AdditionalCopyOptions map[string]map[string]interface{} `json:"additionalCopyOptions,omitempty"`

	// Additional format options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type)
	// (or Expression with resultType object). Example: "additionalFormatOptions": {
	// "FORCE": "TRUE", "LOADUNCERTAINFILES": "'FALSE'" }
	AdditionalFormatOptions map[string]map[string]interface{} `json:"additionalFormatOptions,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}
}

// GetImportSettings implements the ImportSettingsClassification interface for type SnowflakeImportCopyCommand.
func (s *SnowflakeImportCopyCommand) GetImportSettings() *ImportSettings {
	return &ImportSettings{
		Type:                 s.Type,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeImportCopyCommand.
func (s SnowflakeImportCopyCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalCopyOptions", s.AdditionalCopyOptions)
	populate(objectMap, "additionalFormatOptions", s.AdditionalFormatOptions)
	objectMap["type"] = "SnowflakeImportCopyCommand"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeImportCopyCommand.
func (s *SnowflakeImportCopyCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCopyOptions":
			err = unpopulate(val, &s.AdditionalCopyOptions)
			delete(rawMsg, key)
		case "additionalFormatOptions":
			err = unpopulate(val, &s.AdditionalFormatOptions)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SnowflakeLinkedService - Snowflake linked service.
type SnowflakeLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Snowflake linked service properties.
	TypeProperties *SnowflakeLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SnowflakeLinkedService.
func (s *SnowflakeLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeLinkedService.
func (s SnowflakeLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Snowflake"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeLinkedService.
func (s *SnowflakeLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SnowflakeLinkedServiceTypeProperties - Snowflake linked service properties.
type SnowflakeLinkedServiceTypeProperties struct {
	// REQUIRED; The connection string of snowflake. Type: string, SecureString.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// SnowflakeSink - A copy activity snowflake sink.
type SnowflakeSink struct {
	// REQUIRED; Copy sink type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Snowflake import settings.
	ImportSettings *SnowflakeImportCopyCommand `json:"importSettings,omitempty"`

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript map[string]interface{} `json:"preCopyScript,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount map[string]interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait map[string]interface{} `json:"sinkRetryWait,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize map[string]interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout map[string]interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type SnowflakeSink.
func (s *SnowflakeSink) GetCopySink() *CopySink {
	return &CopySink{
		Type:                     s.Type,
		WriteBatchSize:           s.WriteBatchSize,
		WriteBatchTimeout:        s.WriteBatchTimeout,
		SinkRetryCount:           s.SinkRetryCount,
		SinkRetryWait:            s.SinkRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeSink.
func (s SnowflakeSink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "importSettings", s.ImportSettings)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "preCopyScript", s.PreCopyScript)
	populate(objectMap, "sinkRetryCount", s.SinkRetryCount)
	populate(objectMap, "sinkRetryWait", s.SinkRetryWait)
	objectMap["type"] = "SnowflakeSink"
	populate(objectMap, "writeBatchSize", s.WriteBatchSize)
	populate(objectMap, "writeBatchTimeout", s.WriteBatchTimeout)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeSink.
func (s *SnowflakeSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "importSettings":
			err = unpopulate(val, &s.ImportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "preCopyScript":
			err = unpopulate(val, &s.PreCopyScript)
			delete(rawMsg, key)
		case "sinkRetryCount":
			err = unpopulate(val, &s.SinkRetryCount)
			delete(rawMsg, key)
		case "sinkRetryWait":
			err = unpopulate(val, &s.SinkRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "writeBatchSize":
			err = unpopulate(val, &s.WriteBatchSize)
			delete(rawMsg, key)
		case "writeBatchTimeout":
			err = unpopulate(val, &s.WriteBatchTimeout)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SnowflakeSource - A copy activity snowflake source.
type SnowflakeSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Snowflake export settings.
	ExportSettings *SnowflakeExportCopyCommand `json:"exportSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Snowflake Sql query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SnowflakeSource.
func (s *SnowflakeSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SnowflakeSource.
func (s SnowflakeSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "exportSettings", s.ExportSettings)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SnowflakeSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowflakeSource.
func (s *SnowflakeSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "exportSettings":
			err = unpopulate(val, &s.ExportSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkDatasetTypeProperties - Spark Properties
type SparkDatasetTypeProperties struct {
	// The schema name of the Spark. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Spark. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// SparkLinkedService - Spark Server linked service.
type SparkLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Spark Server linked service properties.
	TypeProperties *SparkLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SparkLinkedService.
func (s *SparkLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SparkLinkedService.
func (s SparkLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Spark"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedService.
func (s *SparkLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkLinkedServiceTypeProperties - Spark Server linked service properties.
type SparkLinkedServiceTypeProperties struct {
	// REQUIRED; The authentication method used to access the Spark server.
	AuthenticationType *SparkAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; IP address or host name of the Spark server
	Host map[string]interface{} `json:"host,omitempty"`

	// REQUIRED; The TCP port that the Spark server uses to listen for client connections.
	Port map[string]interface{} `json:"port,omitempty"`

	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCNMismatch map[string]interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert map[string]interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSSL map[string]interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Spark server.
	HTTPPath map[string]interface{} `json:"httpPath,omitempty"`

	// The password corresponding to the user name that you provided in the Username field
	Password SecretBaseClassification `json:"password,omitempty"`

	// The type of Spark server.
	ServerType *SparkServerType `json:"serverType,omitempty"`

	// The transport protocol to use in the Thrift layer.
	ThriftTransportProtocol *SparkThriftTransportProtocol `json:"thriftTransportProtocol,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath map[string]interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore map[string]interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name that you use to access Spark Server.
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkLinkedServiceTypeProperties.
func (s SparkLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowHostNameCNMismatch", s.AllowHostNameCNMismatch)
	populate(objectMap, "allowSelfSignedServerCert", s.AllowSelfSignedServerCert)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "enableSsl", s.EnableSSL)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "httpPath", s.HTTPPath)
	populate(objectMap, "host", s.Host)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "port", s.Port)
	populate(objectMap, "serverType", s.ServerType)
	populate(objectMap, "thriftTransportProtocol", s.ThriftTransportProtocol)
	populate(objectMap, "trustedCertPath", s.TrustedCertPath)
	populate(objectMap, "useSystemTrustStore", s.UseSystemTrustStore)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedServiceTypeProperties.
func (s *SparkLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			err = unpopulate(val, &s.AllowHostNameCNMismatch)
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			err = unpopulate(val, &s.AllowSelfSignedServerCert)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &s.AuthenticationType)
			delete(rawMsg, key)
		case "enableSsl":
			err = unpopulate(val, &s.EnableSSL)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "httpPath":
			err = unpopulate(val, &s.HTTPPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &s.Host)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &s.Port)
			delete(rawMsg, key)
		case "serverType":
			err = unpopulate(val, &s.ServerType)
			delete(rawMsg, key)
		case "thriftTransportProtocol":
			err = unpopulate(val, &s.ThriftTransportProtocol)
			delete(rawMsg, key)
		case "trustedCertPath":
			err = unpopulate(val, &s.TrustedCertPath)
			delete(rawMsg, key)
		case "useSystemTrustStore":
			err = unpopulate(val, &s.UseSystemTrustStore)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkObjectDataset - Spark Server dataset.
type SparkObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *SparkDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SparkObjectDataset.
func (s *SparkObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SparkObjectDataset.
func (s SparkObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SparkObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkObjectDataset.
func (s *SparkObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkSource - A copy activity Spark Server source.
type SparkSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SparkSource.
func (s *SparkSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SparkSource.
func (s *SparkSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SparkSource.
func (s SparkSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SparkSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkSource.
func (s *SparkSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SquareLinkedService - Square Service linked service.
type SquareLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Square Service linked service properties.
	TypeProperties *SquareLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SquareLinkedService.
func (s *SquareLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SquareLinkedService.
func (s SquareLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Square"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedService.
func (s *SquareLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SquareLinkedServiceTypeProperties - Square Service linked service properties.
type SquareLinkedServiceTypeProperties struct {
	// The client ID associated with your Square application.
	ClientID map[string]interface{} `json:"clientId,omitempty"`

	// The client secret associated with your Square application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// Properties used to connect to Square. It is mutually exclusive with any other properties in the linked service. Type: object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Square instance. (i.e. mystore.mysquare.com)
	Host map[string]interface{} `json:"host,omitempty"`

	// The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
	RedirectURI map[string]interface{} `json:"redirectUri,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SquareLinkedServiceTypeProperties.
func (s SquareLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", s.ClientID)
	populate(objectMap, "clientSecret", s.ClientSecret)
	populate(objectMap, "connectionProperties", s.ConnectionProperties)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "host", s.Host)
	populate(objectMap, "redirectUri", s.RedirectURI)
	populate(objectMap, "useEncryptedEndpoints", s.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", s.UseHostVerification)
	populate(objectMap, "usePeerVerification", s.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedServiceTypeProperties.
func (s *SquareLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &s.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			s.ClientSecret, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, &s.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &s.Host)
			delete(rawMsg, key)
		case "redirectUri":
			err = unpopulate(val, &s.RedirectURI)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &s.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &s.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &s.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SquareObjectDataset - Square Service dataset.
type SquareObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SquareObjectDataset.
func (s *SquareObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SquareObjectDataset.
func (s SquareObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SquareObject"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareObjectDataset.
func (s *SquareObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SquareSource - A copy activity Square Service source.
type SquareSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SquareSource.
func (s *SquareSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SquareSource.
func (s *SquareSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SquareSource.
func (s SquareSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SquareSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareSource.
func (s *SquareSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisEnvironment - Ssis environment.
type SsisEnvironment struct {
	// REQUIRED; Type of metadata.
	Type *SsisObjectMetadataType `json:"type,omitempty"`

	// Metadata description.
	Description *string `json:"description,omitempty"`

	// Folder id which contains environment.
	FolderID *int64 `json:"folderId,omitempty"`

	// Metadata id.
	ID *int64 `json:"id,omitempty"`

	// Metadata name.
	Name *string `json:"name,omitempty"`

	// Variable in environment
	Variables []*SsisVariable `json:"variables,omitempty"`
}

// GetSsisObjectMetadata implements the SsisObjectMetadataClassification interface for type SsisEnvironment.
func (s *SsisEnvironment) GetSsisObjectMetadata() *SsisObjectMetadata {
	return &SsisObjectMetadata{
		Type:        s.Type,
		ID:          s.ID,
		Name:        s.Name,
		Description: s.Description,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SsisEnvironment.
func (s SsisEnvironment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = SsisObjectMetadataTypeEnvironment
	populate(objectMap, "variables", s.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisEnvironment.
func (s *SsisEnvironment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, &s.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, &s.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisEnvironmentReference - Ssis environment reference.
type SsisEnvironmentReference struct {
	// Environment folder name.
	EnvironmentFolderName *string `json:"environmentFolderName,omitempty"`

	// Environment name.
	EnvironmentName *string `json:"environmentName,omitempty"`

	// Environment reference id.
	ID *int64 `json:"id,omitempty"`

	// Reference type
	ReferenceType *string `json:"referenceType,omitempty"`
}

// SsisFolder - Ssis folder.
type SsisFolder struct {
	// REQUIRED; Type of metadata.
	Type *SsisObjectMetadataType `json:"type,omitempty"`

	// Metadata description.
	Description *string `json:"description,omitempty"`

	// Metadata id.
	ID *int64 `json:"id,omitempty"`

	// Metadata name.
	Name *string `json:"name,omitempty"`
}

// GetSsisObjectMetadata implements the SsisObjectMetadataClassification interface for type SsisFolder.
func (s *SsisFolder) GetSsisObjectMetadata() *SsisObjectMetadata {
	return &SsisObjectMetadata{
		Type:        s.Type,
		ID:          s.ID,
		Name:        s.Name,
		Description: s.Description,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SsisFolder.
func (s SsisFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = SsisObjectMetadataTypeFolder
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisFolder.
func (s *SsisFolder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisObjectMetadataClassification provides polymorphic access to related types.
// Call the interface's GetSsisObjectMetadata() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SsisEnvironment, *SsisFolder, *SsisObjectMetadata, *SsisPackage, *SsisProject
type SsisObjectMetadataClassification interface {
	// GetSsisObjectMetadata returns the SsisObjectMetadata content of the underlying type.
	GetSsisObjectMetadata() *SsisObjectMetadata
}

// SsisObjectMetadata - SSIS object metadata.
type SsisObjectMetadata struct {
	// REQUIRED; Type of metadata.
	Type *SsisObjectMetadataType `json:"type,omitempty"`

	// Metadata description.
	Description *string `json:"description,omitempty"`

	// Metadata id.
	ID *int64 `json:"id,omitempty"`

	// Metadata name.
	Name *string `json:"name,omitempty"`
}

// GetSsisObjectMetadata implements the SsisObjectMetadataClassification interface for type SsisObjectMetadata.
func (s *SsisObjectMetadata) GetSsisObjectMetadata() *SsisObjectMetadata { return s }

// SsisObjectMetadataListResponse - A list of SSIS object metadata.
type SsisObjectMetadataListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of SSIS object metadata.
	Value []SsisObjectMetadataClassification `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SsisObjectMetadataListResponse.
func (s SsisObjectMetadataListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisObjectMetadataListResponse.
func (s *SsisObjectMetadataListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &s.NextLink)
			delete(rawMsg, key)
		case "value":
			s.Value, err = unmarshalSsisObjectMetadataClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisObjectMetadataStatusResponse - The status of the operation.
type SsisObjectMetadataStatusResponse struct {
	// The operation error message.
	Error *string `json:"error,omitempty"`

	// The operation name.
	Name *string `json:"name,omitempty"`

	// The operation properties.
	Properties *string `json:"properties,omitempty"`

	// The status of the operation.
	Status *string `json:"status,omitempty"`
}

// SsisPackage - Ssis Package.
type SsisPackage struct {
	// REQUIRED; Type of metadata.
	Type *SsisObjectMetadataType `json:"type,omitempty"`

	// Metadata description.
	Description *string `json:"description,omitempty"`

	// Folder id which contains package.
	FolderID *int64 `json:"folderId,omitempty"`

	// Metadata id.
	ID *int64 `json:"id,omitempty"`

	// Metadata name.
	Name *string `json:"name,omitempty"`

	// Parameters in package
	Parameters []*SsisParameter `json:"parameters,omitempty"`

	// Project id which contains package.
	ProjectID *int64 `json:"projectId,omitempty"`

	// Project version which contains package.
	ProjectVersion *int64 `json:"projectVersion,omitempty"`
}

// GetSsisObjectMetadata implements the SsisObjectMetadataClassification interface for type SsisPackage.
func (s *SsisPackage) GetSsisObjectMetadata() *SsisObjectMetadata {
	return &SsisObjectMetadata{
		Type:        s.Type,
		ID:          s.ID,
		Name:        s.Name,
		Description: s.Description,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SsisPackage.
func (s SsisPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "projectId", s.ProjectID)
	populate(objectMap, "projectVersion", s.ProjectVersion)
	objectMap["type"] = SsisObjectMetadataTypePackage
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisPackage.
func (s *SsisPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, &s.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "projectId":
			err = unpopulate(val, &s.ProjectID)
			delete(rawMsg, key)
		case "projectVersion":
			err = unpopulate(val, &s.ProjectVersion)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisParameter - Ssis parameter.
type SsisParameter struct {
	// Parameter type.
	DataType *string `json:"dataType,omitempty"`

	// Default value of parameter.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Parameter description.
	Description *string `json:"description,omitempty"`

	// Design default value of parameter.
	DesignDefaultValue *string `json:"designDefaultValue,omitempty"`

	// Parameter id.
	ID *int64 `json:"id,omitempty"`

	// Parameter name.
	Name *string `json:"name,omitempty"`

	// Whether parameter is required.
	Required *bool `json:"required,omitempty"`

	// Whether parameter is sensitive.
	Sensitive *bool `json:"sensitive,omitempty"`

	// Default sensitive value of parameter.
	SensitiveDefaultValue *string `json:"sensitiveDefaultValue,omitempty"`

	// Parameter value set.
	ValueSet *bool `json:"valueSet,omitempty"`

	// Parameter value type.
	ValueType *string `json:"valueType,omitempty"`

	// Parameter reference variable.
	Variable *string `json:"variable,omitempty"`
}

// SsisProject - Ssis project.
type SsisProject struct {
	// REQUIRED; Type of metadata.
	Type *SsisObjectMetadataType `json:"type,omitempty"`

	// Metadata description.
	Description *string `json:"description,omitempty"`

	// Environment reference in project
	EnvironmentRefs []*SsisEnvironmentReference `json:"environmentRefs,omitempty"`

	// Folder id which contains project.
	FolderID *int64 `json:"folderId,omitempty"`

	// Metadata id.
	ID *int64 `json:"id,omitempty"`

	// Metadata name.
	Name *string `json:"name,omitempty"`

	// Parameters in project
	Parameters []*SsisParameter `json:"parameters,omitempty"`

	// Project version.
	Version *int64 `json:"version,omitempty"`
}

// GetSsisObjectMetadata implements the SsisObjectMetadataClassification interface for type SsisProject.
func (s *SsisProject) GetSsisObjectMetadata() *SsisObjectMetadata {
	return &SsisObjectMetadata{
		Type:        s.Type,
		ID:          s.ID,
		Name:        s.Name,
		Description: s.Description,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SsisProject.
func (s SsisProject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "environmentRefs", s.EnvironmentRefs)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = SsisObjectMetadataTypeProject
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisProject.
func (s *SsisProject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "environmentRefs":
			err = unpopulate(val, &s.EnvironmentRefs)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, &s.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisVariable - Ssis variable.
type SsisVariable struct {
	// Variable type.
	DataType *string `json:"dataType,omitempty"`

	// Variable description.
	Description *string `json:"description,omitempty"`

	// Variable id.
	ID *int64 `json:"id,omitempty"`

	// Variable name.
	Name *string `json:"name,omitempty"`

	// Whether variable is sensitive.
	Sensitive *bool `json:"sensitive,omitempty"`

	// Variable sensitive value.
	SensitiveValue *string `json:"sensitiveValue,omitempty"`

	// Variable value.
	Value *string `json:"value,omitempty"`
}

// StagingSettings - Staging settings.
type StagingSettings struct {
	// REQUIRED; Staging linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Specifies whether to use compression when copying data via an interim staging. Default value is false. Type: boolean (or
	// Expression with resultType boolean).
	EnableCompression map[string]interface{} `json:"enableCompression,omitempty"`

	// The path to storage for storing the interim data. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StagingSettings.
func (s StagingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enableCompression", s.EnableCompression)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "path", s.Path)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StagingSettings.
func (s *StagingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableCompression":
			err = unpopulate(val, &s.EnableCompression)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, &s.Path)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StoreReadSettingsClassification provides polymorphic access to related types.
// Call the interface's GetStoreReadSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AmazonS3CompatibleReadSettings, *AmazonS3ReadSettings, *AzureBlobFSReadSettings, *AzureBlobStorageReadSettings, *AzureDataLakeStoreReadSettings,
// - *AzureFileStorageReadSettings, *FileServerReadSettings, *FtpReadSettings, *GoogleCloudStorageReadSettings, *HTTPReadSettings,
// - *HdfsReadSettings, *OracleCloudStorageReadSettings, *SftpReadSettings, *StoreReadSettings
type StoreReadSettingsClassification interface {
	// GetStoreReadSettings returns the StoreReadSettings content of the underlying type.
	GetStoreReadSettings() *StoreReadSettings
}

// StoreReadSettings - Connector read setting.
type StoreReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type StoreReadSettings.
func (s *StoreReadSettings) GetStoreReadSettings() *StoreReadSettings { return s }

// MarshalJSON implements the json.Marshaller interface for type StoreReadSettings.
func (s StoreReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	objectMap["type"] = s.Type
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StoreReadSettings.
func (s *StoreReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StoreWriteSettingsClassification provides polymorphic access to related types.
// Call the interface's GetStoreWriteSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureBlobFSWriteSettings, *AzureBlobStorageWriteSettings, *AzureDataLakeStoreWriteSettings, *AzureFileStorageWriteSettings,
// - *FileServerWriteSettings, *SftpWriteSettings, *StoreWriteSettings
type StoreWriteSettingsClassification interface {
	// GetStoreWriteSettings returns the StoreWriteSettings content of the underlying type.
	GetStoreWriteSettings() *StoreWriteSettings
}

// StoreWriteSettings - Connector write settings.
type StoreWriteSettings struct {
	// REQUIRED; The write setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior map[string]interface{} `json:"copyBehavior,omitempty"`

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type StoreWriteSettings.
func (s *StoreWriteSettings) GetStoreWriteSettings() *StoreWriteSettings { return s }

// MarshalJSON implements the json.Marshaller interface for type StoreWriteSettings.
func (s StoreWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyBehavior", s.CopyBehavior)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	objectMap["type"] = s.Type
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StoreWriteSettings.
func (s *StoreWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			err = unpopulate(val, &s.CopyBehavior)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StoredProcedureParameter - SQL stored procedure parameter.
type StoredProcedureParameter struct {
	// Stored procedure parameter type.
	Type *StoredProcedureParameterType `json:"type,omitempty"`

	// Stored procedure parameter value. Type: string (or Expression with resultType string).
	Value map[string]interface{} `json:"value,omitempty"`
}

// SubResource - Azure Data Factory nested resource, which belongs to a factory.
type SubResource struct {
	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SubResourceDebugResource - Azure Data Factory nested debug resource.
type SubResourceDebugResource struct {
	// The resource name.
	Name *string `json:"name,omitempty"`
}

// SwitchActivity - This activity evaluates an expression and executes activities under the cases property that correspond
// to the expression evaluation expected in the equals property.
type SwitchActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Switch activity properties.
	TypeProperties *SwitchActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type SwitchActivity.
func (s *SwitchActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 s.Name,
		Type:                 s.Type,
		Description:          s.Description,
		DependsOn:            s.DependsOn,
		UserProperties:       s.UserProperties,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type SwitchActivity.
func (s *SwitchActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 s.Name,
		Type:                 s.Type,
		Description:          s.Description,
		DependsOn:            s.DependsOn,
		UserProperties:       s.UserProperties,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SwitchActivity.
func (s SwitchActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", s.DependsOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = "Switch"
	populate(objectMap, "typeProperties", s.TypeProperties)
	populate(objectMap, "userProperties", s.UserProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivity.
func (s *SwitchActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &s.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &s.UserProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SwitchActivityTypeProperties - Switch activity properties.
type SwitchActivityTypeProperties struct {
	// REQUIRED; An expression that would evaluate to a string or integer. This is used to determine the block of activities in
	// cases that will be executed.
	On *Expression `json:"on,omitempty"`

	// List of cases that correspond to expected values of the 'on' property. This is an optional property and if not provided,
	// the activity will execute activities provided in defaultActivities.
	Cases []*SwitchCase `json:"cases,omitempty"`

	// List of activities to execute if no case condition is satisfied. This is an optional property and if not provided, the
	// activity will exit without any action.
	DefaultActivities []ActivityClassification `json:"defaultActivities,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SwitchActivityTypeProperties.
func (s SwitchActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cases", s.Cases)
	populate(objectMap, "defaultActivities", s.DefaultActivities)
	populate(objectMap, "on", s.On)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivityTypeProperties.
func (s *SwitchActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cases":
			err = unpopulate(val, &s.Cases)
			delete(rawMsg, key)
		case "defaultActivities":
			s.DefaultActivities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "on":
			err = unpopulate(val, &s.On)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SwitchCase - Switch cases with have a value and corresponding activities.
type SwitchCase struct {
	// List of activities to execute for satisfied case condition.
	Activities []ActivityClassification `json:"activities,omitempty"`

	// Expected value that satisfies the expression result of the 'on' property.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SwitchCase.
func (s SwitchCase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activities", s.Activities)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchCase.
func (s *SwitchCase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			s.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SybaseLinkedService - Linked service for Sybase data source.
type SybaseLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Sybase linked service properties.
	TypeProperties *SybaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type SybaseLinkedService.
func (s *SybaseLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 s.Type,
		ConnectVia:           s.ConnectVia,
		Description:          s.Description,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SybaseLinkedService.
func (s SybaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "connectVia", s.ConnectVia)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	objectMap["type"] = "Sybase"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedService.
func (s *SybaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &s.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SybaseLinkedServiceTypeProperties - Sybase linked service properties.
type SybaseLinkedServiceTypeProperties struct {
	// REQUIRED; Database name for connection. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`

	// REQUIRED; Server name for connection. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// AuthenticationType to be used for connection.
	AuthenticationType *SybaseAuthenticationType `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Schema name for connection. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SybaseLinkedServiceTypeProperties.
func (s SybaseLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "database", s.Database)
	populate(objectMap, "encryptedCredential", s.EncryptedCredential)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "server", s.Server)
	populate(objectMap, "username", s.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedServiceTypeProperties.
func (s *SybaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &s.AuthenticationType)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, &s.Database)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &s.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			s.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &s.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &s.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SybaseSource - A copy activity source for Sybase databases.
type SybaseSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Database query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type SybaseSource.
func (s *SybaseSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type SybaseSource.
func (s *SybaseSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             s.QueryTimeout,
		AdditionalColumns:        s.AdditionalColumns,
		Type:                     s.Type,
		SourceRetryCount:         s.SourceRetryCount,
		SourceRetryWait:          s.SourceRetryWait,
		MaxConcurrentConnections: s.MaxConcurrentConnections,
		DisableMetricsCollection: s.DisableMetricsCollection,
		AdditionalProperties:     s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SybaseSource.
func (s SybaseSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", s.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", s.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", s.MaxConcurrentConnections)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryTimeout", s.QueryTimeout)
	populate(objectMap, "sourceRetryCount", s.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", s.SourceRetryWait)
	objectMap["type"] = "SybaseSource"
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseSource.
func (s *SybaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &s.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &s.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &s.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &s.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &s.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &s.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SybaseTableDataset - The Sybase table dataset.
type SybaseTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Sybase table dataset properties.
	TypeProperties *SybaseTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type SybaseTableDataset.
func (s *SybaseTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 s.Type,
		Description:          s.Description,
		Structure:            s.Structure,
		Schema:               s.Schema,
		LinkedServiceName:    s.LinkedServiceName,
		Parameters:           s.Parameters,
		Annotations:          s.Annotations,
		Folder:               s.Folder,
		AdditionalProperties: s.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SybaseTableDataset.
func (s SybaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "folder", s.Folder)
	populate(objectMap, "linkedServiceName", s.LinkedServiceName)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "schema", s.Schema)
	populate(objectMap, "structure", s.Structure)
	objectMap["type"] = "SybaseTable"
	populate(objectMap, "typeProperties", s.TypeProperties)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseTableDataset.
func (s *SybaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &s.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &s.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &s.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &s.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SybaseTableDatasetTypeProperties - Sybase table dataset properties.
type SybaseTableDatasetTypeProperties struct {
	// The Sybase table name. Type: string (or Expression with resultType string).
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// TabularSourceClassification provides polymorphic access to related types.
// Call the interface's GetTabularSource() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AmazonMWSSource, *AmazonRdsForSQLServerSource, *AmazonRedshiftSource, *AzureMariaDBSource, *AzureMySQLSource, *AzurePostgreSQLSource,
// - *AzureSQLSource, *AzureTableSource, *CassandraSource, *ConcurSource, *CouchbaseSource, *Db2Source, *DrillSource, *DynamicsAXSource,
// - *EloquaSource, *GoogleAdWordsSource, *GoogleBigQuerySource, *GreenplumSource, *HBaseSource, *HiveSource, *HubspotSource,
// - *ImpalaSource, *InformixSource, *JiraSource, *MagentoSource, *MariaDBSource, *MarketoSource, *MySQLSource, *NetezzaSource,
// - *OdbcSource, *OracleServiceCloudSource, *PaypalSource, *PhoenixSource, *PostgreSQLSource, *PrestoSource, *QuickBooksSource,
// - *ResponsysSource, *SQLDWSource, *SQLMISource, *SQLServerSource, *SQLSource, *SalesforceMarketingCloudSource, *SalesforceSource,
// - *SapBwSource, *SapCloudForCustomerSource, *SapEccSource, *SapHanaSource, *SapOpenHubSource, *SapTableSource, *ServiceNowSource,
// - *ShopifySource, *SparkSource, *SquareSource, *SybaseSource, *TabularSource, *TeradataSource, *VerticaSource, *XeroSource,
// - *ZohoSource
type TabularSourceClassification interface {
	CopySourceClassification
	// GetTabularSource returns the TabularSource content of the underlying type.
	GetTabularSource() *TabularSource
}

// TabularSource - Copy activity sources of tabular type.
type TabularSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type TabularSource.
func (t *TabularSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     t.Type,
		SourceRetryCount:         t.SourceRetryCount,
		SourceRetryWait:          t.SourceRetryWait,
		MaxConcurrentConnections: t.MaxConcurrentConnections,
		DisableMetricsCollection: t.DisableMetricsCollection,
		AdditionalProperties:     t.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type TabularSource.
func (t *TabularSource) GetTabularSource() *TabularSource { return t }

// MarshalJSON implements the json.Marshaller interface for type TabularSource.
func (t TabularSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", t.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", t.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", t.MaxConcurrentConnections)
	populate(objectMap, "queryTimeout", t.QueryTimeout)
	populate(objectMap, "sourceRetryCount", t.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", t.SourceRetryWait)
	objectMap["type"] = "TabularSource"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TabularSource.
func (t *TabularSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &t.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &t.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &t.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &t.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &t.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &t.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TabularTranslator - A copy activity tabular translator.
type TabularTranslator struct {
	// REQUIRED; Copy translator type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The JSON Path of the Nested Array that is going to do cross-apply. Type: object (or Expression with resultType object).
	CollectionReference map[string]interface{} `json:"collectionReference,omitempty"`

	// Column mappings. Example: "UserId: MyUserId, Group: MyGroup, Name: MyName" Type: string (or Expression with resultType
	// string). This property will be retired. Please use mappings property.
	ColumnMappings map[string]interface{} `json:"columnMappings,omitempty"`

	// Whether to map complex (array and object) values to simple strings in json format. Type: boolean (or Expression with resultType
	// boolean).
	MapComplexValuesToString map[string]interface{} `json:"mapComplexValuesToString,omitempty"`

	// Column mappings with logical types. Tabular->tabular example:
	// [{"source":{"name":"CustomerName","type":"String"},"sink":{"name":"ClientName","type":"String"}},{"source":{"name":"CustomerAddress","type":"String"},"sink":{"name":"ClientAddress","type":"String"}}].
	// Hierarchical->tabular example:
	// [{"source":{"path":"$.CustomerName","type":"String"},"sink":{"name":"ClientName","type":"String"}},{"source":{"path":"$.CustomerAddress","type":"String"},"sink":{"name":"ClientAddress","type":"String"}}].
	// Type: object (or Expression with resultType object).
	Mappings map[string]interface{} `json:"mappings,omitempty"`

	// The schema mapping to map between tabular data and hierarchical data. Example: {"Column1": "$.Column1", "Column2": "$.Column2.Property1",
	// "Column3": "$.Column2.Property2"}. Type: object (or Expression
	// with resultType object). This property will be retired. Please use mappings property.
	SchemaMapping map[string]interface{} `json:"schemaMapping,omitempty"`

	// Whether to enable the advanced type conversion feature in the Copy activity. Type: boolean (or Expression with resultType
	// boolean).
	TypeConversion map[string]interface{} `json:"typeConversion,omitempty"`

	// Type conversion settings
	TypeConversionSettings *TypeConversionSettings `json:"typeConversionSettings,omitempty"`
}

// GetCopyTranslator implements the CopyTranslatorClassification interface for type TabularTranslator.
func (t *TabularTranslator) GetCopyTranslator() *CopyTranslator {
	return &CopyTranslator{
		Type:                 t.Type,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TabularTranslator.
func (t TabularTranslator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "collectionReference", t.CollectionReference)
	populate(objectMap, "columnMappings", t.ColumnMappings)
	populate(objectMap, "mapComplexValuesToString", t.MapComplexValuesToString)
	populate(objectMap, "mappings", t.Mappings)
	populate(objectMap, "schemaMapping", t.SchemaMapping)
	objectMap["type"] = "TabularTranslator"
	populate(objectMap, "typeConversion", t.TypeConversion)
	populate(objectMap, "typeConversionSettings", t.TypeConversionSettings)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TabularTranslator.
func (t *TabularTranslator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collectionReference":
			err = unpopulate(val, &t.CollectionReference)
			delete(rawMsg, key)
		case "columnMappings":
			err = unpopulate(val, &t.ColumnMappings)
			delete(rawMsg, key)
		case "mapComplexValuesToString":
			err = unpopulate(val, &t.MapComplexValuesToString)
			delete(rawMsg, key)
		case "mappings":
			err = unpopulate(val, &t.Mappings)
			delete(rawMsg, key)
		case "schemaMapping":
			err = unpopulate(val, &t.SchemaMapping)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		case "typeConversion":
			err = unpopulate(val, &t.TypeConversion)
			delete(rawMsg, key)
		case "typeConversionSettings":
			err = unpopulate(val, &t.TypeConversionSettings)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TarGZipReadSettings - The TarGZip compression read settings.
type TarGZipReadSettings struct {
	// REQUIRED; The Compression setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Preserve the compression file name as folder path. Type: boolean (or Expression with resultType boolean).
	PreserveCompressionFileNameAsFolder map[string]interface{} `json:"preserveCompressionFileNameAsFolder,omitempty"`
}

// GetCompressionReadSettings implements the CompressionReadSettingsClassification interface for type TarGZipReadSettings.
func (t *TarGZipReadSettings) GetCompressionReadSettings() *CompressionReadSettings {
	return &CompressionReadSettings{
		Type:                 t.Type,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TarGZipReadSettings.
func (t TarGZipReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "preserveCompressionFileNameAsFolder", t.PreserveCompressionFileNameAsFolder)
	objectMap["type"] = "TarGZipReadSettings"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TarGZipReadSettings.
func (t *TarGZipReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preserveCompressionFileNameAsFolder":
			err = unpopulate(val, &t.PreserveCompressionFileNameAsFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TarReadSettings - The Tar compression read settings.
type TarReadSettings struct {
	// REQUIRED; The Compression setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Preserve the compression file name as folder path. Type: boolean (or Expression with resultType boolean).
	PreserveCompressionFileNameAsFolder map[string]interface{} `json:"preserveCompressionFileNameAsFolder,omitempty"`
}

// GetCompressionReadSettings implements the CompressionReadSettingsClassification interface for type TarReadSettings.
func (t *TarReadSettings) GetCompressionReadSettings() *CompressionReadSettings {
	return &CompressionReadSettings{
		Type:                 t.Type,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TarReadSettings.
func (t TarReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "preserveCompressionFileNameAsFolder", t.PreserveCompressionFileNameAsFolder)
	objectMap["type"] = "TarReadSettings"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TarReadSettings.
func (t *TarReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preserveCompressionFileNameAsFolder":
			err = unpopulate(val, &t.PreserveCompressionFileNameAsFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TeradataLinkedService - Linked service for Teradata data source.
type TeradataLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Teradata linked service properties.
	TypeProperties *TeradataLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type TeradataLinkedService.
func (t *TeradataLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 t.Type,
		ConnectVia:           t.ConnectVia,
		Description:          t.Description,
		Parameters:           t.Parameters,
		Annotations:          t.Annotations,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TeradataLinkedService.
func (t TeradataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "connectVia", t.ConnectVia)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "parameters", t.Parameters)
	objectMap["type"] = "Teradata"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedService.
func (t *TeradataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &t.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &t.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &t.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TeradataLinkedServiceTypeProperties - Teradata linked service properties.
type TeradataLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *TeradataAuthenticationType `json:"authenticationType,omitempty"`

	// Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server map[string]interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TeradataLinkedServiceTypeProperties.
func (t TeradataLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationType", t.AuthenticationType)
	populate(objectMap, "connectionString", t.ConnectionString)
	populate(objectMap, "encryptedCredential", t.EncryptedCredential)
	populate(objectMap, "password", t.Password)
	populate(objectMap, "server", t.Server)
	populate(objectMap, "username", t.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedServiceTypeProperties.
func (t *TeradataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &t.AuthenticationType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &t.ConnectionString)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &t.EncryptedCredential)
			delete(rawMsg, key)
		case "password":
			t.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &t.Server)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &t.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TeradataPartitionSettings - The settings that will be leveraged for teradata source partitioning.
type TeradataPartitionSettings struct {
	// The name of the column that will be used for proceeding range or hash partitioning. Type: string (or Expression with resultType
	// string).
	PartitionColumnName map[string]interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionLowerBound map[string]interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type:
	// string (or Expression with resultType string).
	PartitionUpperBound map[string]interface{} `json:"partitionUpperBound,omitempty"`
}

// TeradataSource - A copy activity Teradata source.
type TeradataSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// The partition mechanism that will be used for teradata read in parallel. Possible values include: "None", "Hash", "DynamicRange".
	PartitionOption map[string]interface{} `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for teradata source partitioning.
	PartitionSettings *TeradataPartitionSettings `json:"partitionSettings,omitempty"`

	// Teradata query. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type TeradataSource.
func (t *TeradataSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     t.Type,
		SourceRetryCount:         t.SourceRetryCount,
		SourceRetryWait:          t.SourceRetryWait,
		MaxConcurrentConnections: t.MaxConcurrentConnections,
		DisableMetricsCollection: t.DisableMetricsCollection,
		AdditionalProperties:     t.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type TeradataSource.
func (t *TeradataSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             t.QueryTimeout,
		AdditionalColumns:        t.AdditionalColumns,
		Type:                     t.Type,
		SourceRetryCount:         t.SourceRetryCount,
		SourceRetryWait:          t.SourceRetryWait,
		MaxConcurrentConnections: t.MaxConcurrentConnections,
		DisableMetricsCollection: t.DisableMetricsCollection,
		AdditionalProperties:     t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TeradataSource.
func (t TeradataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", t.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", t.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", t.MaxConcurrentConnections)
	populate(objectMap, "partitionOption", t.PartitionOption)
	populate(objectMap, "partitionSettings", t.PartitionSettings)
	populate(objectMap, "query", t.Query)
	populate(objectMap, "queryTimeout", t.QueryTimeout)
	populate(objectMap, "sourceRetryCount", t.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", t.SourceRetryWait)
	objectMap["type"] = "TeradataSource"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataSource.
func (t *TeradataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &t.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &t.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &t.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "partitionOption":
			err = unpopulate(val, &t.PartitionOption)
			delete(rawMsg, key)
		case "partitionSettings":
			err = unpopulate(val, &t.PartitionSettings)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &t.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &t.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &t.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &t.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TeradataTableDataset - The Teradata database dataset.
type TeradataTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Teradata dataset properties.
	TypeProperties *TeradataTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type TeradataTableDataset.
func (t *TeradataTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 t.Type,
		Description:          t.Description,
		Structure:            t.Structure,
		Schema:               t.Schema,
		LinkedServiceName:    t.LinkedServiceName,
		Parameters:           t.Parameters,
		Annotations:          t.Annotations,
		Folder:               t.Folder,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TeradataTableDataset.
func (t TeradataTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "folder", t.Folder)
	populate(objectMap, "linkedServiceName", t.LinkedServiceName)
	populate(objectMap, "parameters", t.Parameters)
	populate(objectMap, "schema", t.Schema)
	populate(objectMap, "structure", t.Structure)
	objectMap["type"] = "TeradataTable"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataTableDataset.
func (t *TeradataTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &t.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &t.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &t.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &t.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &t.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &t.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TeradataTableDatasetTypeProperties - Teradata dataset properties.
type TeradataTableDatasetTypeProperties struct {
	// The database name of Teradata. Type: string (or Expression with resultType string).
	Database map[string]interface{} `json:"database,omitempty"`

	// The table name of Teradata. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`
}

// TextFormat - The data stored in text format.
type TextFormat struct {
	// REQUIRED; Type of dataset storage format.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The column delimiter. Type: string (or Expression with resultType string).
	ColumnDelimiter map[string]interface{} `json:"columnDelimiter,omitempty"`

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer map[string]interface{} `json:"deserializer,omitempty"`

	// The code page name of the preferred encoding. If miss, the default value is utf-8, unless BOM denotes another Unicode
	// encoding. Refer to the Name column of the table in the following link
	// to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with
	// resultType string).
	EncodingName map[string]interface{} `json:"encodingName,omitempty"`

	// The escape character. Type: string (or Expression with resultType string).
	EscapeChar map[string]interface{} `json:"escapeChar,omitempty"`

	// When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the
	// first row of data. The default value is false. Type: boolean (or Expression
	// with resultType boolean).
	FirstRowAsHeader map[string]interface{} `json:"firstRowAsHeader,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue map[string]interface{} `json:"nullValue,omitempty"`

	// The quote character. Type: string (or Expression with resultType string).
	QuoteChar map[string]interface{} `json:"quoteChar,omitempty"`

	// The row delimiter. Type: string (or Expression with resultType string).
	RowDelimiter map[string]interface{} `json:"rowDelimiter,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer map[string]interface{} `json:"serializer,omitempty"`

	// The number of lines/rows to be skipped when parsing text files. The default value is 0. Type: integer (or Expression with
	// resultType integer).
	SkipLineCount map[string]interface{} `json:"skipLineCount,omitempty"`

	// Treat empty column values in the text file as null. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	TreatEmptyAsNull map[string]interface{} `json:"treatEmptyAsNull,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type TextFormat.
func (t *TextFormat) GetDatasetStorageFormat() *DatasetStorageFormat {
	return &DatasetStorageFormat{
		Type:                 t.Type,
		Serializer:           t.Serializer,
		Deserializer:         t.Deserializer,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TextFormat.
func (t TextFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columnDelimiter", t.ColumnDelimiter)
	populate(objectMap, "deserializer", t.Deserializer)
	populate(objectMap, "encodingName", t.EncodingName)
	populate(objectMap, "escapeChar", t.EscapeChar)
	populate(objectMap, "firstRowAsHeader", t.FirstRowAsHeader)
	populate(objectMap, "nullValue", t.NullValue)
	populate(objectMap, "quoteChar", t.QuoteChar)
	populate(objectMap, "rowDelimiter", t.RowDelimiter)
	populate(objectMap, "serializer", t.Serializer)
	populate(objectMap, "skipLineCount", t.SkipLineCount)
	populate(objectMap, "treatEmptyAsNull", t.TreatEmptyAsNull)
	objectMap["type"] = "TextFormat"
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextFormat.
func (t *TextFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			err = unpopulate(val, &t.ColumnDelimiter)
			delete(rawMsg, key)
		case "deserializer":
			err = unpopulate(val, &t.Deserializer)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, &t.EncodingName)
			delete(rawMsg, key)
		case "escapeChar":
			err = unpopulate(val, &t.EscapeChar)
			delete(rawMsg, key)
		case "firstRowAsHeader":
			err = unpopulate(val, &t.FirstRowAsHeader)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, &t.NullValue)
			delete(rawMsg, key)
		case "quoteChar":
			err = unpopulate(val, &t.QuoteChar)
			delete(rawMsg, key)
		case "rowDelimiter":
			err = unpopulate(val, &t.RowDelimiter)
			delete(rawMsg, key)
		case "serializer":
			err = unpopulate(val, &t.Serializer)
			delete(rawMsg, key)
		case "skipLineCount":
			err = unpopulate(val, &t.SkipLineCount)
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			err = unpopulate(val, &t.TreatEmptyAsNull)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Transformation - A data flow transformation.
type Transformation struct {
	// REQUIRED; Transformation name.
	Name *string `json:"name,omitempty"`

	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Flowlet Reference
	Flowlet *DataFlowReference `json:"flowlet,omitempty"`

	// Linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`
}

// TriggerClassification provides polymorphic access to related types.
// Call the interface's GetTrigger() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *BlobEventsTrigger, *BlobTrigger, *ChainingTrigger, *CustomEventsTrigger, *MultiplePipelineTrigger, *RerunTumblingWindowTrigger,
// - *ScheduleTrigger, *Trigger, *TumblingWindowTrigger
type TriggerClassification interface {
	// GetTrigger returns the Trigger content of the underlying type.
	GetTrigger() *Trigger
}

// Trigger - Azure data factory nested object which contains information about creating pipeline run
type Trigger struct {
	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetTrigger implements the TriggerClassification interface for type Trigger.
func (t *Trigger) GetTrigger() *Trigger { return t }

// MarshalJSON implements the json.Marshaller interface for type Trigger.
func (t Trigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "runtimeState", t.RuntimeState)
	objectMap["type"] = t.Type
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Trigger.
func (t *Trigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &t.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &t.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerDependencyReferenceClassification provides polymorphic access to related types.
// Call the interface's GetTriggerDependencyReference() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *TriggerDependencyReference, *TumblingWindowTriggerDependencyReference
type TriggerDependencyReferenceClassification interface {
	DependencyReferenceClassification
	// GetTriggerDependencyReference returns the TriggerDependencyReference content of the underlying type.
	GetTriggerDependencyReference() *TriggerDependencyReference
}

// TriggerDependencyReference - Trigger referenced dependency.
type TriggerDependencyReference struct {
	// REQUIRED; Referenced trigger.
	ReferenceTrigger *TriggerReference `json:"referenceTrigger,omitempty"`

	// REQUIRED; The type of dependency reference.
	Type *string `json:"type,omitempty"`
}

// GetDependencyReference implements the DependencyReferenceClassification interface for type TriggerDependencyReference.
func (t *TriggerDependencyReference) GetDependencyReference() *DependencyReference {
	return &DependencyReference{
		Type: t.Type,
	}
}

// GetTriggerDependencyReference implements the TriggerDependencyReferenceClassification interface for type TriggerDependencyReference.
func (t *TriggerDependencyReference) GetTriggerDependencyReference() *TriggerDependencyReference {
	return t
}

// MarshalJSON implements the json.Marshaller interface for type TriggerDependencyReference.
func (t TriggerDependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "referenceTrigger", t.ReferenceTrigger)
	objectMap["type"] = "TriggerDependencyReference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerDependencyReference.
func (t *TriggerDependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceTrigger":
			err = unpopulate(val, &t.ReferenceTrigger)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerFilterParameters - Query parameters for triggers.
type TriggerFilterParameters struct {
	// The continuation token for getting the next page of results. Null for first page.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// The name of the parent TumblingWindowTrigger to get the child rerun triggers
	ParentTriggerName *string `json:"parentTriggerName,omitempty"`
}

// TriggerListResponse - A list of trigger resources.
type TriggerListResponse struct {
	// REQUIRED; List of triggers.
	Value []*TriggerResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerListResponse.
func (t TriggerListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TriggerPipelineReference - Pipeline that needs to be triggered with the given parameters.
type TriggerPipelineReference struct {
	// Pipeline parameters.
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`

	// Pipeline reference.
	PipelineReference *PipelineReference `json:"pipelineReference,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerPipelineReference.
func (t TriggerPipelineReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parameters", t.Parameters)
	populate(objectMap, "pipelineReference", t.PipelineReference)
	return json.Marshal(objectMap)
}

// TriggerQueryResponse - A query of triggers.
type TriggerQueryResponse struct {
	// REQUIRED; List of triggers.
	Value []*TriggerResource `json:"value,omitempty"`

	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerQueryResponse.
func (t TriggerQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "continuationToken", t.ContinuationToken)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TriggerReference - Trigger reference type.
type TriggerReference struct {
	// REQUIRED; Reference trigger name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// REQUIRED; Trigger reference type.
	Type *TriggerReferenceType `json:"type,omitempty"`
}

// TriggerResource - Trigger resource type.
type TriggerResource struct {
	// REQUIRED; Properties of the trigger.
	Properties TriggerClassification `json:"properties,omitempty"`

	// READ-ONLY; Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerResource.
func (t TriggerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerResource.
func (t *TriggerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &t.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &t.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "properties":
			t.Properties, err = unmarshalTriggerClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerRun - Trigger runs.
type TriggerRun struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Status of the upstream pipelines.
	DependencyStatus map[string]map[string]interface{} `json:"dependencyStatus,omitempty" azure:"ro"`

	// READ-ONLY; Trigger error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; List of property name and value related to trigger run. Name, value pair depends on type of trigger.
	Properties map[string]*string `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; Run dimension for which trigger was fired.
	RunDimension map[string]*string `json:"runDimension,omitempty" azure:"ro"`

	// READ-ONLY; Trigger run status.
	Status *TriggerRunStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Trigger name.
	TriggerName *string `json:"triggerName,omitempty" azure:"ro"`

	// READ-ONLY; Trigger run id.
	TriggerRunID *string `json:"triggerRunId,omitempty" azure:"ro"`

	// READ-ONLY; Trigger run start time.
	TriggerRunTimestamp *time.Time `json:"triggerRunTimestamp,omitempty" azure:"ro"`

	// READ-ONLY; Trigger type.
	TriggerType *string `json:"triggerType,omitempty" azure:"ro"`

	// READ-ONLY; List of pipeline name and run Id triggered by the trigger run.
	TriggeredPipelines map[string]*string `json:"triggeredPipelines,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerRun.
func (t TriggerRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependencyStatus", t.DependencyStatus)
	populate(objectMap, "message", t.Message)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "runDimension", t.RunDimension)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "triggerName", t.TriggerName)
	populate(objectMap, "triggerRunId", t.TriggerRunID)
	populateTimeRFC3339(objectMap, "triggerRunTimestamp", t.TriggerRunTimestamp)
	populate(objectMap, "triggerType", t.TriggerType)
	populate(objectMap, "triggeredPipelines", t.TriggeredPipelines)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerRun.
func (t *TriggerRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependencyStatus":
			err = unpopulate(val, &t.DependencyStatus)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &t.Message)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "runDimension":
			err = unpopulate(val, &t.RunDimension)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "triggerName":
			err = unpopulate(val, &t.TriggerName)
			delete(rawMsg, key)
		case "triggerRunId":
			err = unpopulate(val, &t.TriggerRunID)
			delete(rawMsg, key)
		case "triggerRunTimestamp":
			err = unpopulateTimeRFC3339(val, &t.TriggerRunTimestamp)
			delete(rawMsg, key)
		case "triggerType":
			err = unpopulate(val, &t.TriggerType)
			delete(rawMsg, key)
		case "triggeredPipelines":
			err = unpopulate(val, &t.TriggeredPipelines)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerRunsClientCancelOptions contains the optional parameters for the TriggerRunsClient.Cancel method.
type TriggerRunsClientCancelOptions struct {
	// placeholder for future optional parameters
}

// TriggerRunsClientQueryByFactoryOptions contains the optional parameters for the TriggerRunsClient.QueryByFactory method.
type TriggerRunsClientQueryByFactoryOptions struct {
	// placeholder for future optional parameters
}

// TriggerRunsClientRerunOptions contains the optional parameters for the TriggerRunsClient.Rerun method.
type TriggerRunsClientRerunOptions struct {
	// placeholder for future optional parameters
}

// TriggerRunsQueryResponse - A list of trigger runs.
type TriggerRunsQueryResponse struct {
	// REQUIRED; List of trigger runs.
	Value []*TriggerRun `json:"value,omitempty"`

	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerRunsQueryResponse.
func (t TriggerRunsQueryResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "continuationToken", t.ContinuationToken)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TriggerSubscriptionOperationStatus - Defines the response of a trigger subscription operation.
type TriggerSubscriptionOperationStatus struct {
	// READ-ONLY; Event Subscription Status.
	Status *EventSubscriptionStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Trigger name.
	TriggerName *string `json:"triggerName,omitempty" azure:"ro"`
}

// TriggersClientBeginStartOptions contains the optional parameters for the TriggersClient.BeginStart method.
type TriggersClientBeginStartOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientBeginStopOptions contains the optional parameters for the TriggersClient.BeginStop method.
type TriggersClientBeginStopOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientBeginSubscribeToEventsOptions contains the optional parameters for the TriggersClient.BeginSubscribeToEvents
// method.
type TriggersClientBeginSubscribeToEventsOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientBeginUnsubscribeFromEventsOptions contains the optional parameters for the TriggersClient.BeginUnsubscribeFromEvents
// method.
type TriggersClientBeginUnsubscribeFromEventsOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientCreateOrUpdateOptions contains the optional parameters for the TriggersClient.CreateOrUpdate method.
type TriggersClientCreateOrUpdateOptions struct {
	// ETag of the trigger entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// TriggersClientDeleteOptions contains the optional parameters for the TriggersClient.Delete method.
type TriggersClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientGetEventSubscriptionStatusOptions contains the optional parameters for the TriggersClient.GetEventSubscriptionStatus
// method.
type TriggersClientGetEventSubscriptionStatusOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientGetOptions contains the optional parameters for the TriggersClient.Get method.
type TriggersClientGetOptions struct {
	// ETag of the trigger entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// TriggersClientListByFactoryOptions contains the optional parameters for the TriggersClient.ListByFactory method.
type TriggersClientListByFactoryOptions struct {
	// placeholder for future optional parameters
}

// TriggersClientQueryByFactoryOptions contains the optional parameters for the TriggersClient.QueryByFactory method.
type TriggersClientQueryByFactoryOptions struct {
	// placeholder for future optional parameters
}

// TumblingWindowTrigger - Trigger that schedules pipeline runs for all fixed time interval windows from a start time without
// gaps and also supports backfill scenarios (when start time is in the past).
type TumblingWindowTrigger struct {
	// REQUIRED; Pipeline for which runs are created when an event is fired for trigger window that is ready.
	Pipeline *TriggerPipelineReference `json:"pipeline,omitempty"`

	// REQUIRED; Trigger type.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Tumbling Window Trigger properties.
	TypeProperties *TumblingWindowTriggerTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`
}

// GetTrigger implements the TriggerClassification interface for type TumblingWindowTrigger.
func (t *TumblingWindowTrigger) GetTrigger() *Trigger {
	return &Trigger{
		Type:                 t.Type,
		Description:          t.Description,
		RuntimeState:         t.RuntimeState,
		Annotations:          t.Annotations,
		AdditionalProperties: t.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTrigger.
func (t TumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", t.Annotations)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "pipeline", t.Pipeline)
	populate(objectMap, "runtimeState", t.RuntimeState)
	objectMap["type"] = "TumblingWindowTrigger"
	populate(objectMap, "typeProperties", t.TypeProperties)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTrigger.
func (t *TumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &t.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "pipeline":
			err = unpopulate(val, &t.Pipeline)
			delete(rawMsg, key)
		case "runtimeState":
			err = unpopulate(val, &t.RuntimeState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &t.TypeProperties)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TumblingWindowTriggerDependencyReference - Referenced tumbling window trigger dependency.
type TumblingWindowTriggerDependencyReference struct {
	// REQUIRED; Referenced trigger.
	ReferenceTrigger *TriggerReference `json:"referenceTrigger,omitempty"`

	// REQUIRED; The type of dependency reference.
	Type *string `json:"type,omitempty"`

	// Timespan applied to the start time of a tumbling window when evaluating dependency.
	Offset *string `json:"offset,omitempty"`

	// The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
	Size *string `json:"size,omitempty"`
}

// GetDependencyReference implements the DependencyReferenceClassification interface for type TumblingWindowTriggerDependencyReference.
func (t *TumblingWindowTriggerDependencyReference) GetDependencyReference() *DependencyReference {
	return &DependencyReference{
		Type: t.Type,
	}
}

// GetTriggerDependencyReference implements the TriggerDependencyReferenceClassification interface for type TumblingWindowTriggerDependencyReference.
func (t *TumblingWindowTriggerDependencyReference) GetTriggerDependencyReference() *TriggerDependencyReference {
	return &TriggerDependencyReference{
		ReferenceTrigger: t.ReferenceTrigger,
		Type:             t.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTriggerDependencyReference.
func (t TumblingWindowTriggerDependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "offset", t.Offset)
	populate(objectMap, "referenceTrigger", t.ReferenceTrigger)
	populate(objectMap, "size", t.Size)
	objectMap["type"] = "TumblingWindowTriggerDependencyReference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTriggerDependencyReference.
func (t *TumblingWindowTriggerDependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "offset":
			err = unpopulate(val, &t.Offset)
			delete(rawMsg, key)
		case "referenceTrigger":
			err = unpopulate(val, &t.ReferenceTrigger)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, &t.Size)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TumblingWindowTriggerTypeProperties - Tumbling Window Trigger properties.
type TumblingWindowTriggerTypeProperties struct {
	// REQUIRED; The frequency of the time windows.
	Frequency *TumblingWindowFrequency `json:"frequency,omitempty"`

	// REQUIRED; The interval of the time windows. The minimum interval allowed is 15 Minutes.
	Interval *int32 `json:"interval,omitempty"`

	// REQUIRED; The max number of parallel time windows (ready for execution) for which a new run is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// REQUIRED; The start time for the time period for the trigger during which events are fired for windows that are ready.
	// Only UTC time is currently supported.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Specifies how long the trigger waits past due time before triggering new run. It doesn't alter window start and end time.
	// The default is 0. Type: string (or Expression with resultType string),
	// pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Delay map[string]interface{} `json:"delay,omitempty"`

	// Triggers that this trigger depends on. Only tumbling window triggers are supported.
	DependsOn []DependencyReferenceClassification `json:"dependsOn,omitempty"`

	// The end time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time
	// is currently supported.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Retry policy that will be applied for failed pipeline runs.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTriggerTypeProperties.
func (t TumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "delay", t.Delay)
	populate(objectMap, "dependsOn", t.DependsOn)
	populateTimeRFC3339(objectMap, "endTime", t.EndTime)
	populate(objectMap, "frequency", t.Frequency)
	populate(objectMap, "interval", t.Interval)
	populate(objectMap, "maxConcurrency", t.MaxConcurrency)
	populate(objectMap, "retryPolicy", t.RetryPolicy)
	populateTimeRFC3339(objectMap, "startTime", t.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTriggerTypeProperties.
func (t *TumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delay":
			err = unpopulate(val, &t.Delay)
			delete(rawMsg, key)
		case "dependsOn":
			t.DependsOn, err = unmarshalDependencyReferenceClassificationArray(val)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &t.EndTime)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &t.Frequency)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, &t.Interval)
			delete(rawMsg, key)
		case "maxConcurrency":
			err = unpopulate(val, &t.MaxConcurrency)
			delete(rawMsg, key)
		case "retryPolicy":
			err = unpopulate(val, &t.RetryPolicy)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &t.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TypeConversionSettings - Type conversion settings
type TypeConversionSettings struct {
	// Whether to allow data truncation when converting the data. Type: boolean (or Expression with resultType boolean).
	AllowDataTruncation map[string]interface{} `json:"allowDataTruncation,omitempty"`

	// The culture used to convert data from/to string. Type: string (or Expression with resultType string).
	Culture map[string]interface{} `json:"culture,omitempty"`

	// The format for DateTime values. Type: string (or Expression with resultType string).
	DateTimeFormat map[string]interface{} `json:"dateTimeFormat,omitempty"`

	// The format for DateTimeOffset values. Type: string (or Expression with resultType string).
	DateTimeOffsetFormat map[string]interface{} `json:"dateTimeOffsetFormat,omitempty"`

	// The format for TimeSpan values. Type: string (or Expression with resultType string).
	TimeSpanFormat map[string]interface{} `json:"timeSpanFormat,omitempty"`

	// Whether to treat boolean values as numbers. Type: boolean (or Expression with resultType boolean).
	TreatBooleanAsNumber map[string]interface{} `json:"treatBooleanAsNumber,omitempty"`
}

// UntilActivity - This activity executes inner activities until the specified boolean expression results to true or timeout
// is reached, whichever is earlier.
type UntilActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Until activity properties.
	TypeProperties *UntilActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type UntilActivity.
func (u *UntilActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 u.Name,
		Type:                 u.Type,
		Description:          u.Description,
		DependsOn:            u.DependsOn,
		UserProperties:       u.UserProperties,
		AdditionalProperties: u.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type UntilActivity.
func (u *UntilActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 u.Name,
		Type:                 u.Type,
		Description:          u.Description,
		DependsOn:            u.DependsOn,
		UserProperties:       u.UserProperties,
		AdditionalProperties: u.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type UntilActivity.
func (u UntilActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", u.DependsOn)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "name", u.Name)
	objectMap["type"] = "Until"
	populate(objectMap, "typeProperties", u.TypeProperties)
	populate(objectMap, "userProperties", u.UserProperties)
	if u.AdditionalProperties != nil {
		for key, val := range u.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivity.
func (u *UntilActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &u.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &u.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &u.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &u.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &u.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &u.UserProperties)
			delete(rawMsg, key)
		default:
			if u.AdditionalProperties == nil {
				u.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				u.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UntilActivityTypeProperties - Until activity properties.
type UntilActivityTypeProperties struct {
	// REQUIRED; List of activities to execute.
	Activities []ActivityClassification `json:"activities,omitempty"`

	// REQUIRED; An expression that would evaluate to Boolean. The loop will continue until this expression evaluates to true
	Expression *Expression `json:"expression,omitempty"`

	// Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7)
	// which is 1 week as default. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])). Type: string (or Expression with resultType string),
	// pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout map[string]interface{} `json:"timeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UntilActivityTypeProperties.
func (u UntilActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activities", u.Activities)
	populate(objectMap, "expression", u.Expression)
	populate(objectMap, "timeout", u.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivityTypeProperties.
func (u *UntilActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			u.Activities, err = unmarshalActivityClassificationArray(val)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, &u.Expression)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &u.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UpdateIntegrationRuntimeNodeRequest - Update integration runtime node request.
type UpdateIntegrationRuntimeNodeRequest struct {
	// The number of concurrent jobs permitted to run on the integration runtime node. Values between 1 and maxConcurrentJobs(inclusive)
	// are allowed.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIntegrationRuntimeNodeRequest.
func (u UpdateIntegrationRuntimeNodeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "concurrentJobsLimit", u.ConcurrentJobsLimit)
	return json.Marshal(objectMap)
}

// UpdateIntegrationRuntimeRequest - Update integration runtime request.
type UpdateIntegrationRuntimeRequest struct {
	// Enables or disables the auto-update feature of the self-hosted integration runtime. See https://go.microsoft.com/fwlink/?linkid=854189.
	AutoUpdate *IntegrationRuntimeAutoUpdate `json:"autoUpdate,omitempty"`

	// The time offset (in hours) in the day, e.g., PT03H is 3 hours. The integration runtime auto update will happen on that
	// time.
	UpdateDelayOffset *string `json:"updateDelayOffset,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIntegrationRuntimeRequest.
func (u UpdateIntegrationRuntimeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoUpdate", u.AutoUpdate)
	populate(objectMap, "updateDelayOffset", u.UpdateDelayOffset)
	return json.Marshal(objectMap)
}

// UserAccessPolicy - Get Data Plane read only token request definition.
type UserAccessPolicy struct {
	// The resource path to get access relative to factory. Currently only empty string is supported which corresponds to the
	// factory resource.
	AccessResourcePath *string `json:"accessResourcePath,omitempty"`

	// Expiration time for the token. Maximum duration for the token is eight hours and by default the token will expire in eight
	// hours.
	ExpireTime *string `json:"expireTime,omitempty"`

	// The string with permissions for Data Plane access. Currently only 'r' is supported which grants read only access.
	Permissions *string `json:"permissions,omitempty"`

	// The name of the profile. Currently only the default is supported. The default value is DefaultProfile.
	ProfileName *string `json:"profileName,omitempty"`

	// Start time for the token. If not specified the current time will be used.
	StartTime *string `json:"startTime,omitempty"`
}

// UserProperty - User property.
type UserProperty struct {
	// REQUIRED; User property name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; User property value. Type: string (or Expression with resultType string).
	Value map[string]interface{} `json:"value,omitempty"`
}

// ValidationActivity - This activity verifies that an external resource exists.
type ValidationActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Validation activity properties.
	TypeProperties *ValidationActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type ValidationActivity.
func (v *ValidationActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 v.Name,
		Type:                 v.Type,
		Description:          v.Description,
		DependsOn:            v.DependsOn,
		UserProperties:       v.UserProperties,
		AdditionalProperties: v.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type ValidationActivity.
func (v *ValidationActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 v.Name,
		Type:                 v.Type,
		Description:          v.Description,
		DependsOn:            v.DependsOn,
		UserProperties:       v.UserProperties,
		AdditionalProperties: v.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ValidationActivity.
func (v ValidationActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", v.DependsOn)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "name", v.Name)
	objectMap["type"] = "Validation"
	populate(objectMap, "typeProperties", v.TypeProperties)
	populate(objectMap, "userProperties", v.UserProperties)
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationActivity.
func (v *ValidationActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &v.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &v.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &v.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &v.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &v.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &v.UserProperties)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidationActivityTypeProperties - Validation activity properties.
type ValidationActivityTypeProperties struct {
	// REQUIRED; Validation activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Can be used if dataset points to a folder. If set to true, the folder must have at least one file. If set to false, the
	// folder must be empty. Type: boolean (or Expression with resultType boolean).
	ChildItems map[string]interface{} `json:"childItems,omitempty"`

	// Can be used if dataset points to a file. The file must be greater than or equal in size to the value specified. Type: integer
	// (or Expression with resultType integer).
	MinimumSize map[string]interface{} `json:"minimumSize,omitempty"`

	// A delay in seconds between validation attempts. If no value is specified, 10 seconds will be used as the default. Type:
	// integer (or Expression with resultType integer).
	Sleep map[string]interface{} `json:"sleep,omitempty"`

	// Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7)
	// which is 1 week as default. Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout map[string]interface{} `json:"timeout,omitempty"`
}

// VariableSpecification - Definition of a single variable for a Pipeline.
type VariableSpecification struct {
	// REQUIRED; Variable type.
	Type *VariableType `json:"type,omitempty"`

	// Default value of variable.
	DefaultValue map[string]interface{} `json:"defaultValue,omitempty"`
}

// VerticaDatasetTypeProperties - Vertica Properties
type VerticaDatasetTypeProperties struct {
	// The schema name of the Vertica. Type: string (or Expression with resultType string).
	Schema map[string]interface{} `json:"schema,omitempty"`

	// The table name of the Vertica. Type: string (or Expression with resultType string).
	Table map[string]interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName map[string]interface{} `json:"tableName,omitempty"`
}

// VerticaLinkedService - Vertica linked service.
type VerticaLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Vertica linked service properties.
	TypeProperties *VerticaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type VerticaLinkedService.
func (v *VerticaLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 v.Type,
		ConnectVia:           v.ConnectVia,
		Description:          v.Description,
		Parameters:           v.Parameters,
		Annotations:          v.Annotations,
		AdditionalProperties: v.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VerticaLinkedService.
func (v VerticaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", v.Annotations)
	populate(objectMap, "connectVia", v.ConnectVia)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "parameters", v.Parameters)
	objectMap["type"] = "Vertica"
	populate(objectMap, "typeProperties", v.TypeProperties)
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaLinkedService.
func (v *VerticaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &v.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &v.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &v.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &v.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &v.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &v.TypeProperties)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VerticaLinkedServiceTypeProperties - Vertica linked service properties.
type VerticaLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString map[string]interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// VerticaSource - A copy activity Vertica source.
type VerticaSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type VerticaSource.
func (v *VerticaSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     v.Type,
		SourceRetryCount:         v.SourceRetryCount,
		SourceRetryWait:          v.SourceRetryWait,
		MaxConcurrentConnections: v.MaxConcurrentConnections,
		DisableMetricsCollection: v.DisableMetricsCollection,
		AdditionalProperties:     v.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type VerticaSource.
func (v *VerticaSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             v.QueryTimeout,
		AdditionalColumns:        v.AdditionalColumns,
		Type:                     v.Type,
		SourceRetryCount:         v.SourceRetryCount,
		SourceRetryWait:          v.SourceRetryWait,
		MaxConcurrentConnections: v.MaxConcurrentConnections,
		DisableMetricsCollection: v.DisableMetricsCollection,
		AdditionalProperties:     v.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VerticaSource.
func (v VerticaSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", v.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", v.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", v.MaxConcurrentConnections)
	populate(objectMap, "query", v.Query)
	populate(objectMap, "queryTimeout", v.QueryTimeout)
	populate(objectMap, "sourceRetryCount", v.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", v.SourceRetryWait)
	objectMap["type"] = "VerticaSource"
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaSource.
func (v *VerticaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &v.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &v.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &v.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &v.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &v.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &v.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &v.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &v.Type)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VerticaTableDataset - Vertica dataset.
type VerticaTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *VerticaDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type VerticaTableDataset.
func (v *VerticaTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 v.Type,
		Description:          v.Description,
		Structure:            v.Structure,
		Schema:               v.Schema,
		LinkedServiceName:    v.LinkedServiceName,
		Parameters:           v.Parameters,
		Annotations:          v.Annotations,
		Folder:               v.Folder,
		AdditionalProperties: v.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VerticaTableDataset.
func (v VerticaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", v.Annotations)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "folder", v.Folder)
	populate(objectMap, "linkedServiceName", v.LinkedServiceName)
	populate(objectMap, "parameters", v.Parameters)
	populate(objectMap, "schema", v.Schema)
	populate(objectMap, "structure", v.Structure)
	objectMap["type"] = "VerticaTable"
	populate(objectMap, "typeProperties", v.TypeProperties)
	if v.AdditionalProperties != nil {
		for key, val := range v.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaTableDataset.
func (v *VerticaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &v.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &v.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &v.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &v.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &v.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &v.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &v.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &v.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &v.TypeProperties)
			delete(rawMsg, key)
		default:
			if v.AdditionalProperties == nil {
				v.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				v.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WaitActivity - This activity suspends pipeline execution for the specified interval.
type WaitActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Wait activity properties.
	TypeProperties *WaitActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type WaitActivity.
func (w *WaitActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 w.Name,
		Type:                 w.Type,
		Description:          w.Description,
		DependsOn:            w.DependsOn,
		UserProperties:       w.UserProperties,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type WaitActivity.
func (w *WaitActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 w.Name,
		Type:                 w.Type,
		Description:          w.Description,
		DependsOn:            w.DependsOn,
		UserProperties:       w.UserProperties,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WaitActivity.
func (w WaitActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", w.DependsOn)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "name", w.Name)
	objectMap["type"] = "Wait"
	populate(objectMap, "typeProperties", w.TypeProperties)
	populate(objectMap, "userProperties", w.UserProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WaitActivity.
func (w *WaitActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &w.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &w.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &w.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &w.UserProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WaitActivityTypeProperties - Wait activity properties.
type WaitActivityTypeProperties struct {
	// REQUIRED; Duration in seconds.
	WaitTimeInSeconds map[string]interface{} `json:"waitTimeInSeconds,omitempty"`
}

// WebActivity - Web activity.
type WebActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Web activity properties.
	TypeProperties *WebActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type WebActivity.
func (w *WebActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 w.Name,
		Type:                 w.Type,
		Description:          w.Description,
		DependsOn:            w.DependsOn,
		UserProperties:       w.UserProperties,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type WebActivity.
func (w *WebActivity) GetExecutionActivity() *ExecutionActivity {
	return &ExecutionActivity{
		LinkedServiceName:    w.LinkedServiceName,
		Policy:               w.Policy,
		Name:                 w.Name,
		Type:                 w.Type,
		Description:          w.Description,
		DependsOn:            w.DependsOn,
		UserProperties:       w.UserProperties,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebActivity.
func (w WebActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", w.DependsOn)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "linkedServiceName", w.LinkedServiceName)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "policy", w.Policy)
	objectMap["type"] = "WebActivity"
	populate(objectMap, "typeProperties", w.TypeProperties)
	populate(objectMap, "userProperties", w.UserProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivity.
func (w *WebActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &w.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &w.LinkedServiceName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &w.Name)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &w.Policy)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &w.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &w.UserProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebActivityAuthentication - Web activity authentication properties.
type WebActivityAuthentication struct {
	// The credential reference containing authentication information.
	Credential *CredentialReference `json:"credential,omitempty"`

	// Password for the PFX file or basic authentication / Secret when used for ServicePrincipal
	Password SecretBaseClassification `json:"password,omitempty"`

	// Base64-encoded contents of a PFX file or Certificate when used for ServicePrincipal
	Pfx SecretBaseClassification `json:"pfx,omitempty"`

	// Resource for which Azure Auth token will be requested when using MSI Authentication. Type: string (or Expression with resultType
	// string).
	Resource map[string]interface{} `json:"resource,omitempty"`

	// Web activity authentication (Basic/ClientCertificate/MSI/ServicePrincipal)
	Type *string `json:"type,omitempty"`

	// TenantId for which Azure Auth token will be requested when using ServicePrincipal Authentication. Type: string (or Expression
	// with resultType string).
	UserTenant map[string]interface{} `json:"userTenant,omitempty"`

	// Web activity authentication user name for basic authentication or ClientID when used for ServicePrincipal. Type: string
	// (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebActivityAuthentication.
func (w WebActivityAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "credential", w.Credential)
	populate(objectMap, "password", w.Password)
	populate(objectMap, "pfx", w.Pfx)
	populate(objectMap, "resource", w.Resource)
	populate(objectMap, "type", w.Type)
	populate(objectMap, "userTenant", w.UserTenant)
	populate(objectMap, "username", w.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivityAuthentication.
func (w *WebActivityAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credential":
			err = unpopulate(val, &w.Credential)
			delete(rawMsg, key)
		case "password":
			w.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "pfx":
			w.Pfx, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, &w.Resource)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "userTenant":
			err = unpopulate(val, &w.UserTenant)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &w.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebActivityTypeProperties - Web activity type properties.
type WebActivityTypeProperties struct {
	// REQUIRED; Rest API method for target endpoint.
	Method *WebActivityMethod `json:"method,omitempty"`

	// REQUIRED; Web activity target endpoint and path. Type: string (or Expression with resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// Authentication method used for calling the endpoint.
	Authentication *WebActivityAuthentication `json:"authentication,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type:
	// string (or Expression with resultType string).
	Body map[string]interface{} `json:"body,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// List of datasets passed to web endpoint.
	Datasets []*DatasetReference `json:"datasets,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers"
	// : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type:
	// string (or Expression with resultType string).
	Headers map[string]interface{} `json:"headers,omitempty"`

	// List of linked services passed to web endpoint.
	LinkedServices []*LinkedServiceReference `json:"linkedServices,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebActivityTypeProperties.
func (w WebActivityTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authentication", w.Authentication)
	populate(objectMap, "body", w.Body)
	populate(objectMap, "connectVia", w.ConnectVia)
	populate(objectMap, "datasets", w.Datasets)
	populate(objectMap, "headers", w.Headers)
	populate(objectMap, "linkedServices", w.LinkedServices)
	populate(objectMap, "method", w.Method)
	populate(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// WebAnonymousAuthentication - A WebLinkedService that uses anonymous authentication to communicate with an HTTP endpoint.
type WebAnonymousAuthentication struct {
	// REQUIRED; Type of authentication used to connect to the web table source.
	AuthenticationType *WebAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType
	// string).
	URL map[string]interface{} `json:"url,omitempty"`
}

// GetWebLinkedServiceTypeProperties implements the WebLinkedServiceTypePropertiesClassification interface for type WebAnonymousAuthentication.
func (w *WebAnonymousAuthentication) GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties {
	return &WebLinkedServiceTypeProperties{
		URL:                w.URL,
		AuthenticationType: w.AuthenticationType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebAnonymousAuthentication.
func (w WebAnonymousAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authenticationType"] = WebAuthenticationTypeAnonymous
	populate(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAnonymousAuthentication.
func (w *WebAnonymousAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &w.AuthenticationType)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebBasicAuthentication - A WebLinkedService that uses basic authentication to communicate with an HTTP endpoint.
type WebBasicAuthentication struct {
	// REQUIRED; Type of authentication used to connect to the web table source.
	AuthenticationType *WebAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// REQUIRED; The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType
	// string).
	URL map[string]interface{} `json:"url,omitempty"`

	// REQUIRED; User name for Basic authentication. Type: string (or Expression with resultType string).
	Username map[string]interface{} `json:"username,omitempty"`
}

// GetWebLinkedServiceTypeProperties implements the WebLinkedServiceTypePropertiesClassification interface for type WebBasicAuthentication.
func (w *WebBasicAuthentication) GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties {
	return &WebLinkedServiceTypeProperties{
		URL:                w.URL,
		AuthenticationType: w.AuthenticationType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebBasicAuthentication.
func (w WebBasicAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authenticationType"] = WebAuthenticationTypeBasic
	populate(objectMap, "password", w.Password)
	populate(objectMap, "url", w.URL)
	populate(objectMap, "username", w.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebBasicAuthentication.
func (w *WebBasicAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &w.AuthenticationType)
			delete(rawMsg, key)
		case "password":
			w.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &w.URL)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &w.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebClientCertificateAuthentication - A WebLinkedService that uses client certificate based authentication to communicate
// with an HTTP endpoint. This scheme follows mutual authentication; the server must also provide valid credentials to
// the client.
type WebClientCertificateAuthentication struct {
	// REQUIRED; Type of authentication used to connect to the web table source.
	AuthenticationType *WebAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; Password for the PFX file.
	Password SecretBaseClassification `json:"password,omitempty"`

	// REQUIRED; Base64-encoded contents of a PFX file.
	Pfx SecretBaseClassification `json:"pfx,omitempty"`

	// REQUIRED; The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType
	// string).
	URL map[string]interface{} `json:"url,omitempty"`
}

// GetWebLinkedServiceTypeProperties implements the WebLinkedServiceTypePropertiesClassification interface for type WebClientCertificateAuthentication.
func (w *WebClientCertificateAuthentication) GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties {
	return &WebLinkedServiceTypeProperties{
		URL:                w.URL,
		AuthenticationType: w.AuthenticationType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebClientCertificateAuthentication.
func (w WebClientCertificateAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authenticationType"] = WebAuthenticationTypeClientCertificate
	populate(objectMap, "password", w.Password)
	populate(objectMap, "pfx", w.Pfx)
	populate(objectMap, "url", w.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebClientCertificateAuthentication.
func (w *WebClientCertificateAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			err = unpopulate(val, &w.AuthenticationType)
			delete(rawMsg, key)
		case "password":
			w.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "pfx":
			w.Pfx, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, &w.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebHookActivity - WebHook activity.
type WebHookActivity struct {
	// REQUIRED; Activity name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Type of activity.
	Type *string `json:"type,omitempty"`

	// REQUIRED; WebHook activity properties.
	TypeProperties *WebHookActivityTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Activity depends on condition.
	DependsOn []*ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity user properties.
	UserProperties []*UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type WebHookActivity.
func (w *WebHookActivity) GetActivity() *Activity {
	return &Activity{
		Name:                 w.Name,
		Type:                 w.Type,
		Description:          w.Description,
		DependsOn:            w.DependsOn,
		UserProperties:       w.UserProperties,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// GetControlActivity implements the ControlActivityClassification interface for type WebHookActivity.
func (w *WebHookActivity) GetControlActivity() *ControlActivity {
	return &ControlActivity{
		Name:                 w.Name,
		Type:                 w.Type,
		Description:          w.Description,
		DependsOn:            w.DependsOn,
		UserProperties:       w.UserProperties,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebHookActivity.
func (w WebHookActivity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dependsOn", w.DependsOn)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "name", w.Name)
	objectMap["type"] = "WebHook"
	populate(objectMap, "typeProperties", w.TypeProperties)
	populate(objectMap, "userProperties", w.UserProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookActivity.
func (w *WebHookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			err = unpopulate(val, &w.DependsOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &w.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &w.TypeProperties)
			delete(rawMsg, key)
		case "userProperties":
			err = unpopulate(val, &w.UserProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebHookActivityTypeProperties - WebHook activity type properties.
type WebHookActivityTypeProperties struct {
	// REQUIRED; Rest API method for target endpoint.
	Method *WebHookActivityMethod `json:"method,omitempty"`

	// REQUIRED; WebHook activity target endpoint and path. Type: string (or Expression with resultType string).
	URL map[string]interface{} `json:"url,omitempty"`

	// Authentication method used for calling the endpoint.
	Authentication *WebActivityAuthentication `json:"authentication,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type:
	// string (or Expression with resultType string).
	Body map[string]interface{} `json:"body,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers"
	// : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type:
	// string (or Expression with resultType string).
	Headers map[string]interface{} `json:"headers,omitempty"`

	// When set to true, statusCode, output and error in callback request body will be consumed by activity. The activity can
	// be marked as failed by setting statusCode >= 400 in callback request. Default is
	// false. Type: boolean (or Expression with resultType boolean).
	ReportStatusOnCallBack map[string]interface{} `json:"reportStatusOnCallBack,omitempty"`

	// The timeout within which the webhook should be called back. If there is no value specified, it defaults to 10 minutes.
	// Type: string. Pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *string `json:"timeout,omitempty"`
}

// WebLinkedService - Web linked service.
type WebLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Web linked service properties.
	TypeProperties WebLinkedServiceTypePropertiesClassification `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type WebLinkedService.
func (w *WebLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 w.Type,
		ConnectVia:           w.ConnectVia,
		Description:          w.Description,
		Parameters:           w.Parameters,
		Annotations:          w.Annotations,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebLinkedService.
func (w WebLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", w.Annotations)
	populate(objectMap, "connectVia", w.ConnectVia)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "parameters", w.Parameters)
	objectMap["type"] = "Web"
	populate(objectMap, "typeProperties", w.TypeProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedService.
func (w *WebLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &w.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &w.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &w.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			w.TypeProperties, err = unmarshalWebLinkedServiceTypePropertiesClassification(val)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebLinkedServiceTypePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetWebLinkedServiceTypeProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *WebAnonymousAuthentication, *WebBasicAuthentication, *WebClientCertificateAuthentication, *WebLinkedServiceTypeProperties
type WebLinkedServiceTypePropertiesClassification interface {
	// GetWebLinkedServiceTypeProperties returns the WebLinkedServiceTypeProperties content of the underlying type.
	GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties
}

// WebLinkedServiceTypeProperties - Base definition of WebLinkedServiceTypeProperties, this typeProperties is polymorphic
// based on authenticationType, so not flattened in SDK models.
type WebLinkedServiceTypeProperties struct {
	// REQUIRED; Type of authentication used to connect to the web table source.
	AuthenticationType *WebAuthenticationType `json:"authenticationType,omitempty"`

	// REQUIRED; The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType
	// string).
	URL map[string]interface{} `json:"url,omitempty"`
}

// GetWebLinkedServiceTypeProperties implements the WebLinkedServiceTypePropertiesClassification interface for type WebLinkedServiceTypeProperties.
func (w *WebLinkedServiceTypeProperties) GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties {
	return w
}

// WebSource - A copy activity source for web page table.
type WebSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type WebSource.
func (w *WebSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     w.Type,
		SourceRetryCount:         w.SourceRetryCount,
		SourceRetryWait:          w.SourceRetryWait,
		MaxConcurrentConnections: w.MaxConcurrentConnections,
		DisableMetricsCollection: w.DisableMetricsCollection,
		AdditionalProperties:     w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebSource.
func (w WebSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", w.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", w.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", w.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", w.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", w.SourceRetryWait)
	objectMap["type"] = "WebSource"
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSource.
func (w *WebSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &w.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &w.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &w.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &w.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &w.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebTableDataset - The dataset points to a HTML table in the web page.
type WebTableDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Web table dataset properties.
	TypeProperties *WebTableDatasetTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type WebTableDataset.
func (w *WebTableDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 w.Type,
		Description:          w.Description,
		Structure:            w.Structure,
		Schema:               w.Schema,
		LinkedServiceName:    w.LinkedServiceName,
		Parameters:           w.Parameters,
		Annotations:          w.Annotations,
		Folder:               w.Folder,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebTableDataset.
func (w WebTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", w.Annotations)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "folder", w.Folder)
	populate(objectMap, "linkedServiceName", w.LinkedServiceName)
	populate(objectMap, "parameters", w.Parameters)
	populate(objectMap, "schema", w.Schema)
	populate(objectMap, "structure", w.Structure)
	objectMap["type"] = "WebTable"
	populate(objectMap, "typeProperties", w.TypeProperties)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebTableDataset.
func (w *WebTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &w.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &w.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &w.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &w.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &w.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &w.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &w.TypeProperties)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebTableDatasetTypeProperties - Web table dataset properties.
type WebTableDatasetTypeProperties struct {
	// REQUIRED; The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum:
	// 0.
	Index map[string]interface{} `json:"index,omitempty"`

	// The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
	Path map[string]interface{} `json:"path,omitempty"`
}

// WranglingDataFlow - Power Query data flow.
type WranglingDataFlow struct {
	// REQUIRED; Type of data flow.
	Type *string `json:"type,omitempty"`

	// List of tags that can be used for describing the data flow.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The description of the data flow.
	Description *string `json:"description,omitempty"`

	// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
	Folder *DataFlowFolder `json:"folder,omitempty"`

	// PowerQuery data flow type properties.
	TypeProperties *PowerQueryTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataFlow implements the DataFlowClassification interface for type WranglingDataFlow.
func (w *WranglingDataFlow) GetDataFlow() *DataFlow {
	return &DataFlow{
		Type:        w.Type,
		Description: w.Description,
		Annotations: w.Annotations,
		Folder:      w.Folder,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WranglingDataFlow.
func (w WranglingDataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", w.Annotations)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "folder", w.Folder)
	objectMap["type"] = "WranglingDataFlow"
	populate(objectMap, "typeProperties", w.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WranglingDataFlow.
func (w *WranglingDataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &w.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &w.Folder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &w.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XMLDataset - Xml dataset.
type XMLDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Xml dataset properties.
	TypeProperties *XMLDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type XMLDataset.
func (x *XMLDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 x.Type,
		Description:          x.Description,
		Structure:            x.Structure,
		Schema:               x.Schema,
		LinkedServiceName:    x.LinkedServiceName,
		Parameters:           x.Parameters,
		Annotations:          x.Annotations,
		Folder:               x.Folder,
		AdditionalProperties: x.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type XMLDataset.
func (x XMLDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", x.Annotations)
	populate(objectMap, "description", x.Description)
	populate(objectMap, "folder", x.Folder)
	populate(objectMap, "linkedServiceName", x.LinkedServiceName)
	populate(objectMap, "parameters", x.Parameters)
	populate(objectMap, "schema", x.Schema)
	populate(objectMap, "structure", x.Structure)
	objectMap["type"] = "Xml"
	populate(objectMap, "typeProperties", x.TypeProperties)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLDataset.
func (x *XMLDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &x.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &x.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &x.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &x.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &x.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &x.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &x.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &x.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &x.TypeProperties)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XMLDatasetTypeProperties - Xml dataset properties.
type XMLDatasetTypeProperties struct {
	// REQUIRED; The location of the json data storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The data compression method used for the json dataset.
	Compression *DatasetCompression `json:"compression,omitempty"`

	// The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another
	// Unicode encoding. Refer to the name column of the table in the following link to
	// set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType
	// string).
	EncodingName map[string]interface{} `json:"encodingName,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue map[string]interface{} `json:"nullValue,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XMLDatasetTypeProperties.
func (x XMLDatasetTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", x.Compression)
	populate(objectMap, "encodingName", x.EncodingName)
	populate(objectMap, "location", x.Location)
	populate(objectMap, "nullValue", x.NullValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLDatasetTypeProperties.
func (x *XMLDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &x.Compression)
			delete(rawMsg, key)
		case "encodingName":
			err = unpopulate(val, &x.EncodingName)
			delete(rawMsg, key)
		case "location":
			x.Location, err = unmarshalDatasetLocationClassification(val)
			delete(rawMsg, key)
		case "nullValue":
			err = unpopulate(val, &x.NullValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XMLReadSettings - Xml read settings.
type XMLReadSettings struct {
	// REQUIRED; The read setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Compression settings.
	CompressionProperties CompressionReadSettingsClassification `json:"compressionProperties,omitempty"`

	// Indicates whether type detection is enabled when reading the xml files. Type: boolean (or Expression with resultType boolean).
	DetectDataType map[string]interface{} `json:"detectDataType,omitempty"`

	// Namespace uri to prefix mappings to override the prefixes in column names when namespace is enabled, if no prefix is defined
	// for a namespace uri, the prefix of xml element/attribute name in the xml
	// data file will be used. Example: "{"http://www.example.com/xml":"prefix"}" Type: object (or Expression with resultType
	// object).
	NamespacePrefixes map[string]interface{} `json:"namespacePrefixes,omitempty"`

	// Indicates whether namespace is enabled when reading the xml files. Type: boolean (or Expression with resultType boolean).
	Namespaces map[string]interface{} `json:"namespaces,omitempty"`

	// Indicates what validation method is used when reading the xml files. Allowed values: 'none', 'xsd', or 'dtd'. Type: string
	// (or Expression with resultType string).
	ValidationMode map[string]interface{} `json:"validationMode,omitempty"`
}

// GetFormatReadSettings implements the FormatReadSettingsClassification interface for type XMLReadSettings.
func (x *XMLReadSettings) GetFormatReadSettings() *FormatReadSettings {
	return &FormatReadSettings{
		Type:                 x.Type,
		AdditionalProperties: x.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type XMLReadSettings.
func (x XMLReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compressionProperties", x.CompressionProperties)
	populate(objectMap, "detectDataType", x.DetectDataType)
	populate(objectMap, "namespacePrefixes", x.NamespacePrefixes)
	populate(objectMap, "namespaces", x.Namespaces)
	objectMap["type"] = "XmlReadSettings"
	populate(objectMap, "validationMode", x.ValidationMode)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLReadSettings.
func (x *XMLReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionProperties":
			x.CompressionProperties, err = unmarshalCompressionReadSettingsClassification(val)
			delete(rawMsg, key)
		case "detectDataType":
			err = unpopulate(val, &x.DetectDataType)
			delete(rawMsg, key)
		case "namespacePrefixes":
			err = unpopulate(val, &x.NamespacePrefixes)
			delete(rawMsg, key)
		case "namespaces":
			err = unpopulate(val, &x.Namespaces)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &x.Type)
			delete(rawMsg, key)
		case "validationMode":
			err = unpopulate(val, &x.ValidationMode)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XMLSource - A copy activity Xml source.
type XMLSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// Xml format settings.
	FormatSettings *XMLReadSettings `json:"formatSettings,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`

	// Xml store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type XMLSource.
func (x *XMLSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     x.Type,
		SourceRetryCount:         x.SourceRetryCount,
		SourceRetryWait:          x.SourceRetryWait,
		MaxConcurrentConnections: x.MaxConcurrentConnections,
		DisableMetricsCollection: x.DisableMetricsCollection,
		AdditionalProperties:     x.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type XMLSource.
func (x XMLSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", x.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", x.DisableMetricsCollection)
	populate(objectMap, "formatSettings", x.FormatSettings)
	populate(objectMap, "maxConcurrentConnections", x.MaxConcurrentConnections)
	populate(objectMap, "sourceRetryCount", x.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", x.SourceRetryWait)
	populate(objectMap, "storeSettings", x.StoreSettings)
	objectMap["type"] = "XmlSource"
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLSource.
func (x *XMLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &x.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &x.DisableMetricsCollection)
			delete(rawMsg, key)
		case "formatSettings":
			err = unpopulate(val, &x.FormatSettings)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &x.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &x.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &x.SourceRetryWait)
			delete(rawMsg, key)
		case "storeSettings":
			x.StoreSettings, err = unmarshalStoreReadSettingsClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &x.Type)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XeroLinkedService - Xero Service linked service.
type XeroLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Xero Service linked service properties.
	TypeProperties *XeroLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type XeroLinkedService.
func (x *XeroLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 x.Type,
		ConnectVia:           x.ConnectVia,
		Description:          x.Description,
		Parameters:           x.Parameters,
		Annotations:          x.Annotations,
		AdditionalProperties: x.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type XeroLinkedService.
func (x XeroLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", x.Annotations)
	populate(objectMap, "connectVia", x.ConnectVia)
	populate(objectMap, "description", x.Description)
	populate(objectMap, "parameters", x.Parameters)
	objectMap["type"] = "Xero"
	populate(objectMap, "typeProperties", x.TypeProperties)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedService.
func (x *XeroLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &x.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &x.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &x.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &x.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &x.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &x.TypeProperties)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XeroLinkedServiceTypeProperties - Xero Service linked service properties.
type XeroLinkedServiceTypeProperties struct {
	// Properties used to connect to Xero. It is mutually exclusive with any other properties in the linked service. Type: object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The consumer key associated with the Xero application.
	ConsumerKey SecretBaseClassification `json:"consumerKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Xero server. (i.e. api.xero.com)
	Host map[string]interface{} `json:"host,omitempty"`

	// The private key from the .pem file that was generated for your Xero private application. You must include all the text
	// from the .pem file, including the Unix line endings( ).
	PrivateKey SecretBaseClassification `json:"privateKey,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XeroLinkedServiceTypeProperties.
func (x XeroLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionProperties", x.ConnectionProperties)
	populate(objectMap, "consumerKey", x.ConsumerKey)
	populate(objectMap, "encryptedCredential", x.EncryptedCredential)
	populate(objectMap, "host", x.Host)
	populate(objectMap, "privateKey", x.PrivateKey)
	populate(objectMap, "useEncryptedEndpoints", x.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", x.UseHostVerification)
	populate(objectMap, "usePeerVerification", x.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedServiceTypeProperties.
func (x *XeroLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionProperties":
			err = unpopulate(val, &x.ConnectionProperties)
			delete(rawMsg, key)
		case "consumerKey":
			x.ConsumerKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &x.EncryptedCredential)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &x.Host)
			delete(rawMsg, key)
		case "privateKey":
			x.PrivateKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &x.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &x.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &x.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XeroObjectDataset - Xero Service dataset.
type XeroObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type XeroObjectDataset.
func (x *XeroObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 x.Type,
		Description:          x.Description,
		Structure:            x.Structure,
		Schema:               x.Schema,
		LinkedServiceName:    x.LinkedServiceName,
		Parameters:           x.Parameters,
		Annotations:          x.Annotations,
		Folder:               x.Folder,
		AdditionalProperties: x.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type XeroObjectDataset.
func (x XeroObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", x.Annotations)
	populate(objectMap, "description", x.Description)
	populate(objectMap, "folder", x.Folder)
	populate(objectMap, "linkedServiceName", x.LinkedServiceName)
	populate(objectMap, "parameters", x.Parameters)
	populate(objectMap, "schema", x.Schema)
	populate(objectMap, "structure", x.Structure)
	objectMap["type"] = "XeroObject"
	populate(objectMap, "typeProperties", x.TypeProperties)
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroObjectDataset.
func (x *XeroObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &x.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &x.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &x.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &x.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &x.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &x.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &x.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &x.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &x.TypeProperties)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// XeroSource - A copy activity Xero Service source.
type XeroSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type XeroSource.
func (x *XeroSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     x.Type,
		SourceRetryCount:         x.SourceRetryCount,
		SourceRetryWait:          x.SourceRetryWait,
		MaxConcurrentConnections: x.MaxConcurrentConnections,
		DisableMetricsCollection: x.DisableMetricsCollection,
		AdditionalProperties:     x.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type XeroSource.
func (x *XeroSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             x.QueryTimeout,
		AdditionalColumns:        x.AdditionalColumns,
		Type:                     x.Type,
		SourceRetryCount:         x.SourceRetryCount,
		SourceRetryWait:          x.SourceRetryWait,
		MaxConcurrentConnections: x.MaxConcurrentConnections,
		DisableMetricsCollection: x.DisableMetricsCollection,
		AdditionalProperties:     x.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type XeroSource.
func (x XeroSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", x.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", x.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", x.MaxConcurrentConnections)
	populate(objectMap, "query", x.Query)
	populate(objectMap, "queryTimeout", x.QueryTimeout)
	populate(objectMap, "sourceRetryCount", x.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", x.SourceRetryWait)
	objectMap["type"] = "XeroSource"
	if x.AdditionalProperties != nil {
		for key, val := range x.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroSource.
func (x *XeroSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &x.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &x.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &x.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &x.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &x.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &x.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &x.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &x.Type)
			delete(rawMsg, key)
		default:
			if x.AdditionalProperties == nil {
				x.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				x.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ZipDeflateReadSettings - The ZipDeflate compression read settings.
type ZipDeflateReadSettings struct {
	// REQUIRED; The Compression setting type.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Preserve the zip file name as folder path. Type: boolean (or Expression with resultType boolean).
	PreserveZipFileNameAsFolder map[string]interface{} `json:"preserveZipFileNameAsFolder,omitempty"`
}

// GetCompressionReadSettings implements the CompressionReadSettingsClassification interface for type ZipDeflateReadSettings.
func (z *ZipDeflateReadSettings) GetCompressionReadSettings() *CompressionReadSettings {
	return &CompressionReadSettings{
		Type:                 z.Type,
		AdditionalProperties: z.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ZipDeflateReadSettings.
func (z ZipDeflateReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "preserveZipFileNameAsFolder", z.PreserveZipFileNameAsFolder)
	objectMap["type"] = "ZipDeflateReadSettings"
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZipDeflateReadSettings.
func (z *ZipDeflateReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preserveZipFileNameAsFolder":
			err = unpopulate(val, &z.PreserveZipFileNameAsFolder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &z.Type)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ZohoLinkedService - Zoho server linked service.
type ZohoLinkedService struct {
	// REQUIRED; Type of linked service.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Zoho server linked service properties.
	TypeProperties *ZohoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type ZohoLinkedService.
func (z *ZohoLinkedService) GetLinkedService() *LinkedService {
	return &LinkedService{
		Type:                 z.Type,
		ConnectVia:           z.ConnectVia,
		Description:          z.Description,
		Parameters:           z.Parameters,
		Annotations:          z.Annotations,
		AdditionalProperties: z.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ZohoLinkedService.
func (z ZohoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", z.Annotations)
	populate(objectMap, "connectVia", z.ConnectVia)
	populate(objectMap, "description", z.Description)
	populate(objectMap, "parameters", z.Parameters)
	objectMap["type"] = "Zoho"
	populate(objectMap, "typeProperties", z.TypeProperties)
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedService.
func (z *ZohoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &z.Annotations)
			delete(rawMsg, key)
		case "connectVia":
			err = unpopulate(val, &z.ConnectVia)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &z.Description)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &z.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &z.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &z.TypeProperties)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ZohoLinkedServiceTypeProperties - Zoho server linked service properties.
type ZohoLinkedServiceTypeProperties struct {
	// The access token for Zoho authentication.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// Properties used to connect to Zoho. It is mutually exclusive with any other properties in the linked service. Type: object.
	ConnectionProperties map[string]interface{} `json:"connectionProperties,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential map[string]interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
	Endpoint map[string]interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints map[string]interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification map[string]interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification map[string]interface{} `json:"usePeerVerification,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ZohoLinkedServiceTypeProperties.
func (z ZohoLinkedServiceTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessToken", z.AccessToken)
	populate(objectMap, "connectionProperties", z.ConnectionProperties)
	populate(objectMap, "encryptedCredential", z.EncryptedCredential)
	populate(objectMap, "endpoint", z.Endpoint)
	populate(objectMap, "useEncryptedEndpoints", z.UseEncryptedEndpoints)
	populate(objectMap, "useHostVerification", z.UseHostVerification)
	populate(objectMap, "usePeerVerification", z.UsePeerVerification)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedServiceTypeProperties.
func (z *ZohoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			z.AccessToken, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "connectionProperties":
			err = unpopulate(val, &z.ConnectionProperties)
			delete(rawMsg, key)
		case "encryptedCredential":
			err = unpopulate(val, &z.EncryptedCredential)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &z.Endpoint)
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			err = unpopulate(val, &z.UseEncryptedEndpoints)
			delete(rawMsg, key)
		case "useHostVerification":
			err = unpopulate(val, &z.UseHostVerification)
			delete(rawMsg, key)
		case "usePeerVerification":
			err = unpopulate(val, &z.UsePeerVerification)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ZohoObjectDataset - Zoho server dataset.
type ZohoObjectDataset struct {
	// REQUIRED; Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// REQUIRED; Type of dataset.
	Type *string `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations []map[string]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Parameters for dataset.
	Parameters map[string]*ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema map[string]interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure map[string]interface{} `json:"structure,omitempty"`

	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type ZohoObjectDataset.
func (z *ZohoObjectDataset) GetDataset() *Dataset {
	return &Dataset{
		Type:                 z.Type,
		Description:          z.Description,
		Structure:            z.Structure,
		Schema:               z.Schema,
		LinkedServiceName:    z.LinkedServiceName,
		Parameters:           z.Parameters,
		Annotations:          z.Annotations,
		Folder:               z.Folder,
		AdditionalProperties: z.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ZohoObjectDataset.
func (z ZohoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", z.Annotations)
	populate(objectMap, "description", z.Description)
	populate(objectMap, "folder", z.Folder)
	populate(objectMap, "linkedServiceName", z.LinkedServiceName)
	populate(objectMap, "parameters", z.Parameters)
	populate(objectMap, "schema", z.Schema)
	populate(objectMap, "structure", z.Structure)
	objectMap["type"] = "ZohoObject"
	populate(objectMap, "typeProperties", z.TypeProperties)
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoObjectDataset.
func (z *ZohoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &z.Annotations)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &z.Description)
			delete(rawMsg, key)
		case "folder":
			err = unpopulate(val, &z.Folder)
			delete(rawMsg, key)
		case "linkedServiceName":
			err = unpopulate(val, &z.LinkedServiceName)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &z.Parameters)
			delete(rawMsg, key)
		case "schema":
			err = unpopulate(val, &z.Schema)
			delete(rawMsg, key)
		case "structure":
			err = unpopulate(val, &z.Structure)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &z.Type)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &z.TypeProperties)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ZohoSource - A copy activity Zoho server source.
type ZohoSource struct {
	// REQUIRED; Copy source type.
	Type *string `json:"type,omitempty"`

	// Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with
	// resultType array of objects).
	AdditionalColumns map[string]interface{} `json:"additionalColumns,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
	DisableMetricsCollection map[string]interface{} `json:"disableMetricsCollection,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections map[string]interface{} `json:"maxConcurrentConnections,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query map[string]interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout map[string]interface{} `json:"queryTimeout,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount map[string]interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait map[string]interface{} `json:"sourceRetryWait,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type ZohoSource.
func (z *ZohoSource) GetCopySource() *CopySource {
	return &CopySource{
		Type:                     z.Type,
		SourceRetryCount:         z.SourceRetryCount,
		SourceRetryWait:          z.SourceRetryWait,
		MaxConcurrentConnections: z.MaxConcurrentConnections,
		DisableMetricsCollection: z.DisableMetricsCollection,
		AdditionalProperties:     z.AdditionalProperties,
	}
}

// GetTabularSource implements the TabularSourceClassification interface for type ZohoSource.
func (z *ZohoSource) GetTabularSource() *TabularSource {
	return &TabularSource{
		QueryTimeout:             z.QueryTimeout,
		AdditionalColumns:        z.AdditionalColumns,
		Type:                     z.Type,
		SourceRetryCount:         z.SourceRetryCount,
		SourceRetryWait:          z.SourceRetryWait,
		MaxConcurrentConnections: z.MaxConcurrentConnections,
		DisableMetricsCollection: z.DisableMetricsCollection,
		AdditionalProperties:     z.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ZohoSource.
func (z ZohoSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalColumns", z.AdditionalColumns)
	populate(objectMap, "disableMetricsCollection", z.DisableMetricsCollection)
	populate(objectMap, "maxConcurrentConnections", z.MaxConcurrentConnections)
	populate(objectMap, "query", z.Query)
	populate(objectMap, "queryTimeout", z.QueryTimeout)
	populate(objectMap, "sourceRetryCount", z.SourceRetryCount)
	populate(objectMap, "sourceRetryWait", z.SourceRetryWait)
	objectMap["type"] = "ZohoSource"
	if z.AdditionalProperties != nil {
		for key, val := range z.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoSource.
func (z *ZohoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalColumns":
			err = unpopulate(val, &z.AdditionalColumns)
			delete(rawMsg, key)
		case "disableMetricsCollection":
			err = unpopulate(val, &z.DisableMetricsCollection)
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			err = unpopulate(val, &z.MaxConcurrentConnections)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &z.Query)
			delete(rawMsg, key)
		case "queryTimeout":
			err = unpopulate(val, &z.QueryTimeout)
			delete(rawMsg, key)
		case "sourceRetryCount":
			err = unpopulate(val, &z.SourceRetryCount)
			delete(rawMsg, key)
		case "sourceRetryWait":
			err = unpopulate(val, &z.SourceRetryWait)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &z.Type)
			delete(rawMsg, key)
		default:
			if z.AdditionalProperties == nil {
				z.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				z.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
