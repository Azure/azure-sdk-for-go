//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatalakeanalytics

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccountsBeginCreateOptions contains the optional parameters for the Accounts.BeginCreate method.
type AccountsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AccountsBeginDeleteOptions contains the optional parameters for the Accounts.BeginDelete method.
type AccountsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AccountsBeginUpdateOptions contains the optional parameters for the Accounts.BeginUpdate method.
type AccountsBeginUpdateOptions struct {
	// Parameters supplied to the update Data Lake Analytics account operation.
	Parameters *UpdateDataLakeAnalyticsAccountParameters
}

// AccountsCheckNameAvailabilityOptions contains the optional parameters for the Accounts.CheckNameAvailability method.
type AccountsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// AccountsGetOptions contains the optional parameters for the Accounts.Get method.
type AccountsGetOptions struct {
	// placeholder for future optional parameters
}

// AccountsListByResourceGroupOptions contains the optional parameters for the Accounts.ListByResourceGroup method.
type AccountsListByResourceGroupOptions struct {
	// The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
	// Optional.
	Count *bool
	// OData filter. Optional.
	Filter *string
	// OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted,
	// e.g. Categories?$orderby=CategoryName desc. Optional.
	Orderby *string
	// OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
	Select *string
	// The number of items to skip over before returning elements. Optional.
	Skip *int32
	// The number of items to return. Optional.
	Top *int32
}

// AccountsListOptions contains the optional parameters for the Accounts.List method.
type AccountsListOptions struct {
	// The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
	// Optional.
	Count *bool
	// OData filter. Optional.
	Filter *string
	// OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted,
	// e.g. Categories?$orderby=CategoryName desc. Optional.
	Orderby *string
	// OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
	Select *string
	// The number of items to skip over before returning elements. Optional.
	Skip *int32
	// The number of items to return. Optional.
	Top *int32
}

// AddDataLakeStoreParameters - The parameters used to add a new Data Lake Store account.
type AddDataLakeStoreParameters struct {
	// The Data Lake Store account properties to use when adding a new Data Lake Store account.
	Properties *AddDataLakeStoreProperties `json:"properties,omitempty"`
}

// AddDataLakeStoreProperties - The Data Lake Store account properties to use when adding a new Data Lake Store account.
type AddDataLakeStoreProperties struct {
	// The optional suffix for the Data Lake Store account.
	Suffix *string `json:"suffix,omitempty"`
}

// AddDataLakeStoreWithAccountParameters - The parameters used to add a new Data Lake Store account while creating a new Data Lake Analytics account.
type AddDataLakeStoreWithAccountParameters struct {
	// REQUIRED; The unique name of the Data Lake Store account to add.
	Name *string `json:"name,omitempty"`

	// The Data Lake Store account properties to use when adding a new Data Lake Store account.
	Properties *AddDataLakeStoreProperties `json:"properties,omitempty"`
}

// AddStorageAccountParameters - The parameters used to add a new Azure Storage account.
type AddStorageAccountParameters struct {
	// REQUIRED; The Azure Storage account properties to use when adding a new Azure Storage account.
	Properties *AddStorageAccountProperties `json:"properties,omitempty"`
}

// AddStorageAccountProperties - The Azure Storage account properties to use when adding a new Azure Storage account.
type AddStorageAccountProperties struct {
	// REQUIRED; The access key associated with this Azure Storage account that will be used to connect to it.
	AccessKey *string `json:"accessKey,omitempty"`

	// The optional suffix for the storage account.
	Suffix *string `json:"suffix,omitempty"`
}

// AddStorageAccountWithAccountParameters - The parameters used to add a new Azure Storage account while creating a new Data Lake Analytics account.
type AddStorageAccountWithAccountParameters struct {
	// REQUIRED; The unique name of the Azure Storage account to add.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The Azure Storage account properties to use when adding a new Azure Storage account.
	Properties *AddStorageAccountProperties `json:"properties,omitempty"`
}

// CapabilityInformation - Subscription-level properties and limits for Data Lake Analytics.
type CapabilityInformation struct {
	// READ-ONLY; The current number of accounts under this subscription.
	AccountCount *int32 `json:"accountCount,omitempty" azure:"ro"`

	// READ-ONLY; The maximum supported number of accounts under this subscription.
	MaxAccountCount *int32 `json:"maxAccountCount,omitempty" azure:"ro"`

	// READ-ONLY; The Boolean value of true or false to indicate the maintenance state.
	MigrationState *bool `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; The subscription state.
	State *SubscriptionState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; The subscription credentials that uniquely identifies the subscription.
	SubscriptionID *string `json:"subscriptionId,omitempty" azure:"ro"`
}

// CheckNameAvailabilityParameters - Data Lake Analytics account name availability check parameters.
type CheckNameAvailabilityParameters struct {
	// REQUIRED; The Data Lake Analytics name to check availability for.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The resource type. Note: This should not be set by the user, as the constant value is Microsoft.DataLakeAnalytics/accounts
	Type *CheckNameAvailabilityParametersType `json:"type,omitempty"`
}

// ComputePoliciesCreateOrUpdateOptions contains the optional parameters for the ComputePolicies.CreateOrUpdate method.
type ComputePoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ComputePoliciesDeleteOptions contains the optional parameters for the ComputePolicies.Delete method.
type ComputePoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ComputePoliciesGetOptions contains the optional parameters for the ComputePolicies.Get method.
type ComputePoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// ComputePoliciesListByAccountOptions contains the optional parameters for the ComputePolicies.ListByAccount method.
type ComputePoliciesListByAccountOptions struct {
	// placeholder for future optional parameters
}

// ComputePoliciesUpdateOptions contains the optional parameters for the ComputePolicies.Update method.
type ComputePoliciesUpdateOptions struct {
	// Parameters supplied to update the compute policy.
	Parameters *UpdateComputePolicyParameters
}

// ComputePolicy - Data Lake Analytics compute policy information.
type ComputePolicy struct {
	SubResource
	// READ-ONLY; The compute policy properties.
	Properties *ComputePolicyProperties `json:"properties,omitempty" azure:"ro"`
}

// ComputePolicyListResult - The list of compute policies in the account.
type ComputePolicyListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*ComputePolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ComputePolicyListResult.
func (c ComputePolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ComputePolicyProperties - The compute policy properties.
type ComputePolicyProperties struct {
	// READ-ONLY; The maximum degree of parallelism per job this user can use to submit jobs.
	MaxDegreeOfParallelismPerJob *int32 `json:"maxDegreeOfParallelismPerJob,omitempty" azure:"ro"`

	// READ-ONLY; The minimum priority per job this user can use to submit jobs.
	MinPriorityPerJob *int32 `json:"minPriorityPerJob,omitempty" azure:"ro"`

	// READ-ONLY; The AAD object identifier for the entity to create a policy for.
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`

	// READ-ONLY; The type of AAD object the object identifier refers to.
	ObjectType *AADObjectType `json:"objectType,omitempty" azure:"ro"`
}

// CreateComputePolicyWithAccountParameters - The parameters used to create a new compute policy while creating a new Data Lake Analytics account.
type CreateComputePolicyWithAccountParameters struct {
	// REQUIRED; The unique name of the compute policy to create.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The compute policy properties to use when creating a new compute policy.
	Properties *CreateOrUpdateComputePolicyProperties `json:"properties,omitempty"`
}

// CreateDataLakeAnalyticsAccountParameters - The parameters to use for creating a Data Lake Analytics account.
type CreateDataLakeAnalyticsAccountParameters struct {
	// REQUIRED; The resource location.
	Location *string `json:"location,omitempty"`

	// REQUIRED; The Data Lake Analytics account properties to use for creating.
	Properties *CreateDataLakeAnalyticsAccountProperties `json:"properties,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CreateDataLakeAnalyticsAccountParameters.
func (c CreateDataLakeAnalyticsAccountParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", c.Location)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

type CreateDataLakeAnalyticsAccountProperties struct {
	// REQUIRED; The list of Data Lake Store accounts associated with this account.
	DataLakeStoreAccounts []*AddDataLakeStoreWithAccountParameters `json:"dataLakeStoreAccounts,omitempty"`

	// REQUIRED; The default Data Lake Store account associated with this account.
	DefaultDataLakeStoreAccount *string `json:"defaultDataLakeStoreAccount,omitempty"`

	// The list of compute policies associated with this account.
	ComputePolicies []*CreateComputePolicyWithAccountParameters `json:"computePolicies,omitempty"`

	// The current state of allowing or disallowing IPs originating within Azure through the firewall. If the firewall is disabled, this is not enforced.
	FirewallAllowAzureIPs *FirewallAllowAzureIPsState `json:"firewallAllowAzureIps,omitempty"`

	// The list of firewall rules associated with this account.
	FirewallRules []*CreateFirewallRuleWithAccountParameters `json:"firewallRules,omitempty"`

	// The current state of the IP address firewall for this account.
	FirewallState *FirewallState `json:"firewallState,omitempty"`

	// The maximum supported degree of parallelism for this account.
	MaxDegreeOfParallelism *int32 `json:"maxDegreeOfParallelism,omitempty"`

	// The maximum supported degree of parallelism per job for this account.
	MaxDegreeOfParallelismPerJob *int32 `json:"maxDegreeOfParallelismPerJob,omitempty"`

	// The maximum supported jobs running under the account at the same time.
	MaxJobCount *int32 `json:"maxJobCount,omitempty"`

	// The minimum supported priority per job for this account.
	MinPriorityPerJob *int32 `json:"minPriorityPerJob,omitempty"`

	// The commitment tier for the next month.
	NewTier *TierType `json:"newTier,omitempty"`

	// The number of days that job metadata is retained.
	QueryStoreRetention *int32 `json:"queryStoreRetention,omitempty"`

	// The list of Azure Blob Storage accounts associated with this account.
	StorageAccounts []*AddStorageAccountWithAccountParameters `json:"storageAccounts,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CreateDataLakeAnalyticsAccountProperties.
func (c CreateDataLakeAnalyticsAccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computePolicies", c.ComputePolicies)
	populate(objectMap, "dataLakeStoreAccounts", c.DataLakeStoreAccounts)
	populate(objectMap, "defaultDataLakeStoreAccount", c.DefaultDataLakeStoreAccount)
	populate(objectMap, "firewallAllowAzureIps", c.FirewallAllowAzureIPs)
	populate(objectMap, "firewallRules", c.FirewallRules)
	populate(objectMap, "firewallState", c.FirewallState)
	populate(objectMap, "maxDegreeOfParallelism", c.MaxDegreeOfParallelism)
	populate(objectMap, "maxDegreeOfParallelismPerJob", c.MaxDegreeOfParallelismPerJob)
	populate(objectMap, "maxJobCount", c.MaxJobCount)
	populate(objectMap, "minPriorityPerJob", c.MinPriorityPerJob)
	populate(objectMap, "newTier", c.NewTier)
	populate(objectMap, "queryStoreRetention", c.QueryStoreRetention)
	populate(objectMap, "storageAccounts", c.StorageAccounts)
	return json.Marshal(objectMap)
}

// CreateFirewallRuleWithAccountParameters - The parameters used to create a new firewall rule while creating a new Data Lake Analytics account.
type CreateFirewallRuleWithAccountParameters struct {
	// REQUIRED; The unique name of the firewall rule to create.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The firewall rule properties to use when creating a new firewall rule.
	Properties *CreateOrUpdateFirewallRuleProperties `json:"properties,omitempty"`
}

// CreateOrUpdateComputePolicyParameters - The parameters used to create a new compute policy.
type CreateOrUpdateComputePolicyParameters struct {
	// REQUIRED; The compute policy properties to use when creating a new compute policy.
	Properties *CreateOrUpdateComputePolicyProperties `json:"properties,omitempty"`
}

// CreateOrUpdateComputePolicyProperties - The compute policy properties to use when creating a new compute policy.
type CreateOrUpdateComputePolicyProperties struct {
	// REQUIRED; The AAD object identifier for the entity to create a policy for.
	ObjectID *string `json:"objectId,omitempty"`

	// REQUIRED; The type of AAD object the object identifier refers to.
	ObjectType *AADObjectType `json:"objectType,omitempty"`

	// The maximum degree of parallelism per job this user can use to submit jobs. This property, the min priority per job property, or both must be passed.
	MaxDegreeOfParallelismPerJob *int32 `json:"maxDegreeOfParallelismPerJob,omitempty"`

	// The minimum priority per job this user can use to submit jobs. This property, the max degree of parallelism per job property, or both must be passed.
	MinPriorityPerJob *int32 `json:"minPriorityPerJob,omitempty"`
}

// CreateOrUpdateFirewallRuleParameters - The parameters used to create a new firewall rule.
type CreateOrUpdateFirewallRuleParameters struct {
	// REQUIRED; The firewall rule properties to use when creating a new firewall rule.
	Properties *CreateOrUpdateFirewallRuleProperties `json:"properties,omitempty"`
}

// CreateOrUpdateFirewallRuleProperties - The firewall rule properties to use when creating a new firewall rule.
type CreateOrUpdateFirewallRuleProperties struct {
	// REQUIRED; The end IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
	EndIPAddress *string `json:"endIpAddress,omitempty"`

	// REQUIRED; The start IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
	StartIPAddress *string `json:"startIpAddress,omitempty"`
}

// DataLakeAnalyticsAccount - A Data Lake Analytics account object, containing all information associated with the named Data Lake Analytics account.
type DataLakeAnalyticsAccount struct {
	Resource
	// READ-ONLY; The properties defined by Data Lake Analytics all properties are specific to each resource provider.
	Properties *DataLakeAnalyticsAccountProperties `json:"properties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsAccount.
func (d DataLakeAnalyticsAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// DataLakeAnalyticsAccountBasic - A Data Lake Analytics account object, containing all information associated with the named Data Lake Analytics account.
type DataLakeAnalyticsAccountBasic struct {
	Resource
	// READ-ONLY; The properties defined by Data Lake Analytics all properties are specific to each resource provider.
	Properties *DataLakeAnalyticsAccountPropertiesBasic `json:"properties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsAccountBasic.
func (d DataLakeAnalyticsAccountBasic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// DataLakeAnalyticsAccountListResult - Data Lake Analytics account list information.
type DataLakeAnalyticsAccountListResult struct {
	// READ-ONLY; The current number of data lake analytics accounts under this subscription.
	Count *int32 `json:"count,omitempty" azure:"ro"`

	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*DataLakeAnalyticsAccountBasic `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsAccountListResult.
func (d DataLakeAnalyticsAccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "count", d.Count)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataLakeAnalyticsAccountProperties - The account specific properties that are associated with an underlying Data Lake Analytics account. Returned only
// when retrieving a specific account.
type DataLakeAnalyticsAccountProperties struct {
	DataLakeAnalyticsAccountPropertiesBasic
	// The current state of allowing or disallowing IPs originating within Azure through the firewall. If the firewall is disabled, this is not enforced.
	FirewallAllowAzureIPs *FirewallAllowAzureIPsState `json:"firewallAllowAzureIps,omitempty"`

	// The current state of the IP address firewall for this account.
	FirewallState *FirewallState `json:"firewallState,omitempty"`

	// The maximum supported degree of parallelism for this account.
	MaxDegreeOfParallelism *int32 `json:"maxDegreeOfParallelism,omitempty"`

	// The maximum supported degree of parallelism per job for this account.
	MaxDegreeOfParallelismPerJob *int32 `json:"maxDegreeOfParallelismPerJob,omitempty"`

	// The maximum supported jobs running under the account at the same time.
	MaxJobCount *int32 `json:"maxJobCount,omitempty"`

	// The commitment tier for the next month.
	NewTier *TierType `json:"newTier,omitempty"`

	// The list of Data Lake Store accounts associated with this account.
	PublicDataLakeStoreAccounts []*DataLakeStoreAccountInformation `json:"publicDataLakeStoreAccounts,omitempty"`

	// The number of days that job metadata is retained.
	QueryStoreRetention *int32 `json:"queryStoreRetention,omitempty"`

	// READ-ONLY; The list of compute policies associated with this account.
	ComputePolicies []*ComputePolicy `json:"computePolicies,omitempty" azure:"ro"`

	// READ-ONLY; The commitment tier in use for the current month.
	CurrentTier *TierType `json:"currentTier,omitempty" azure:"ro"`

	// READ-ONLY; The list of Data Lake Store accounts associated with this account.
	DataLakeStoreAccounts []*DataLakeStoreAccountInformation `json:"dataLakeStoreAccounts,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the DebugDataAccessLevel for this account.
	DebugDataAccessLevel *DebugDataAccessLevel `json:"debugDataAccessLevel,omitempty" azure:"ro"`

	// READ-ONLY; The default Data Lake Store account associated with this account.
	DefaultDataLakeStoreAccount *string `json:"defaultDataLakeStoreAccount,omitempty" azure:"ro"`

	// READ-ONLY; The type of the default Data Lake Store account associated with this account.
	DefaultDataLakeStoreAccountType *string `json:"defaultDataLakeStoreAccountType,omitempty" azure:"ro"`

	// READ-ONLY; The list of firewall rules associated with this account.
	FirewallRules []*FirewallRule `json:"firewallRules,omitempty" azure:"ro"`

	// READ-ONLY; The list of hiveMetastores associated with this account.
	HiveMetastores []*HiveMetastore `json:"hiveMetastores,omitempty" azure:"ro"`

	// READ-ONLY; The maximum supported active jobs under the account at the same time.
	MaxActiveJobCountPerUser *int32 `json:"maxActiveJobCountPerUser,omitempty" azure:"ro"`

	// READ-ONLY; The maximum supported active jobs under the account at the same time.
	MaxJobRunningTimeInMin *int32 `json:"maxJobRunningTimeInMin,omitempty" azure:"ro"`

	// READ-ONLY; The maximum supported jobs queued under the account at the same time.
	MaxQueuedJobCountPerUser *int32 `json:"maxQueuedJobCountPerUser,omitempty" azure:"ro"`

	// READ-ONLY; The minimum supported priority per job for this account.
	MinPriorityPerJob *int32 `json:"minPriorityPerJob,omitempty" azure:"ro"`

	// READ-ONLY; The list of Azure Blob Storage accounts associated with this account.
	StorageAccounts []*StorageAccountInformation `json:"storageAccounts,omitempty" azure:"ro"`

	// READ-ONLY; The system defined maximum supported degree of parallelism for this account, which restricts the maximum value of parallelism the user can
	// set for the account.
	SystemMaxDegreeOfParallelism *int32 `json:"systemMaxDegreeOfParallelism,omitempty" azure:"ro"`

	// READ-ONLY; The system defined maximum supported jobs running under the account at the same time, which restricts the maximum number of running jobs the
	// user can set for the account.
	SystemMaxJobCount *int32 `json:"systemMaxJobCount,omitempty" azure:"ro"`

	// READ-ONLY; The list of virtualNetwork rules associated with this account.
	VirtualNetworkRules []*VirtualNetworkRule `json:"virtualNetworkRules,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsAccountProperties.
func (d DataLakeAnalyticsAccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DataLakeAnalyticsAccountPropertiesBasic.marshalInternal(objectMap)
	populate(objectMap, "computePolicies", d.ComputePolicies)
	populate(objectMap, "currentTier", d.CurrentTier)
	populate(objectMap, "dataLakeStoreAccounts", d.DataLakeStoreAccounts)
	populate(objectMap, "debugDataAccessLevel", d.DebugDataAccessLevel)
	populate(objectMap, "defaultDataLakeStoreAccount", d.DefaultDataLakeStoreAccount)
	populate(objectMap, "defaultDataLakeStoreAccountType", d.DefaultDataLakeStoreAccountType)
	populate(objectMap, "firewallAllowAzureIps", d.FirewallAllowAzureIPs)
	populate(objectMap, "firewallRules", d.FirewallRules)
	populate(objectMap, "firewallState", d.FirewallState)
	populate(objectMap, "hiveMetastores", d.HiveMetastores)
	populate(objectMap, "maxActiveJobCountPerUser", d.MaxActiveJobCountPerUser)
	populate(objectMap, "maxDegreeOfParallelism", d.MaxDegreeOfParallelism)
	populate(objectMap, "maxDegreeOfParallelismPerJob", d.MaxDegreeOfParallelismPerJob)
	populate(objectMap, "maxJobCount", d.MaxJobCount)
	populate(objectMap, "maxJobRunningTimeInMin", d.MaxJobRunningTimeInMin)
	populate(objectMap, "maxQueuedJobCountPerUser", d.MaxQueuedJobCountPerUser)
	populate(objectMap, "minPriorityPerJob", d.MinPriorityPerJob)
	populate(objectMap, "newTier", d.NewTier)
	populate(objectMap, "publicDataLakeStoreAccounts", d.PublicDataLakeStoreAccounts)
	populate(objectMap, "queryStoreRetention", d.QueryStoreRetention)
	populate(objectMap, "storageAccounts", d.StorageAccounts)
	populate(objectMap, "systemMaxDegreeOfParallelism", d.SystemMaxDegreeOfParallelism)
	populate(objectMap, "systemMaxJobCount", d.SystemMaxJobCount)
	populate(objectMap, "virtualNetworkRules", d.VirtualNetworkRules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsAccountProperties.
func (d *DataLakeAnalyticsAccountProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computePolicies":
			err = unpopulate(val, &d.ComputePolicies)
			delete(rawMsg, key)
		case "currentTier":
			err = unpopulate(val, &d.CurrentTier)
			delete(rawMsg, key)
		case "dataLakeStoreAccounts":
			err = unpopulate(val, &d.DataLakeStoreAccounts)
			delete(rawMsg, key)
		case "debugDataAccessLevel":
			err = unpopulate(val, &d.DebugDataAccessLevel)
			delete(rawMsg, key)
		case "defaultDataLakeStoreAccount":
			err = unpopulate(val, &d.DefaultDataLakeStoreAccount)
			delete(rawMsg, key)
		case "defaultDataLakeStoreAccountType":
			err = unpopulate(val, &d.DefaultDataLakeStoreAccountType)
			delete(rawMsg, key)
		case "firewallAllowAzureIps":
			err = unpopulate(val, &d.FirewallAllowAzureIPs)
			delete(rawMsg, key)
		case "firewallRules":
			err = unpopulate(val, &d.FirewallRules)
			delete(rawMsg, key)
		case "firewallState":
			err = unpopulate(val, &d.FirewallState)
			delete(rawMsg, key)
		case "hiveMetastores":
			err = unpopulate(val, &d.HiveMetastores)
			delete(rawMsg, key)
		case "maxActiveJobCountPerUser":
			err = unpopulate(val, &d.MaxActiveJobCountPerUser)
			delete(rawMsg, key)
		case "maxDegreeOfParallelism":
			err = unpopulate(val, &d.MaxDegreeOfParallelism)
			delete(rawMsg, key)
		case "maxDegreeOfParallelismPerJob":
			err = unpopulate(val, &d.MaxDegreeOfParallelismPerJob)
			delete(rawMsg, key)
		case "maxJobCount":
			err = unpopulate(val, &d.MaxJobCount)
			delete(rawMsg, key)
		case "maxJobRunningTimeInMin":
			err = unpopulate(val, &d.MaxJobRunningTimeInMin)
			delete(rawMsg, key)
		case "maxQueuedJobCountPerUser":
			err = unpopulate(val, &d.MaxQueuedJobCountPerUser)
			delete(rawMsg, key)
		case "minPriorityPerJob":
			err = unpopulate(val, &d.MinPriorityPerJob)
			delete(rawMsg, key)
		case "newTier":
			err = unpopulate(val, &d.NewTier)
			delete(rawMsg, key)
		case "publicDataLakeStoreAccounts":
			err = unpopulate(val, &d.PublicDataLakeStoreAccounts)
			delete(rawMsg, key)
		case "queryStoreRetention":
			err = unpopulate(val, &d.QueryStoreRetention)
			delete(rawMsg, key)
		case "storageAccounts":
			err = unpopulate(val, &d.StorageAccounts)
			delete(rawMsg, key)
		case "systemMaxDegreeOfParallelism":
			err = unpopulate(val, &d.SystemMaxDegreeOfParallelism)
			delete(rawMsg, key)
		case "systemMaxJobCount":
			err = unpopulate(val, &d.SystemMaxJobCount)
			delete(rawMsg, key)
		case "virtualNetworkRules":
			err = unpopulate(val, &d.VirtualNetworkRules)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DataLakeAnalyticsAccountPropertiesBasic.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataLakeAnalyticsAccountPropertiesBasic - The basic account specific properties that are associated with an underlying Data Lake Analytics account.
type DataLakeAnalyticsAccountPropertiesBasic struct {
	// READ-ONLY; The unique identifier associated with this Data Lake Analytics account.
	AccountID *string `json:"accountId,omitempty" azure:"ro"`

	// READ-ONLY; The account creation time.
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`

	// READ-ONLY; The full CName endpoint for this account.
	Endpoint *string `json:"endpoint,omitempty" azure:"ro"`

	// READ-ONLY; The account last modified time.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the Data Lake Analytics account.
	ProvisioningState *DataLakeAnalyticsAccountStatus `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The state of the Data Lake Analytics account.
	State *DataLakeAnalyticsAccountState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsAccountPropertiesBasic.
func (d DataLakeAnalyticsAccountPropertiesBasic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsAccountPropertiesBasic.
func (d *DataLakeAnalyticsAccountPropertiesBasic) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DataLakeAnalyticsAccountPropertiesBasic) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "accountId", d.AccountID)
	populateTimeRFC3339(objectMap, "creationTime", d.CreationTime)
	populate(objectMap, "endpoint", d.Endpoint)
	populateTimeRFC3339(objectMap, "lastModifiedTime", d.LastModifiedTime)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "state", d.State)
}

func (d *DataLakeAnalyticsAccountPropertiesBasic) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountId":
			err = unpopulate(val, &d.AccountID)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTimeRFC3339(val, &d.CreationTime)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &d.Endpoint)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &d.LastModifiedTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &d.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataLakeStoreAccountInformation - Data Lake Store account information.
type DataLakeStoreAccountInformation struct {
	SubResource
	// The Data Lake Store account properties.
	Properties *DataLakeStoreAccountInformationProperties `json:"properties,omitempty"`
}

// DataLakeStoreAccountInformationListResult - Data Lake Store account list information.
type DataLakeStoreAccountInformationListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*DataLakeStoreAccountInformation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeStoreAccountInformationListResult.
func (d DataLakeStoreAccountInformationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataLakeStoreAccountInformationProperties - The Data Lake Store account properties.
type DataLakeStoreAccountInformationProperties struct {
	// READ-ONLY; The optional suffix for the Data Lake Store account.
	Suffix *string `json:"suffix,omitempty" azure:"ro"`
}

// DataLakeStoreAccountsAddOptions contains the optional parameters for the DataLakeStoreAccounts.Add method.
type DataLakeStoreAccountsAddOptions struct {
	// The details of the Data Lake Store account.
	Parameters *AddDataLakeStoreParameters
}

// DataLakeStoreAccountsDeleteOptions contains the optional parameters for the DataLakeStoreAccounts.Delete method.
type DataLakeStoreAccountsDeleteOptions struct {
	// placeholder for future optional parameters
}

// DataLakeStoreAccountsGetOptions contains the optional parameters for the DataLakeStoreAccounts.Get method.
type DataLakeStoreAccountsGetOptions struct {
	// placeholder for future optional parameters
}

// DataLakeStoreAccountsListByAccountOptions contains the optional parameters for the DataLakeStoreAccounts.ListByAccount method.
type DataLakeStoreAccountsListByAccountOptions struct {
	// The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
	// Optional.
	Count *bool
	// OData filter. Optional.
	Filter *string
	// OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted,
	// e.g. Categories?$orderby=CategoryName desc. Optional.
	Orderby *string
	// OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
	Select *string
	// The number of items to skip over before returning elements. Optional.
	Skip *int32
	// The number of items to return. Optional.
	Top *int32
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// FirewallRule - Data Lake Analytics firewall rule information.
type FirewallRule struct {
	SubResource
	// READ-ONLY; The firewall rule properties.
	Properties *FirewallRuleProperties `json:"properties,omitempty" azure:"ro"`
}

// FirewallRuleListResult - Data Lake Analytics firewall rule list information.
type FirewallRuleListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*FirewallRule `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FirewallRuleListResult.
func (f FirewallRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FirewallRuleProperties - The firewall rule properties.
type FirewallRuleProperties struct {
	// READ-ONLY; The end IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
	EndIPAddress *string `json:"endIpAddress,omitempty" azure:"ro"`

	// READ-ONLY; The start IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
	StartIPAddress *string `json:"startIpAddress,omitempty" azure:"ro"`
}

// FirewallRulesCreateOrUpdateOptions contains the optional parameters for the FirewallRules.CreateOrUpdate method.
type FirewallRulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// FirewallRulesDeleteOptions contains the optional parameters for the FirewallRules.Delete method.
type FirewallRulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// FirewallRulesGetOptions contains the optional parameters for the FirewallRules.Get method.
type FirewallRulesGetOptions struct {
	// placeholder for future optional parameters
}

// FirewallRulesListByAccountOptions contains the optional parameters for the FirewallRules.ListByAccount method.
type FirewallRulesListByAccountOptions struct {
	// placeholder for future optional parameters
}

// FirewallRulesUpdateOptions contains the optional parameters for the FirewallRules.Update method.
type FirewallRulesUpdateOptions struct {
	// Parameters supplied to update the firewall rule.
	Parameters *UpdateFirewallRuleParameters
}

type HiveMetastore struct {
	SubResource
	// READ-ONLY; The HiveMetastoreProperties rule properties.
	Properties *HiveMetastoreProperties `json:"properties,omitempty" azure:"ro"`
}

// HiveMetastoreListResult - Data Lake Analytics HiveMetastore list information.
type HiveMetastoreListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*HiveMetastore `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveMetastoreListResult.
func (h HiveMetastoreListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// HiveMetastoreProperties - The HiveMetastore properties.
type HiveMetastoreProperties struct {
	// READ-ONLY; The databaseName for the Hive MetaStore
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the NestedResource
	NestedResourceProvisioningState *NestedResourceProvisioningState `json:"nestedResourceProvisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The password for the Hive MetaStore
	Password *string `json:"password,omitempty" azure:"ro"`

	// READ-ONLY; The runtimeVersion for the Hive MetaStore
	RuntimeVersion *string `json:"runtimeVersion,omitempty" azure:"ro"`

	// READ-ONLY; The serverUri for the Hive MetaStore
	ServerURI *string `json:"serverUri,omitempty" azure:"ro"`

	// READ-ONLY; The userName for the Hive MetaStore
	UserName *string `json:"userName,omitempty" azure:"ro"`
}

// LocationsGetCapabilityOptions contains the optional parameters for the Locations.GetCapability method.
type LocationsGetCapabilityOptions struct {
	// placeholder for future optional parameters
}

// NameAvailabilityInformation - Data Lake Analytics account name availability result information.
type NameAvailabilityInformation struct {
	// READ-ONLY; The message describing why the Data Lake Analytics account name is not available, if nameAvailable is false.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The Boolean value of true or false to indicate whether the Data Lake Analytics account name is available or not.
	NameAvailable *bool `json:"nameAvailable,omitempty" azure:"ro"`

	// READ-ONLY; The reason why the Data Lake Analytics account name is not available, if nameAvailable is false.
	Reason *string `json:"reason,omitempty" azure:"ro"`
}

// Operation - An available operation for Data Lake Analytics.
type Operation struct {
	// READ-ONLY; The display information for the operation.
	Display *OperationDisplay `json:"display,omitempty" azure:"ro"`

	// READ-ONLY; The name of the operation.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The intended executor of the operation.
	Origin *OperationOrigin `json:"origin,omitempty" azure:"ro"`

	// READ-ONLY; The OperationMetaPropertyInfo for the operation.
	Properties *OperationMetaPropertyInfo `json:"properties,omitempty" azure:"ro"`
}

// OperationDisplay - The display information for a particular operation.
type OperationDisplay struct {
	// READ-ONLY; A friendly description of the operation.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; A friendly name of the operation.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; The resource provider of the operation.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; The resource type of the operation.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - The list of available operations for Data Lake Analytics.
type OperationListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

type OperationMetaLogSpecification struct {
	// The blobDuration for OperationMetaLogSpecification.
	BlobDuration *string `json:"blobDuration,omitempty"`

	// The displayName for OperationMetaLogSpecification.
	DisplayName *string `json:"displayName,omitempty"`

	// The name for OperationMetaLogSpecification.
	Name *string `json:"name,omitempty"`
}

type OperationMetaMetricAvailabilitiesSpecification struct {
	// The blobDuration for OperationMetaMetricAvailabilitiesSpecification.
	BlobDuration *string `json:"blobDuration,omitempty"`

	// The timegrain for OperationMetaMetricAvailabilitiesSpecification.
	TimeGrain *string `json:"timeGrain,omitempty"`
}

type OperationMetaMetricSpecification struct {
	// The aggregationType for OperationMetaMetricSpecification.
	AggregationType *string `json:"aggregationType,omitempty"`

	// The availabilities for OperationMetaMetricSpecification.
	Availabilities []*OperationMetaMetricAvailabilitiesSpecification `json:"availabilities,omitempty"`

	// The displayName for OperationMetaMetricSpecification.
	DisplayDescription *string `json:"displayDescription,omitempty"`

	// The displayName for OperationMetaMetricSpecification.
	DisplayName *string `json:"displayName,omitempty"`

	// The name for OperationMetaMetricSpecification.
	Name *string `json:"name,omitempty"`

	// The unit for OperationMetaMetricSpecification.
	Unit *string `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetaMetricSpecification.
func (o OperationMetaMetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", o.AggregationType)
	populate(objectMap, "availabilities", o.Availabilities)
	populate(objectMap, "displayDescription", o.DisplayDescription)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "unit", o.Unit)
	return json.Marshal(objectMap)
}

type OperationMetaPropertyInfo struct {
	// The operations OperationMetaServiceSpecification.
	ServiceSpecification *OperationMetaServiceSpecification `json:"serviceSpecification,omitempty"`
}

type OperationMetaServiceSpecification struct {
	// The logSpecifications for OperationMetaServiceSpecification.
	LogSpecifications []*OperationMetaLogSpecification `json:"logSpecifications,omitempty"`

	// The metricSpecifications for OperationMetaServiceSpecification.
	MetricSpecifications []*OperationMetaMetricSpecification `json:"metricSpecifications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetaServiceSpecification.
func (o OperationMetaServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", o.LogSpecifications)
	populate(objectMap, "metricSpecifications", o.MetricSpecifications)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// Resource - The resource model definition.
type Resource struct {
	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource location.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource tags.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// SasTokenInformation - SAS token information.
type SasTokenInformation struct {
	// READ-ONLY; The access token for the associated Azure Storage Container.
	AccessToken *string `json:"accessToken,omitempty" azure:"ro"`
}

// SasTokenInformationListResult - The SAS response that contains the storage account, container and associated SAS token for connection use.
type SasTokenInformationListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*SasTokenInformation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SasTokenInformationListResult.
func (s SasTokenInformationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageAccountInformation - Azure Storage account information.
type StorageAccountInformation struct {
	SubResource
	// READ-ONLY; The Azure Storage account properties.
	Properties *StorageAccountInformationProperties `json:"properties,omitempty" azure:"ro"`
}

// StorageAccountInformationListResult - Azure Storage account list information.
type StorageAccountInformationListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*StorageAccountInformation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountInformationListResult.
func (s StorageAccountInformationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageAccountInformationProperties - The Azure Storage account properties.
type StorageAccountInformationProperties struct {
	// READ-ONLY; The optional suffix for the storage account.
	Suffix *string `json:"suffix,omitempty" azure:"ro"`
}

// StorageAccountsAddOptions contains the optional parameters for the StorageAccounts.Add method.
type StorageAccountsAddOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsDeleteOptions contains the optional parameters for the StorageAccounts.Delete method.
type StorageAccountsDeleteOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsGetOptions contains the optional parameters for the StorageAccounts.Get method.
type StorageAccountsGetOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsGetStorageContainerOptions contains the optional parameters for the StorageAccounts.GetStorageContainer method.
type StorageAccountsGetStorageContainerOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsListByAccountOptions contains the optional parameters for the StorageAccounts.ListByAccount method.
type StorageAccountsListByAccountOptions struct {
	// The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
	// Optional.
	Count *bool
	// The OData filter. Optional.
	Filter *string
	// OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted,
	// e.g. Categories?$orderby=CategoryName desc. Optional.
	Orderby *string
	// OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
	Select *string
	// The number of items to skip over before returning elements. Optional.
	Skip *int32
	// The number of items to return. Optional.
	Top *int32
}

// StorageAccountsListSasTokensOptions contains the optional parameters for the StorageAccounts.ListSasTokens method.
type StorageAccountsListSasTokensOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsListStorageContainersOptions contains the optional parameters for the StorageAccounts.ListStorageContainers method.
type StorageAccountsListStorageContainersOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsUpdateOptions contains the optional parameters for the StorageAccounts.Update method.
type StorageAccountsUpdateOptions struct {
	// The parameters containing the access key and suffix to update the storage account with, if any. Passing nothing results in no change.
	Parameters *UpdateStorageAccountParameters
}

// StorageContainer - Azure Storage blob container information.
type StorageContainer struct {
	SubResource
	// READ-ONLY; The properties of the blob container.
	Properties *StorageContainerProperties `json:"properties,omitempty" azure:"ro"`
}

// StorageContainerListResult - The list of blob containers associated with the storage account attached to the Data Lake Analytics account.
type StorageContainerListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*StorageContainer `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageContainerListResult.
func (s StorageContainerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageContainerProperties - Azure Storage blob container properties information.
type StorageContainerProperties struct {
	// READ-ONLY; The last modified time of the blob container.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageContainerProperties.
func (s StorageContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "lastModifiedTime", s.LastModifiedTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageContainerProperties.
func (s *StorageContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubResource - The resource model definition for a nested resource.
type SubResource struct {
	// READ-ONLY; The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// UpdateComputePolicyParameters - The parameters used to update a compute policy.
type UpdateComputePolicyParameters struct {
	// The compute policy properties to use when updating a compute policy.
	Properties *UpdateComputePolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateComputePolicyParameters.
func (u UpdateComputePolicyParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UpdateComputePolicyProperties - The compute policy properties to use when updating a compute policy.
type UpdateComputePolicyProperties struct {
	// The maximum degree of parallelism per job this user can use to submit jobs. This property, the min priority per job property, or both must be passed.
	MaxDegreeOfParallelismPerJob *int32 `json:"maxDegreeOfParallelismPerJob,omitempty"`

	// The minimum priority per job this user can use to submit jobs. This property, the max degree of parallelism per job property, or both must be passed.
	MinPriorityPerJob *int32 `json:"minPriorityPerJob,omitempty"`

	// The AAD object identifier for the entity to create a policy for.
	ObjectID *string `json:"objectId,omitempty"`

	// The type of AAD object the object identifier refers to.
	ObjectType *AADObjectType `json:"objectType,omitempty"`
}

// UpdateComputePolicyWithAccountParameters - The parameters used to update a compute policy while updating a Data Lake Analytics account.
type UpdateComputePolicyWithAccountParameters struct {
	// REQUIRED; The unique name of the compute policy to update.
	Name *string `json:"name,omitempty"`

	// The compute policy properties to use when updating a compute policy.
	Properties *UpdateComputePolicyProperties `json:"properties,omitempty"`
}

// UpdateDataLakeAnalyticsAccountParameters - The parameters that can be used to update an existing Data Lake Analytics account.
type UpdateDataLakeAnalyticsAccountParameters struct {
	// The properties that can be updated in an existing Data Lake Analytics account.
	Properties *UpdateDataLakeAnalyticsAccountProperties `json:"properties,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateDataLakeAnalyticsAccountParameters.
func (u UpdateDataLakeAnalyticsAccountParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

// UpdateDataLakeAnalyticsAccountProperties - The properties to update that are associated with an underlying Data Lake Analytics account.
type UpdateDataLakeAnalyticsAccountProperties struct {
	// The list of compute policies associated with this account.
	ComputePolicies []*UpdateComputePolicyWithAccountParameters `json:"computePolicies,omitempty"`

	// The list of Data Lake Store accounts associated with this account.
	DataLakeStoreAccounts []*UpdateDataLakeStoreWithAccountParameters `json:"dataLakeStoreAccounts,omitempty"`

	// The current state of allowing or disallowing IPs originating within Azure through the firewall. If the firewall is disabled, this is not enforced.
	FirewallAllowAzureIPs *FirewallAllowAzureIPsState `json:"firewallAllowAzureIps,omitempty"`

	// The list of firewall rules associated with this account.
	FirewallRules []*UpdateFirewallRuleWithAccountParameters `json:"firewallRules,omitempty"`

	// The current state of the IP address firewall for this account. Disabling the firewall does not remove existing rules, they will just be ignored until
	// the firewall is re-enabled.
	FirewallState *FirewallState `json:"firewallState,omitempty"`

	// The maximum supported degree of parallelism for this account.
	MaxDegreeOfParallelism *int32 `json:"maxDegreeOfParallelism,omitempty"`

	// The maximum supported degree of parallelism per job for this account.
	MaxDegreeOfParallelismPerJob *int32 `json:"maxDegreeOfParallelismPerJob,omitempty"`

	// The maximum supported jobs running under the account at the same time.
	MaxJobCount *int32 `json:"maxJobCount,omitempty"`

	// The minimum supported priority per job for this account.
	MinPriorityPerJob *int32 `json:"minPriorityPerJob,omitempty"`

	// The commitment tier to use for next month.
	NewTier *TierType `json:"newTier,omitempty"`

	// The number of days that job metadata is retained.
	QueryStoreRetention *int32 `json:"queryStoreRetention,omitempty"`

	// The list of Azure Blob storage accounts associated with this account.
	StorageAccounts []*UpdateStorageAccountWithAccountParameters `json:"storageAccounts,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateDataLakeAnalyticsAccountProperties.
func (u UpdateDataLakeAnalyticsAccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computePolicies", u.ComputePolicies)
	populate(objectMap, "dataLakeStoreAccounts", u.DataLakeStoreAccounts)
	populate(objectMap, "firewallAllowAzureIps", u.FirewallAllowAzureIPs)
	populate(objectMap, "firewallRules", u.FirewallRules)
	populate(objectMap, "firewallState", u.FirewallState)
	populate(objectMap, "maxDegreeOfParallelism", u.MaxDegreeOfParallelism)
	populate(objectMap, "maxDegreeOfParallelismPerJob", u.MaxDegreeOfParallelismPerJob)
	populate(objectMap, "maxJobCount", u.MaxJobCount)
	populate(objectMap, "minPriorityPerJob", u.MinPriorityPerJob)
	populate(objectMap, "newTier", u.NewTier)
	populate(objectMap, "queryStoreRetention", u.QueryStoreRetention)
	populate(objectMap, "storageAccounts", u.StorageAccounts)
	return json.Marshal(objectMap)
}

// UpdateDataLakeStoreProperties - The Data Lake Store account properties to use when updating a Data Lake Store account.
type UpdateDataLakeStoreProperties struct {
	// The optional suffix for the Data Lake Store account.
	Suffix *string `json:"suffix,omitempty"`
}

// UpdateDataLakeStoreWithAccountParameters - The parameters used to update a Data Lake Store account while updating a Data Lake Analytics account.
type UpdateDataLakeStoreWithAccountParameters struct {
	// REQUIRED; The unique name of the Data Lake Store account to update.
	Name *string `json:"name,omitempty"`

	// The Data Lake Store account properties to use when updating a Data Lake Store account.
	Properties *UpdateDataLakeStoreProperties `json:"properties,omitempty"`
}

// UpdateFirewallRuleParameters - The parameters used to update a firewall rule.
type UpdateFirewallRuleParameters struct {
	// The firewall rule properties to use when updating a firewall rule.
	Properties *UpdateFirewallRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateFirewallRuleParameters.
func (u UpdateFirewallRuleParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UpdateFirewallRuleProperties - The firewall rule properties to use when updating a firewall rule.
type UpdateFirewallRuleProperties struct {
	// The end IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
	EndIPAddress *string `json:"endIpAddress,omitempty"`

	// The start IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
	StartIPAddress *string `json:"startIpAddress,omitempty"`
}

// UpdateFirewallRuleWithAccountParameters - The parameters used to update a firewall rule while updating a Data Lake Analytics account.
type UpdateFirewallRuleWithAccountParameters struct {
	// REQUIRED; The unique name of the firewall rule to update.
	Name *string `json:"name,omitempty"`

	// The firewall rule properties to use when updating a firewall rule.
	Properties *UpdateFirewallRuleProperties `json:"properties,omitempty"`
}

// UpdateStorageAccountParameters - The parameters used to update an Azure Storage account.
type UpdateStorageAccountParameters struct {
	// The Azure Storage account properties to use when updating an Azure Storage account.
	Properties *UpdateStorageAccountProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateStorageAccountParameters.
func (u UpdateStorageAccountParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UpdateStorageAccountProperties - The Azure Storage account properties to use when updating an Azure Storage account.
type UpdateStorageAccountProperties struct {
	// The updated access key associated with this Azure Storage account that will be used to connect to it.
	AccessKey *string `json:"accessKey,omitempty"`

	// The optional suffix for the storage account.
	Suffix *string `json:"suffix,omitempty"`
}

// UpdateStorageAccountWithAccountParameters - The parameters used to update an Azure Storage account while updating a Data Lake Analytics account.
type UpdateStorageAccountWithAccountParameters struct {
	// REQUIRED; The unique name of the Azure Storage account to update.
	Name *string `json:"name,omitempty"`

	// The Azure Storage account properties to use when updating an Azure Storage account.
	Properties *UpdateStorageAccountProperties `json:"properties,omitempty"`
}

// VirtualNetworkRule - Data Lake Analytics VirtualNetwork Rule information.
type VirtualNetworkRule struct {
	SubResource
	// READ-ONLY; The VirtualNetwork rule properties.
	Properties *VirtualNetworkRuleProperties `json:"properties,omitempty" azure:"ro"`
}

// VirtualNetworkRuleListResult - Data Lake Analytics VirtualNetwork rule list information.
type VirtualNetworkRuleListResult struct {
	// READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The results of the list operation.
	Value []*VirtualNetworkRule `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkRuleListResult.
func (v VirtualNetworkRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualNetworkRuleProperties - The VirtualNetwork Rule properties.
type VirtualNetworkRuleProperties struct {
	// READ-ONLY; The resource identifier for the subnet
	SubnetID *string `json:"subnetId,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the VirtualNetwork Rule
	VirtualNetworkRuleState *VirtualNetworkRuleState `json:"virtualNetworkRuleState,omitempty" azure:"ro"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
