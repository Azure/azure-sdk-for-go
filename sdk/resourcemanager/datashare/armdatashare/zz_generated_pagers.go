//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatashare

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AccountsClientListByResourceGroupPager struct {
	client    *AccountsClient
	current   AccountsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountList.NextLink == nil || len(*p.current.AccountList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountsClientListByResourceGroupResponse page.
func (p *AccountsClientListByResourceGroupPager) PageResponse() AccountsClientListByResourceGroupResponse {
	return p.current
}

// AccountsClientListBySubscriptionPager provides operations for iterating over paged responses.
type AccountsClientListBySubscriptionPager struct {
	client    *AccountsClient
	current   AccountsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountList.NextLink == nil || len(*p.current.AccountList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountsClientListBySubscriptionResponse page.
func (p *AccountsClientListBySubscriptionPager) PageResponse() AccountsClientListBySubscriptionResponse {
	return p.current
}

// ConsumerInvitationsClientListInvitationsPager provides operations for iterating over paged responses.
type ConsumerInvitationsClientListInvitationsPager struct {
	client    *ConsumerInvitationsClient
	current   ConsumerInvitationsClientListInvitationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConsumerInvitationsClientListInvitationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConsumerInvitationsClientListInvitationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConsumerInvitationsClientListInvitationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConsumerInvitationList.NextLink == nil || len(*p.current.ConsumerInvitationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInvitationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConsumerInvitationsClientListInvitationsResponse page.
func (p *ConsumerInvitationsClientListInvitationsPager) PageResponse() ConsumerInvitationsClientListInvitationsResponse {
	return p.current
}

// ConsumerSourceDataSetsClientListByShareSubscriptionPager provides operations for iterating over paged responses.
type ConsumerSourceDataSetsClientListByShareSubscriptionPager struct {
	client    *ConsumerSourceDataSetsClient
	current   ConsumerSourceDataSetsClientListByShareSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConsumerSourceDataSetsClientListByShareSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConsumerSourceDataSetsClientListByShareSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConsumerSourceDataSetsClientListByShareSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConsumerSourceDataSetList.NextLink == nil || len(*p.current.ConsumerSourceDataSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConsumerSourceDataSetsClientListByShareSubscriptionResponse page.
func (p *ConsumerSourceDataSetsClientListByShareSubscriptionPager) PageResponse() ConsumerSourceDataSetsClientListByShareSubscriptionResponse {
	return p.current
}

// DataSetMappingsClientListByShareSubscriptionPager provides operations for iterating over paged responses.
type DataSetMappingsClientListByShareSubscriptionPager struct {
	client    *DataSetMappingsClient
	current   DataSetMappingsClientListByShareSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataSetMappingsClientListByShareSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataSetMappingsClientListByShareSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataSetMappingsClientListByShareSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataSetMappingList.NextLink == nil || len(*p.current.DataSetMappingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataSetMappingsClientListByShareSubscriptionResponse page.
func (p *DataSetMappingsClientListByShareSubscriptionPager) PageResponse() DataSetMappingsClientListByShareSubscriptionResponse {
	return p.current
}

// DataSetsClientListBySharePager provides operations for iterating over paged responses.
type DataSetsClientListBySharePager struct {
	client    *DataSetsClient
	current   DataSetsClientListByShareResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataSetsClientListByShareResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataSetsClientListBySharePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataSetsClientListBySharePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataSetList.NextLink == nil || len(*p.current.DataSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataSetsClientListByShareResponse page.
func (p *DataSetsClientListBySharePager) PageResponse() DataSetsClientListByShareResponse {
	return p.current
}

// InvitationsClientListBySharePager provides operations for iterating over paged responses.
type InvitationsClientListBySharePager struct {
	client    *InvitationsClient
	current   InvitationsClientListByShareResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvitationsClientListByShareResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InvitationsClientListBySharePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InvitationsClientListBySharePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvitationList.NextLink == nil || len(*p.current.InvitationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InvitationsClientListByShareResponse page.
func (p *InvitationsClientListBySharePager) PageResponse() InvitationsClientListByShareResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationList.NextLink == nil || len(*p.current.OperationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// ProviderShareSubscriptionsClientListBySharePager provides operations for iterating over paged responses.
type ProviderShareSubscriptionsClientListBySharePager struct {
	client    *ProviderShareSubscriptionsClient
	current   ProviderShareSubscriptionsClientListByShareResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderShareSubscriptionsClientListByShareResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderShareSubscriptionsClientListBySharePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderShareSubscriptionsClientListBySharePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderShareSubscriptionList.NextLink == nil || len(*p.current.ProviderShareSubscriptionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderShareSubscriptionsClientListByShareResponse page.
func (p *ProviderShareSubscriptionsClientListBySharePager) PageResponse() ProviderShareSubscriptionsClientListByShareResponse {
	return p.current
}

// ShareSubscriptionsClientListByAccountPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListByAccountPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListByAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListByAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ShareSubscriptionsClientListByAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ShareSubscriptionsClientListByAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareSubscriptionList.NextLink == nil || len(*p.current.ShareSubscriptionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ShareSubscriptionsClientListByAccountResponse page.
func (p *ShareSubscriptionsClientListByAccountPager) PageResponse() ShareSubscriptionsClientListByAccountResponse {
	return p.current
}

// ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceShareSynchronizationSettingList.NextLink == nil || len(*p.current.SourceShareSynchronizationSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSourceShareSynchronizationSettingsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse page.
func (p *ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager) PageResponse() ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse {
	return p.current
}

// ShareSubscriptionsClientListSynchronizationDetailsPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListSynchronizationDetailsPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListSynchronizationDetailsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListSynchronizationDetailsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ShareSubscriptionsClientListSynchronizationDetailsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ShareSubscriptionsClientListSynchronizationDetailsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SynchronizationDetailsList.NextLink == nil || len(*p.current.SynchronizationDetailsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSynchronizationDetailsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ShareSubscriptionsClientListSynchronizationDetailsResponse page.
func (p *ShareSubscriptionsClientListSynchronizationDetailsPager) PageResponse() ShareSubscriptionsClientListSynchronizationDetailsResponse {
	return p.current
}

// ShareSubscriptionsClientListSynchronizationsPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListSynchronizationsPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListSynchronizationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListSynchronizationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ShareSubscriptionsClientListSynchronizationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ShareSubscriptionsClientListSynchronizationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareSubscriptionSynchronizationList.NextLink == nil || len(*p.current.ShareSubscriptionSynchronizationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSynchronizationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ShareSubscriptionsClientListSynchronizationsResponse page.
func (p *ShareSubscriptionsClientListSynchronizationsPager) PageResponse() ShareSubscriptionsClientListSynchronizationsResponse {
	return p.current
}

// SharesClientListByAccountPager provides operations for iterating over paged responses.
type SharesClientListByAccountPager struct {
	client    *SharesClient
	current   SharesClientListByAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesClientListByAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharesClientListByAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharesClientListByAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareList.NextLink == nil || len(*p.current.ShareList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharesClientListByAccountResponse page.
func (p *SharesClientListByAccountPager) PageResponse() SharesClientListByAccountResponse {
	return p.current
}

// SharesClientListSynchronizationDetailsPager provides operations for iterating over paged responses.
type SharesClientListSynchronizationDetailsPager struct {
	client    *SharesClient
	current   SharesClientListSynchronizationDetailsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesClientListSynchronizationDetailsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharesClientListSynchronizationDetailsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharesClientListSynchronizationDetailsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SynchronizationDetailsList.NextLink == nil || len(*p.current.SynchronizationDetailsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSynchronizationDetailsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharesClientListSynchronizationDetailsResponse page.
func (p *SharesClientListSynchronizationDetailsPager) PageResponse() SharesClientListSynchronizationDetailsResponse {
	return p.current
}

// SharesClientListSynchronizationsPager provides operations for iterating over paged responses.
type SharesClientListSynchronizationsPager struct {
	client    *SharesClient
	current   SharesClientListSynchronizationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesClientListSynchronizationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SharesClientListSynchronizationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SharesClientListSynchronizationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareSynchronizationList.NextLink == nil || len(*p.current.ShareSynchronizationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSynchronizationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SharesClientListSynchronizationsResponse page.
func (p *SharesClientListSynchronizationsPager) PageResponse() SharesClientListSynchronizationsResponse {
	return p.current
}

// SynchronizationSettingsClientListBySharePager provides operations for iterating over paged responses.
type SynchronizationSettingsClientListBySharePager struct {
	client    *SynchronizationSettingsClient
	current   SynchronizationSettingsClientListByShareResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SynchronizationSettingsClientListByShareResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SynchronizationSettingsClientListBySharePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SynchronizationSettingsClientListBySharePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SynchronizationSettingList.NextLink == nil || len(*p.current.SynchronizationSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SynchronizationSettingsClientListByShareResponse page.
func (p *SynchronizationSettingsClientListBySharePager) PageResponse() SynchronizationSettingsClientListByShareResponse {
	return p.current
}

// TriggersClientListByShareSubscriptionPager provides operations for iterating over paged responses.
type TriggersClientListByShareSubscriptionPager struct {
	client    *TriggersClient
	current   TriggersClientListByShareSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TriggersClientListByShareSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TriggersClientListByShareSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TriggersClientListByShareSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggerList.NextLink == nil || len(*p.current.TriggerList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByShareSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TriggersClientListByShareSubscriptionResponse page.
func (p *TriggersClientListByShareSubscriptionPager) PageResponse() TriggersClientListByShareSubscriptionResponse {
	return p.current
}
