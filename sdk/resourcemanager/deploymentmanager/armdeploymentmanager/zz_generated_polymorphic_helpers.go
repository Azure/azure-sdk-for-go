//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdeploymentmanager

import "encoding/json"

func unmarshalAuthenticationClassification(rawMsg json.RawMessage) (AuthenticationClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AuthenticationClassification
	switch m["type"] {
	case "Sas":
		b = &SasAuthentication{}
	default:
		b = &Authentication{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAuthenticationClassificationArray(rawMsg json.RawMessage) ([]AuthenticationClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AuthenticationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAuthenticationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAuthenticationClassificationMap(rawMsg json.RawMessage) (map[string]AuthenticationClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AuthenticationClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAuthenticationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalHealthCheckStepAttributesClassification(rawMsg json.RawMessage) (HealthCheckStepAttributesClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b HealthCheckStepAttributesClassification
	switch m["type"] {
	case "REST":
		b = &RestHealthCheckStepAttributes{}
	default:
		b = &HealthCheckStepAttributes{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalHealthCheckStepAttributesClassificationArray(rawMsg json.RawMessage) ([]HealthCheckStepAttributesClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]HealthCheckStepAttributesClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalHealthCheckStepAttributesClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalHealthCheckStepAttributesClassificationMap(rawMsg json.RawMessage) (map[string]HealthCheckStepAttributesClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]HealthCheckStepAttributesClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalHealthCheckStepAttributesClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalRestRequestAuthenticationClassification(rawMsg json.RawMessage) (RestRequestAuthenticationClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RestRequestAuthenticationClassification
	switch m["type"] {
	case string(RestAuthTypeAPIKey):
		b = &APIKeyAuthentication{}
	case string(RestAuthTypeRolloutIdentity):
		b = &RolloutIdentityAuthentication{}
	default:
		b = &RestRequestAuthentication{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalRestRequestAuthenticationClassificationArray(rawMsg json.RawMessage) ([]RestRequestAuthenticationClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RestRequestAuthenticationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRestRequestAuthenticationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRestRequestAuthenticationClassificationMap(rawMsg json.RawMessage) (map[string]RestRequestAuthenticationClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]RestRequestAuthenticationClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalRestRequestAuthenticationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalStepPropertiesClassification(rawMsg json.RawMessage) (StepPropertiesClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b StepPropertiesClassification
	switch m["stepType"] {
	case string(StepTypeHealthCheck):
		b = &HealthCheckStepProperties{}
	case string(StepTypeWait):
		b = &WaitStepProperties{}
	default:
		b = &StepProperties{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalStepPropertiesClassificationArray(rawMsg json.RawMessage) ([]StepPropertiesClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]StepPropertiesClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalStepPropertiesClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalStepPropertiesClassificationMap(rawMsg json.RawMessage) (map[string]StepPropertiesClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]StepPropertiesClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalStepPropertiesClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}
