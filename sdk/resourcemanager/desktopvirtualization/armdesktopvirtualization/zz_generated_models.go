//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdesktopvirtualization

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
	"time"
)

// Application - Schema for Application properties.
type Application struct {
	// REQUIRED; Detailed properties for Application
	Properties *ApplicationProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ApplicationGroup - Represents a ApplicationGroup definition.
type ApplicationGroup struct {
	// REQUIRED; Detailed properties for ApplicationGroup
	Properties *ApplicationGroupProperties                  `json:"properties,omitempty"`
	Identity   *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`

	// Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are
	// a kind of Microsoft.Web/sites type. If supported, the resource provider must
	// validate and persist this value.
	Kind *string `json:"kind,omitempty"`

	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another
	// Azure resource. If this is present, complete mode deployment will not
	// delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string                                  `json:"managedBy,omitempty"`
	Plan      *ResourceModelWithAllowedPropertySetPlan `json:"plan,omitempty"`
	SKU       *ResourceModelWithAllowedPropertySetSKU  `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The etag field is not required. If it is provided in the response body, it must also be provided as a header
	// per the normal etag convention. Entity tags are used for comparing two or more entities
	// from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match
	// (section 14.26), and If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationGroup.
func (a ApplicationGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "managedBy", a.ManagedBy)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "plan", a.Plan)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "sku", a.SKU)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// ApplicationGroupList - List of ApplicationGroup definitions.
type ApplicationGroupList struct {
	// List of ApplicationGroup definitions.
	Value []*ApplicationGroup `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationGroupList.
func (a ApplicationGroupList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ApplicationGroupPatch - ApplicationGroup properties that can be patched.
type ApplicationGroupPatch struct {
	// ApplicationGroup properties that can be patched.
	Properties *ApplicationGroupPatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationGroupPatch.
func (a ApplicationGroupPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// ApplicationGroupPatchProperties - ApplicationGroup properties that can be patched.
type ApplicationGroupPatchProperties struct {
	// Description of ApplicationGroup.
	Description *string `json:"description,omitempty"`

	// Friendly name of ApplicationGroup.
	FriendlyName *string `json:"friendlyName,omitempty"`
}

// ApplicationGroupProperties - Schema for ApplicationGroup properties.
type ApplicationGroupProperties struct {
	// REQUIRED; Resource Type of ApplicationGroup.
	ApplicationGroupType *ApplicationGroupType `json:"applicationGroupType,omitempty"`

	// REQUIRED; HostPool arm path of ApplicationGroup.
	HostPoolArmPath *string `json:"hostPoolArmPath,omitempty"`

	// Description of ApplicationGroup.
	Description *string `json:"description,omitempty"`

	// Friendly name of ApplicationGroup.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// The registration info of HostPool.
	MigrationRequest *MigrationRequestProperties `json:"migrationRequest,omitempty"`

	// READ-ONLY; Is cloud pc resource.
	CloudPcResource *bool `json:"cloudPcResource,omitempty" azure:"ro"`

	// READ-ONLY; ObjectId of ApplicationGroup. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`

	// READ-ONLY; Workspace arm path of ApplicationGroup.
	WorkspaceArmPath *string `json:"workspaceArmPath,omitempty" azure:"ro"`
}

// ApplicationGroupsClientCreateOrUpdateOptions contains the optional parameters for the ApplicationGroupsClient.CreateOrUpdate
// method.
type ApplicationGroupsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationGroupsClientDeleteOptions contains the optional parameters for the ApplicationGroupsClient.Delete method.
type ApplicationGroupsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationGroupsClientGetOptions contains the optional parameters for the ApplicationGroupsClient.Get method.
type ApplicationGroupsClientGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationGroupsClientListByResourceGroupOptions contains the optional parameters for the ApplicationGroupsClient.ListByResourceGroup
// method.
type ApplicationGroupsClientListByResourceGroupOptions struct {
	// OData filter expression. Valid properties for filtering are applicationGroupType.
	Filter *string
}

// ApplicationGroupsClientListBySubscriptionOptions contains the optional parameters for the ApplicationGroupsClient.ListBySubscription
// method.
type ApplicationGroupsClientListBySubscriptionOptions struct {
	// OData filter expression. Valid properties for filtering are applicationGroupType.
	Filter *string
}

// ApplicationGroupsClientUpdateOptions contains the optional parameters for the ApplicationGroupsClient.Update method.
type ApplicationGroupsClientUpdateOptions struct {
	// Object containing ApplicationGroup definitions.
	ApplicationGroup *ApplicationGroupPatch
}

// ApplicationList - List of Application definitions.
type ApplicationList struct {
	// List of Application definitions.
	Value []*Application `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationList.
func (a ApplicationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ApplicationPatch - Application properties that can be patched.
type ApplicationPatch struct {
	// Detailed properties for Application
	Properties *ApplicationPatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationPatch.
func (a ApplicationPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// ApplicationPatchProperties - Application properties that can be patched.
type ApplicationPatchProperties struct {
	// Resource Type of Application.
	ApplicationType *RemoteApplicationType `json:"applicationType,omitempty"`

	// Command Line Arguments for Application.
	CommandLineArguments *string `json:"commandLineArguments,omitempty"`

	// Specifies whether this published application can be launched with command line arguments provided by the client, command
	// line arguments specified at publish time, or no command line arguments at all.
	CommandLineSetting *CommandLineSetting `json:"commandLineSetting,omitempty"`

	// Description of Application.
	Description *string `json:"description,omitempty"`

	// Specifies a path for the executable file for the application.
	FilePath *string `json:"filePath,omitempty"`

	// Friendly name of Application.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// Index of the icon.
	IconIndex *int32 `json:"iconIndex,omitempty"`

	// Path to icon.
	IconPath *string `json:"iconPath,omitempty"`

	// Specifies the package application Id for MSIX applications
	MsixPackageApplicationID *string `json:"msixPackageApplicationId,omitempty"`

	// Specifies the package family name for MSIX applications
	MsixPackageFamilyName *string `json:"msixPackageFamilyName,omitempty"`

	// Specifies whether to show the RemoteApp program in the RD Web Access server.
	ShowInPortal *bool `json:"showInPortal,omitempty"`
}

// ApplicationProperties - Schema for Application properties.
type ApplicationProperties struct {
	// REQUIRED; Specifies whether this published application can be launched with command line arguments provided by the client,
	// command line arguments specified at publish time, or no command line arguments at all.
	CommandLineSetting *CommandLineSetting `json:"commandLineSetting,omitempty"`

	// Resource Type of Application.
	ApplicationType *RemoteApplicationType `json:"applicationType,omitempty"`

	// Command Line Arguments for Application.
	CommandLineArguments *string `json:"commandLineArguments,omitempty"`

	// Description of Application.
	Description *string `json:"description,omitempty"`

	// Specifies a path for the executable file for the application.
	FilePath *string `json:"filePath,omitempty"`

	// Friendly name of Application.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// Index of the icon.
	IconIndex *int32 `json:"iconIndex,omitempty"`

	// Path to icon.
	IconPath *string `json:"iconPath,omitempty"`

	// Specifies the package application Id for MSIX applications
	MsixPackageApplicationID *string `json:"msixPackageApplicationId,omitempty"`

	// Specifies the package family name for MSIX applications
	MsixPackageFamilyName *string `json:"msixPackageFamilyName,omitempty"`

	// Specifies whether to show the RemoteApp program in the RD Web Access server.
	ShowInPortal *bool `json:"showInPortal,omitempty"`

	// READ-ONLY; the icon a 64 bit string as a byte array.
	IconContent []byte `json:"iconContent,omitempty" azure:"ro"`

	// READ-ONLY; Hash of the icon.
	IconHash *string `json:"iconHash,omitempty" azure:"ro"`

	// READ-ONLY; ObjectId of Application. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationProperties.
func (a ApplicationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationType", a.ApplicationType)
	populate(objectMap, "commandLineArguments", a.CommandLineArguments)
	populate(objectMap, "commandLineSetting", a.CommandLineSetting)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "filePath", a.FilePath)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populateByteArray(objectMap, "iconContent", a.IconContent, runtime.Base64StdFormat)
	populate(objectMap, "iconHash", a.IconHash)
	populate(objectMap, "iconIndex", a.IconIndex)
	populate(objectMap, "iconPath", a.IconPath)
	populate(objectMap, "msixPackageApplicationId", a.MsixPackageApplicationID)
	populate(objectMap, "msixPackageFamilyName", a.MsixPackageFamilyName)
	populate(objectMap, "objectId", a.ObjectID)
	populate(objectMap, "showInPortal", a.ShowInPortal)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationProperties.
func (a *ApplicationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationType":
			err = unpopulate(val, &a.ApplicationType)
			delete(rawMsg, key)
		case "commandLineArguments":
			err = unpopulate(val, &a.CommandLineArguments)
			delete(rawMsg, key)
		case "commandLineSetting":
			err = unpopulate(val, &a.CommandLineSetting)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "filePath":
			err = unpopulate(val, &a.FilePath)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &a.FriendlyName)
			delete(rawMsg, key)
		case "iconContent":
			err = runtime.DecodeByteArray(string(val), &a.IconContent, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "iconHash":
			err = unpopulate(val, &a.IconHash)
			delete(rawMsg, key)
		case "iconIndex":
			err = unpopulate(val, &a.IconIndex)
			delete(rawMsg, key)
		case "iconPath":
			err = unpopulate(val, &a.IconPath)
			delete(rawMsg, key)
		case "msixPackageApplicationId":
			err = unpopulate(val, &a.MsixPackageApplicationID)
			delete(rawMsg, key)
		case "msixPackageFamilyName":
			err = unpopulate(val, &a.MsixPackageFamilyName)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, &a.ObjectID)
			delete(rawMsg, key)
		case "showInPortal":
			err = unpopulate(val, &a.ShowInPortal)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ApplicationsClientCreateOrUpdateOptions contains the optional parameters for the ApplicationsClient.CreateOrUpdate method.
type ApplicationsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsClientDeleteOptions contains the optional parameters for the ApplicationsClient.Delete method.
type ApplicationsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsClientGetOptions contains the optional parameters for the ApplicationsClient.Get method.
type ApplicationsClientGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsClientListOptions contains the optional parameters for the ApplicationsClient.List method.
type ApplicationsClientListOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsClientUpdateOptions contains the optional parameters for the ApplicationsClient.Update method.
type ApplicationsClientUpdateOptions struct {
	// Object containing Application definitions.
	Application *ApplicationPatch
}

// CloudError - Cloud error object.
type CloudError struct {
	// Cloud error object properties.
	Error *CloudErrorProperties `json:"error,omitempty"`
}

// CloudErrorProperties - Cloud error object properties.
type CloudErrorProperties struct {
	// Error code
	Code *string `json:"code,omitempty"`

	// Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
}

// Desktop - Schema for Desktop properties.
type Desktop struct {
	// Detailed properties for Desktop
	Properties *DesktopProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DesktopList - List of Desktop definitions.
type DesktopList struct {
	// List of Desktop definitions.
	Value []*Desktop `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DesktopList.
func (d DesktopList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DesktopPatch - Desktop properties that can be patched.
type DesktopPatch struct {
	// Detailed properties for Desktop
	Properties *DesktopPatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DesktopPatch.
func (d DesktopPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DesktopPatchProperties - Desktop properties that can be patched.
type DesktopPatchProperties struct {
	// Description of Desktop.
	Description *string `json:"description,omitempty"`

	// Friendly name of Desktop.
	FriendlyName *string `json:"friendlyName,omitempty"`
}

// DesktopProperties - Schema for Desktop properties.
type DesktopProperties struct {
	// Description of Desktop.
	Description *string `json:"description,omitempty"`

	// Friendly name of Desktop.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// READ-ONLY; The icon a 64 bit string as a byte array.
	IconContent []byte `json:"iconContent,omitempty" azure:"ro"`

	// READ-ONLY; Hash of the icon.
	IconHash *string `json:"iconHash,omitempty" azure:"ro"`

	// READ-ONLY; ObjectId of Desktop. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DesktopProperties.
func (d DesktopProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", d.Description)
	populate(objectMap, "friendlyName", d.FriendlyName)
	populateByteArray(objectMap, "iconContent", d.IconContent, runtime.Base64StdFormat)
	populate(objectMap, "iconHash", d.IconHash)
	populate(objectMap, "objectId", d.ObjectID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DesktopProperties.
func (d *DesktopProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &d.Description)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &d.FriendlyName)
			delete(rawMsg, key)
		case "iconContent":
			err = runtime.DecodeByteArray(string(val), &d.IconContent, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "iconHash":
			err = unpopulate(val, &d.IconHash)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, &d.ObjectID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DesktopsClientGetOptions contains the optional parameters for the DesktopsClient.Get method.
type DesktopsClientGetOptions struct {
	// placeholder for future optional parameters
}

// DesktopsClientListOptions contains the optional parameters for the DesktopsClient.List method.
type DesktopsClientListOptions struct {
	// placeholder for future optional parameters
}

// DesktopsClientUpdateOptions contains the optional parameters for the DesktopsClient.Update method.
type DesktopsClientUpdateOptions struct {
	// Object containing Desktop definitions.
	Desktop *DesktopPatch
}

// ExpandMsixImage - Represents the definition of contents retrieved after expanding the MSIX Image.
type ExpandMsixImage struct {
	// Detailed properties for ExpandMsixImage
	Properties *ExpandMsixImageProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ExpandMsixImageList - List of MSIX package properties retrieved from MSIX Image expansion.
type ExpandMsixImageList struct {
	// List of MSIX package properties from give MSIX Image.
	Value []*ExpandMsixImage `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExpandMsixImageList.
func (e ExpandMsixImageList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExpandMsixImageProperties - Schema for Expand MSIX Image properties.
type ExpandMsixImageProperties struct {
	// User friendly Name to be displayed in the portal.
	DisplayName *string `json:"displayName,omitempty"`

	// VHD/CIM image path on Network Share.
	ImagePath *string `json:"imagePath,omitempty"`

	// Make this version of the package the active one across the hostpool.
	IsActive *bool `json:"isActive,omitempty"`

	// Specifies how to register Package in feed.
	IsRegularRegistration *bool `json:"isRegularRegistration,omitempty"`

	// Date Package was last updated, found in the appxmanifest.xml.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// Alias of MSIX Package.
	PackageAlias *string `json:"packageAlias,omitempty"`

	// List of package applications.
	PackageApplications []*MsixPackageApplications `json:"packageApplications,omitempty"`

	// List of package dependencies.
	PackageDependencies []*MsixPackageDependencies `json:"packageDependencies,omitempty"`

	// Package Family Name from appxmanifest.xml. Contains Package Name and Publisher name.
	PackageFamilyName *string `json:"packageFamilyName,omitempty"`

	// Package Full Name from appxmanifest.xml.
	PackageFullName *string `json:"packageFullName,omitempty"`

	// Package Name from appxmanifest.xml.
	PackageName *string `json:"packageName,omitempty"`

	// Relative Path to the package inside the image.
	PackageRelativePath *string `json:"packageRelativePath,omitempty"`

	// Package Version found in the appxmanifest.xml.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExpandMsixImageProperties.
func (e ExpandMsixImageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "imagePath", e.ImagePath)
	populate(objectMap, "isActive", e.IsActive)
	populate(objectMap, "isRegularRegistration", e.IsRegularRegistration)
	populateTimeRFC3339(objectMap, "lastUpdated", e.LastUpdated)
	populate(objectMap, "packageAlias", e.PackageAlias)
	populate(objectMap, "packageApplications", e.PackageApplications)
	populate(objectMap, "packageDependencies", e.PackageDependencies)
	populate(objectMap, "packageFamilyName", e.PackageFamilyName)
	populate(objectMap, "packageFullName", e.PackageFullName)
	populate(objectMap, "packageName", e.PackageName)
	populate(objectMap, "packageRelativePath", e.PackageRelativePath)
	populate(objectMap, "version", e.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpandMsixImageProperties.
func (e *ExpandMsixImageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, &e.DisplayName)
			delete(rawMsg, key)
		case "imagePath":
			err = unpopulate(val, &e.ImagePath)
			delete(rawMsg, key)
		case "isActive":
			err = unpopulate(val, &e.IsActive)
			delete(rawMsg, key)
		case "isRegularRegistration":
			err = unpopulate(val, &e.IsRegularRegistration)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateTimeRFC3339(val, &e.LastUpdated)
			delete(rawMsg, key)
		case "packageAlias":
			err = unpopulate(val, &e.PackageAlias)
			delete(rawMsg, key)
		case "packageApplications":
			err = unpopulate(val, &e.PackageApplications)
			delete(rawMsg, key)
		case "packageDependencies":
			err = unpopulate(val, &e.PackageDependencies)
			delete(rawMsg, key)
		case "packageFamilyName":
			err = unpopulate(val, &e.PackageFamilyName)
			delete(rawMsg, key)
		case "packageFullName":
			err = unpopulate(val, &e.PackageFullName)
			delete(rawMsg, key)
		case "packageName":
			err = unpopulate(val, &e.PackageName)
			delete(rawMsg, key)
		case "packageRelativePath":
			err = unpopulate(val, &e.PackageRelativePath)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &e.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HostPool - Represents a HostPool definition.
type HostPool struct {
	// REQUIRED; Detailed properties for HostPool
	Properties *HostPoolProperties                          `json:"properties,omitempty"`
	Identity   *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`

	// Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are
	// a kind of Microsoft.Web/sites type. If supported, the resource provider must
	// validate and persist this value.
	Kind *string `json:"kind,omitempty"`

	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another
	// Azure resource. If this is present, complete mode deployment will not
	// delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string                                  `json:"managedBy,omitempty"`
	Plan      *ResourceModelWithAllowedPropertySetPlan `json:"plan,omitempty"`
	SKU       *ResourceModelWithAllowedPropertySetSKU  `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The etag field is not required. If it is provided in the response body, it must also be provided as a header
	// per the normal etag convention. Entity tags are used for comparing two or more entities
	// from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match
	// (section 14.26), and If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HostPool.
func (h HostPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", h.Etag)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "identity", h.Identity)
	populate(objectMap, "kind", h.Kind)
	populate(objectMap, "location", h.Location)
	populate(objectMap, "managedBy", h.ManagedBy)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "plan", h.Plan)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "sku", h.SKU)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// HostPoolList - List of HostPool definitions.
type HostPoolList struct {
	// List of HostPool definitions.
	Value []*HostPool `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HostPoolList.
func (h HostPoolList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// HostPoolPatch - HostPool properties that can be patched.
type HostPoolPatch struct {
	// HostPool properties that can be patched.
	Properties *HostPoolPatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HostPoolPatch.
func (h HostPoolPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// HostPoolPatchProperties - Properties of HostPool.
type HostPoolPatchProperties struct {
	// Custom rdp property of HostPool.
	CustomRdpProperty *string `json:"customRdpProperty,omitempty"`

	// Description of HostPool.
	Description *string `json:"description,omitempty"`

	// Friendly name of HostPool.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// The type of the load balancer.
	LoadBalancerType *LoadBalancerType `json:"loadBalancerType,omitempty"`

	// The max session limit of HostPool.
	MaxSessionLimit *int32 `json:"maxSessionLimit,omitempty"`

	// PersonalDesktopAssignment type for HostPool.
	PersonalDesktopAssignmentType *PersonalDesktopAssignmentType `json:"personalDesktopAssignmentType,omitempty"`

	// The type of preferred application group type, default to Desktop Application Group
	PreferredAppGroupType *PreferredAppGroupType `json:"preferredAppGroupType,omitempty"`

	// Enabled to allow this resource to be access from the public network
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The registration info of HostPool.
	RegistrationInfo *RegistrationInfoPatch `json:"registrationInfo,omitempty"`

	// The ring number of HostPool.
	Ring *int32 `json:"ring,omitempty"`

	// ClientId for the registered Relying Party used to issue WVD SSO certificates.
	SsoClientID *string `json:"ssoClientId,omitempty"`

	// Path to Azure KeyVault storing the secret used for communication to ADFS.
	SsoClientSecretKeyVaultPath *string `json:"ssoClientSecretKeyVaultPath,omitempty"`

	// The type of single sign on Secret Type.
	SsoSecretType *SSOSecretType `json:"ssoSecretType,omitempty"`

	// URL to customer ADFS server for signing WVD SSO certificates.
	SsoadfsAuthority *string `json:"ssoadfsAuthority,omitempty"`

	// The flag to turn on/off StartVMOnConnect feature.
	StartVMOnConnect *bool `json:"startVMOnConnect,omitempty"`

	// VM template for sessionhosts configuration within hostpool.
	VMTemplate *string `json:"vmTemplate,omitempty"`

	// Is validation environment.
	ValidationEnvironment *bool `json:"validationEnvironment,omitempty"`
}

// HostPoolProperties - Properties of HostPool.
type HostPoolProperties struct {
	// REQUIRED; HostPool type for desktop.
	HostPoolType *HostPoolType `json:"hostPoolType,omitempty"`

	// REQUIRED; The type of the load balancer.
	LoadBalancerType *LoadBalancerType `json:"loadBalancerType,omitempty"`

	// REQUIRED; The type of preferred application group type, default to Desktop Application Group
	PreferredAppGroupType *PreferredAppGroupType `json:"preferredAppGroupType,omitempty"`

	// Custom rdp property of HostPool.
	CustomRdpProperty *string `json:"customRdpProperty,omitempty"`

	// Description of HostPool.
	Description *string `json:"description,omitempty"`

	// Friendly name of HostPool.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// The max session limit of HostPool.
	MaxSessionLimit *int32 `json:"maxSessionLimit,omitempty"`

	// The registration info of HostPool.
	MigrationRequest *MigrationRequestProperties `json:"migrationRequest,omitempty"`

	// PersonalDesktopAssignment type for HostPool.
	PersonalDesktopAssignmentType *PersonalDesktopAssignmentType `json:"personalDesktopAssignmentType,omitempty"`

	// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only
	// be accessed via private endpoints
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The registration info of HostPool.
	RegistrationInfo *RegistrationInfo `json:"registrationInfo,omitempty"`

	// The ring number of HostPool.
	Ring *int32 `json:"ring,omitempty"`

	// ClientId for the registered Relying Party used to issue WVD SSO certificates.
	SsoClientID *string `json:"ssoClientId,omitempty"`

	// Path to Azure KeyVault storing the secret used for communication to ADFS.
	SsoClientSecretKeyVaultPath *string `json:"ssoClientSecretKeyVaultPath,omitempty"`

	// The type of single sign on Secret Type.
	SsoSecretType *SSOSecretType `json:"ssoSecretType,omitempty"`

	// URL to customer ADFS server for signing WVD SSO certificates.
	SsoadfsAuthority *string `json:"ssoadfsAuthority,omitempty"`

	// The flag to turn on/off StartVMOnConnect feature.
	StartVMOnConnect *bool `json:"startVMOnConnect,omitempty"`

	// VM template for sessionhosts configuration within hostpool.
	VMTemplate *string `json:"vmTemplate,omitempty"`

	// Is validation environment.
	ValidationEnvironment *bool `json:"validationEnvironment,omitempty"`

	// READ-ONLY; List of applicationGroup links.
	ApplicationGroupReferences []*string `json:"applicationGroupReferences,omitempty" azure:"ro"`

	// READ-ONLY; Is cloud pc resource.
	CloudPcResource *bool `json:"cloudPcResource,omitempty" azure:"ro"`

	// READ-ONLY; ObjectId of HostPool. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HostPoolProperties.
func (h HostPoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationGroupReferences", h.ApplicationGroupReferences)
	populate(objectMap, "cloudPcResource", h.CloudPcResource)
	populate(objectMap, "customRdpProperty", h.CustomRdpProperty)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "friendlyName", h.FriendlyName)
	populate(objectMap, "hostPoolType", h.HostPoolType)
	populate(objectMap, "loadBalancerType", h.LoadBalancerType)
	populate(objectMap, "maxSessionLimit", h.MaxSessionLimit)
	populate(objectMap, "migrationRequest", h.MigrationRequest)
	populate(objectMap, "objectId", h.ObjectID)
	populate(objectMap, "personalDesktopAssignmentType", h.PersonalDesktopAssignmentType)
	populate(objectMap, "preferredAppGroupType", h.PreferredAppGroupType)
	populate(objectMap, "publicNetworkAccess", h.PublicNetworkAccess)
	populate(objectMap, "registrationInfo", h.RegistrationInfo)
	populate(objectMap, "ring", h.Ring)
	populate(objectMap, "ssoClientId", h.SsoClientID)
	populate(objectMap, "ssoClientSecretKeyVaultPath", h.SsoClientSecretKeyVaultPath)
	populate(objectMap, "ssoSecretType", h.SsoSecretType)
	populate(objectMap, "ssoadfsAuthority", h.SsoadfsAuthority)
	populate(objectMap, "startVMOnConnect", h.StartVMOnConnect)
	populate(objectMap, "vmTemplate", h.VMTemplate)
	populate(objectMap, "validationEnvironment", h.ValidationEnvironment)
	return json.Marshal(objectMap)
}

// HostPoolsClientCreateOrUpdateOptions contains the optional parameters for the HostPoolsClient.CreateOrUpdate method.
type HostPoolsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// HostPoolsClientDeleteOptions contains the optional parameters for the HostPoolsClient.Delete method.
type HostPoolsClientDeleteOptions struct {
	// Force flag to delete sessionHost.
	Force *bool
}

// HostPoolsClientGetOptions contains the optional parameters for the HostPoolsClient.Get method.
type HostPoolsClientGetOptions struct {
	// placeholder for future optional parameters
}

// HostPoolsClientListByResourceGroupOptions contains the optional parameters for the HostPoolsClient.ListByResourceGroup
// method.
type HostPoolsClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// HostPoolsClientListOptions contains the optional parameters for the HostPoolsClient.List method.
type HostPoolsClientListOptions struct {
	// placeholder for future optional parameters
}

// HostPoolsClientRetrieveRegistrationTokenOptions contains the optional parameters for the HostPoolsClient.RetrieveRegistrationToken
// method.
type HostPoolsClientRetrieveRegistrationTokenOptions struct {
	// placeholder for future optional parameters
}

// HostPoolsClientUpdateOptions contains the optional parameters for the HostPoolsClient.Update method.
type HostPoolsClientUpdateOptions struct {
	// Object containing HostPool definitions.
	HostPool *HostPoolPatch
}

// Identity for the resource.
type Identity struct {
	// The identity type.
	Type *string `json:"type,omitempty"`

	// READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// LogSpecification - Specifications of the Log for Azure Monitoring
type LogSpecification struct {
	// Blob duration of the log
	BlobDuration *string `json:"blobDuration,omitempty"`

	// Localized friendly display name of the log
	DisplayName *string `json:"displayName,omitempty"`

	// Name of the log
	Name *string `json:"name,omitempty"`
}

// MSIXImageURI - Represents URI referring to MSIX Image
type MSIXImageURI struct {
	// URI to Image
	URI *string `json:"uri,omitempty"`
}

// MSIXPackage - Schema for MSIX Package properties.
type MSIXPackage struct {
	// REQUIRED; Detailed properties for MSIX Package
	Properties *MSIXPackageProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MSIXPackageList - List of MSIX Package definitions.
type MSIXPackageList struct {
	// List of MSIX Package definitions.
	Value []*MSIXPackage `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MSIXPackageList.
func (m MSIXPackageList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MSIXPackagePatch - MSIX Package properties that can be patched.
type MSIXPackagePatch struct {
	// Detailed properties for MSIX Package
	Properties *MSIXPackagePatchProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MSIXPackagePatch.
func (m MSIXPackagePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MSIXPackagePatchProperties - MSIX Package properties that can be patched.
type MSIXPackagePatchProperties struct {
	// Display name for MSIX Package.
	DisplayName *string `json:"displayName,omitempty"`

	// Set a version of the package to be active across hostpool.
	IsActive *bool `json:"isActive,omitempty"`

	// Set Registration mode. Regular or Delayed.
	IsRegularRegistration *bool `json:"isRegularRegistration,omitempty"`
}

// MSIXPackageProperties - Schema for MSIX Package properties.
type MSIXPackageProperties struct {
	// User friendly Name to be displayed in the portal.
	DisplayName *string `json:"displayName,omitempty"`

	// VHD/CIM image path on Network Share.
	ImagePath *string `json:"imagePath,omitempty"`

	// Make this version of the package the active one across the hostpool.
	IsActive *bool `json:"isActive,omitempty"`

	// Specifies how to register Package in feed.
	IsRegularRegistration *bool `json:"isRegularRegistration,omitempty"`

	// Date Package was last updated, found in the appxmanifest.xml.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// List of package applications.
	PackageApplications []*MsixPackageApplications `json:"packageApplications,omitempty"`

	// List of package dependencies.
	PackageDependencies []*MsixPackageDependencies `json:"packageDependencies,omitempty"`

	// Package Family Name from appxmanifest.xml. Contains Package Name and Publisher name.
	PackageFamilyName *string `json:"packageFamilyName,omitempty"`

	// Package Name from appxmanifest.xml.
	PackageName *string `json:"packageName,omitempty"`

	// Relative Path to the package inside the image.
	PackageRelativePath *string `json:"packageRelativePath,omitempty"`

	// Package Version found in the appxmanifest.xml.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MSIXPackageProperties.
func (m MSIXPackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "imagePath", m.ImagePath)
	populate(objectMap, "isActive", m.IsActive)
	populate(objectMap, "isRegularRegistration", m.IsRegularRegistration)
	populateTimeRFC3339(objectMap, "lastUpdated", m.LastUpdated)
	populate(objectMap, "packageApplications", m.PackageApplications)
	populate(objectMap, "packageDependencies", m.PackageDependencies)
	populate(objectMap, "packageFamilyName", m.PackageFamilyName)
	populate(objectMap, "packageName", m.PackageName)
	populate(objectMap, "packageRelativePath", m.PackageRelativePath)
	populate(objectMap, "version", m.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MSIXPackageProperties.
func (m *MSIXPackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, &m.DisplayName)
			delete(rawMsg, key)
		case "imagePath":
			err = unpopulate(val, &m.ImagePath)
			delete(rawMsg, key)
		case "isActive":
			err = unpopulate(val, &m.IsActive)
			delete(rawMsg, key)
		case "isRegularRegistration":
			err = unpopulate(val, &m.IsRegularRegistration)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateTimeRFC3339(val, &m.LastUpdated)
			delete(rawMsg, key)
		case "packageApplications":
			err = unpopulate(val, &m.PackageApplications)
			delete(rawMsg, key)
		case "packageDependencies":
			err = unpopulate(val, &m.PackageDependencies)
			delete(rawMsg, key)
		case "packageFamilyName":
			err = unpopulate(val, &m.PackageFamilyName)
			delete(rawMsg, key)
		case "packageName":
			err = unpopulate(val, &m.PackageName)
			delete(rawMsg, key)
		case "packageRelativePath":
			err = unpopulate(val, &m.PackageRelativePath)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &m.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MSIXPackagesClientCreateOrUpdateOptions contains the optional parameters for the MSIXPackagesClient.CreateOrUpdate method.
type MSIXPackagesClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// MSIXPackagesClientDeleteOptions contains the optional parameters for the MSIXPackagesClient.Delete method.
type MSIXPackagesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// MSIXPackagesClientGetOptions contains the optional parameters for the MSIXPackagesClient.Get method.
type MSIXPackagesClientGetOptions struct {
	// placeholder for future optional parameters
}

// MSIXPackagesClientListOptions contains the optional parameters for the MSIXPackagesClient.List method.
type MSIXPackagesClientListOptions struct {
	// placeholder for future optional parameters
}

// MSIXPackagesClientUpdateOptions contains the optional parameters for the MSIXPackagesClient.Update method.
type MSIXPackagesClientUpdateOptions struct {
	// Object containing MSIX Package definitions.
	MsixPackage *MSIXPackagePatch
}

// MigrationRequestProperties - Properties for arm migration.
type MigrationRequestProperties struct {
	// The path to the legacy object to migrate.
	MigrationPath *string `json:"migrationPath,omitempty"`

	// The type of operation for migration.
	Operation *Operation `json:"operation,omitempty"`
}

// MsixImagesClientExpandOptions contains the optional parameters for the MsixImagesClient.Expand method.
type MsixImagesClientExpandOptions struct {
	// placeholder for future optional parameters
}

// MsixPackageApplications - Schema for MSIX Package Application properties.
type MsixPackageApplications struct {
	// Package Application Id, found in appxmanifest.xml.
	AppID *string `json:"appId,omitempty"`

	// Used to activate Package Application. Consists of Package Name and ApplicationID. Found in appxmanifest.xml.
	AppUserModelID *string `json:"appUserModelID,omitempty"`

	// Description of Package Application.
	Description *string `json:"description,omitempty"`

	// User friendly name.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// User friendly name.
	IconImageName *string `json:"iconImageName,omitempty"`

	// the icon a 64 bit string as a byte array.
	RawIcon []byte `json:"rawIcon,omitempty"`

	// the icon a 64 bit string as a byte array.
	RawPNG []byte `json:"rawPng,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MsixPackageApplications.
func (m MsixPackageApplications) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appId", m.AppID)
	populate(objectMap, "appUserModelID", m.AppUserModelID)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "friendlyName", m.FriendlyName)
	populate(objectMap, "iconImageName", m.IconImageName)
	populateByteArray(objectMap, "rawIcon", m.RawIcon, runtime.Base64StdFormat)
	populateByteArray(objectMap, "rawPng", m.RawPNG, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MsixPackageApplications.
func (m *MsixPackageApplications) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
			err = unpopulate(val, &m.AppID)
			delete(rawMsg, key)
		case "appUserModelID":
			err = unpopulate(val, &m.AppUserModelID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &m.FriendlyName)
			delete(rawMsg, key)
		case "iconImageName":
			err = unpopulate(val, &m.IconImageName)
			delete(rawMsg, key)
		case "rawIcon":
			err = runtime.DecodeByteArray(string(val), &m.RawIcon, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "rawPng":
			err = runtime.DecodeByteArray(string(val), &m.RawPNG, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MsixPackageDependencies - Schema for MSIX Package Dependencies properties.
type MsixPackageDependencies struct {
	// Name of package dependency.
	DependencyName *string `json:"dependencyName,omitempty"`

	// Dependency version required.
	MinVersion *string `json:"minVersion,omitempty"`

	// Name of dependency publisher.
	Publisher *string `json:"publisher,omitempty"`
}

// OperationProperties - Properties of the operation
type OperationProperties struct {
	// Service specification payload
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// Plan for the resource.
type Plan struct {
	// REQUIRED; A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact
	// at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`

	// REQUIRED; The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`

	// A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// PrivateEndpoint - The Private Endpoint resource.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - The Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionListResultWithSystemData - List of private endpoint connection associated with the specified storage
// account
type PrivateEndpointConnectionListResultWithSystemData struct {
	// Array of private endpoint connections
	Value []*PrivateEndpointConnectionWithSystemData `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResultWithSystemData.
func (p PrivateEndpointConnectionListResultWithSystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// REQUIRED; A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// The provisioning state of the private endpoint connection resource.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty"`
}

// PrivateEndpointConnectionWithSystemData - The Private Endpoint Connection resource.
type PrivateEndpointConnectionWithSystemData struct {
	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionsClientDeleteByHostPoolOptions contains the optional parameters for the PrivateEndpointConnectionsClient.DeleteByHostPool
// method.
type PrivateEndpointConnectionsClientDeleteByHostPoolOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientDeleteByWorkspaceOptions contains the optional parameters for the PrivateEndpointConnectionsClient.DeleteByWorkspace
// method.
type PrivateEndpointConnectionsClientDeleteByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientGetByHostPoolOptions contains the optional parameters for the PrivateEndpointConnectionsClient.GetByHostPool
// method.
type PrivateEndpointConnectionsClientGetByHostPoolOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientGetByWorkspaceOptions contains the optional parameters for the PrivateEndpointConnectionsClient.GetByWorkspace
// method.
type PrivateEndpointConnectionsClientGetByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientListByHostPoolOptions contains the optional parameters for the PrivateEndpointConnectionsClient.ListByHostPool
// method.
type PrivateEndpointConnectionsClientListByHostPoolOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientListByWorkspaceOptions contains the optional parameters for the PrivateEndpointConnectionsClient.ListByWorkspace
// method.
type PrivateEndpointConnectionsClientListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientUpdateByHostPoolOptions contains the optional parameters for the PrivateEndpointConnectionsClient.UpdateByHostPool
// method.
type PrivateEndpointConnectionsClientUpdateByHostPoolOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientUpdateByWorkspaceOptions contains the optional parameters for the PrivateEndpointConnectionsClient.UpdateByWorkspace
// method.
type PrivateEndpointConnectionsClientUpdateByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	// Resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkResourceListResult - A list of private link resources
type PrivateLinkResourceListResult struct {
	// Array of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// The private link resource Private link DNS zone name.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`

	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesClientListByHostPoolOptions contains the optional parameters for the PrivateLinkResourcesClient.ListByHostPool
// method.
type PrivateLinkResourcesClientListByHostPoolOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesClientListByWorkspaceOptions contains the optional parameters for the PrivateLinkResourcesClient.ListByWorkspace
// method.
type PrivateLinkResourcesClientListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer
// and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// RegistrationInfo - Represents a RegistrationInfo definition.
type RegistrationInfo struct {
	// Expiration time of registration token.
	ExpirationTime *time.Time `json:"expirationTime,omitempty"`

	// The type of resetting the token.
	RegistrationTokenOperation *RegistrationTokenOperation `json:"registrationTokenOperation,omitempty"`

	// The registration token base64 encoded string.
	Token *string `json:"token,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistrationInfo.
func (r RegistrationInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expirationTime", r.ExpirationTime)
	populate(objectMap, "registrationTokenOperation", r.RegistrationTokenOperation)
	populate(objectMap, "token", r.Token)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistrationInfo.
func (r *RegistrationInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, &r.ExpirationTime)
			delete(rawMsg, key)
		case "registrationTokenOperation":
			err = unpopulate(val, &r.RegistrationTokenOperation)
			delete(rawMsg, key)
		case "token":
			err = unpopulate(val, &r.Token)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RegistrationInfoPatch - Represents a RegistrationInfo definition.
type RegistrationInfoPatch struct {
	// Expiration time of registration token.
	ExpirationTime *time.Time `json:"expirationTime,omitempty"`

	// The type of resetting the token.
	RegistrationTokenOperation *RegistrationTokenOperation `json:"registrationTokenOperation,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistrationInfoPatch.
func (r RegistrationInfoPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expirationTime", r.ExpirationTime)
	populate(objectMap, "registrationTokenOperation", r.RegistrationTokenOperation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistrationInfoPatch.
func (r *RegistrationInfoPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, &r.ExpirationTime)
			delete(rawMsg, key)
		case "registrationTokenOperation":
			err = unpopulate(val, &r.RegistrationTokenOperation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ResourceModelWithAllowedPropertySet - The resource model definition containing the full set of allowed properties for a
// resource. Except properties bag, there cannot be a top level property outside of this set.
type ResourceModelWithAllowedPropertySet struct {
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`

	// Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are
	// a kind of Microsoft.Web/sites type. If supported, the resource provider must
	// validate and persist this value.
	Kind *string `json:"kind,omitempty"`

	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another
	// Azure resource. If this is present, complete mode deployment will not
	// delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string                                  `json:"managedBy,omitempty"`
	Plan      *ResourceModelWithAllowedPropertySetPlan `json:"plan,omitempty"`
	SKU       *ResourceModelWithAllowedPropertySetSKU  `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The etag field is not required. If it is provided in the response body, it must also be provided as a header
	// per the normal etag convention. Entity tags are used for comparing two or more entities
	// from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match
	// (section 14.26), and If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceModelWithAllowedPropertySet.
func (r ResourceModelWithAllowedPropertySet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "managedBy", r.ManagedBy)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "plan", r.Plan)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

type ResourceModelWithAllowedPropertySetIdentity struct {
	// The identity type.
	Type *string `json:"type,omitempty"`

	// READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

type ResourceModelWithAllowedPropertySetPlan struct {
	// REQUIRED; A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact
	// at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`

	// REQUIRED; The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`

	// A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

type ResourceModelWithAllowedPropertySetSKU struct {
	// REQUIRED; The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the
	// resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`

	// If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`

	// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required
	// on a PUT.
	Tier *SKUTier `json:"tier,omitempty"`
}

// ResourceProviderOperation - Supported operation of this resource provider.
type ResourceProviderOperation struct {
	// Display metadata associated with the operation.
	Display *ResourceProviderOperationDisplay `json:"display,omitempty"`

	// Is a data action.
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Operation name, in format of {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`

	// Properties of the operation
	Properties *OperationProperties `json:"properties,omitempty"`
}

// ResourceProviderOperationDisplay - Display metadata associated with the operation.
type ResourceProviderOperationDisplay struct {
	// Description of this operation.
	Description *string `json:"description,omitempty"`

	// Type of operation: get, read, delete, etc.
	Operation *string `json:"operation,omitempty"`

	// Resource provider: Microsoft Desktop Virtualization.
	Provider *string `json:"provider,omitempty"`

	// Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// ResourceProviderOperationList - Result of the request to list operations.
type ResourceProviderOperationList struct {
	// List of operations supported by this resource provider.
	Value []*ResourceProviderOperation `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceProviderOperationList.
func (r ResourceProviderOperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// SKU - The resource model definition representing SKU
type SKU struct {
	// REQUIRED; The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the
	// resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`

	// If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`

	// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required
	// on a PUT.
	Tier *SKUTier `json:"tier,omitempty"`
}

// ScalingHostPoolReference - Scaling plan reference to hostpool.
type ScalingHostPoolReference struct {
	// Arm path of referenced hostpool.
	HostPoolArmPath *string `json:"hostPoolArmPath,omitempty"`

	// Is the scaling plan enabled for this hostpool.
	ScalingPlanEnabled *bool `json:"scalingPlanEnabled,omitempty"`
}

// ScalingPlan - Represents a scaling plan definition.
type ScalingPlan struct {
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`

	// Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are
	// a kind of Microsoft.Web/sites type. If supported, the resource provider must
	// validate and persist this value.
	Kind *string `json:"kind,omitempty"`

	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another
	// Azure resource. If this is present, complete mode deployment will not
	// delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string                                  `json:"managedBy,omitempty"`
	Plan      *ResourceModelWithAllowedPropertySetPlan `json:"plan,omitempty"`

	// Detailed properties for scaling plan.
	Properties *ScalingPlanProperties                  `json:"properties,omitempty"`
	SKU        *ResourceModelWithAllowedPropertySetSKU `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The etag field is not required. If it is provided in the response body, it must also be provided as a header
	// per the normal etag convention. Entity tags are used for comparing two or more entities
	// from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match
	// (section 14.26), and If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalingPlan.
func (s ScalingPlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "kind", s.Kind)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "managedBy", s.ManagedBy)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "plan", s.Plan)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// ScalingPlanList - List of scaling plan definitions.
type ScalingPlanList struct {
	// List of scaling plan definitions.
	Value []*ScalingPlan `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalingPlanList.
func (s ScalingPlanList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ScalingPlanPatch - Scaling plan properties that can be patched.
type ScalingPlanPatch struct {
	// Detailed properties for scaling plan
	Properties *ScalingPlanPatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalingPlanPatch.
func (s ScalingPlanPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// ScalingPlanPatchProperties - Scaling plan properties.
type ScalingPlanPatchProperties struct {
	// Description of scaling plan.
	Description *string `json:"description,omitempty"`

	// Exclusion tag for scaling plan.
	ExclusionTag *string `json:"exclusionTag,omitempty"`

	// User friendly name of scaling plan.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// List of ScalingHostPoolReference definitions.
	HostPoolReferences []*ScalingHostPoolReference `json:"hostPoolReferences,omitempty"`

	// List of ScalingSchedule definitions.
	Schedules []*ScalingSchedule `json:"schedules,omitempty"`

	// Timezone of the scaling plan.
	TimeZone *string `json:"timeZone,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalingPlanPatchProperties.
func (s ScalingPlanPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "exclusionTag", s.ExclusionTag)
	populate(objectMap, "friendlyName", s.FriendlyName)
	populate(objectMap, "hostPoolReferences", s.HostPoolReferences)
	populate(objectMap, "schedules", s.Schedules)
	populate(objectMap, "timeZone", s.TimeZone)
	return json.Marshal(objectMap)
}

// ScalingPlanProperties - Scaling plan properties.
type ScalingPlanProperties struct {
	// Description of scaling plan.
	Description *string `json:"description,omitempty"`

	// Exclusion tag for scaling plan.
	ExclusionTag *string `json:"exclusionTag,omitempty"`

	// User friendly name of scaling plan.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// List of ScalingHostPoolReference definitions.
	HostPoolReferences []*ScalingHostPoolReference `json:"hostPoolReferences,omitempty"`

	// HostPool type for desktop.
	HostPoolType *ScalingHostPoolType `json:"hostPoolType,omitempty"`

	// List of ScalingSchedule definitions.
	Schedules []*ScalingSchedule `json:"schedules,omitempty"`

	// Timezone of the scaling plan.
	TimeZone *string `json:"timeZone,omitempty"`

	// READ-ONLY; ObjectId of scaling plan. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalingPlanProperties.
func (s ScalingPlanProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "exclusionTag", s.ExclusionTag)
	populate(objectMap, "friendlyName", s.FriendlyName)
	populate(objectMap, "hostPoolReferences", s.HostPoolReferences)
	populate(objectMap, "hostPoolType", s.HostPoolType)
	populate(objectMap, "objectId", s.ObjectID)
	populate(objectMap, "schedules", s.Schedules)
	populate(objectMap, "timeZone", s.TimeZone)
	return json.Marshal(objectMap)
}

// ScalingPlansClientCreateOptions contains the optional parameters for the ScalingPlansClient.Create method.
type ScalingPlansClientCreateOptions struct {
	// placeholder for future optional parameters
}

// ScalingPlansClientDeleteOptions contains the optional parameters for the ScalingPlansClient.Delete method.
type ScalingPlansClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ScalingPlansClientGetOptions contains the optional parameters for the ScalingPlansClient.Get method.
type ScalingPlansClientGetOptions struct {
	// placeholder for future optional parameters
}

// ScalingPlansClientListByHostPoolOptions contains the optional parameters for the ScalingPlansClient.ListByHostPool method.
type ScalingPlansClientListByHostPoolOptions struct {
	// placeholder for future optional parameters
}

// ScalingPlansClientListByResourceGroupOptions contains the optional parameters for the ScalingPlansClient.ListByResourceGroup
// method.
type ScalingPlansClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ScalingPlansClientListBySubscriptionOptions contains the optional parameters for the ScalingPlansClient.ListBySubscription
// method.
type ScalingPlansClientListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// ScalingPlansClientUpdateOptions contains the optional parameters for the ScalingPlansClient.Update method.
type ScalingPlansClientUpdateOptions struct {
	// Object containing scaling plan definitions.
	ScalingPlan *ScalingPlanPatch
}

// ScalingSchedule - Scaling plan schedule.
type ScalingSchedule struct {
	// Set of days of the week on which this schedule is active.
	DaysOfWeek []*ScalingScheduleDaysOfWeekItem `json:"daysOfWeek,omitempty"`

	// Name of the scaling schedule.
	Name *string `json:"name,omitempty"`

	// Load balancing algorithm for off-peak period.
	OffPeakLoadBalancingAlgorithm *SessionHostLoadBalancingAlgorithm `json:"offPeakLoadBalancingAlgorithm,omitempty"`

	// Starting time for off-peak period.
	OffPeakStartTime *Time `json:"offPeakStartTime,omitempty"`

	// Load balancing algorithm for peak period.
	PeakLoadBalancingAlgorithm *SessionHostLoadBalancingAlgorithm `json:"peakLoadBalancingAlgorithm,omitempty"`

	// Starting time for peak period.
	PeakStartTime *Time `json:"peakStartTime,omitempty"`

	// Capacity threshold for ramp down period.
	RampDownCapacityThresholdPct *int32 `json:"rampDownCapacityThresholdPct,omitempty"`

	// Should users be logged off forcefully from hosts.
	RampDownForceLogoffUsers *bool `json:"rampDownForceLogoffUsers,omitempty"`

	// Load balancing algorithm for ramp down period.
	RampDownLoadBalancingAlgorithm *SessionHostLoadBalancingAlgorithm `json:"rampDownLoadBalancingAlgorithm,omitempty"`

	// Minimum host percentage for ramp down period.
	RampDownMinimumHostsPct *int32 `json:"rampDownMinimumHostsPct,omitempty"`

	// Notification message for users during ramp down period.
	RampDownNotificationMessage *string `json:"rampDownNotificationMessage,omitempty"`

	// Starting time for ramp down period.
	RampDownStartTime *Time `json:"rampDownStartTime,omitempty"`

	// Specifies when to stop hosts during ramp down period.
	RampDownStopHostsWhen *StopHostsWhen `json:"rampDownStopHostsWhen,omitempty"`

	// Number of minutes to wait to stop hosts during ramp down period.
	RampDownWaitTimeMinutes *int32 `json:"rampDownWaitTimeMinutes,omitempty"`

	// Capacity threshold for ramp up period.
	RampUpCapacityThresholdPct *int32 `json:"rampUpCapacityThresholdPct,omitempty"`

	// Load balancing algorithm for ramp up period.
	RampUpLoadBalancingAlgorithm *SessionHostLoadBalancingAlgorithm `json:"rampUpLoadBalancingAlgorithm,omitempty"`

	// Minimum host percentage for ramp up period.
	RampUpMinimumHostsPct *int32 `json:"rampUpMinimumHostsPct,omitempty"`

	// Starting time for ramp up period.
	RampUpStartTime *Time `json:"rampUpStartTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalingSchedule.
func (s ScalingSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "daysOfWeek", s.DaysOfWeek)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "offPeakLoadBalancingAlgorithm", s.OffPeakLoadBalancingAlgorithm)
	populate(objectMap, "offPeakStartTime", s.OffPeakStartTime)
	populate(objectMap, "peakLoadBalancingAlgorithm", s.PeakLoadBalancingAlgorithm)
	populate(objectMap, "peakStartTime", s.PeakStartTime)
	populate(objectMap, "rampDownCapacityThresholdPct", s.RampDownCapacityThresholdPct)
	populate(objectMap, "rampDownForceLogoffUsers", s.RampDownForceLogoffUsers)
	populate(objectMap, "rampDownLoadBalancingAlgorithm", s.RampDownLoadBalancingAlgorithm)
	populate(objectMap, "rampDownMinimumHostsPct", s.RampDownMinimumHostsPct)
	populate(objectMap, "rampDownNotificationMessage", s.RampDownNotificationMessage)
	populate(objectMap, "rampDownStartTime", s.RampDownStartTime)
	populate(objectMap, "rampDownStopHostsWhen", s.RampDownStopHostsWhen)
	populate(objectMap, "rampDownWaitTimeMinutes", s.RampDownWaitTimeMinutes)
	populate(objectMap, "rampUpCapacityThresholdPct", s.RampUpCapacityThresholdPct)
	populate(objectMap, "rampUpLoadBalancingAlgorithm", s.RampUpLoadBalancingAlgorithm)
	populate(objectMap, "rampUpMinimumHostsPct", s.RampUpMinimumHostsPct)
	populate(objectMap, "rampUpStartTime", s.RampUpStartTime)
	return json.Marshal(objectMap)
}

// SendMessage - Represents message sent to a UserSession.
type SendMessage struct {
	// Body of message.
	MessageBody *string `json:"messageBody,omitempty"`

	// Title of message.
	MessageTitle *string `json:"messageTitle,omitempty"`
}

// ServiceSpecification - Service specification payload
type ServiceSpecification struct {
	// Specifications of the Log for Azure Monitoring
	LogSpecifications []*LogSpecification `json:"logSpecifications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSpecification.
func (s ServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", s.LogSpecifications)
	return json.Marshal(objectMap)
}

// SessionHost - Represents a SessionHost definition.
type SessionHost struct {
	// Detailed properties for SessionHost
	Properties *SessionHostProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SessionHostHealthCheckFailureDetails - Contains details on the failure.
type SessionHostHealthCheckFailureDetails struct {
	// READ-ONLY; Error code corresponding for the failure.
	ErrorCode *int32 `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of the last update.
	LastHealthCheckDateTime *time.Time `json:"lastHealthCheckDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Failure message: hints on what is wrong and how to recover.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SessionHostHealthCheckFailureDetails.
func (s SessionHostHealthCheckFailureDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorCode", s.ErrorCode)
	populateTimeRFC3339(objectMap, "lastHealthCheckDateTime", s.LastHealthCheckDateTime)
	populate(objectMap, "message", s.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SessionHostHealthCheckFailureDetails.
func (s *SessionHostHealthCheckFailureDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, &s.ErrorCode)
			delete(rawMsg, key)
		case "lastHealthCheckDateTime":
			err = unpopulateTimeRFC3339(val, &s.LastHealthCheckDateTime)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &s.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SessionHostHealthCheckReport - The report for session host information.
type SessionHostHealthCheckReport struct {
	// READ-ONLY; Additional detailed information on the failure.
	AdditionalFailureDetails *SessionHostHealthCheckFailureDetails `json:"additionalFailureDetails,omitempty" azure:"ro"`

	// READ-ONLY; Represents the name of the health check operation performed.
	HealthCheckName *HealthCheckName `json:"healthCheckName,omitempty" azure:"ro"`

	// READ-ONLY; Represents the Health state of the health check we performed.
	HealthCheckResult *HealthCheckResult `json:"healthCheckResult,omitempty" azure:"ro"`
}

// SessionHostList - List of SessionHost definitions.
type SessionHostList struct {
	// List of SessionHost definitions.
	Value []*SessionHost `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SessionHostList.
func (s SessionHostList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SessionHostPatch - SessionHost properties that can be patched.
type SessionHostPatch struct {
	// Detailed properties for SessionHost
	Properties *SessionHostPatchProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SessionHostPatch.
func (s SessionHostPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// SessionHostPatchProperties - SessionHost properties that can be patched.
type SessionHostPatchProperties struct {
	// Allow a new session.
	AllowNewSession *bool `json:"allowNewSession,omitempty"`

	// User assigned to SessionHost.
	AssignedUser *string `json:"assignedUser,omitempty"`
}

// SessionHostProperties - Schema for SessionHost properties.
type SessionHostProperties struct {
	// Version of agent on SessionHost.
	AgentVersion *string `json:"agentVersion,omitempty"`

	// Allow a new session.
	AllowNewSession *bool `json:"allowNewSession,omitempty"`

	// User assigned to SessionHost.
	AssignedUser *string `json:"assignedUser,omitempty"`

	// Last heart beat from SessionHost.
	LastHeartBeat *time.Time `json:"lastHeartBeat,omitempty"`

	// The version of the OS on the session host.
	OSVersion *string `json:"osVersion,omitempty"`

	// Number of sessions on SessionHost.
	Sessions *int32 `json:"sessions,omitempty"`

	// Status for a SessionHost.
	Status *Status `json:"status,omitempty"`

	// The version of the side by side stack on the session host.
	SxSStackVersion *string `json:"sxSStackVersion,omitempty"`

	// The error message.
	UpdateErrorMessage *string `json:"updateErrorMessage,omitempty"`

	// Update state of a SessionHost.
	UpdateState *UpdateState `json:"updateState,omitempty"`

	// READ-ONLY; The timestamp of the last update.
	LastUpdateTime *time.Time `json:"lastUpdateTime,omitempty" azure:"ro"`

	// READ-ONLY; ObjectId of SessionHost. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`

	// READ-ONLY; Resource Id of SessionHost's underlying virtual machine.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; List of SessionHostHealthCheckReports
	SessionHostHealthCheckResults []*SessionHostHealthCheckReport `json:"sessionHostHealthCheckResults,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of the status.
	StatusTimestamp *time.Time `json:"statusTimestamp,omitempty" azure:"ro"`

	// READ-ONLY; Virtual Machine Id of SessionHost's underlying virtual machine.
	VirtualMachineID *string `json:"virtualMachineId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SessionHostProperties.
func (s SessionHostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentVersion", s.AgentVersion)
	populate(objectMap, "allowNewSession", s.AllowNewSession)
	populate(objectMap, "assignedUser", s.AssignedUser)
	populateTimeRFC3339(objectMap, "lastHeartBeat", s.LastHeartBeat)
	populateTimeRFC3339(objectMap, "lastUpdateTime", s.LastUpdateTime)
	populate(objectMap, "osVersion", s.OSVersion)
	populate(objectMap, "objectId", s.ObjectID)
	populate(objectMap, "resourceId", s.ResourceID)
	populate(objectMap, "sessionHostHealthCheckResults", s.SessionHostHealthCheckResults)
	populate(objectMap, "sessions", s.Sessions)
	populate(objectMap, "status", s.Status)
	populateTimeRFC3339(objectMap, "statusTimestamp", s.StatusTimestamp)
	populate(objectMap, "sxSStackVersion", s.SxSStackVersion)
	populate(objectMap, "updateErrorMessage", s.UpdateErrorMessage)
	populate(objectMap, "updateState", s.UpdateState)
	populate(objectMap, "virtualMachineId", s.VirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SessionHostProperties.
func (s *SessionHostProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentVersion":
			err = unpopulate(val, &s.AgentVersion)
			delete(rawMsg, key)
		case "allowNewSession":
			err = unpopulate(val, &s.AllowNewSession)
			delete(rawMsg, key)
		case "assignedUser":
			err = unpopulate(val, &s.AssignedUser)
			delete(rawMsg, key)
		case "lastHeartBeat":
			err = unpopulateTimeRFC3339(val, &s.LastHeartBeat)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateTimeRFC3339(val, &s.LastUpdateTime)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, &s.OSVersion)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, &s.ObjectID)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &s.ResourceID)
			delete(rawMsg, key)
		case "sessionHostHealthCheckResults":
			err = unpopulate(val, &s.SessionHostHealthCheckResults)
			delete(rawMsg, key)
		case "sessions":
			err = unpopulate(val, &s.Sessions)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "statusTimestamp":
			err = unpopulateTimeRFC3339(val, &s.StatusTimestamp)
			delete(rawMsg, key)
		case "sxSStackVersion":
			err = unpopulate(val, &s.SxSStackVersion)
			delete(rawMsg, key)
		case "updateErrorMessage":
			err = unpopulate(val, &s.UpdateErrorMessage)
			delete(rawMsg, key)
		case "updateState":
			err = unpopulate(val, &s.UpdateState)
			delete(rawMsg, key)
		case "virtualMachineId":
			err = unpopulate(val, &s.VirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SessionHostsClientDeleteOptions contains the optional parameters for the SessionHostsClient.Delete method.
type SessionHostsClientDeleteOptions struct {
	// Force flag to force sessionHost deletion even when userSession exists.
	Force *bool
}

// SessionHostsClientGetOptions contains the optional parameters for the SessionHostsClient.Get method.
type SessionHostsClientGetOptions struct {
	// placeholder for future optional parameters
}

// SessionHostsClientListOptions contains the optional parameters for the SessionHostsClient.List method.
type SessionHostsClientListOptions struct {
	// placeholder for future optional parameters
}

// SessionHostsClientUpdateOptions contains the optional parameters for the SessionHostsClient.Update method.
type SessionHostsClientUpdateOptions struct {
	// Force flag to update assign, unassign or reassign personal desktop.
	Force *bool
	// Object containing SessionHost definitions.
	SessionHost *SessionHostPatch
}

// StartMenuItem - Represents a StartMenuItem definition.
type StartMenuItem struct {
	// Detailed properties for StartMenuItem
	Properties *StartMenuItemProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// StartMenuItemList - List of StartMenuItem definitions.
type StartMenuItemList struct {
	// List of StartMenuItem definitions.
	Value []*StartMenuItem `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StartMenuItemList.
func (s StartMenuItemList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StartMenuItemProperties - Schema for StartMenuItem properties.
type StartMenuItemProperties struct {
	// Alias of StartMenuItem.
	AppAlias *string `json:"appAlias,omitempty"`

	// Command line arguments for StartMenuItem.
	CommandLineArguments *string `json:"commandLineArguments,omitempty"`

	// Path to the file of StartMenuItem.
	FilePath *string `json:"filePath,omitempty"`

	// Index of the icon.
	IconIndex *int32 `json:"iconIndex,omitempty"`

	// Path to the icon.
	IconPath *string `json:"iconPath,omitempty"`
}

// StartMenuItemsClientListOptions contains the optional parameters for the StartMenuItemsClient.List method.
type StartMenuItemsClientListOptions struct {
	// placeholder for future optional parameters
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Time - The time for a scaling action to occur.
type Time struct {
	// REQUIRED; The hour.
	Hour *int32 `json:"hour,omitempty"`

	// REQUIRED; The minute.
	Minute *int32 `json:"minute,omitempty"`
}

// UserSession - Represents a UserSession definition.
type UserSession struct {
	// Detailed properties for UserSession
	Properties *UserSessionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// UserSessionList - List of UserSession definitions.
type UserSessionList struct {
	// List of UserSession definitions.
	Value []*UserSession `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UserSessionList.
func (u UserSessionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UserSessionProperties - Schema for UserSession properties.
type UserSessionProperties struct {
	// The active directory user name.
	ActiveDirectoryUserName *string `json:"activeDirectoryUserName,omitempty"`

	// Application type of application.
	ApplicationType *ApplicationType `json:"applicationType,omitempty"`

	// The timestamp of the user session create.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// State of user session.
	SessionState *SessionState `json:"sessionState,omitempty"`

	// The user principal name.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`

	// READ-ONLY; ObjectId of user session. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UserSessionProperties.
func (u UserSessionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeDirectoryUserName", u.ActiveDirectoryUserName)
	populate(objectMap, "applicationType", u.ApplicationType)
	populateTimeRFC3339(objectMap, "createTime", u.CreateTime)
	populate(objectMap, "objectId", u.ObjectID)
	populate(objectMap, "sessionState", u.SessionState)
	populate(objectMap, "userPrincipalName", u.UserPrincipalName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserSessionProperties.
func (u *UserSessionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeDirectoryUserName":
			err = unpopulate(val, &u.ActiveDirectoryUserName)
			delete(rawMsg, key)
		case "applicationType":
			err = unpopulate(val, &u.ApplicationType)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateTimeRFC3339(val, &u.CreateTime)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, &u.ObjectID)
			delete(rawMsg, key)
		case "sessionState":
			err = unpopulate(val, &u.SessionState)
			delete(rawMsg, key)
		case "userPrincipalName":
			err = unpopulate(val, &u.UserPrincipalName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UserSessionsClientDeleteOptions contains the optional parameters for the UserSessionsClient.Delete method.
type UserSessionsClientDeleteOptions struct {
	// Force flag to login off userSession.
	Force *bool
}

// UserSessionsClientDisconnectOptions contains the optional parameters for the UserSessionsClient.Disconnect method.
type UserSessionsClientDisconnectOptions struct {
	// placeholder for future optional parameters
}

// UserSessionsClientGetOptions contains the optional parameters for the UserSessionsClient.Get method.
type UserSessionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// UserSessionsClientListByHostPoolOptions contains the optional parameters for the UserSessionsClient.ListByHostPool method.
type UserSessionsClientListByHostPoolOptions struct {
	// OData filter expression. Valid properties for filtering are userprincipalname and sessionstate.
	Filter *string
}

// UserSessionsClientListOptions contains the optional parameters for the UserSessionsClient.List method.
type UserSessionsClientListOptions struct {
	// placeholder for future optional parameters
}

// UserSessionsClientSendMessageOptions contains the optional parameters for the UserSessionsClient.SendMessage method.
type UserSessionsClientSendMessageOptions struct {
	// Object containing message includes title and message body
	SendMessage *SendMessage
}

// Workspace - Represents a Workspace definition.
type Workspace struct {
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`

	// Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are
	// a kind of Microsoft.Web/sites type. If supported, the resource provider must
	// validate and persist this value.
	Kind *string `json:"kind,omitempty"`

	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another
	// Azure resource. If this is present, complete mode deployment will not
	// delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string                                  `json:"managedBy,omitempty"`
	Plan      *ResourceModelWithAllowedPropertySetPlan `json:"plan,omitempty"`

	// Detailed properties for Workspace
	Properties *WorkspaceProperties                    `json:"properties,omitempty"`
	SKU        *ResourceModelWithAllowedPropertySetSKU `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The etag field is not required. If it is provided in the response body, it must also be provided as a header
	// per the normal etag convention. Entity tags are used for comparing two or more entities
	// from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match
	// (section 14.26), and If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", w.Etag)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "kind", w.Kind)
	populate(objectMap, "location", w.Location)
	populate(objectMap, "managedBy", w.ManagedBy)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "plan", w.Plan)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "sku", w.SKU)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "tags", w.Tags)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// WorkspaceList - List of Workspace definitions.
type WorkspaceList struct {
	// List of Workspace definitions.
	Value []*Workspace `json:"value,omitempty"`

	// READ-ONLY; Link to the next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceList.
func (w WorkspaceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WorkspacePatch - Workspace properties that can be patched.
type WorkspacePatch struct {
	// Detailed properties for Workspace
	Properties *WorkspacePatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspacePatch.
func (w WorkspacePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// WorkspacePatchProperties - Workspace properties that can be patched.
type WorkspacePatchProperties struct {
	// List of applicationGroup links.
	ApplicationGroupReferences []*string `json:"applicationGroupReferences,omitempty"`

	// Description of Workspace.
	Description *string `json:"description,omitempty"`

	// Friendly name of Workspace.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// Enabled to allow this resource to be access from the public network
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspacePatchProperties.
func (w WorkspacePatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationGroupReferences", w.ApplicationGroupReferences)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "friendlyName", w.FriendlyName)
	populate(objectMap, "publicNetworkAccess", w.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// WorkspaceProperties - Schema for Workspace properties.
type WorkspaceProperties struct {
	// List of applicationGroup resource Ids.
	ApplicationGroupReferences []*string `json:"applicationGroupReferences,omitempty"`

	// Description of Workspace.
	Description *string `json:"description,omitempty"`

	// Friendly name of Workspace.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only
	// be accessed via private endpoints
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// READ-ONLY; Is cloud pc resource.
	CloudPcResource *bool `json:"cloudPcResource,omitempty" azure:"ro"`

	// READ-ONLY; ObjectId of Workspace. (internal use)
	ObjectID *string `json:"objectId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceProperties.
func (w WorkspaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationGroupReferences", w.ApplicationGroupReferences)
	populate(objectMap, "cloudPcResource", w.CloudPcResource)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "friendlyName", w.FriendlyName)
	populate(objectMap, "objectId", w.ObjectID)
	populate(objectMap, "publicNetworkAccess", w.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// WorkspacesClientCreateOrUpdateOptions contains the optional parameters for the WorkspacesClient.CreateOrUpdate method.
type WorkspacesClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesClientDeleteOptions contains the optional parameters for the WorkspacesClient.Delete method.
type WorkspacesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesClientGetOptions contains the optional parameters for the WorkspacesClient.Get method.
type WorkspacesClientGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesClientListByResourceGroupOptions contains the optional parameters for the WorkspacesClient.ListByResourceGroup
// method.
type WorkspacesClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesClientListBySubscriptionOptions contains the optional parameters for the WorkspacesClient.ListBySubscription
// method.
type WorkspacesClientListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesClientUpdateOptions contains the optional parameters for the WorkspacesClient.Update method.
type WorkspacesClientUpdateOptions struct {
	// Object containing Workspace definitions.
	Workspace *WorkspacePatch
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
