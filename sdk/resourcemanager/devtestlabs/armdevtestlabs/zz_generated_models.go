//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdevtestlabs

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// ApplicableSchedule - Schedules applicable to a virtual machine. The schedules may have been defined on a VM or on lab level.
type ApplicableSchedule struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *ApplicableScheduleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicableSchedule.
func (a ApplicableSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ApplicableScheduleFragment - Schedules applicable to a virtual machine. The schedules may have been defined on a VM or on lab level.
type ApplicableScheduleFragment struct {
	UpdateResource
}

// ApplicableScheduleProperties - Properties of a schedules applicable to a virtual machine.
type ApplicableScheduleProperties struct {
	// The auto-shutdown schedule, if one has been set at the lab or lab resource level.
	LabVMsShutdown *Schedule `json:"labVmsShutdown,omitempty"`

	// The auto-startup schedule, if one has been set at the lab or lab resource level.
	LabVMsStartup *Schedule `json:"labVmsStartup,omitempty"`
}

// ApplyArtifactsRequest - Request body for applying artifacts to a virtual machine.
type ApplyArtifactsRequest struct {
	// The list of artifacts to apply.
	Artifacts []*ArtifactInstallProperties `json:"artifacts,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplyArtifactsRequest.
func (a ApplyArtifactsRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "artifacts", a.Artifacts)
	return json.Marshal(objectMap)
}

// ArmTemplate - An Azure Resource Manager template.
type ArmTemplate struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *ArmTemplateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmTemplate.
func (a ArmTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ArmTemplateInfo - Information about a generated ARM template.
type ArmTemplateInfo struct {
	// The parameters of the ARM template.
	Parameters map[string]interface{} `json:"parameters,omitempty"`

	// The template's contents.
	Template map[string]interface{} `json:"template,omitempty"`
}

// ArmTemplateList - The response of a list operation.
type ArmTemplateList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*ArmTemplate `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmTemplateList.
func (a ArmTemplateList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ArmTemplateParameterProperties - Properties of an Azure Resource Manager template parameter.
type ArmTemplateParameterProperties struct {
	// The name of the template parameter.
	Name *string `json:"name,omitempty"`

	// The value of the template parameter.
	Value *string `json:"value,omitempty"`
}

// ArmTemplateProperties - Properties of an Azure Resource Manager template.
type ArmTemplateProperties struct {
	// READ-ONLY; The contents of the ARM template.
	Contents map[string]interface{} `json:"contents,omitempty" azure:"ro"`

	// READ-ONLY; The creation date of the armTemplate.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The description of the ARM template.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The display name of the ARM template.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; Whether or not ARM template is enabled for use by lab user.
	Enabled *bool `json:"enabled,omitempty" azure:"ro"`

	// READ-ONLY; The URI to the icon of the ARM template.
	Icon *string `json:"icon,omitempty" azure:"ro"`

	// READ-ONLY; File name and parameter values information from all azuredeploy.*.parameters.json for the ARM template.
	ParametersValueFilesInfo []*ParametersValueFileInfo `json:"parametersValueFilesInfo,omitempty" azure:"ro"`

	// READ-ONLY; The publisher of the ARM template.
	Publisher *string `json:"publisher,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmTemplateProperties.
func (a ArmTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contents", a.Contents)
	populateTimeRFC3339(objectMap, "createdDate", a.CreatedDate)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "enabled", a.Enabled)
	populate(objectMap, "icon", a.Icon)
	populate(objectMap, "parametersValueFilesInfo", a.ParametersValueFilesInfo)
	populate(objectMap, "publisher", a.Publisher)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArmTemplateProperties.
func (a *ArmTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contents":
			err = unpopulate(val, &a.Contents)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &a.CreatedDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &a.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &a.Enabled)
			delete(rawMsg, key)
		case "icon":
			err = unpopulate(val, &a.Icon)
			delete(rawMsg, key)
		case "parametersValueFilesInfo":
			err = unpopulate(val, &a.ParametersValueFilesInfo)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, &a.Publisher)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ArmTemplatesGetOptions contains the optional parameters for the ArmTemplates.Get method.
type ArmTemplatesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=displayName)'
	Expand *string
}

// ArmTemplatesListOptions contains the optional parameters for the ArmTemplates.List method.
type ArmTemplatesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=displayName)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// Artifact - An artifact.
type Artifact struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *ArtifactProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Artifact.
func (a Artifact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ArtifactDeploymentStatusProperties - Properties of an artifact deployment.
type ArtifactDeploymentStatusProperties struct {
	// The total count of the artifacts that were successfully applied.
	ArtifactsApplied *int32 `json:"artifactsApplied,omitempty"`

	// The deployment status of the artifact.
	DeploymentStatus *string `json:"deploymentStatus,omitempty"`

	// The total count of the artifacts that were tentatively applied.
	TotalArtifacts *int32 `json:"totalArtifacts,omitempty"`
}

// ArtifactInstallProperties - Properties of an artifact.
type ArtifactInstallProperties struct {
	// The artifact's identifier.
	ArtifactID *string `json:"artifactId,omitempty"`

	// The artifact's title.
	ArtifactTitle *string `json:"artifactTitle,omitempty"`

	// The status message from the deployment.
	DeploymentStatusMessage *string `json:"deploymentStatusMessage,omitempty"`

	// The time that the artifact starts to install on the virtual machine.
	InstallTime *time.Time `json:"installTime,omitempty"`

	// The parameters of the artifact.
	Parameters []*ArtifactParameterProperties `json:"parameters,omitempty"`

	// The status of the artifact.
	Status *string `json:"status,omitempty"`

	// The status message from the virtual machine extension.
	VMExtensionStatusMessage *string `json:"vmExtensionStatusMessage,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactInstallProperties.
func (a ArtifactInstallProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "artifactId", a.ArtifactID)
	populate(objectMap, "artifactTitle", a.ArtifactTitle)
	populate(objectMap, "deploymentStatusMessage", a.DeploymentStatusMessage)
	populateTimeRFC3339(objectMap, "installTime", a.InstallTime)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "vmExtensionStatusMessage", a.VMExtensionStatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArtifactInstallProperties.
func (a *ArtifactInstallProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "artifactId":
			err = unpopulate(val, &a.ArtifactID)
			delete(rawMsg, key)
		case "artifactTitle":
			err = unpopulate(val, &a.ArtifactTitle)
			delete(rawMsg, key)
		case "deploymentStatusMessage":
			err = unpopulate(val, &a.DeploymentStatusMessage)
			delete(rawMsg, key)
		case "installTime":
			err = unpopulateTimeRFC3339(val, &a.InstallTime)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		case "vmExtensionStatusMessage":
			err = unpopulate(val, &a.VMExtensionStatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ArtifactList - The response of a list operation.
type ArtifactList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Artifact `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactList.
func (a ArtifactList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ArtifactParameterProperties - Properties of an artifact parameter.
type ArtifactParameterProperties struct {
	// The name of the artifact parameter.
	Name *string `json:"name,omitempty"`

	// The value of the artifact parameter.
	Value *string `json:"value,omitempty"`
}

// ArtifactProperties - Properties of an artifact.
type ArtifactProperties struct {
	// READ-ONLY; The artifact's creation date.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The artifact's description.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The file path to the artifact.
	FilePath *string `json:"filePath,omitempty" azure:"ro"`

	// READ-ONLY; The URI to the artifact icon.
	Icon *string `json:"icon,omitempty" azure:"ro"`

	// READ-ONLY; The artifact's parameters.
	Parameters map[string]interface{} `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; The artifact's publisher.
	Publisher *string `json:"publisher,omitempty" azure:"ro"`

	// READ-ONLY; The artifact's target OS.
	TargetOsType *string `json:"targetOsType,omitempty" azure:"ro"`

	// READ-ONLY; The artifact's title.
	Title *string `json:"title,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactProperties.
func (a ArtifactProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", a.CreatedDate)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "filePath", a.FilePath)
	populate(objectMap, "icon", a.Icon)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "publisher", a.Publisher)
	populate(objectMap, "targetOsType", a.TargetOsType)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArtifactProperties.
func (a *ArtifactProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &a.CreatedDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "filePath":
			err = unpopulate(val, &a.FilePath)
			delete(rawMsg, key)
		case "icon":
			err = unpopulate(val, &a.Icon)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &a.Parameters)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, &a.Publisher)
			delete(rawMsg, key)
		case "targetOsType":
			err = unpopulate(val, &a.TargetOsType)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &a.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ArtifactSource - Properties of an artifact source.
type ArtifactSource struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *ArtifactSourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactSource.
func (a ArtifactSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ArtifactSourceFragment - Properties of an artifact source.
type ArtifactSourceFragment struct {
	UpdateResource
}

// ArtifactSourceList - The response of a list operation.
type ArtifactSourceList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*ArtifactSource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactSourceList.
func (a ArtifactSourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ArtifactSourceProperties - Properties of an artifact source.
type ArtifactSourceProperties struct {
	// The folder containing Azure Resource Manager templates.
	ArmTemplateFolderPath *string `json:"armTemplateFolderPath,omitempty"`

	// The artifact source's branch reference.
	BranchRef *string `json:"branchRef,omitempty"`

	// The artifact source's display name.
	DisplayName *string `json:"displayName,omitempty"`

	// The folder containing artifacts.
	FolderPath *string `json:"folderPath,omitempty"`

	// The security token to authenticate to the artifact source.
	SecurityToken *string `json:"securityToken,omitempty"`

	// The artifact source's type.
	SourceType *SourceControlType `json:"sourceType,omitempty"`

	// Indicates if the artifact source is enabled (values: Enabled, Disabled).
	Status *EnableStatus `json:"status,omitempty"`

	// The artifact source's URI.
	URI *string `json:"uri,omitempty"`

	// READ-ONLY; The artifact source's creation date.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactSourceProperties.
func (a ArtifactSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "armTemplateFolderPath", a.ArmTemplateFolderPath)
	populate(objectMap, "branchRef", a.BranchRef)
	populateTimeRFC3339(objectMap, "createdDate", a.CreatedDate)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "folderPath", a.FolderPath)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "securityToken", a.SecurityToken)
	populate(objectMap, "sourceType", a.SourceType)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "uri", a.URI)
	populate(objectMap, "uniqueIdentifier", a.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArtifactSourceProperties.
func (a *ArtifactSourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "armTemplateFolderPath":
			err = unpopulate(val, &a.ArmTemplateFolderPath)
			delete(rawMsg, key)
		case "branchRef":
			err = unpopulate(val, &a.BranchRef)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &a.CreatedDate)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &a.DisplayName)
			delete(rawMsg, key)
		case "folderPath":
			err = unpopulate(val, &a.FolderPath)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		case "securityToken":
			err = unpopulate(val, &a.SecurityToken)
			delete(rawMsg, key)
		case "sourceType":
			err = unpopulate(val, &a.SourceType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, &a.URI)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &a.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ArtifactSourcesCreateOrUpdateOptions contains the optional parameters for the ArtifactSources.CreateOrUpdate method.
type ArtifactSourcesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ArtifactSourcesDeleteOptions contains the optional parameters for the ArtifactSources.Delete method.
type ArtifactSourcesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ArtifactSourcesGetOptions contains the optional parameters for the ArtifactSources.Get method.
type ArtifactSourcesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=displayName)'
	Expand *string
}

// ArtifactSourcesListOptions contains the optional parameters for the ArtifactSources.List method.
type ArtifactSourcesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=displayName)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// ArtifactSourcesUpdateOptions contains the optional parameters for the ArtifactSources.Update method.
type ArtifactSourcesUpdateOptions struct {
	// placeholder for future optional parameters
}

// ArtifactsGenerateArmTemplateOptions contains the optional parameters for the Artifacts.GenerateArmTemplate method.
type ArtifactsGenerateArmTemplateOptions struct {
	// placeholder for future optional parameters
}

// ArtifactsGetOptions contains the optional parameters for the Artifacts.Get method.
type ArtifactsGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=title)'
	Expand *string
}

// ArtifactsListOptions contains the optional parameters for the Artifacts.List method.
type ArtifactsListOptions struct {
	// Specify the $expand query. Example: 'properties($select=title)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// AttachDiskProperties - Properties of the disk to attach.
type AttachDiskProperties struct {
	// The resource ID of the Lab virtual machine to which the disk is attached.
	LeasedByLabVMID *string `json:"leasedByLabVmId,omitempty"`
}

// AttachNewDataDiskOptions - Properties to attach new disk to the Virtual Machine.
type AttachNewDataDiskOptions struct {
	// The name of the disk to be attached.
	DiskName *string `json:"diskName,omitempty"`

	// Size of the disk to be attached in Gibibytes.
	DiskSizeGiB *int32 `json:"diskSizeGiB,omitempty"`

	// The storage type for the disk (i.e. Standard, Premium).
	DiskType *StorageType `json:"diskType,omitempty"`
}

// BulkCreationParameters - Parameters for creating multiple virtual machines as a single action.
type BulkCreationParameters struct {
	// The number of virtual machine instances to create.
	InstanceCount *int32 `json:"instanceCount,omitempty"`
}

// CloudError - Error from a REST request.
// Implements the error and azcore.HTTPResponse interfaces.
type CloudError struct {
	raw string
	// The cloud error that occurred
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
// The contents of the error text are not contractual and subject to change.
func (e CloudError) Error() string {
	return e.raw
}

// CloudErrorBody - Body of an error from a REST request.
type CloudErrorBody struct {
	// The error code.
	Code *string `json:"code,omitempty"`

	// Inner errors.
	Details []*CloudErrorBody `json:"details,omitempty"`

	// The error message.
	Message *string `json:"message,omitempty"`

	// The error target.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudErrorBody.
func (c CloudErrorBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", c.Code)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// ComputeDataDisk - A data disks attached to a virtual machine.
type ComputeDataDisk struct {
	// Gets data disk size in GiB.
	DiskSizeGiB *int32 `json:"diskSizeGiB,omitempty"`

	// When backed by a blob, the URI of underlying blob.
	DiskURI *string `json:"diskUri,omitempty"`

	// When backed by managed disk, this is the ID of the compute disk resource.
	ManagedDiskID *string `json:"managedDiskId,omitempty"`

	// Gets data disk name.
	Name *string `json:"name,omitempty"`
}

// ComputeVMInstanceViewStatus - Status information about a virtual machine.
type ComputeVMInstanceViewStatus struct {
	// Gets the status Code.
	Code *string `json:"code,omitempty"`

	// Gets the short localizable label for the status.
	DisplayStatus *string `json:"displayStatus,omitempty"`

	// Gets the message associated with the status.
	Message *string `json:"message,omitempty"`
}

// ComputeVMProperties - Properties of a virtual machine returned by the Microsoft.Compute API.
type ComputeVMProperties struct {
	// Gets data disks blob uri for the virtual machine.
	DataDiskIDs []*string `json:"dataDiskIds,omitempty"`

	// Gets all data disks attached to the virtual machine.
	DataDisks []*ComputeDataDisk `json:"dataDisks,omitempty"`

	// Gets the network interface ID of the virtual machine.
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty"`

	// Gets OS disk blob uri for the virtual machine.
	OSDiskID *string `json:"osDiskId,omitempty"`

	// Gets the OS type of the virtual machine.
	OSType *string `json:"osType,omitempty"`

	// Gets the statuses of the virtual machine.
	Statuses []*ComputeVMInstanceViewStatus `json:"statuses,omitempty"`

	// Gets the size of the virtual machine.
	VMSize *string `json:"vmSize,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ComputeVMProperties.
func (c ComputeVMProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataDiskIds", c.DataDiskIDs)
	populate(objectMap, "dataDisks", c.DataDisks)
	populate(objectMap, "networkInterfaceId", c.NetworkInterfaceID)
	populate(objectMap, "osDiskId", c.OSDiskID)
	populate(objectMap, "osType", c.OSType)
	populate(objectMap, "statuses", c.Statuses)
	populate(objectMap, "vmSize", c.VMSize)
	return json.Marshal(objectMap)
}

// CostThresholdProperties - Properties of a cost threshold item.
type CostThresholdProperties struct {
	// Indicates whether this threshold will be displayed on cost charts.
	DisplayOnChart *CostThresholdStatus `json:"displayOnChart,omitempty"`

	// Indicates the datetime when notifications were last sent for this threshold.
	NotificationSent *string `json:"notificationSent,omitempty"`

	// The value of the percentage cost threshold.
	PercentageThreshold *PercentageCostThresholdProperties `json:"percentageThreshold,omitempty"`

	// Indicates whether notifications will be sent when this threshold is exceeded.
	SendNotificationWhenExceeded *CostThresholdStatus `json:"sendNotificationWhenExceeded,omitempty"`

	// The ID of the cost threshold item.
	ThresholdID *string `json:"thresholdId,omitempty"`
}

// CostsCreateOrUpdateOptions contains the optional parameters for the Costs.CreateOrUpdate method.
type CostsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// CostsGetOptions contains the optional parameters for the Costs.Get method.
type CostsGetOptions struct {
	// Specify the $expand query. Example: 'properties($expand=labCostDetails)'
	Expand *string
}

// CustomImage - A custom image.
type CustomImage struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *CustomImageProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomImage.
func (c CustomImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// CustomImageFragment - A custom image.
type CustomImageFragment struct {
	UpdateResource
}

// CustomImageList - The response of a list operation.
type CustomImageList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*CustomImage `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomImageList.
func (c CustomImageList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CustomImageProperties - Properties of a custom image.
type CustomImageProperties struct {
	// The author of the custom image.
	Author *string `json:"author,omitempty"`

	// Storage information about the plan related to this custom image
	CustomImagePlan *CustomImagePropertiesFromPlan `json:"customImagePlan,omitempty"`

	// Storage information about the data disks present in the custom image
	DataDiskStorageInfo []*DataDiskStorageTypeInfo `json:"dataDiskStorageInfo,omitempty"`

	// The description of the custom image.
	Description *string `json:"description,omitempty"`

	// Whether or not the custom images underlying offer/plan has been enabled for programmatic deployment
	IsPlanAuthorized *bool `json:"isPlanAuthorized,omitempty"`

	// The Managed Image Id backing the custom image.
	ManagedImageID *string `json:"managedImageId,omitempty"`

	// The Managed Snapshot Id backing the custom image.
	ManagedSnapshotID *string `json:"managedSnapshotId,omitempty"`

	// The virtual machine from which the image is to be created.
	VM *CustomImagePropertiesFromVM `json:"vm,omitempty"`

	// The VHD from which the image is to be created.
	Vhd *CustomImagePropertiesCustom `json:"vhd,omitempty"`

	// READ-ONLY; The creation date of the custom image.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomImageProperties.
func (c CustomImageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", c.Author)
	populateTimeRFC3339(objectMap, "creationDate", c.CreationDate)
	populate(objectMap, "customImagePlan", c.CustomImagePlan)
	populate(objectMap, "dataDiskStorageInfo", c.DataDiskStorageInfo)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "isPlanAuthorized", c.IsPlanAuthorized)
	populate(objectMap, "managedImageId", c.ManagedImageID)
	populate(objectMap, "managedSnapshotId", c.ManagedSnapshotID)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "uniqueIdentifier", c.UniqueIdentifier)
	populate(objectMap, "vm", c.VM)
	populate(objectMap, "vhd", c.Vhd)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomImageProperties.
func (c *CustomImageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
			err = unpopulate(val, &c.Author)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &c.CreationDate)
			delete(rawMsg, key)
		case "customImagePlan":
			err = unpopulate(val, &c.CustomImagePlan)
			delete(rawMsg, key)
		case "dataDiskStorageInfo":
			err = unpopulate(val, &c.DataDiskStorageInfo)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "isPlanAuthorized":
			err = unpopulate(val, &c.IsPlanAuthorized)
			delete(rawMsg, key)
		case "managedImageId":
			err = unpopulate(val, &c.ManagedImageID)
			delete(rawMsg, key)
		case "managedSnapshotId":
			err = unpopulate(val, &c.ManagedSnapshotID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &c.UniqueIdentifier)
			delete(rawMsg, key)
		case "vm":
			err = unpopulate(val, &c.VM)
			delete(rawMsg, key)
		case "vhd":
			err = unpopulate(val, &c.Vhd)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomImagePropertiesCustom - Properties for creating a custom image from a VHD.
type CustomImagePropertiesCustom struct {
	// REQUIRED; The OS type of the custom image (i.e. Windows, Linux)
	OSType *CustomImageOsType `json:"osType,omitempty"`

	// The image name.
	ImageName *string `json:"imageName,omitempty"`

	// Indicates whether sysprep has been run on the VHD.
	SysPrep *bool `json:"sysPrep,omitempty"`
}

// CustomImagePropertiesFromPlan - Properties for plan on a custom image.
type CustomImagePropertiesFromPlan struct {
	// The id of the plan, equivalent to name of the plan
	ID *string `json:"id,omitempty"`

	// The offer for the plan from the marketplace image the custom image is derived from
	Offer *string `json:"offer,omitempty"`

	// The publisher for the plan from the marketplace image the custom image is derived from
	Publisher *string `json:"publisher,omitempty"`
}

// CustomImagePropertiesFromVM - Properties for creating a custom image from a virtual machine.
type CustomImagePropertiesFromVM struct {
	// The Linux OS information of the VM.
	LinuxOsInfo *LinuxOsInfo `json:"linuxOsInfo,omitempty"`

	// The source vm identifier.
	SourceVMID *string `json:"sourceVmId,omitempty"`

	// The Windows OS information of the VM.
	WindowsOsInfo *WindowsOsInfo `json:"windowsOsInfo,omitempty"`
}

// CustomImagesBeginCreateOrUpdateOptions contains the optional parameters for the CustomImages.BeginCreateOrUpdate method.
type CustomImagesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// CustomImagesBeginDeleteOptions contains the optional parameters for the CustomImages.BeginDelete method.
type CustomImagesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// CustomImagesGetOptions contains the optional parameters for the CustomImages.Get method.
type CustomImagesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=vm)'
	Expand *string
}

// CustomImagesListOptions contains the optional parameters for the CustomImages.List method.
type CustomImagesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=vm)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// CustomImagesUpdateOptions contains the optional parameters for the CustomImages.Update method.
type CustomImagesUpdateOptions struct {
	// placeholder for future optional parameters
}

// DataDiskProperties - Request body for adding a new or existing data disk to a virtual machine.
type DataDiskProperties struct {
	// Specifies options to attach a new disk to the virtual machine.
	AttachNewDataDiskOptions *AttachNewDataDiskOptions `json:"attachNewDataDiskOptions,omitempty"`

	// Specifies the existing lab disk id to attach to virtual machine.
	ExistingLabDiskID *string `json:"existingLabDiskId,omitempty"`

	// Caching option for a data disk (i.e. None, ReadOnly, ReadWrite).
	HostCaching *HostCachingOptions `json:"hostCaching,omitempty"`
}

// DataDiskStorageTypeInfo - Storage information about the data disks present in the custom image
type DataDiskStorageTypeInfo struct {
	// Disk Lun
	Lun *string `json:"lun,omitempty"`

	// Disk Storage Type
	StorageType *StorageType `json:"storageType,omitempty"`
}

// DayDetails - Properties of a daily schedule.
type DayDetails struct {
	// The time of day the schedule will occur.
	Time *string `json:"time,omitempty"`
}

// DetachDataDiskProperties - Request body for detaching data disk from a virtual machine.
type DetachDataDiskProperties struct {
	// Specifies the disk resource ID to detach from virtual machine.
	ExistingLabDiskID *string `json:"existingLabDiskId,omitempty"`
}

// DetachDiskProperties - Properties of the disk to detach.
type DetachDiskProperties struct {
	// The resource ID of the Lab VM to which the disk is attached.
	LeasedByLabVMID *string `json:"leasedByLabVmId,omitempty"`
}

// Disk - A Disk.
type Disk struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *DiskProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Disk.
func (d Disk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// DiskFragment - A Disk.
type DiskFragment struct {
	UpdateResource
}

// DiskList - The response of a list operation.
type DiskList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Disk `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskList.
func (d DiskList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DiskProperties - Properties of a disk.
type DiskProperties struct {
	// When backed by a blob, the name of the VHD blob without extension.
	DiskBlobName *string `json:"diskBlobName,omitempty"`

	// The size of the disk in Gibibytes.
	DiskSizeGiB *int32 `json:"diskSizeGiB,omitempty"`

	// The storage type for the disk (i.e. Standard, Premium).
	DiskType *StorageType `json:"diskType,omitempty"`

	// When backed by a blob, the URI of underlying blob.
	DiskURI *string `json:"diskUri,omitempty"`

	// The host caching policy of the disk (i.e. None, ReadOnly, ReadWrite).
	HostCaching *string `json:"hostCaching,omitempty"`

	// The resource ID of the VM to which this disk is leased.
	LeasedByLabVMID *string `json:"leasedByLabVmId,omitempty"`

	// When backed by managed disk, this is the ID of the compute disk resource.
	ManagedDiskID *string `json:"managedDiskId,omitempty"`

	// When backed by a blob, the storage account where the blob is.
	StorageAccountID *string `json:"storageAccountId,omitempty"`

	// READ-ONLY; The creation date of the disk.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskProperties.
func (d DiskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", d.CreatedDate)
	populate(objectMap, "diskBlobName", d.DiskBlobName)
	populate(objectMap, "diskSizeGiB", d.DiskSizeGiB)
	populate(objectMap, "diskType", d.DiskType)
	populate(objectMap, "diskUri", d.DiskURI)
	populate(objectMap, "hostCaching", d.HostCaching)
	populate(objectMap, "leasedByLabVmId", d.LeasedByLabVMID)
	populate(objectMap, "managedDiskId", d.ManagedDiskID)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "storageAccountId", d.StorageAccountID)
	populate(objectMap, "uniqueIdentifier", d.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskProperties.
func (d *DiskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &d.CreatedDate)
			delete(rawMsg, key)
		case "diskBlobName":
			err = unpopulate(val, &d.DiskBlobName)
			delete(rawMsg, key)
		case "diskSizeGiB":
			err = unpopulate(val, &d.DiskSizeGiB)
			delete(rawMsg, key)
		case "diskType":
			err = unpopulate(val, &d.DiskType)
			delete(rawMsg, key)
		case "diskUri":
			err = unpopulate(val, &d.DiskURI)
			delete(rawMsg, key)
		case "hostCaching":
			err = unpopulate(val, &d.HostCaching)
			delete(rawMsg, key)
		case "leasedByLabVmId":
			err = unpopulate(val, &d.LeasedByLabVMID)
			delete(rawMsg, key)
		case "managedDiskId":
			err = unpopulate(val, &d.ManagedDiskID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "storageAccountId":
			err = unpopulate(val, &d.StorageAccountID)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &d.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DisksBeginAttachOptions contains the optional parameters for the Disks.BeginAttach method.
type DisksBeginAttachOptions struct {
	// placeholder for future optional parameters
}

// DisksBeginCreateOrUpdateOptions contains the optional parameters for the Disks.BeginCreateOrUpdate method.
type DisksBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DisksBeginDeleteOptions contains the optional parameters for the Disks.BeginDelete method.
type DisksBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DisksBeginDetachOptions contains the optional parameters for the Disks.BeginDetach method.
type DisksBeginDetachOptions struct {
	// placeholder for future optional parameters
}

// DisksGetOptions contains the optional parameters for the Disks.Get method.
type DisksGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=diskType)'
	Expand *string
}

// DisksListOptions contains the optional parameters for the Disks.List method.
type DisksListOptions struct {
	// Specify the $expand query. Example: 'properties($select=diskType)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// DisksUpdateOptions contains the optional parameters for the Disks.Update method.
type DisksUpdateOptions struct {
	// placeholder for future optional parameters
}

// DtlEnvironment - An environment, which is essentially an ARM template deployment.
type DtlEnvironment struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *EnvironmentProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DtlEnvironment.
func (d DtlEnvironment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// DtlEnvironmentFragment - An environment, which is essentially an ARM template deployment.
type DtlEnvironmentFragment struct {
	UpdateResource
}

// DtlEnvironmentList - The response of a list operation.
type DtlEnvironmentList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*DtlEnvironment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DtlEnvironmentList.
func (d DtlEnvironmentList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// EnvironmentDeploymentProperties - Properties of an environment deployment.
type EnvironmentDeploymentProperties struct {
	// The Azure Resource Manager template's identifier.
	ArmTemplateID *string `json:"armTemplateId,omitempty"`

	// The parameters of the Azure Resource Manager template.
	Parameters []*ArmTemplateParameterProperties `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentDeploymentProperties.
func (e EnvironmentDeploymentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "armTemplateId", e.ArmTemplateID)
	populate(objectMap, "parameters", e.Parameters)
	return json.Marshal(objectMap)
}

// EnvironmentProperties - Properties of an environment.
type EnvironmentProperties struct {
	// The display name of the Azure Resource Manager template that produced the environment.
	ArmTemplateDisplayName *string `json:"armTemplateDisplayName,omitempty"`

	// The deployment properties of the environment.
	DeploymentProperties *EnvironmentDeploymentProperties `json:"deploymentProperties,omitempty"`

	// READ-ONLY; The creator of the environment.
	CreatedByUser *string `json:"createdByUser,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The identifier of the resource group containing the environment's resources.
	ResourceGroupID *string `json:"resourceGroupId,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// EnvironmentsBeginCreateOrUpdateOptions contains the optional parameters for the Environments.BeginCreateOrUpdate method.
type EnvironmentsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// EnvironmentsBeginDeleteOptions contains the optional parameters for the Environments.BeginDelete method.
type EnvironmentsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// EnvironmentsGetOptions contains the optional parameters for the Environments.Get method.
type EnvironmentsGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=deploymentProperties)'
	Expand *string
}

// EnvironmentsListOptions contains the optional parameters for the Environments.List method.
type EnvironmentsListOptions struct {
	// Specify the $expand query. Example: 'properties($select=deploymentProperties)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// EnvironmentsUpdateOptions contains the optional parameters for the Environments.Update method.
type EnvironmentsUpdateOptions struct {
	// placeholder for future optional parameters
}

// EvaluatePoliciesProperties - Properties for evaluating a policy set.
type EvaluatePoliciesProperties struct {
	// The fact data.
	FactData *string `json:"factData,omitempty"`

	// The fact name.
	FactName *string `json:"factName,omitempty"`

	// The user for which policies will be evaluated
	UserObjectID *string `json:"userObjectId,omitempty"`

	// The value offset.
	ValueOffset *string `json:"valueOffset,omitempty"`
}

// EvaluatePoliciesRequest - Request body for evaluating a policy set.
type EvaluatePoliciesRequest struct {
	// Policies to evaluate.
	Policies []*EvaluatePoliciesProperties `json:"policies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatePoliciesRequest.
func (e EvaluatePoliciesRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "policies", e.Policies)
	return json.Marshal(objectMap)
}

// EvaluatePoliciesResponse - Response body for evaluating a policy set.
type EvaluatePoliciesResponse struct {
	// Results of evaluating a policy set.
	Results []*PolicySetResult `json:"results,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatePoliciesResponse.
func (e EvaluatePoliciesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "results", e.Results)
	return json.Marshal(objectMap)
}

// Event - An event to be notified for.
type Event struct {
	// The event type for which this notification is enabled (i.e. AutoShutdown, Cost)
	EventName *NotificationChannelEventType `json:"eventName,omitempty"`
}

// ExportResourceUsageParameters - The parameters of the export operation.
type ExportResourceUsageParameters struct {
	// The blob storage absolute sas uri with write permission to the container which the usage data needs to be uploaded to.
	BlobStorageAbsoluteSasURI *string `json:"blobStorageAbsoluteSasUri,omitempty"`

	// The start time of the usage. If not provided, usage will be reported since the beginning of data collection.
	UsageStartDate *time.Time `json:"usageStartDate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExportResourceUsageParameters.
func (e ExportResourceUsageParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobStorageAbsoluteSasUri", e.BlobStorageAbsoluteSasURI)
	populateTimeRFC3339(objectMap, "usageStartDate", e.UsageStartDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExportResourceUsageParameters.
func (e *ExportResourceUsageParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobStorageAbsoluteSasUri":
			err = unpopulate(val, &e.BlobStorageAbsoluteSasURI)
			delete(rawMsg, key)
		case "usageStartDate":
			err = unpopulateTimeRFC3339(val, &e.UsageStartDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ExternalSubnet - Subnet information as returned by the Microsoft.Network API.
type ExternalSubnet struct {
	// Gets or sets the identifier.
	ID *string `json:"id,omitempty"`

	// Gets or sets the name.
	Name *string `json:"name,omitempty"`
}

// Formula - A formula for creating a VM, specifying an image base and other parameters
type Formula struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *FormulaProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Formula.
func (f Formula) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", f.Properties)
	return json.Marshal(objectMap)
}

// FormulaFragment - A formula for creating a VM, specifying an image base and other parameters
type FormulaFragment struct {
	UpdateResource
}

// FormulaList - The response of a list operation.
type FormulaList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Formula `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FormulaList.
func (f FormulaList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FormulaProperties - Properties of a formula.
type FormulaProperties struct {
	// The description of the formula.
	Description *string `json:"description,omitempty"`

	// The content of the formula.
	FormulaContent *LabVirtualMachineCreationParameter `json:"formulaContent,omitempty"`

	// The OS type of the formula.
	OSType *string `json:"osType,omitempty"`

	// Information about a VM from which a formula is to be created.
	VM *FormulaPropertiesFromVM `json:"vm,omitempty"`

	// READ-ONLY; The author of the formula.
	Author *string `json:"author,omitempty" azure:"ro"`

	// READ-ONLY; The creation date of the formula.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FormulaProperties.
func (f FormulaProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", f.Author)
	populateTimeRFC3339(objectMap, "creationDate", f.CreationDate)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "formulaContent", f.FormulaContent)
	populate(objectMap, "osType", f.OSType)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "uniqueIdentifier", f.UniqueIdentifier)
	populate(objectMap, "vm", f.VM)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FormulaProperties.
func (f *FormulaProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
			err = unpopulate(val, &f.Author)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &f.CreationDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "formulaContent":
			err = unpopulate(val, &f.FormulaContent)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &f.OSType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &f.ProvisioningState)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &f.UniqueIdentifier)
			delete(rawMsg, key)
		case "vm":
			err = unpopulate(val, &f.VM)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FormulaPropertiesFromVM - Information about a VM from which a formula is to be created.
type FormulaPropertiesFromVM struct {
	// The identifier of the VM from which a formula is to be created.
	LabVMID *string `json:"labVmId,omitempty"`
}

// FormulasBeginCreateOrUpdateOptions contains the optional parameters for the Formulas.BeginCreateOrUpdate method.
type FormulasBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// FormulasDeleteOptions contains the optional parameters for the Formulas.Delete method.
type FormulasDeleteOptions struct {
	// placeholder for future optional parameters
}

// FormulasGetOptions contains the optional parameters for the Formulas.Get method.
type FormulasGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=description)'
	Expand *string
}

// FormulasListOptions contains the optional parameters for the Formulas.List method.
type FormulasListOptions struct {
	// Specify the $expand query. Example: 'properties($select=description)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// FormulasUpdateOptions contains the optional parameters for the Formulas.Update method.
type FormulasUpdateOptions struct {
	// placeholder for future optional parameters
}

// GalleryImage - A gallery image.
type GalleryImage struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *GalleryImageProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GalleryImage.
func (g GalleryImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", g.Properties)
	return json.Marshal(objectMap)
}

// GalleryImageList - The response of a list operation.
type GalleryImageList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*GalleryImage `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GalleryImageList.
func (g GalleryImageList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// GalleryImageProperties - Properties of a gallery image.
type GalleryImageProperties struct {
	// The author of the gallery image.
	Author *string `json:"author,omitempty"`

	// The description of the gallery image.
	Description *string `json:"description,omitempty"`

	// Indicates whether this gallery image is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// The icon of the gallery image.
	Icon *string `json:"icon,omitempty"`

	// The image reference of the gallery image.
	ImageReference *GalleryImageReference `json:"imageReference,omitempty"`

	// Indicates if the plan has been authorized for programmatic deployment.
	IsPlanAuthorized *bool `json:"isPlanAuthorized,omitempty"`

	// The third party plan that applies to this image
	PlanID *string `json:"planId,omitempty"`

	// READ-ONLY; The creation date of the gallery image.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GalleryImageProperties.
func (g GalleryImageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", g.Author)
	populateTimeRFC3339(objectMap, "createdDate", g.CreatedDate)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "enabled", g.Enabled)
	populate(objectMap, "icon", g.Icon)
	populate(objectMap, "imageReference", g.ImageReference)
	populate(objectMap, "isPlanAuthorized", g.IsPlanAuthorized)
	populate(objectMap, "planId", g.PlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryImageProperties.
func (g *GalleryImageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
			err = unpopulate(val, &g.Author)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &g.CreatedDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &g.Description)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &g.Enabled)
			delete(rawMsg, key)
		case "icon":
			err = unpopulate(val, &g.Icon)
			delete(rawMsg, key)
		case "imageReference":
			err = unpopulate(val, &g.ImageReference)
			delete(rawMsg, key)
		case "isPlanAuthorized":
			err = unpopulate(val, &g.IsPlanAuthorized)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, &g.PlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GalleryImageReference - The reference information for an Azure Marketplace image.
type GalleryImageReference struct {
	// The OS type of the gallery image.
	OSType *string `json:"osType,omitempty"`

	// The offer of the gallery image.
	Offer *string `json:"offer,omitempty"`

	// The publisher of the gallery image.
	Publisher *string `json:"publisher,omitempty"`

	// The SKU of the gallery image.
	SKU *string `json:"sku,omitempty"`

	// The version of the gallery image.
	Version *string `json:"version,omitempty"`
}

// GalleryImagesListOptions contains the optional parameters for the GalleryImages.List method.
type GalleryImagesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=author)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// GenerateArmTemplateRequest - Parameters for generating an ARM template for deploying artifacts.
type GenerateArmTemplateRequest struct {
	// Options for uploading the files for the artifact. UploadFilesAndGenerateSasTokens is the default value.
	FileUploadOptions *FileUploadOptions `json:"fileUploadOptions,omitempty"`

	// The location of the virtual machine.
	Location *string `json:"location,omitempty"`

	// The parameters of the ARM template.
	Parameters []*ParameterInfo `json:"parameters,omitempty"`

	// The resource name of the virtual machine.
	VirtualMachineName *string `json:"virtualMachineName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GenerateArmTemplateRequest.
func (g GenerateArmTemplateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileUploadOptions", g.FileUploadOptions)
	populate(objectMap, "location", g.Location)
	populate(objectMap, "parameters", g.Parameters)
	populate(objectMap, "virtualMachineName", g.VirtualMachineName)
	return json.Marshal(objectMap)
}

// GenerateUploadURIParameter - Properties for generating an upload URI.
type GenerateUploadURIParameter struct {
	// The blob name of the upload URI.
	BlobName *string `json:"blobName,omitempty"`
}

// GenerateUploadURIResponse - Response body for generating an upload URI.
type GenerateUploadURIResponse struct {
	// The upload URI for the VHD.
	UploadURI *string `json:"uploadUri,omitempty"`
}

// GlobalSchedulesBeginExecuteOptions contains the optional parameters for the GlobalSchedules.BeginExecute method.
type GlobalSchedulesBeginExecuteOptions struct {
	// placeholder for future optional parameters
}

// GlobalSchedulesBeginRetargetOptions contains the optional parameters for the GlobalSchedules.BeginRetarget method.
type GlobalSchedulesBeginRetargetOptions struct {
	// placeholder for future optional parameters
}

// GlobalSchedulesCreateOrUpdateOptions contains the optional parameters for the GlobalSchedules.CreateOrUpdate method.
type GlobalSchedulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// GlobalSchedulesDeleteOptions contains the optional parameters for the GlobalSchedules.Delete method.
type GlobalSchedulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// GlobalSchedulesGetOptions contains the optional parameters for the GlobalSchedules.Get method.
type GlobalSchedulesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
}

// GlobalSchedulesListByResourceGroupOptions contains the optional parameters for the GlobalSchedules.ListByResourceGroup method.
type GlobalSchedulesListByResourceGroupOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// GlobalSchedulesListBySubscriptionOptions contains the optional parameters for the GlobalSchedules.ListBySubscription method.
type GlobalSchedulesListBySubscriptionOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// GlobalSchedulesUpdateOptions contains the optional parameters for the GlobalSchedules.Update method.
type GlobalSchedulesUpdateOptions struct {
	// placeholder for future optional parameters
}

// HourDetails - Properties of an hourly schedule.
type HourDetails struct {
	// Minutes of the hour the schedule will run.
	Minute *int32 `json:"minute,omitempty"`
}

// IdentityProperties - Properties of a managed identity
type IdentityProperties struct {
	// The client secret URL of the identity.
	ClientSecretURL *string `json:"clientSecretUrl,omitempty"`

	// The principal id of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`

	// The tenant identifier of resource.
	TenantID *string `json:"tenantId,omitempty"`

	// Managed identity.
	Type *ManagedIdentityType `json:"type,omitempty"`
}

// ImportLabVirtualMachineRequest - This represents the payload required to import a virtual machine from a different lab into the current one
type ImportLabVirtualMachineRequest struct {
	// The name of the virtual machine in the destination lab
	DestinationVirtualMachineName *string `json:"destinationVirtualMachineName,omitempty"`

	// The full resource ID of the virtual machine to be imported.
	SourceVirtualMachineResourceID *string `json:"sourceVirtualMachineResourceId,omitempty"`
}

// InboundNatRule - A rule for NAT - exposing a VM's port (backendPort) on the public IP address using a load balancer.
type InboundNatRule struct {
	// The port to which the external traffic will be redirected.
	BackendPort *int32 `json:"backendPort,omitempty"`

	// The external endpoint port of the inbound connection. Possible values range between 1 and 65535, inclusive. If unspecified, a value will be allocated
	// automatically.
	FrontendPort *int32 `json:"frontendPort,omitempty"`

	// The transport protocol for the endpoint.
	TransportProtocol *TransportProtocol `json:"transportProtocol,omitempty"`
}

// Lab - A lab.
type Lab struct {
	Resource
	// The properties of the resource.
	Properties *LabProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Lab.
func (l Lab) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// LabAnnouncementProperties - Properties of a lab's announcement banner
type LabAnnouncementProperties struct {
	// Is the lab announcement active/enabled at this time?
	Enabled *EnableStatus `json:"enabled,omitempty"`

	// The time at which the announcement expires (null for never)
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	// Has this announcement expired?
	Expired *bool `json:"expired,omitempty"`

	// The markdown text (if any) that this lab displays in the UI. If left empty/null, nothing will be shown.
	Markdown *string `json:"markdown,omitempty"`

	// The plain text title for the lab announcement
	Title *string `json:"title,omitempty"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LabAnnouncementProperties.
func (l LabAnnouncementProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", l.Enabled)
	populateTimeRFC3339(objectMap, "expirationDate", l.ExpirationDate)
	populate(objectMap, "expired", l.Expired)
	populate(objectMap, "markdown", l.Markdown)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "title", l.Title)
	populate(objectMap, "uniqueIdentifier", l.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LabAnnouncementProperties.
func (l *LabAnnouncementProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			err = unpopulate(val, &l.Enabled)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &l.ExpirationDate)
			delete(rawMsg, key)
		case "expired":
			err = unpopulate(val, &l.Expired)
			delete(rawMsg, key)
		case "markdown":
			err = unpopulate(val, &l.Markdown)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &l.Title)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &l.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LabCost - A cost item.
type LabCost struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *LabCostProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabCost.
func (l LabCost) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// LabCostDetailsProperties - The properties of a lab cost item.
type LabCostDetailsProperties struct {
	// The cost component of the cost item.
	Cost *float64 `json:"cost,omitempty"`

	// The type of the cost.
	CostType *CostType `json:"costType,omitempty"`

	// The date of the cost item.
	Date *time.Time `json:"date,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabCostDetailsProperties.
func (l LabCostDetailsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cost", l.Cost)
	populate(objectMap, "costType", l.CostType)
	populateTimeRFC3339(objectMap, "date", l.Date)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LabCostDetailsProperties.
func (l *LabCostDetailsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, &l.Cost)
			delete(rawMsg, key)
		case "costType":
			err = unpopulate(val, &l.CostType)
			delete(rawMsg, key)
		case "date":
			err = unpopulateTimeRFC3339(val, &l.Date)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LabCostProperties - Properties of a cost item.
type LabCostProperties struct {
	// The creation date of the cost.
	CreatedDate *time.Time `json:"createdDate,omitempty"`

	// The currency code of the cost.
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// The end time of the cost data.
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// The start time of the cost data.
	StartDateTime *time.Time `json:"startDateTime,omitempty"`

	// The target cost properties
	TargetCost *TargetCostProperties `json:"targetCost,omitempty"`

	// READ-ONLY; The lab cost details component of the cost data.
	LabCostDetails []*LabCostDetailsProperties `json:"labCostDetails,omitempty" azure:"ro"`

	// READ-ONLY; The lab cost summary component of the cost data.
	LabCostSummary *LabCostSummaryProperties `json:"labCostSummary,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource cost component of the cost data.
	ResourceCosts []*LabResourceCostProperties `json:"resourceCosts,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LabCostProperties.
func (l LabCostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", l.CreatedDate)
	populate(objectMap, "currencyCode", l.CurrencyCode)
	populateTimeRFC3339(objectMap, "endDateTime", l.EndDateTime)
	populate(objectMap, "labCostDetails", l.LabCostDetails)
	populate(objectMap, "labCostSummary", l.LabCostSummary)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceCosts", l.ResourceCosts)
	populateTimeRFC3339(objectMap, "startDateTime", l.StartDateTime)
	populate(objectMap, "targetCost", l.TargetCost)
	populate(objectMap, "uniqueIdentifier", l.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LabCostProperties.
func (l *LabCostProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &l.CreatedDate)
			delete(rawMsg, key)
		case "currencyCode":
			err = unpopulate(val, &l.CurrencyCode)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &l.EndDateTime)
			delete(rawMsg, key)
		case "labCostDetails":
			err = unpopulate(val, &l.LabCostDetails)
			delete(rawMsg, key)
		case "labCostSummary":
			err = unpopulate(val, &l.LabCostSummary)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceCosts":
			err = unpopulate(val, &l.ResourceCosts)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &l.StartDateTime)
			delete(rawMsg, key)
		case "targetCost":
			err = unpopulate(val, &l.TargetCost)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &l.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LabCostSummaryProperties - The properties of the cost summary.
type LabCostSummaryProperties struct {
	// The cost component of the cost item.
	EstimatedLabCost *float64 `json:"estimatedLabCost,omitempty"`
}

// LabFragment - A lab.
type LabFragment struct {
	UpdateResource
}

// LabList - The response of a list operation.
type LabList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Lab `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabList.
func (l LabList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LabProperties - Properties of a lab.
type LabProperties struct {
	// The properties of any lab announcement associated with this lab
	Announcement *LabAnnouncementProperties `json:"announcement,omitempty"`

	// The access rights to be granted to the user when provisioning an environment
	EnvironmentPermission *EnvironmentPermission `json:"environmentPermission,omitempty"`

	// Extended properties of the lab used for experimental features
	ExtendedProperties map[string]*string `json:"extendedProperties,omitempty"`

	// Type of storage used by the lab. It can be either Premium or Standard. Default is Premium.
	LabStorageType *StorageType `json:"labStorageType,omitempty"`

	// The ordered list of artifact resource IDs that should be applied on all Linux VM creations by default, prior to the artifacts specified by the user.
	MandatoryArtifactsResourceIDsLinux []*string `json:"mandatoryArtifactsResourceIdsLinux,omitempty"`

	// The ordered list of artifact resource IDs that should be applied on all Windows VM creations by default, prior to the artifacts specified by the user.
	MandatoryArtifactsResourceIDsWindows []*string `json:"mandatoryArtifactsResourceIdsWindows,omitempty"`

	// The setting to enable usage of premium data disks. When its value is 'Enabled', creation of standard or premium data disks is allowed. When its value
	// is 'Disabled', only creation of standard data
	// disks is allowed.
	PremiumDataDisks *PremiumDataDisk `json:"premiumDataDisks,omitempty"`

	// The properties of any lab support message associated with this lab
	Support *LabSupportProperties `json:"support,omitempty"`

	// READ-ONLY; The lab's artifact storage account.
	ArtifactsStorageAccount *string `json:"artifactsStorageAccount,omitempty" azure:"ro"`

	// READ-ONLY; The creation date of the lab.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The lab's default premium storage account.
	DefaultPremiumStorageAccount *string `json:"defaultPremiumStorageAccount,omitempty" azure:"ro"`

	// READ-ONLY; The lab's default storage account.
	DefaultStorageAccount *string `json:"defaultStorageAccount,omitempty" azure:"ro"`

	// READ-ONLY; The load balancer used to for lab VMs that use shared IP address.
	LoadBalancerID *string `json:"loadBalancerId,omitempty" azure:"ro"`

	// READ-ONLY; The Network Security Group attached to the lab VMs Network interfaces to restrict open ports.
	NetworkSecurityGroupID *string `json:"networkSecurityGroupId,omitempty" azure:"ro"`

	// READ-ONLY; The lab's premium data disk storage account.
	PremiumDataDiskStorageAccount *string `json:"premiumDataDiskStorageAccount,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The public IP address for the lab's load balancer.
	PublicIPID *string `json:"publicIpId,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`

	// READ-ONLY; The resource group in which all new lab virtual machines will be created. To let DevTest Labs manage resource group creation, set this value
	// to null.
	VMCreationResourceGroup *string `json:"vmCreationResourceGroup,omitempty" azure:"ro"`

	// READ-ONLY; The lab's Key vault.
	VaultName *string `json:"vaultName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LabProperties.
func (l LabProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "announcement", l.Announcement)
	populate(objectMap, "artifactsStorageAccount", l.ArtifactsStorageAccount)
	populateTimeRFC3339(objectMap, "createdDate", l.CreatedDate)
	populate(objectMap, "defaultPremiumStorageAccount", l.DefaultPremiumStorageAccount)
	populate(objectMap, "defaultStorageAccount", l.DefaultStorageAccount)
	populate(objectMap, "environmentPermission", l.EnvironmentPermission)
	populate(objectMap, "extendedProperties", l.ExtendedProperties)
	populate(objectMap, "labStorageType", l.LabStorageType)
	populate(objectMap, "loadBalancerId", l.LoadBalancerID)
	populate(objectMap, "mandatoryArtifactsResourceIdsLinux", l.MandatoryArtifactsResourceIDsLinux)
	populate(objectMap, "mandatoryArtifactsResourceIdsWindows", l.MandatoryArtifactsResourceIDsWindows)
	populate(objectMap, "networkSecurityGroupId", l.NetworkSecurityGroupID)
	populate(objectMap, "premiumDataDiskStorageAccount", l.PremiumDataDiskStorageAccount)
	populate(objectMap, "premiumDataDisks", l.PremiumDataDisks)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "publicIpId", l.PublicIPID)
	populate(objectMap, "support", l.Support)
	populate(objectMap, "uniqueIdentifier", l.UniqueIdentifier)
	populate(objectMap, "vmCreationResourceGroup", l.VMCreationResourceGroup)
	populate(objectMap, "vaultName", l.VaultName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LabProperties.
func (l *LabProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "announcement":
			err = unpopulate(val, &l.Announcement)
			delete(rawMsg, key)
		case "artifactsStorageAccount":
			err = unpopulate(val, &l.ArtifactsStorageAccount)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &l.CreatedDate)
			delete(rawMsg, key)
		case "defaultPremiumStorageAccount":
			err = unpopulate(val, &l.DefaultPremiumStorageAccount)
			delete(rawMsg, key)
		case "defaultStorageAccount":
			err = unpopulate(val, &l.DefaultStorageAccount)
			delete(rawMsg, key)
		case "environmentPermission":
			err = unpopulate(val, &l.EnvironmentPermission)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, &l.ExtendedProperties)
			delete(rawMsg, key)
		case "labStorageType":
			err = unpopulate(val, &l.LabStorageType)
			delete(rawMsg, key)
		case "loadBalancerId":
			err = unpopulate(val, &l.LoadBalancerID)
			delete(rawMsg, key)
		case "mandatoryArtifactsResourceIdsLinux":
			err = unpopulate(val, &l.MandatoryArtifactsResourceIDsLinux)
			delete(rawMsg, key)
		case "mandatoryArtifactsResourceIdsWindows":
			err = unpopulate(val, &l.MandatoryArtifactsResourceIDsWindows)
			delete(rawMsg, key)
		case "networkSecurityGroupId":
			err = unpopulate(val, &l.NetworkSecurityGroupID)
			delete(rawMsg, key)
		case "premiumDataDiskStorageAccount":
			err = unpopulate(val, &l.PremiumDataDiskStorageAccount)
			delete(rawMsg, key)
		case "premiumDataDisks":
			err = unpopulate(val, &l.PremiumDataDisks)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "publicIpId":
			err = unpopulate(val, &l.PublicIPID)
			delete(rawMsg, key)
		case "support":
			err = unpopulate(val, &l.Support)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &l.UniqueIdentifier)
			delete(rawMsg, key)
		case "vmCreationResourceGroup":
			err = unpopulate(val, &l.VMCreationResourceGroup)
			delete(rawMsg, key)
		case "vaultName":
			err = unpopulate(val, &l.VaultName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LabResourceCostProperties - The properties of a resource cost item.
type LabResourceCostProperties struct {
	// The ID of the external resource
	ExternalResourceID *string `json:"externalResourceId,omitempty"`

	// The cost component of the resource cost item.
	ResourceCost *float64 `json:"resourceCost,omitempty"`

	// The ID of the resource
	ResourceID *string `json:"resourceId,omitempty"`

	// The owner of the resource (ex. janedoe@microsoft.com)
	ResourceOwner *string `json:"resourceOwner,omitempty"`

	// The category of the resource (ex. PremiumLRS, StandardDS1)
	ResourcePricingTier *string `json:"resourcePricingTier,omitempty"`

	// The status of the resource (ex. Active)
	ResourceStatus *string `json:"resourceStatus,omitempty"`

	// The logical resource type (ex. virtualmachine, storageaccount)
	ResourceType *string `json:"resourceType,omitempty"`

	// The unique identifier of the resource.
	ResourceUID *string `json:"resourceUId,omitempty"`

	// The name of the resource.
	Resourcename *string `json:"resourcename,omitempty"`
}

// LabSupportProperties - Properties of a lab's support banner
type LabSupportProperties struct {
	// Is the lab support banner active/enabled at this time?
	Enabled *EnableStatus `json:"enabled,omitempty"`

	// The markdown text (if any) that this lab displays in the UI. If left empty/null, nothing will be shown.
	Markdown *string `json:"markdown,omitempty"`
}

// LabVhd - Properties of a VHD in the lab.
type LabVhd struct {
	// The URI to the VHD.
	ID *string `json:"id,omitempty"`
}

// LabVhdList - The response of a list operation.
type LabVhdList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*LabVhd `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabVhdList.
func (l LabVhdList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LabVirtualMachine - A virtual machine.
type LabVirtualMachine struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *LabVirtualMachineProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabVirtualMachine.
func (l LabVirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// LabVirtualMachineCreationParameter - Properties for creating a virtual machine.
type LabVirtualMachineCreationParameter struct {
	// The location of the new virtual machine or environment
	Location *string `json:"location,omitempty"`

	// The name of the virtual machine or environment
	Name *string `json:"name,omitempty"`

	// The properties of the resource.
	Properties *LabVirtualMachineCreationParameterProperties `json:"properties,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabVirtualMachineCreationParameter.
func (l LabVirtualMachineCreationParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// LabVirtualMachineCreationParameterProperties - Properties for virtual machine creation.
type LabVirtualMachineCreationParameterProperties struct {
	// Indicates whether another user can take ownership of the virtual machine
	AllowClaim *bool `json:"allowClaim,omitempty"`

	// The artifacts to be installed on the virtual machine.
	Artifacts []*ArtifactInstallProperties `json:"artifacts,omitempty"`

	// The number of virtual machine instances to create.
	BulkCreationParameters *BulkCreationParameters `json:"bulkCreationParameters,omitempty"`

	// The creation date of the virtual machine.
	CreatedDate *time.Time `json:"createdDate,omitempty"`

	// The custom image identifier of the virtual machine.
	CustomImageID *string `json:"customImageId,omitempty"`

	// New or existing data disks to attach to the virtual machine after creation
	DataDiskParameters []*DataDiskProperties `json:"dataDiskParameters,omitempty"`

	// Indicates whether the virtual machine is to be created without a public IP address.
	DisallowPublicIPAddress *bool `json:"disallowPublicIpAddress,omitempty"`

	// The resource ID of the environment that contains this virtual machine, if any.
	EnvironmentID *string `json:"environmentId,omitempty"`

	// The expiration date for VM.
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	// The Microsoft Azure Marketplace image reference of the virtual machine.
	GalleryImageReference *GalleryImageReference `json:"galleryImageReference,omitempty"`

	// Indicates whether this virtual machine uses an SSH key for authentication.
	IsAuthenticationWithSSHKey *bool `json:"isAuthenticationWithSshKey,omitempty"`

	// The lab subnet name of the virtual machine.
	LabSubnetName *string `json:"labSubnetName,omitempty"`

	// The lab virtual network identifier of the virtual machine.
	LabVirtualNetworkID *string `json:"labVirtualNetworkId,omitempty"`

	// The network interface properties.
	NetworkInterface *NetworkInterfaceProperties `json:"networkInterface,omitempty"`

	// The notes of the virtual machine.
	Notes *string `json:"notes,omitempty"`

	// The object identifier of the owner of the virtual machine.
	OwnerObjectID *string `json:"ownerObjectId,omitempty"`

	// The user principal name of the virtual machine owner.
	OwnerUserPrincipalName *string `json:"ownerUserPrincipalName,omitempty"`

	// The password of the virtual machine administrator.
	Password *string `json:"password,omitempty"`

	// The id of the plan associated with the virtual machine image
	PlanID *string `json:"planId,omitempty"`

	// The SSH key of the virtual machine administrator.
	SSHKey *string `json:"sshKey,omitempty"`

	// Virtual Machine schedules to be created
	ScheduleParameters []*ScheduleCreationParameter `json:"scheduleParameters,omitempty"`

	// The size of the virtual machine.
	Size *string `json:"size,omitempty"`

	// Storage type to use for virtual machine (i.e. Standard, Premium).
	StorageType *string `json:"storageType,omitempty"`

	// The user name of the virtual machine.
	UserName *string `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabVirtualMachineCreationParameterProperties.
func (l LabVirtualMachineCreationParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowClaim", l.AllowClaim)
	populate(objectMap, "artifacts", l.Artifacts)
	populate(objectMap, "bulkCreationParameters", l.BulkCreationParameters)
	populateTimeRFC3339(objectMap, "createdDate", l.CreatedDate)
	populate(objectMap, "customImageId", l.CustomImageID)
	populate(objectMap, "dataDiskParameters", l.DataDiskParameters)
	populate(objectMap, "disallowPublicIpAddress", l.DisallowPublicIPAddress)
	populate(objectMap, "environmentId", l.EnvironmentID)
	populateTimeRFC3339(objectMap, "expirationDate", l.ExpirationDate)
	populate(objectMap, "galleryImageReference", l.GalleryImageReference)
	populate(objectMap, "isAuthenticationWithSshKey", l.IsAuthenticationWithSSHKey)
	populate(objectMap, "labSubnetName", l.LabSubnetName)
	populate(objectMap, "labVirtualNetworkId", l.LabVirtualNetworkID)
	populate(objectMap, "networkInterface", l.NetworkInterface)
	populate(objectMap, "notes", l.Notes)
	populate(objectMap, "ownerObjectId", l.OwnerObjectID)
	populate(objectMap, "ownerUserPrincipalName", l.OwnerUserPrincipalName)
	populate(objectMap, "password", l.Password)
	populate(objectMap, "planId", l.PlanID)
	populate(objectMap, "sshKey", l.SSHKey)
	populate(objectMap, "scheduleParameters", l.ScheduleParameters)
	populate(objectMap, "size", l.Size)
	populate(objectMap, "storageType", l.StorageType)
	populate(objectMap, "userName", l.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LabVirtualMachineCreationParameterProperties.
func (l *LabVirtualMachineCreationParameterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowClaim":
			err = unpopulate(val, &l.AllowClaim)
			delete(rawMsg, key)
		case "artifacts":
			err = unpopulate(val, &l.Artifacts)
			delete(rawMsg, key)
		case "bulkCreationParameters":
			err = unpopulate(val, &l.BulkCreationParameters)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &l.CreatedDate)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, &l.CustomImageID)
			delete(rawMsg, key)
		case "dataDiskParameters":
			err = unpopulate(val, &l.DataDiskParameters)
			delete(rawMsg, key)
		case "disallowPublicIpAddress":
			err = unpopulate(val, &l.DisallowPublicIPAddress)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, &l.EnvironmentID)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &l.ExpirationDate)
			delete(rawMsg, key)
		case "galleryImageReference":
			err = unpopulate(val, &l.GalleryImageReference)
			delete(rawMsg, key)
		case "isAuthenticationWithSshKey":
			err = unpopulate(val, &l.IsAuthenticationWithSSHKey)
			delete(rawMsg, key)
		case "labSubnetName":
			err = unpopulate(val, &l.LabSubnetName)
			delete(rawMsg, key)
		case "labVirtualNetworkId":
			err = unpopulate(val, &l.LabVirtualNetworkID)
			delete(rawMsg, key)
		case "networkInterface":
			err = unpopulate(val, &l.NetworkInterface)
			delete(rawMsg, key)
		case "notes":
			err = unpopulate(val, &l.Notes)
			delete(rawMsg, key)
		case "ownerObjectId":
			err = unpopulate(val, &l.OwnerObjectID)
			delete(rawMsg, key)
		case "ownerUserPrincipalName":
			err = unpopulate(val, &l.OwnerUserPrincipalName)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &l.Password)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, &l.PlanID)
			delete(rawMsg, key)
		case "sshKey":
			err = unpopulate(val, &l.SSHKey)
			delete(rawMsg, key)
		case "scheduleParameters":
			err = unpopulate(val, &l.ScheduleParameters)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, &l.Size)
			delete(rawMsg, key)
		case "storageType":
			err = unpopulate(val, &l.StorageType)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &l.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LabVirtualMachineFragment - A virtual machine.
type LabVirtualMachineFragment struct {
	UpdateResource
}

// LabVirtualMachineList - The response of a list operation.
type LabVirtualMachineList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*LabVirtualMachine `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LabVirtualMachineList.
func (l LabVirtualMachineList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LabVirtualMachineProperties - Properties of a virtual machine.
type LabVirtualMachineProperties struct {
	// Indicates whether another user can take ownership of the virtual machine
	AllowClaim *bool `json:"allowClaim,omitempty"`

	// The artifacts to be installed on the virtual machine.
	Artifacts []*ArtifactInstallProperties `json:"artifacts,omitempty"`

	// The creation date of the virtual machine.
	CreatedDate *time.Time `json:"createdDate,omitempty"`

	// The custom image identifier of the virtual machine.
	CustomImageID *string `json:"customImageId,omitempty"`

	// New or existing data disks to attach to the virtual machine after creation
	DataDiskParameters []*DataDiskProperties `json:"dataDiskParameters,omitempty"`

	// Indicates whether the virtual machine is to be created without a public IP address.
	DisallowPublicIPAddress *bool `json:"disallowPublicIpAddress,omitempty"`

	// The resource ID of the environment that contains this virtual machine, if any.
	EnvironmentID *string `json:"environmentId,omitempty"`

	// The expiration date for VM.
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	// The Microsoft Azure Marketplace image reference of the virtual machine.
	GalleryImageReference *GalleryImageReference `json:"galleryImageReference,omitempty"`

	// Indicates whether this virtual machine uses an SSH key for authentication.
	IsAuthenticationWithSSHKey *bool `json:"isAuthenticationWithSshKey,omitempty"`

	// The lab subnet name of the virtual machine.
	LabSubnetName *string `json:"labSubnetName,omitempty"`

	// The lab virtual network identifier of the virtual machine.
	LabVirtualNetworkID *string `json:"labVirtualNetworkId,omitempty"`

	// The network interface properties.
	NetworkInterface *NetworkInterfaceProperties `json:"networkInterface,omitempty"`

	// The notes of the virtual machine.
	Notes *string `json:"notes,omitempty"`

	// The object identifier of the owner of the virtual machine.
	OwnerObjectID *string `json:"ownerObjectId,omitempty"`

	// The user principal name of the virtual machine owner.
	OwnerUserPrincipalName *string `json:"ownerUserPrincipalName,omitempty"`

	// The password of the virtual machine administrator.
	Password *string `json:"password,omitempty"`

	// The id of the plan associated with the virtual machine image
	PlanID *string `json:"planId,omitempty"`

	// The SSH key of the virtual machine administrator.
	SSHKey *string `json:"sshKey,omitempty"`

	// Virtual Machine schedules to be created
	ScheduleParameters []*ScheduleCreationParameter `json:"scheduleParameters,omitempty"`

	// The size of the virtual machine.
	Size *string `json:"size,omitempty"`

	// Storage type to use for virtual machine (i.e. Standard, Premium).
	StorageType *string `json:"storageType,omitempty"`

	// The user name of the virtual machine.
	UserName *string `json:"userName,omitempty"`

	// READ-ONLY; The applicable schedule for the virtual machine.
	ApplicableSchedule *ApplicableSchedule `json:"applicableSchedule,omitempty" azure:"ro"`

	// READ-ONLY; The artifact deployment status for the virtual machine.
	ArtifactDeploymentStatus *ArtifactDeploymentStatusProperties `json:"artifactDeploymentStatus,omitempty" azure:"ro"`

	// READ-ONLY; The resource identifier (Microsoft.Compute) of the virtual machine.
	ComputeID *string `json:"computeId,omitempty" azure:"ro"`

	// READ-ONLY; The compute virtual machine properties.
	ComputeVM *ComputeVMProperties `json:"computeVm,omitempty" azure:"ro"`

	// READ-ONLY; The email address of creator of the virtual machine.
	CreatedByUser *string `json:"createdByUser,omitempty" azure:"ro"`

	// READ-ONLY; The object identifier of the creator of the virtual machine.
	CreatedByUserID *string `json:"createdByUserId,omitempty" azure:"ro"`

	// READ-ONLY; The fully-qualified domain name of the virtual machine.
	Fqdn *string `json:"fqdn,omitempty" azure:"ro"`

	// READ-ONLY; Last known compute power state captured in DTL
	LastKnownPowerState *string `json:"lastKnownPowerState,omitempty" azure:"ro"`

	// READ-ONLY; The OS type of the virtual machine.
	OSType *string `json:"osType,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`

	// READ-ONLY; Tells source of creation of lab virtual machine. Output property only.
	VirtualMachineCreationSource *VirtualMachineCreationSource `json:"virtualMachineCreationSource,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LabVirtualMachineProperties.
func (l LabVirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowClaim", l.AllowClaim)
	populate(objectMap, "applicableSchedule", l.ApplicableSchedule)
	populate(objectMap, "artifactDeploymentStatus", l.ArtifactDeploymentStatus)
	populate(objectMap, "artifacts", l.Artifacts)
	populate(objectMap, "computeId", l.ComputeID)
	populate(objectMap, "computeVm", l.ComputeVM)
	populate(objectMap, "createdByUser", l.CreatedByUser)
	populate(objectMap, "createdByUserId", l.CreatedByUserID)
	populateTimeRFC3339(objectMap, "createdDate", l.CreatedDate)
	populate(objectMap, "customImageId", l.CustomImageID)
	populate(objectMap, "dataDiskParameters", l.DataDiskParameters)
	populate(objectMap, "disallowPublicIpAddress", l.DisallowPublicIPAddress)
	populate(objectMap, "environmentId", l.EnvironmentID)
	populateTimeRFC3339(objectMap, "expirationDate", l.ExpirationDate)
	populate(objectMap, "fqdn", l.Fqdn)
	populate(objectMap, "galleryImageReference", l.GalleryImageReference)
	populate(objectMap, "isAuthenticationWithSshKey", l.IsAuthenticationWithSSHKey)
	populate(objectMap, "labSubnetName", l.LabSubnetName)
	populate(objectMap, "labVirtualNetworkId", l.LabVirtualNetworkID)
	populate(objectMap, "lastKnownPowerState", l.LastKnownPowerState)
	populate(objectMap, "networkInterface", l.NetworkInterface)
	populate(objectMap, "notes", l.Notes)
	populate(objectMap, "osType", l.OSType)
	populate(objectMap, "ownerObjectId", l.OwnerObjectID)
	populate(objectMap, "ownerUserPrincipalName", l.OwnerUserPrincipalName)
	populate(objectMap, "password", l.Password)
	populate(objectMap, "planId", l.PlanID)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "sshKey", l.SSHKey)
	populate(objectMap, "scheduleParameters", l.ScheduleParameters)
	populate(objectMap, "size", l.Size)
	populate(objectMap, "storageType", l.StorageType)
	populate(objectMap, "uniqueIdentifier", l.UniqueIdentifier)
	populate(objectMap, "userName", l.UserName)
	populate(objectMap, "virtualMachineCreationSource", l.VirtualMachineCreationSource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LabVirtualMachineProperties.
func (l *LabVirtualMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowClaim":
			err = unpopulate(val, &l.AllowClaim)
			delete(rawMsg, key)
		case "applicableSchedule":
			err = unpopulate(val, &l.ApplicableSchedule)
			delete(rawMsg, key)
		case "artifactDeploymentStatus":
			err = unpopulate(val, &l.ArtifactDeploymentStatus)
			delete(rawMsg, key)
		case "artifacts":
			err = unpopulate(val, &l.Artifacts)
			delete(rawMsg, key)
		case "computeId":
			err = unpopulate(val, &l.ComputeID)
			delete(rawMsg, key)
		case "computeVm":
			err = unpopulate(val, &l.ComputeVM)
			delete(rawMsg, key)
		case "createdByUser":
			err = unpopulate(val, &l.CreatedByUser)
			delete(rawMsg, key)
		case "createdByUserId":
			err = unpopulate(val, &l.CreatedByUserID)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &l.CreatedDate)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, &l.CustomImageID)
			delete(rawMsg, key)
		case "dataDiskParameters":
			err = unpopulate(val, &l.DataDiskParameters)
			delete(rawMsg, key)
		case "disallowPublicIpAddress":
			err = unpopulate(val, &l.DisallowPublicIPAddress)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, &l.EnvironmentID)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &l.ExpirationDate)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, &l.Fqdn)
			delete(rawMsg, key)
		case "galleryImageReference":
			err = unpopulate(val, &l.GalleryImageReference)
			delete(rawMsg, key)
		case "isAuthenticationWithSshKey":
			err = unpopulate(val, &l.IsAuthenticationWithSSHKey)
			delete(rawMsg, key)
		case "labSubnetName":
			err = unpopulate(val, &l.LabSubnetName)
			delete(rawMsg, key)
		case "labVirtualNetworkId":
			err = unpopulate(val, &l.LabVirtualNetworkID)
			delete(rawMsg, key)
		case "lastKnownPowerState":
			err = unpopulate(val, &l.LastKnownPowerState)
			delete(rawMsg, key)
		case "networkInterface":
			err = unpopulate(val, &l.NetworkInterface)
			delete(rawMsg, key)
		case "notes":
			err = unpopulate(val, &l.Notes)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &l.OSType)
			delete(rawMsg, key)
		case "ownerObjectId":
			err = unpopulate(val, &l.OwnerObjectID)
			delete(rawMsg, key)
		case "ownerUserPrincipalName":
			err = unpopulate(val, &l.OwnerUserPrincipalName)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &l.Password)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, &l.PlanID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "sshKey":
			err = unpopulate(val, &l.SSHKey)
			delete(rawMsg, key)
		case "scheduleParameters":
			err = unpopulate(val, &l.ScheduleParameters)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, &l.Size)
			delete(rawMsg, key)
		case "storageType":
			err = unpopulate(val, &l.StorageType)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &l.UniqueIdentifier)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &l.UserName)
			delete(rawMsg, key)
		case "virtualMachineCreationSource":
			err = unpopulate(val, &l.VirtualMachineCreationSource)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LabsBeginClaimAnyVMOptions contains the optional parameters for the Labs.BeginClaimAnyVM method.
type LabsBeginClaimAnyVMOptions struct {
	// placeholder for future optional parameters
}

// LabsBeginCreateEnvironmentOptions contains the optional parameters for the Labs.BeginCreateEnvironment method.
type LabsBeginCreateEnvironmentOptions struct {
	// placeholder for future optional parameters
}

// LabsBeginCreateOrUpdateOptions contains the optional parameters for the Labs.BeginCreateOrUpdate method.
type LabsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// LabsBeginDeleteOptions contains the optional parameters for the Labs.BeginDelete method.
type LabsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// LabsBeginExportResourceUsageOptions contains the optional parameters for the Labs.BeginExportResourceUsage method.
type LabsBeginExportResourceUsageOptions struct {
	// placeholder for future optional parameters
}

// LabsBeginImportVirtualMachineOptions contains the optional parameters for the Labs.BeginImportVirtualMachine method.
type LabsBeginImportVirtualMachineOptions struct {
	// placeholder for future optional parameters
}

// LabsGenerateUploadURIOptions contains the optional parameters for the Labs.GenerateUploadURI method.
type LabsGenerateUploadURIOptions struct {
	// placeholder for future optional parameters
}

// LabsGetOptions contains the optional parameters for the Labs.Get method.
type LabsGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=defaultStorageAccount)'
	Expand *string
}

// LabsListByResourceGroupOptions contains the optional parameters for the Labs.ListByResourceGroup method.
type LabsListByResourceGroupOptions struct {
	// Specify the $expand query. Example: 'properties($select=defaultStorageAccount)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// LabsListBySubscriptionOptions contains the optional parameters for the Labs.ListBySubscription method.
type LabsListBySubscriptionOptions struct {
	// Specify the $expand query. Example: 'properties($select=defaultStorageAccount)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// LabsListVhdsOptions contains the optional parameters for the Labs.ListVhds method.
type LabsListVhdsOptions struct {
	// placeholder for future optional parameters
}

// LabsUpdateOptions contains the optional parameters for the Labs.Update method.
type LabsUpdateOptions struct {
	// placeholder for future optional parameters
}

// LinuxOsInfo - Information about a Linux OS.
type LinuxOsInfo struct {
	// The state of the Linux OS (i.e. NonDeprovisioned, DeprovisionRequested, DeprovisionApplied).
	LinuxOsState *LinuxOsState `json:"linuxOsState,omitempty"`
}

// NetworkInterfaceProperties - Properties of a network interface.
type NetworkInterfaceProperties struct {
	// The DNS name.
	DNSName *string `json:"dnsName,omitempty"`

	// The private IP address.
	PrivateIPAddress *string `json:"privateIpAddress,omitempty"`

	// The public IP address.
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`

	// The resource ID of the public IP address.
	PublicIPAddressID *string `json:"publicIpAddressId,omitempty"`

	// The RdpAuthority property is a server DNS host name or IP address followed by the service port number for RDP (Remote Desktop Protocol).
	RdpAuthority *string `json:"rdpAuthority,omitempty"`

	// The SshAuthority property is a server DNS host name or IP address followed by the service port number for SSH.
	SSHAuthority *string `json:"sshAuthority,omitempty"`

	// The configuration for sharing a public IP address across multiple virtual machines.
	SharedPublicIPAddressConfiguration *SharedPublicIPAddressConfiguration `json:"sharedPublicIpAddressConfiguration,omitempty"`

	// The resource ID of the sub net.
	SubnetID *string `json:"subnetId,omitempty"`

	// The resource ID of the virtual network.
	VirtualNetworkID *string `json:"virtualNetworkId,omitempty"`
}

// NotificationChannel - A notification.
type NotificationChannel struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *NotificationChannelProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotificationChannel.
func (n NotificationChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", n.Properties)
	return json.Marshal(objectMap)
}

// NotificationChannelFragment - A notification.
type NotificationChannelFragment struct {
	UpdateResource
}

// NotificationChannelList - The response of a list operation.
type NotificationChannelList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*NotificationChannel `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotificationChannelList.
func (n NotificationChannelList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// NotificationChannelProperties - Properties of a schedule.
type NotificationChannelProperties struct {
	// Description of notification.
	Description *string `json:"description,omitempty"`

	// The email recipient to send notifications to (can be a list of semi-colon separated email addresses).
	EmailRecipient *string `json:"emailRecipient,omitempty"`

	// The list of event for which this notification is enabled.
	Events []*Event `json:"events,omitempty"`

	// The locale to use when sending a notification (fallback for unsupported languages is EN).
	NotificationLocale *string `json:"notificationLocale,omitempty"`

	// The webhook URL to send notifications to.
	WebHookURL *string `json:"webHookUrl,omitempty"`

	// READ-ONLY; The creation date of the notification channel.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NotificationChannelProperties.
func (n NotificationChannelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", n.CreatedDate)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "emailRecipient", n.EmailRecipient)
	populate(objectMap, "events", n.Events)
	populate(objectMap, "notificationLocale", n.NotificationLocale)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "uniqueIdentifier", n.UniqueIdentifier)
	populate(objectMap, "webHookUrl", n.WebHookURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotificationChannelProperties.
func (n *NotificationChannelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &n.CreatedDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &n.Description)
			delete(rawMsg, key)
		case "emailRecipient":
			err = unpopulate(val, &n.EmailRecipient)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &n.Events)
			delete(rawMsg, key)
		case "notificationLocale":
			err = unpopulate(val, &n.NotificationLocale)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &n.ProvisioningState)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &n.UniqueIdentifier)
			delete(rawMsg, key)
		case "webHookUrl":
			err = unpopulate(val, &n.WebHookURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NotificationChannelsCreateOrUpdateOptions contains the optional parameters for the NotificationChannels.CreateOrUpdate method.
type NotificationChannelsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// NotificationChannelsDeleteOptions contains the optional parameters for the NotificationChannels.Delete method.
type NotificationChannelsDeleteOptions struct {
	// placeholder for future optional parameters
}

// NotificationChannelsGetOptions contains the optional parameters for the NotificationChannels.Get method.
type NotificationChannelsGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=webHookUrl)'
	Expand *string
}

// NotificationChannelsListOptions contains the optional parameters for the NotificationChannels.List method.
type NotificationChannelsListOptions struct {
	// Specify the $expand query. Example: 'properties($select=webHookUrl)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// NotificationChannelsNotifyOptions contains the optional parameters for the NotificationChannels.Notify method.
type NotificationChannelsNotifyOptions struct {
	// placeholder for future optional parameters
}

// NotificationChannelsUpdateOptions contains the optional parameters for the NotificationChannels.Update method.
type NotificationChannelsUpdateOptions struct {
	// placeholder for future optional parameters
}

// NotificationSettings - Notification settings for a schedule.
type NotificationSettings struct {
	// The email recipient to send notifications to (can be a list of semi-colon separated email addresses).
	EmailRecipient *string `json:"emailRecipient,omitempty"`

	// The locale to use when sending a notification (fallback for unsupported languages is EN).
	NotificationLocale *string `json:"notificationLocale,omitempty"`

	// If notifications are enabled for this schedule (i.e. Enabled, Disabled).
	Status *EnableStatus `json:"status,omitempty"`

	// Time in minutes before event at which notification will be sent.
	TimeInMinutes *int32 `json:"timeInMinutes,omitempty"`

	// The webhook URL to which the notification will be sent.
	WebhookURL *string `json:"webhookUrl,omitempty"`
}

// NotifyParameters - Properties for generating a Notification.
type NotifyParameters struct {
	// The type of event (i.e. AutoShutdown, Cost)
	EventName *NotificationChannelEventType `json:"eventName,omitempty"`

	// Properties for the notification in json format.
	JSONPayload *string `json:"jsonPayload,omitempty"`
}

// OperationError - Error details for the operation in case of a failure.
type OperationError struct {
	// The error code of the operation error.
	Code *string `json:"code,omitempty"`

	// The error message of the operation error.
	Message *string `json:"message,omitempty"`
}

// OperationMetadata - The REST API operation supported by DevTestLab ResourceProvider.
type OperationMetadata struct {
	// The object that describes the operations
	Display *OperationMetadataDisplay `json:"display,omitempty"`

	// Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
}

// OperationMetadataDisplay - The object that describes the operations
type OperationMetadataDisplay struct {
	// Friendly name of the operation
	Description *string `json:"description,omitempty"`

	// Operation type: read, write, delete, listKeys/action, etc.
	Operation *string `json:"operation,omitempty"`

	// Friendly name of the resource provider
	Provider *string `json:"provider,omitempty"`

	// Resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationResult - An Operation Result
type OperationResult struct {
	// Error details for the operation in case of a failure.
	Error *OperationError `json:"error,omitempty"`

	// The operation status.
	Status *string `json:"status,omitempty"`

	// The status code for the operation.
	StatusCode *HTTPStatusCode `json:"statusCode,omitempty"`
}

// OperationsGetOptions contains the optional parameters for the Operations.Get method.
type OperationsGetOptions struct {
	// placeholder for future optional parameters
}

// ParameterInfo - Information about an artifact's parameter.
type ParameterInfo struct {
	// The name of the artifact parameter.
	Name *string `json:"name,omitempty"`

	// The value of the artifact parameter.
	Value *string `json:"value,omitempty"`
}

// ParametersValueFileInfo - A file containing a set of parameter values for an ARM template.
type ParametersValueFileInfo struct {
	// File name.
	FileName *string `json:"fileName,omitempty"`

	// Contents of the file.
	ParametersValueInfo map[string]interface{} `json:"parametersValueInfo,omitempty"`
}

// PercentageCostThresholdProperties - Properties of a percentage cost threshold.
type PercentageCostThresholdProperties struct {
	// The cost threshold value.
	ThresholdValue *float64 `json:"thresholdValue,omitempty"`
}

// PoliciesCreateOrUpdateOptions contains the optional parameters for the Policies.CreateOrUpdate method.
type PoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PoliciesDeleteOptions contains the optional parameters for the Policies.Delete method.
type PoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// PoliciesGetOptions contains the optional parameters for the Policies.Get method.
type PoliciesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=description)'
	Expand *string
}

// PoliciesListOptions contains the optional parameters for the Policies.List method.
type PoliciesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=description)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// PoliciesUpdateOptions contains the optional parameters for the Policies.Update method.
type PoliciesUpdateOptions struct {
	// placeholder for future optional parameters
}

// Policy - A Policy.
type Policy struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *PolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Policy.
func (p Policy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PolicyFragment - A Policy.
type PolicyFragment struct {
	UpdateResource
}

// PolicyList - The response of a list operation.
type PolicyList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Policy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyList.
func (p PolicyList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PolicyProperties - Properties of a Policy.
type PolicyProperties struct {
	// The description of the policy.
	Description *string `json:"description,omitempty"`

	// The evaluator type of the policy (i.e. AllowedValuesPolicy, MaxValuePolicy).
	EvaluatorType *PolicyEvaluatorType `json:"evaluatorType,omitempty"`

	// The fact data of the policy.
	FactData *string `json:"factData,omitempty"`

	// The fact name of the policy (e.g. LabVmCount, LabVmSize, MaxVmsAllowedPerLab, etc.
	FactName *PolicyFactName `json:"factName,omitempty"`

	// The status of the policy.
	Status *PolicyStatus `json:"status,omitempty"`

	// The threshold of the policy (i.e. a number for MaxValuePolicy, and a JSON array of values for AllowedValuesPolicy).
	Threshold *string `json:"threshold,omitempty"`

	// READ-ONLY; The creation date of the policy.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyProperties.
func (p PolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", p.CreatedDate)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "evaluatorType", p.EvaluatorType)
	populate(objectMap, "factData", p.FactData)
	populate(objectMap, "factName", p.FactName)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "status", p.Status)
	populate(objectMap, "threshold", p.Threshold)
	populate(objectMap, "uniqueIdentifier", p.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyProperties.
func (p *PolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &p.CreatedDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "evaluatorType":
			err = unpopulate(val, &p.EvaluatorType)
			delete(rawMsg, key)
		case "factData":
			err = unpopulate(val, &p.FactData)
			delete(rawMsg, key)
		case "factName":
			err = unpopulate(val, &p.FactName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &p.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &p.Status)
			delete(rawMsg, key)
		case "threshold":
			err = unpopulate(val, &p.Threshold)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &p.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PolicySetResult - Result of a policy set evaluation.
type PolicySetResult struct {
	// A value indicating whether this policy set evaluation has discovered violations.
	HasError *bool `json:"hasError,omitempty"`

	// The list of policy violations.
	PolicyViolations []*PolicyViolation `json:"policyViolations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicySetResult.
func (p PolicySetResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hasError", p.HasError)
	populate(objectMap, "policyViolations", p.PolicyViolations)
	return json.Marshal(objectMap)
}

// PolicySetsEvaluatePoliciesOptions contains the optional parameters for the PolicySets.EvaluatePolicies method.
type PolicySetsEvaluatePoliciesOptions struct {
	// placeholder for future optional parameters
}

// PolicyViolation - Policy violation.
type PolicyViolation struct {
	// The code of the policy violation.
	Code *string `json:"code,omitempty"`

	// The message of the policy violation.
	Message *string `json:"message,omitempty"`
}

// Port - Properties of a network port.
type Port struct {
	// Backend port of the target virtual machine.
	BackendPort *int32 `json:"backendPort,omitempty"`

	// Protocol type of the port.
	TransportProtocol *TransportProtocol `json:"transportProtocol,omitempty"`
}

// ProviderOperationResult - Result of the request to list REST API operations
type ProviderOperationResult struct {
	// List of operations supported by the resource provider.
	Value []*OperationMetadata `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProviderOperationResult.
func (p ProviderOperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ProviderOperationsListOptions contains the optional parameters for the ProviderOperations.List method.
type ProviderOperationsListOptions struct {
	// placeholder for future optional parameters
}

// RdpConnection - Represents a .rdp file
type RdpConnection struct {
	// The contents of the .rdp file
	Contents *string `json:"contents,omitempty"`
}

// ResizeLabVirtualMachineProperties - Request body for resizing a virtual machine.
type ResizeLabVirtualMachineProperties struct {
	// Specifies the size of the virtual machine.
	Size *string `json:"size,omitempty"`
}

// Resource - An Azure resource.
type Resource struct {
	// The location of the resource.
	Location *string `json:"location,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// RetargetScheduleProperties - Properties for retargeting a virtual machine schedule.
type RetargetScheduleProperties struct {
	// The resource Id of the virtual machine on which the schedule operates
	CurrentResourceID *string `json:"currentResourceId,omitempty"`

	// The resource Id of the virtual machine that the schedule should be retargeted to
	TargetResourceID *string `json:"targetResourceId,omitempty"`
}

// Schedule - A schedule.
type Schedule struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *ScheduleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Schedule.
func (s Schedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// ScheduleCreationParameter - Properties for creating a schedule.
type ScheduleCreationParameter struct {
	// The name of the virtual machine or environment
	Name *string `json:"name,omitempty"`

	// The properties of the schedule.
	Properties *ScheduleCreationParameterProperties `json:"properties,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The location of the new virtual machine or environment
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleCreationParameter.
func (s ScheduleCreationParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// ScheduleCreationParameterProperties - Properties for schedule creation.
type ScheduleCreationParameterProperties struct {
	// If the schedule will occur once each day of the week, specify the daily recurrence.
	DailyRecurrence *DayDetails `json:"dailyRecurrence,omitempty"`

	// If the schedule will occur multiple times a day, specify the hourly recurrence.
	HourlyRecurrence *HourDetails `json:"hourlyRecurrence,omitempty"`

	// Notification settings.
	NotificationSettings *NotificationSettings `json:"notificationSettings,omitempty"`

	// The status of the schedule (i.e. Enabled, Disabled)
	Status *EnableStatus `json:"status,omitempty"`

	// The resource ID to which the schedule belongs
	TargetResourceID *string `json:"targetResourceId,omitempty"`

	// The task type of the schedule (e.g. LabVmsShutdownTask, LabVmAutoStart).
	TaskType *string `json:"taskType,omitempty"`

	// The time zone ID (e.g. Pacific Standard time).
	TimeZoneID *string `json:"timeZoneId,omitempty"`

	// If the schedule will occur only some days of the week, specify the weekly recurrence.
	WeeklyRecurrence *WeekDetails `json:"weeklyRecurrence,omitempty"`
}

// ScheduleFragment - A schedule.
type ScheduleFragment struct {
	UpdateResource
}

// ScheduleList - The response of a list operation.
type ScheduleList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Schedule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleList.
func (s ScheduleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ScheduleProperties - Properties of a schedule.
type ScheduleProperties struct {
	// If the schedule will occur once each day of the week, specify the daily recurrence.
	DailyRecurrence *DayDetails `json:"dailyRecurrence,omitempty"`

	// If the schedule will occur multiple times a day, specify the hourly recurrence.
	HourlyRecurrence *HourDetails `json:"hourlyRecurrence,omitempty"`

	// Notification settings.
	NotificationSettings *NotificationSettings `json:"notificationSettings,omitempty"`

	// The status of the schedule (i.e. Enabled, Disabled)
	Status *EnableStatus `json:"status,omitempty"`

	// The resource ID to which the schedule belongs
	TargetResourceID *string `json:"targetResourceId,omitempty"`

	// The task type of the schedule (e.g. LabVmsShutdownTask, LabVmAutoStart).
	TaskType *string `json:"taskType,omitempty"`

	// The time zone ID (e.g. Pacific Standard time).
	TimeZoneID *string `json:"timeZoneId,omitempty"`

	// If the schedule will occur only some days of the week, specify the weekly recurrence.
	WeeklyRecurrence *WeekDetails `json:"weeklyRecurrence,omitempty"`

	// READ-ONLY; The creation date of the schedule.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleProperties.
func (s ScheduleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", s.CreatedDate)
	populate(objectMap, "dailyRecurrence", s.DailyRecurrence)
	populate(objectMap, "hourlyRecurrence", s.HourlyRecurrence)
	populate(objectMap, "notificationSettings", s.NotificationSettings)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "targetResourceId", s.TargetResourceID)
	populate(objectMap, "taskType", s.TaskType)
	populate(objectMap, "timeZoneId", s.TimeZoneID)
	populate(objectMap, "uniqueIdentifier", s.UniqueIdentifier)
	populate(objectMap, "weeklyRecurrence", s.WeeklyRecurrence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleProperties.
func (s *ScheduleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &s.CreatedDate)
			delete(rawMsg, key)
		case "dailyRecurrence":
			err = unpopulate(val, &s.DailyRecurrence)
			delete(rawMsg, key)
		case "hourlyRecurrence":
			err = unpopulate(val, &s.HourlyRecurrence)
			delete(rawMsg, key)
		case "notificationSettings":
			err = unpopulate(val, &s.NotificationSettings)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "targetResourceId":
			err = unpopulate(val, &s.TargetResourceID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &s.TaskType)
			delete(rawMsg, key)
		case "timeZoneId":
			err = unpopulate(val, &s.TimeZoneID)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &s.UniqueIdentifier)
			delete(rawMsg, key)
		case "weeklyRecurrence":
			err = unpopulate(val, &s.WeeklyRecurrence)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SchedulesBeginExecuteOptions contains the optional parameters for the Schedules.BeginExecute method.
type SchedulesBeginExecuteOptions struct {
	// placeholder for future optional parameters
}

// SchedulesCreateOrUpdateOptions contains the optional parameters for the Schedules.CreateOrUpdate method.
type SchedulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SchedulesDeleteOptions contains the optional parameters for the Schedules.Delete method.
type SchedulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// SchedulesGetOptions contains the optional parameters for the Schedules.Get method.
type SchedulesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
}

// SchedulesListApplicableOptions contains the optional parameters for the Schedules.ListApplicable method.
type SchedulesListApplicableOptions struct {
	// placeholder for future optional parameters
}

// SchedulesListOptions contains the optional parameters for the Schedules.List method.
type SchedulesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// SchedulesUpdateOptions contains the optional parameters for the Schedules.Update method.
type SchedulesUpdateOptions struct {
	// placeholder for future optional parameters
}

// Secret - A secret.
type Secret struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *SecretProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Secret.
func (s Secret) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SecretFragment - A secret.
type SecretFragment struct {
	UpdateResource
}

// SecretList - The response of a list operation.
type SecretList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*Secret `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretList.
func (s SecretList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SecretProperties - Properties of a secret.
type SecretProperties struct {
	// The value of the secret for secret creation.
	Value *string `json:"value,omitempty"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// SecretsBeginCreateOrUpdateOptions contains the optional parameters for the Secrets.BeginCreateOrUpdate method.
type SecretsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SecretsDeleteOptions contains the optional parameters for the Secrets.Delete method.
type SecretsDeleteOptions struct {
	// placeholder for future optional parameters
}

// SecretsGetOptions contains the optional parameters for the Secrets.Get method.
type SecretsGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=value)'
	Expand *string
}

// SecretsListOptions contains the optional parameters for the Secrets.List method.
type SecretsListOptions struct {
	// Specify the $expand query. Example: 'properties($select=value)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// SecretsUpdateOptions contains the optional parameters for the Secrets.Update method.
type SecretsUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabric - A Service Fabric.
type ServiceFabric struct {
	Resource
	// REQUIRED; The properties of the resource.
	Properties *ServiceFabricProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceFabric.
func (s ServiceFabric) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// ServiceFabricFragment - A Service Fabric.
type ServiceFabricFragment struct {
	UpdateResource
}

// ServiceFabricList - The response of a list operation.
type ServiceFabricList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*ServiceFabric `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceFabricList.
func (s ServiceFabricList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceFabricProperties - Properties of a service fabric.
type ServiceFabricProperties struct {
	// The resource id of the environment under which the service fabric resource is present
	EnvironmentID *string `json:"environmentId,omitempty"`

	// The backing service fabric resource's id
	ExternalServiceFabricID *string `json:"externalServiceFabricId,omitempty"`

	// READ-ONLY; The applicable schedule for the virtual machine.
	ApplicableSchedule *ApplicableSchedule `json:"applicableSchedule,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// ServiceFabricSchedulesBeginExecuteOptions contains the optional parameters for the ServiceFabricSchedules.BeginExecute method.
type ServiceFabricSchedulesBeginExecuteOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricSchedulesCreateOrUpdateOptions contains the optional parameters for the ServiceFabricSchedules.CreateOrUpdate method.
type ServiceFabricSchedulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricSchedulesDeleteOptions contains the optional parameters for the ServiceFabricSchedules.Delete method.
type ServiceFabricSchedulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricSchedulesGetOptions contains the optional parameters for the ServiceFabricSchedules.Get method.
type ServiceFabricSchedulesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
}

// ServiceFabricSchedulesListOptions contains the optional parameters for the ServiceFabricSchedules.List method.
type ServiceFabricSchedulesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// ServiceFabricSchedulesUpdateOptions contains the optional parameters for the ServiceFabricSchedules.Update method.
type ServiceFabricSchedulesUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricsBeginCreateOrUpdateOptions contains the optional parameters for the ServiceFabrics.BeginCreateOrUpdate method.
type ServiceFabricsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricsBeginDeleteOptions contains the optional parameters for the ServiceFabrics.BeginDelete method.
type ServiceFabricsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricsBeginStartOptions contains the optional parameters for the ServiceFabrics.BeginStart method.
type ServiceFabricsBeginStartOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricsBeginStopOptions contains the optional parameters for the ServiceFabrics.BeginStop method.
type ServiceFabricsBeginStopOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricsGetOptions contains the optional parameters for the ServiceFabrics.Get method.
type ServiceFabricsGetOptions struct {
	// Specify the $expand query. Example: 'properties($expand=applicableSchedule)'
	Expand *string
}

// ServiceFabricsListApplicableSchedulesOptions contains the optional parameters for the ServiceFabrics.ListApplicableSchedules method.
type ServiceFabricsListApplicableSchedulesOptions struct {
	// placeholder for future optional parameters
}

// ServiceFabricsListOptions contains the optional parameters for the ServiceFabrics.List method.
type ServiceFabricsListOptions struct {
	// Specify the $expand query. Example: 'properties($expand=applicableSchedule)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// ServiceFabricsUpdateOptions contains the optional parameters for the ServiceFabrics.Update method.
type ServiceFabricsUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceRunner - A container for a managed identity to execute DevTest lab services.
type ServiceRunner struct {
	Resource
	// The identity of the resource.
	Identity *IdentityProperties `json:"identity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceRunner.
func (s ServiceRunner) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", s.Identity)
	return json.Marshal(objectMap)
}

// ServiceRunnerList - The response of a list operation.
type ServiceRunnerList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*ServiceRunner `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceRunnerList.
func (s ServiceRunnerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceRunnersCreateOrUpdateOptions contains the optional parameters for the ServiceRunners.CreateOrUpdate method.
type ServiceRunnersCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceRunnersDeleteOptions contains the optional parameters for the ServiceRunners.Delete method.
type ServiceRunnersDeleteOptions struct {
	// placeholder for future optional parameters
}

// ServiceRunnersGetOptions contains the optional parameters for the ServiceRunners.Get method.
type ServiceRunnersGetOptions struct {
	// placeholder for future optional parameters
}

// SharedPublicIPAddressConfiguration - Properties of a virtual machine that determine how it is connected to a load balancer.
type SharedPublicIPAddressConfiguration struct {
	// The incoming NAT rules
	InboundNatRules []*InboundNatRule `json:"inboundNatRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SharedPublicIPAddressConfiguration.
func (s SharedPublicIPAddressConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inboundNatRules", s.InboundNatRules)
	return json.Marshal(objectMap)
}

// ShutdownNotificationContent - The contents of a shutdown notification. Webhooks can use this type to deserialize the request body when they get notified
// of an imminent shutdown.
type ShutdownNotificationContent struct {
	// The URL to delay shutdown by 2 hours.
	DelayUrl120 *string `json:"delayUrl120,omitempty"`

	// The URL to delay shutdown by 60 minutes.
	DelayUrl60 *string `json:"delayUrl60,omitempty"`

	// The event for which a notification will be sent.
	EventType *string `json:"eventType,omitempty"`

	// The GUID for the virtual machine to be shut down.
	GUID *string `json:"guid,omitempty"`

	// The lab for the schedule.
	LabName *string `json:"labName,omitempty"`

	// Minutes remaining until shutdown
	MinutesUntilShutdown *string `json:"minutesUntilShutdown,omitempty"`

	// The owner of the virtual machine.
	Owner *string `json:"owner,omitempty"`

	// The resource group name for the schedule.
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// The URL to skip auto-shutdown.
	SkipURL *string `json:"skipUrl,omitempty"`

	// The subscription ID for the schedule.
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// The text for the notification.
	Text *string `json:"text,omitempty"`

	// The virtual machine to be shut down.
	VMName *string `json:"vmName,omitempty"`

	// The URL of the virtual machine.
	VMURL *string `json:"vmUrl,omitempty"`
}

// Subnet information.
type Subnet struct {
	// The permission policy of the subnet for allowing public IP addresses (i.e. Allow, Deny)).
	AllowPublicIP *UsagePermissionType `json:"allowPublicIp,omitempty"`

	// The name of the subnet as seen in the lab.
	LabSubnetName *string `json:"labSubnetName,omitempty"`

	// The resource ID of the subnet.
	ResourceID *string `json:"resourceId,omitempty"`
}

// SubnetOverride - Property overrides on a subnet of a virtual network.
type SubnetOverride struct {
	// The name given to the subnet within the lab.
	LabSubnetName *string `json:"labSubnetName,omitempty"`

	// The resource ID of the subnet.
	ResourceID *string `json:"resourceId,omitempty"`

	// Properties that virtual machines on this subnet will share.
	SharedPublicIPAddressConfiguration *SubnetSharedPublicIPAddressConfiguration `json:"sharedPublicIpAddressConfiguration,omitempty"`

	// Indicates whether this subnet can be used during virtual machine creation (i.e. Allow, Deny).
	UseInVMCreationPermission *UsagePermissionType `json:"useInVmCreationPermission,omitempty"`

	// Indicates whether public IP addresses can be assigned to virtual machines on this subnet (i.e. Allow, Deny).
	UsePublicIPAddressPermission *UsagePermissionType `json:"usePublicIpAddressPermission,omitempty"`

	// The virtual network pool associated with this subnet.
	VirtualNetworkPoolName *string `json:"virtualNetworkPoolName,omitempty"`
}

// SubnetSharedPublicIPAddressConfiguration - Configuration for public IP address sharing.
type SubnetSharedPublicIPAddressConfiguration struct {
	// Backend ports that virtual machines on this subnet are allowed to expose
	AllowedPorts []*Port `json:"allowedPorts,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubnetSharedPublicIPAddressConfiguration.
func (s SubnetSharedPublicIPAddressConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedPorts", s.AllowedPorts)
	return json.Marshal(objectMap)
}

// TargetCostProperties - Properties of a cost target.
type TargetCostProperties struct {
	// Cost thresholds.
	CostThresholds []*CostThresholdProperties `json:"costThresholds,omitempty"`

	// Reporting cycle end date.
	CycleEndDateTime *time.Time `json:"cycleEndDateTime,omitempty"`

	// Reporting cycle start date.
	CycleStartDateTime *time.Time `json:"cycleStartDateTime,omitempty"`

	// Reporting cycle type.
	CycleType *ReportingCycleType `json:"cycleType,omitempty"`

	// Target cost status
	Status *TargetCostStatus `json:"status,omitempty"`

	// Lab target cost
	Target *int32 `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TargetCostProperties.
func (t TargetCostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "costThresholds", t.CostThresholds)
	populateTimeRFC3339(objectMap, "cycleEndDateTime", t.CycleEndDateTime)
	populateTimeRFC3339(objectMap, "cycleStartDateTime", t.CycleStartDateTime)
	populate(objectMap, "cycleType", t.CycleType)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "target", t.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetCostProperties.
func (t *TargetCostProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costThresholds":
			err = unpopulate(val, &t.CostThresholds)
			delete(rawMsg, key)
		case "cycleEndDateTime":
			err = unpopulateTimeRFC3339(val, &t.CycleEndDateTime)
			delete(rawMsg, key)
		case "cycleStartDateTime":
			err = unpopulateTimeRFC3339(val, &t.CycleStartDateTime)
			delete(rawMsg, key)
		case "cycleType":
			err = unpopulate(val, &t.CycleType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &t.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UpdateResource - Represents an update resource
type UpdateResource struct {
	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateResource.
func (u UpdateResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (u UpdateResource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "tags", u.Tags)
}

// User - Profile of a lab user.
type User struct {
	Resource
	// The properties of the resource.
	Properties *UserProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type User.
func (u User) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UserFragment - Profile of a lab user.
type UserFragment struct {
	UpdateResource
}

// UserIdentity - Identity attributes of a lab user.
type UserIdentity struct {
	// Set to the app Id of the client JWT making the request.
	AppID *string `json:"appId,omitempty"`

	// Set to the object Id of the client JWT making the request. Not all users have object Id. For CSP (reseller) scenarios for example, object Id is not available.
	ObjectID *string `json:"objectId,omitempty"`

	// Set to the principal Id of the client JWT making the request. Service principal will not have the principal Id.
	PrincipalID *string `json:"principalId,omitempty"`

	// Set to the principal name / UPN of the client JWT making the request.
	PrincipalName *string `json:"principalName,omitempty"`

	// Set to the tenant ID of the client JWT making the request.
	TenantID *string `json:"tenantId,omitempty"`
}

// UserList - The response of a list operation.
type UserList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*User `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UserList.
func (u UserList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UserProperties - Properties of a lab user profile.
type UserProperties struct {
	// The identity of the user.
	Identity *UserIdentity `json:"identity,omitempty"`

	// The secret store of the user.
	SecretStore *UserSecretStore `json:"secretStore,omitempty"`

	// READ-ONLY; The creation date of the user profile.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UserProperties.
func (u UserProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdDate", u.CreatedDate)
	populate(objectMap, "identity", u.Identity)
	populate(objectMap, "provisioningState", u.ProvisioningState)
	populate(objectMap, "secretStore", u.SecretStore)
	populate(objectMap, "uniqueIdentifier", u.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserProperties.
func (u *UserProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &u.CreatedDate)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &u.Identity)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &u.ProvisioningState)
			delete(rawMsg, key)
		case "secretStore":
			err = unpopulate(val, &u.SecretStore)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &u.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UserSecretStore - Properties of a user's secret store.
type UserSecretStore struct {
	// The ID of the user's Key vault.
	KeyVaultID *string `json:"keyVaultId,omitempty"`

	// The URI of the user's Key vault.
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`
}

// UsersBeginCreateOrUpdateOptions contains the optional parameters for the Users.BeginCreateOrUpdate method.
type UsersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// UsersBeginDeleteOptions contains the optional parameters for the Users.BeginDelete method.
type UsersBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// UsersGetOptions contains the optional parameters for the Users.Get method.
type UsersGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=identity)'
	Expand *string
}

// UsersListOptions contains the optional parameters for the Users.List method.
type UsersListOptions struct {
	// Specify the $expand query. Example: 'properties($select=identity)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// UsersUpdateOptions contains the optional parameters for the Users.Update method.
type UsersUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineSchedulesBeginExecuteOptions contains the optional parameters for the VirtualMachineSchedules.BeginExecute method.
type VirtualMachineSchedulesBeginExecuteOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineSchedulesCreateOrUpdateOptions contains the optional parameters for the VirtualMachineSchedules.CreateOrUpdate method.
type VirtualMachineSchedulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineSchedulesDeleteOptions contains the optional parameters for the VirtualMachineSchedules.Delete method.
type VirtualMachineSchedulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineSchedulesGetOptions contains the optional parameters for the VirtualMachineSchedules.Get method.
type VirtualMachineSchedulesGetOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
}

// VirtualMachineSchedulesListOptions contains the optional parameters for the VirtualMachineSchedules.List method.
type VirtualMachineSchedulesListOptions struct {
	// Specify the $expand query. Example: 'properties($select=status)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// VirtualMachineSchedulesUpdateOptions contains the optional parameters for the VirtualMachineSchedules.Update method.
type VirtualMachineSchedulesUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginAddDataDiskOptions contains the optional parameters for the VirtualMachines.BeginAddDataDisk method.
type VirtualMachinesBeginAddDataDiskOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginApplyArtifactsOptions contains the optional parameters for the VirtualMachines.BeginApplyArtifacts method.
type VirtualMachinesBeginApplyArtifactsOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginClaimOptions contains the optional parameters for the VirtualMachines.BeginClaim method.
type VirtualMachinesBeginClaimOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginCreateOrUpdateOptions contains the optional parameters for the VirtualMachines.BeginCreateOrUpdate method.
type VirtualMachinesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginDeleteOptions contains the optional parameters for the VirtualMachines.BeginDelete method.
type VirtualMachinesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginDetachDataDiskOptions contains the optional parameters for the VirtualMachines.BeginDetachDataDisk method.
type VirtualMachinesBeginDetachDataDiskOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginRedeployOptions contains the optional parameters for the VirtualMachines.BeginRedeploy method.
type VirtualMachinesBeginRedeployOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginResizeOptions contains the optional parameters for the VirtualMachines.BeginResize method.
type VirtualMachinesBeginResizeOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginRestartOptions contains the optional parameters for the VirtualMachines.BeginRestart method.
type VirtualMachinesBeginRestartOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginStartOptions contains the optional parameters for the VirtualMachines.BeginStart method.
type VirtualMachinesBeginStartOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginStopOptions contains the optional parameters for the VirtualMachines.BeginStop method.
type VirtualMachinesBeginStopOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginTransferDisksOptions contains the optional parameters for the VirtualMachines.BeginTransferDisks method.
type VirtualMachinesBeginTransferDisksOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesBeginUnClaimOptions contains the optional parameters for the VirtualMachines.BeginUnClaim method.
type VirtualMachinesBeginUnClaimOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesGetOptions contains the optional parameters for the VirtualMachines.Get method.
type VirtualMachinesGetOptions struct {
	// Specify the $expand query. Example: 'properties($expand=artifacts,computeVm,networkInterface,applicableSchedule)'
	Expand *string
}

// VirtualMachinesGetRdpFileContentsOptions contains the optional parameters for the VirtualMachines.GetRdpFileContents method.
type VirtualMachinesGetRdpFileContentsOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesListApplicableSchedulesOptions contains the optional parameters for the VirtualMachines.ListApplicableSchedules method.
type VirtualMachinesListApplicableSchedulesOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesListOptions contains the optional parameters for the VirtualMachines.List method.
type VirtualMachinesListOptions struct {
	// Specify the $expand query. Example: 'properties($expand=artifacts,computeVm,networkInterface,applicableSchedule)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// VirtualMachinesUpdateOptions contains the optional parameters for the VirtualMachines.Update method.
type VirtualMachinesUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualNetwork - A virtual network.
type VirtualNetwork struct {
	Resource
	// The properties of the resource.
	Properties *VirtualNetworkProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetwork.
func (v VirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// VirtualNetworkFragment - A virtual network.
type VirtualNetworkFragment struct {
	UpdateResource
}

// VirtualNetworkList - The response of a list operation.
type VirtualNetworkList struct {
	// Link for next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Results of the list operation.
	Value []*VirtualNetwork `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkList.
func (v VirtualNetworkList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualNetworkProperties - Properties of a virtual network.
type VirtualNetworkProperties struct {
	// The allowed subnets of the virtual network.
	AllowedSubnets []*Subnet `json:"allowedSubnets,omitempty"`

	// The description of the virtual network.
	Description *string `json:"description,omitempty"`

	// The Microsoft.Network resource identifier of the virtual network.
	ExternalProviderResourceID *string `json:"externalProviderResourceId,omitempty"`

	// The subnet overrides of the virtual network.
	SubnetOverrides []*SubnetOverride `json:"subnetOverrides,omitempty"`

	// READ-ONLY; The creation date of the virtual network.
	CreatedDate *time.Time `json:"createdDate,omitempty" azure:"ro"`

	// READ-ONLY; The external subnet properties.
	ExternalSubnets []*ExternalSubnet `json:"externalSubnets,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning status of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The unique immutable identifier of a resource (Guid).
	UniqueIdentifier *string `json:"uniqueIdentifier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkProperties.
func (v VirtualNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedSubnets", v.AllowedSubnets)
	populateTimeRFC3339(objectMap, "createdDate", v.CreatedDate)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "externalProviderResourceId", v.ExternalProviderResourceID)
	populate(objectMap, "externalSubnets", v.ExternalSubnets)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "subnetOverrides", v.SubnetOverrides)
	populate(objectMap, "uniqueIdentifier", v.UniqueIdentifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkProperties.
func (v *VirtualNetworkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedSubnets":
			err = unpopulate(val, &v.AllowedSubnets)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &v.CreatedDate)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &v.Description)
			delete(rawMsg, key)
		case "externalProviderResourceId":
			err = unpopulate(val, &v.ExternalProviderResourceID)
			delete(rawMsg, key)
		case "externalSubnets":
			err = unpopulate(val, &v.ExternalSubnets)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		case "subnetOverrides":
			err = unpopulate(val, &v.SubnetOverrides)
			delete(rawMsg, key)
		case "uniqueIdentifier":
			err = unpopulate(val, &v.UniqueIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VirtualNetworksBeginCreateOrUpdateOptions contains the optional parameters for the VirtualNetworks.BeginCreateOrUpdate method.
type VirtualNetworksBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualNetworksBeginDeleteOptions contains the optional parameters for the VirtualNetworks.BeginDelete method.
type VirtualNetworksBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VirtualNetworksGetOptions contains the optional parameters for the VirtualNetworks.Get method.
type VirtualNetworksGetOptions struct {
	// Specify the $expand query. Example: 'properties($expand=externalSubnets)'
	Expand *string
}

// VirtualNetworksListOptions contains the optional parameters for the VirtualNetworks.List method.
type VirtualNetworksListOptions struct {
	// Specify the $expand query. Example: 'properties($expand=externalSubnets)'
	Expand *string
	// The filter to apply to the operation. Example: '$filter=contains(name,'myName')
	Filter *string
	// The ordering expression for the results, using OData notation. Example: '$orderby=name desc'
	Orderby *string
	// The maximum number of resources to return from the operation. Example: '$top=10'
	Top *int32
}

// VirtualNetworksUpdateOptions contains the optional parameters for the VirtualNetworks.Update method.
type VirtualNetworksUpdateOptions struct {
	// placeholder for future optional parameters
}

// WeekDetails - Properties of a weekly schedule.
type WeekDetails struct {
	// The time of the day the schedule will occur.
	Time *string `json:"time,omitempty"`

	// The days of the week for which the schedule is set (e.g. Sunday, Monday, Tuesday, etc.).
	Weekdays []*string `json:"weekdays,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WeekDetails.
func (w WeekDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "time", w.Time)
	populate(objectMap, "weekdays", w.Weekdays)
	return json.Marshal(objectMap)
}

// WindowsOsInfo - Information about a Windows OS.
type WindowsOsInfo struct {
	// The state of the Windows OS (i.e. NonSysprepped, SysprepRequested, SysprepApplied).
	WindowsOsState *WindowsOsState `json:"windowsOsState,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
