//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdevtestlabs

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// ArmTemplatesListPager provides operations for iterating over paged responses.
type ArmTemplatesListPager struct {
	client    *ArmTemplatesClient
	current   ArmTemplatesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ArmTemplatesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ArmTemplatesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ArmTemplatesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ArmTemplateList.NextLink == nil || len(*p.current.ArmTemplateList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ArmTemplatesListResponse page.
func (p *ArmTemplatesListPager) PageResponse() ArmTemplatesListResponse {
	return p.current
}

// ArtifactSourcesListPager provides operations for iterating over paged responses.
type ArtifactSourcesListPager struct {
	client    *ArtifactSourcesClient
	current   ArtifactSourcesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ArtifactSourcesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ArtifactSourcesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ArtifactSourcesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ArtifactSourceList.NextLink == nil || len(*p.current.ArtifactSourceList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ArtifactSourcesListResponse page.
func (p *ArtifactSourcesListPager) PageResponse() ArtifactSourcesListResponse {
	return p.current
}

// ArtifactsListPager provides operations for iterating over paged responses.
type ArtifactsListPager struct {
	client    *ArtifactsClient
	current   ArtifactsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ArtifactsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ArtifactsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ArtifactsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ArtifactList.NextLink == nil || len(*p.current.ArtifactList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ArtifactsListResponse page.
func (p *ArtifactsListPager) PageResponse() ArtifactsListResponse {
	return p.current
}

// CustomImagesListPager provides operations for iterating over paged responses.
type CustomImagesListPager struct {
	client    *CustomImagesClient
	current   CustomImagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomImagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomImagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomImagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomImageList.NextLink == nil || len(*p.current.CustomImageList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomImagesListResponse page.
func (p *CustomImagesListPager) PageResponse() CustomImagesListResponse {
	return p.current
}

// DisksListPager provides operations for iterating over paged responses.
type DisksListPager struct {
	client    *DisksClient
	current   DisksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DisksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DisksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DisksListResponse page.
func (p *DisksListPager) PageResponse() DisksListResponse {
	return p.current
}

// EnvironmentsListPager provides operations for iterating over paged responses.
type EnvironmentsListPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DtlEnvironmentList.NextLink == nil || len(*p.current.DtlEnvironmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsListResponse page.
func (p *EnvironmentsListPager) PageResponse() EnvironmentsListResponse {
	return p.current
}

// FormulasListPager provides operations for iterating over paged responses.
type FormulasListPager struct {
	client    *FormulasClient
	current   FormulasListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FormulasListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FormulasListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FormulasListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FormulaList.NextLink == nil || len(*p.current.FormulaList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FormulasListResponse page.
func (p *FormulasListPager) PageResponse() FormulasListResponse {
	return p.current
}

// GalleryImagesListPager provides operations for iterating over paged responses.
type GalleryImagesListPager struct {
	client    *GalleryImagesClient
	current   GalleryImagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryImagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryImagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryImagesListResponse page.
func (p *GalleryImagesListPager) PageResponse() GalleryImagesListResponse {
	return p.current
}

// GlobalSchedulesListByResourceGroupPager provides operations for iterating over paged responses.
type GlobalSchedulesListByResourceGroupPager struct {
	client    *GlobalSchedulesClient
	current   GlobalSchedulesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalSchedulesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GlobalSchedulesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GlobalSchedulesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GlobalSchedulesListByResourceGroupResponse page.
func (p *GlobalSchedulesListByResourceGroupPager) PageResponse() GlobalSchedulesListByResourceGroupResponse {
	return p.current
}

// GlobalSchedulesListBySubscriptionPager provides operations for iterating over paged responses.
type GlobalSchedulesListBySubscriptionPager struct {
	client    *GlobalSchedulesClient
	current   GlobalSchedulesListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalSchedulesListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GlobalSchedulesListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GlobalSchedulesListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GlobalSchedulesListBySubscriptionResponse page.
func (p *GlobalSchedulesListBySubscriptionPager) PageResponse() GlobalSchedulesListBySubscriptionResponse {
	return p.current
}

// LabsListByResourceGroupPager provides operations for iterating over paged responses.
type LabsListByResourceGroupPager struct {
	client    *LabsClient
	current   LabsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LabsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LabsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LabsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabList.NextLink == nil || len(*p.current.LabList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LabsListByResourceGroupResponse page.
func (p *LabsListByResourceGroupPager) PageResponse() LabsListByResourceGroupResponse {
	return p.current
}

// LabsListBySubscriptionPager provides operations for iterating over paged responses.
type LabsListBySubscriptionPager struct {
	client    *LabsClient
	current   LabsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LabsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LabsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LabsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabList.NextLink == nil || len(*p.current.LabList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LabsListBySubscriptionResponse page.
func (p *LabsListBySubscriptionPager) PageResponse() LabsListBySubscriptionResponse {
	return p.current
}

// LabsListVhdsPager provides operations for iterating over paged responses.
type LabsListVhdsPager struct {
	client    *LabsClient
	current   LabsListVhdsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LabsListVhdsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LabsListVhdsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LabsListVhdsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabVhdList.NextLink == nil || len(*p.current.LabVhdList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listVhdsHandleError(resp)
		return false
	}
	result, err := p.client.listVhdsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LabsListVhdsResponse page.
func (p *LabsListVhdsPager) PageResponse() LabsListVhdsResponse {
	return p.current
}

// NotificationChannelsListPager provides operations for iterating over paged responses.
type NotificationChannelsListPager struct {
	client    *NotificationChannelsClient
	current   NotificationChannelsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NotificationChannelsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NotificationChannelsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NotificationChannelsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotificationChannelList.NextLink == nil || len(*p.current.NotificationChannelList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NotificationChannelsListResponse page.
func (p *NotificationChannelsListPager) PageResponse() NotificationChannelsListResponse {
	return p.current
}

// PoliciesListPager provides operations for iterating over paged responses.
type PoliciesListPager struct {
	client    *PoliciesClient
	current   PoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyList.NextLink == nil || len(*p.current.PolicyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PoliciesListResponse page.
func (p *PoliciesListPager) PageResponse() PoliciesListResponse {
	return p.current
}

// ProviderOperationsListPager provides operations for iterating over paged responses.
type ProviderOperationsListPager struct {
	client    *ProviderOperationsClient
	current   ProviderOperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderOperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderOperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderOperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderOperationResult.NextLink == nil || len(*p.current.ProviderOperationResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderOperationsListResponse page.
func (p *ProviderOperationsListPager) PageResponse() ProviderOperationsListResponse {
	return p.current
}

// SchedulesListApplicablePager provides operations for iterating over paged responses.
type SchedulesListApplicablePager struct {
	client    *SchedulesClient
	current   SchedulesListApplicableResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SchedulesListApplicableResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SchedulesListApplicablePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SchedulesListApplicablePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listApplicableHandleError(resp)
		return false
	}
	result, err := p.client.listApplicableHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SchedulesListApplicableResponse page.
func (p *SchedulesListApplicablePager) PageResponse() SchedulesListApplicableResponse {
	return p.current
}

// SchedulesListPager provides operations for iterating over paged responses.
type SchedulesListPager struct {
	client    *SchedulesClient
	current   SchedulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SchedulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SchedulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SchedulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SchedulesListResponse page.
func (p *SchedulesListPager) PageResponse() SchedulesListResponse {
	return p.current
}

// SecretsListPager provides operations for iterating over paged responses.
type SecretsListPager struct {
	client    *SecretsClient
	current   SecretsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecretsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecretsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecretsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecretList.NextLink == nil || len(*p.current.SecretList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecretsListResponse page.
func (p *SecretsListPager) PageResponse() SecretsListResponse {
	return p.current
}

// ServiceFabricSchedulesListPager provides operations for iterating over paged responses.
type ServiceFabricSchedulesListPager struct {
	client    *ServiceFabricSchedulesClient
	current   ServiceFabricSchedulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceFabricSchedulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceFabricSchedulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceFabricSchedulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceFabricSchedulesListResponse page.
func (p *ServiceFabricSchedulesListPager) PageResponse() ServiceFabricSchedulesListResponse {
	return p.current
}

// ServiceFabricsListPager provides operations for iterating over paged responses.
type ServiceFabricsListPager struct {
	client    *ServiceFabricsClient
	current   ServiceFabricsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceFabricsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceFabricsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceFabricsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceFabricList.NextLink == nil || len(*p.current.ServiceFabricList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceFabricsListResponse page.
func (p *ServiceFabricsListPager) PageResponse() ServiceFabricsListResponse {
	return p.current
}

// UsersListPager provides operations for iterating over paged responses.
type UsersListPager struct {
	client    *UsersClient
	current   UsersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserList.NextLink == nil || len(*p.current.UserList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsersListResponse page.
func (p *UsersListPager) PageResponse() UsersListResponse {
	return p.current
}

// VirtualMachineSchedulesListPager provides operations for iterating over paged responses.
type VirtualMachineSchedulesListPager struct {
	client    *VirtualMachineSchedulesClient
	current   VirtualMachineSchedulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineSchedulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineSchedulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineSchedulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineSchedulesListResponse page.
func (p *VirtualMachineSchedulesListPager) PageResponse() VirtualMachineSchedulesListResponse {
	return p.current
}

// VirtualMachinesListPager provides operations for iterating over paged responses.
type VirtualMachinesListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabVirtualMachineList.NextLink == nil || len(*p.current.LabVirtualMachineList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesListResponse page.
func (p *VirtualMachinesListPager) PageResponse() VirtualMachinesListResponse {
	return p.current
}

// VirtualNetworksListPager provides operations for iterating over paged responses.
type VirtualNetworksListPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkList.NextLink == nil || len(*p.current.VirtualNetworkList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksListResponse page.
func (p *VirtualNetworksListPager) PageResponse() VirtualNetworksListResponse {
	return p.current
}
