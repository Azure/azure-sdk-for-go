//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdevtestlabs

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ArmTemplatesGetResponse contains the response from method ArmTemplates.Get.
type ArmTemplatesGetResponse struct {
	ArmTemplatesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArmTemplatesGetResult contains the result from method ArmTemplates.Get.
type ArmTemplatesGetResult struct {
	ArmTemplate
}

// ArmTemplatesListResponse contains the response from method ArmTemplates.List.
type ArmTemplatesListResponse struct {
	ArmTemplatesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArmTemplatesListResult contains the result from method ArmTemplates.List.
type ArmTemplatesListResult struct {
	ArmTemplateList
}

// ArtifactSourcesCreateOrUpdateResponse contains the response from method ArtifactSources.CreateOrUpdate.
type ArtifactSourcesCreateOrUpdateResponse struct {
	ArtifactSourcesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactSourcesCreateOrUpdateResult contains the result from method ArtifactSources.CreateOrUpdate.
type ArtifactSourcesCreateOrUpdateResult struct {
	ArtifactSource
}

// ArtifactSourcesDeleteResponse contains the response from method ArtifactSources.Delete.
type ArtifactSourcesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactSourcesGetResponse contains the response from method ArtifactSources.Get.
type ArtifactSourcesGetResponse struct {
	ArtifactSourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactSourcesGetResult contains the result from method ArtifactSources.Get.
type ArtifactSourcesGetResult struct {
	ArtifactSource
}

// ArtifactSourcesListResponse contains the response from method ArtifactSources.List.
type ArtifactSourcesListResponse struct {
	ArtifactSourcesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactSourcesListResult contains the result from method ArtifactSources.List.
type ArtifactSourcesListResult struct {
	ArtifactSourceList
}

// ArtifactSourcesUpdateResponse contains the response from method ArtifactSources.Update.
type ArtifactSourcesUpdateResponse struct {
	ArtifactSourcesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactSourcesUpdateResult contains the result from method ArtifactSources.Update.
type ArtifactSourcesUpdateResult struct {
	ArtifactSource
}

// ArtifactsGenerateArmTemplateResponse contains the response from method Artifacts.GenerateArmTemplate.
type ArtifactsGenerateArmTemplateResponse struct {
	ArtifactsGenerateArmTemplateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactsGenerateArmTemplateResult contains the result from method Artifacts.GenerateArmTemplate.
type ArtifactsGenerateArmTemplateResult struct {
	ArmTemplateInfo
}

// ArtifactsGetResponse contains the response from method Artifacts.Get.
type ArtifactsGetResponse struct {
	ArtifactsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactsGetResult contains the result from method Artifacts.Get.
type ArtifactsGetResult struct {
	Artifact
}

// ArtifactsListResponse contains the response from method Artifacts.List.
type ArtifactsListResponse struct {
	ArtifactsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ArtifactsListResult contains the result from method Artifacts.List.
type ArtifactsListResult struct {
	ArtifactList
}

// CostsCreateOrUpdateResponse contains the response from method Costs.CreateOrUpdate.
type CostsCreateOrUpdateResponse struct {
	CostsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CostsCreateOrUpdateResult contains the result from method Costs.CreateOrUpdate.
type CostsCreateOrUpdateResult struct {
	LabCost
}

// CostsGetResponse contains the response from method Costs.Get.
type CostsGetResponse struct {
	CostsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CostsGetResult contains the result from method Costs.Get.
type CostsGetResult struct {
	LabCost
}

// CustomImagesCreateOrUpdatePollerResponse contains the response from method CustomImages.CreateOrUpdate.
type CustomImagesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomImagesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomImagesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomImagesCreateOrUpdateResponse, error) {
	respType := CustomImagesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomImage)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomImagesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CustomImagesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CustomImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomImagesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CustomImagesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomImagesCreateOrUpdateResponse contains the response from method CustomImages.CreateOrUpdate.
type CustomImagesCreateOrUpdateResponse struct {
	CustomImagesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomImagesCreateOrUpdateResult contains the result from method CustomImages.CreateOrUpdate.
type CustomImagesCreateOrUpdateResult struct {
	CustomImage
}

// CustomImagesDeletePollerResponse contains the response from method CustomImages.Delete.
type CustomImagesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomImagesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomImagesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomImagesDeleteResponse, error) {
	respType := CustomImagesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomImagesDeletePollerResponse from the provided client and resume token.
func (l *CustomImagesDeletePollerResponse) Resume(ctx context.Context, client *CustomImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomImagesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CustomImagesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomImagesDeleteResponse contains the response from method CustomImages.Delete.
type CustomImagesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomImagesGetResponse contains the response from method CustomImages.Get.
type CustomImagesGetResponse struct {
	CustomImagesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomImagesGetResult contains the result from method CustomImages.Get.
type CustomImagesGetResult struct {
	CustomImage
}

// CustomImagesListResponse contains the response from method CustomImages.List.
type CustomImagesListResponse struct {
	CustomImagesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomImagesListResult contains the result from method CustomImages.List.
type CustomImagesListResult struct {
	CustomImageList
}

// CustomImagesUpdateResponse contains the response from method CustomImages.Update.
type CustomImagesUpdateResponse struct {
	CustomImagesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomImagesUpdateResult contains the result from method CustomImages.Update.
type CustomImagesUpdateResult struct {
	CustomImage
}

// DisksAttachPollerResponse contains the response from method Disks.Attach.
type DisksAttachPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksAttachPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksAttachPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksAttachResponse, error) {
	respType := DisksAttachResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksAttachPollerResponse from the provided client and resume token.
func (l *DisksAttachPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Attach", token, client.pl, client.attachHandleError)
	if err != nil {
		return err
	}
	poller := &DisksAttachPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksAttachResponse contains the response from method Disks.Attach.
type DisksAttachResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksCreateOrUpdatePollerResponse contains the response from method Disks.CreateOrUpdate.
type DisksCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksCreateOrUpdateResponse, error) {
	respType := DisksCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Disk)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DisksCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DisksCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksCreateOrUpdateResponse contains the response from method Disks.CreateOrUpdate.
type DisksCreateOrUpdateResponse struct {
	DisksCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksCreateOrUpdateResult contains the result from method Disks.CreateOrUpdate.
type DisksCreateOrUpdateResult struct {
	Disk
}

// DisksDeletePollerResponse contains the response from method Disks.Delete.
type DisksDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksDeleteResponse, error) {
	respType := DisksDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksDeletePollerResponse from the provided client and resume token.
func (l *DisksDeletePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DisksDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksDeleteResponse contains the response from method Disks.Delete.
type DisksDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksDetachPollerResponse contains the response from method Disks.Detach.
type DisksDetachPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksDetachPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksDetachPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksDetachResponse, error) {
	respType := DisksDetachResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksDetachPollerResponse from the provided client and resume token.
func (l *DisksDetachPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Detach", token, client.pl, client.detachHandleError)
	if err != nil {
		return err
	}
	poller := &DisksDetachPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksDetachResponse contains the response from method Disks.Detach.
type DisksDetachResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksGetResponse contains the response from method Disks.Get.
type DisksGetResponse struct {
	DisksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksGetResult contains the result from method Disks.Get.
type DisksGetResult struct {
	Disk
}

// DisksListResponse contains the response from method Disks.List.
type DisksListResponse struct {
	DisksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksListResult contains the result from method Disks.List.
type DisksListResult struct {
	DiskList
}

// DisksUpdateResponse contains the response from method Disks.Update.
type DisksUpdateResponse struct {
	DisksUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksUpdateResult contains the result from method Disks.Update.
type DisksUpdateResult struct {
	Disk
}

// EnvironmentsCreateOrUpdatePollerResponse contains the response from method Environments.CreateOrUpdate.
type EnvironmentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EnvironmentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EnvironmentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EnvironmentsCreateOrUpdateResponse, error) {
	respType := EnvironmentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DtlEnvironment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EnvironmentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *EnvironmentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *EnvironmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EnvironmentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &EnvironmentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EnvironmentsCreateOrUpdateResponse contains the response from method Environments.CreateOrUpdate.
type EnvironmentsCreateOrUpdateResponse struct {
	EnvironmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EnvironmentsCreateOrUpdateResult contains the result from method Environments.CreateOrUpdate.
type EnvironmentsCreateOrUpdateResult struct {
	DtlEnvironment
}

// EnvironmentsDeletePollerResponse contains the response from method Environments.Delete.
type EnvironmentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EnvironmentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EnvironmentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EnvironmentsDeleteResponse, error) {
	respType := EnvironmentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EnvironmentsDeletePollerResponse from the provided client and resume token.
func (l *EnvironmentsDeletePollerResponse) Resume(ctx context.Context, client *EnvironmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EnvironmentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &EnvironmentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EnvironmentsDeleteResponse contains the response from method Environments.Delete.
type EnvironmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EnvironmentsGetResponse contains the response from method Environments.Get.
type EnvironmentsGetResponse struct {
	EnvironmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EnvironmentsGetResult contains the result from method Environments.Get.
type EnvironmentsGetResult struct {
	DtlEnvironment
}

// EnvironmentsListResponse contains the response from method Environments.List.
type EnvironmentsListResponse struct {
	EnvironmentsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EnvironmentsListResult contains the result from method Environments.List.
type EnvironmentsListResult struct {
	DtlEnvironmentList
}

// EnvironmentsUpdateResponse contains the response from method Environments.Update.
type EnvironmentsUpdateResponse struct {
	EnvironmentsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EnvironmentsUpdateResult contains the result from method Environments.Update.
type EnvironmentsUpdateResult struct {
	DtlEnvironment
}

// FormulasCreateOrUpdatePollerResponse contains the response from method Formulas.CreateOrUpdate.
type FormulasCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FormulasCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FormulasCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FormulasCreateOrUpdateResponse, error) {
	respType := FormulasCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Formula)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FormulasCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FormulasCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FormulasClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FormulasClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FormulasCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FormulasCreateOrUpdateResponse contains the response from method Formulas.CreateOrUpdate.
type FormulasCreateOrUpdateResponse struct {
	FormulasCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FormulasCreateOrUpdateResult contains the result from method Formulas.CreateOrUpdate.
type FormulasCreateOrUpdateResult struct {
	Formula
}

// FormulasDeleteResponse contains the response from method Formulas.Delete.
type FormulasDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FormulasGetResponse contains the response from method Formulas.Get.
type FormulasGetResponse struct {
	FormulasGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FormulasGetResult contains the result from method Formulas.Get.
type FormulasGetResult struct {
	Formula
}

// FormulasListResponse contains the response from method Formulas.List.
type FormulasListResponse struct {
	FormulasListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FormulasListResult contains the result from method Formulas.List.
type FormulasListResult struct {
	FormulaList
}

// FormulasUpdateResponse contains the response from method Formulas.Update.
type FormulasUpdateResponse struct {
	FormulasUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FormulasUpdateResult contains the result from method Formulas.Update.
type FormulasUpdateResult struct {
	Formula
}

// GalleryImagesListResponse contains the response from method GalleryImages.List.
type GalleryImagesListResponse struct {
	GalleryImagesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GalleryImagesListResult contains the result from method GalleryImages.List.
type GalleryImagesListResult struct {
	GalleryImageList
}

// GlobalSchedulesCreateOrUpdateResponse contains the response from method GlobalSchedules.CreateOrUpdate.
type GlobalSchedulesCreateOrUpdateResponse struct {
	GlobalSchedulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesCreateOrUpdateResult contains the result from method GlobalSchedules.CreateOrUpdate.
type GlobalSchedulesCreateOrUpdateResult struct {
	Schedule
}

// GlobalSchedulesDeleteResponse contains the response from method GlobalSchedules.Delete.
type GlobalSchedulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesExecutePollerResponse contains the response from method GlobalSchedules.Execute.
type GlobalSchedulesExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GlobalSchedulesExecutePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GlobalSchedulesExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GlobalSchedulesExecuteResponse, error) {
	respType := GlobalSchedulesExecuteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GlobalSchedulesExecutePollerResponse from the provided client and resume token.
func (l *GlobalSchedulesExecutePollerResponse) Resume(ctx context.Context, client *GlobalSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GlobalSchedulesClient.Execute", token, client.pl, client.executeHandleError)
	if err != nil {
		return err
	}
	poller := &GlobalSchedulesExecutePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GlobalSchedulesExecuteResponse contains the response from method GlobalSchedules.Execute.
type GlobalSchedulesExecuteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesGetResponse contains the response from method GlobalSchedules.Get.
type GlobalSchedulesGetResponse struct {
	GlobalSchedulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesGetResult contains the result from method GlobalSchedules.Get.
type GlobalSchedulesGetResult struct {
	Schedule
}

// GlobalSchedulesListByResourceGroupResponse contains the response from method GlobalSchedules.ListByResourceGroup.
type GlobalSchedulesListByResourceGroupResponse struct {
	GlobalSchedulesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesListByResourceGroupResult contains the result from method GlobalSchedules.ListByResourceGroup.
type GlobalSchedulesListByResourceGroupResult struct {
	ScheduleList
}

// GlobalSchedulesListBySubscriptionResponse contains the response from method GlobalSchedules.ListBySubscription.
type GlobalSchedulesListBySubscriptionResponse struct {
	GlobalSchedulesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesListBySubscriptionResult contains the result from method GlobalSchedules.ListBySubscription.
type GlobalSchedulesListBySubscriptionResult struct {
	ScheduleList
}

// GlobalSchedulesRetargetPollerResponse contains the response from method GlobalSchedules.Retarget.
type GlobalSchedulesRetargetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GlobalSchedulesRetargetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GlobalSchedulesRetargetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GlobalSchedulesRetargetResponse, error) {
	respType := GlobalSchedulesRetargetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GlobalSchedulesRetargetPollerResponse from the provided client and resume token.
func (l *GlobalSchedulesRetargetPollerResponse) Resume(ctx context.Context, client *GlobalSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GlobalSchedulesClient.Retarget", token, client.pl, client.retargetHandleError)
	if err != nil {
		return err
	}
	poller := &GlobalSchedulesRetargetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GlobalSchedulesRetargetResponse contains the response from method GlobalSchedules.Retarget.
type GlobalSchedulesRetargetResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesUpdateResponse contains the response from method GlobalSchedules.Update.
type GlobalSchedulesUpdateResponse struct {
	GlobalSchedulesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalSchedulesUpdateResult contains the result from method GlobalSchedules.Update.
type GlobalSchedulesUpdateResult struct {
	Schedule
}

// LabsClaimAnyVMPollerResponse contains the response from method Labs.ClaimAnyVM.
type LabsClaimAnyVMPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClaimAnyVMPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClaimAnyVMPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClaimAnyVMResponse, error) {
	respType := LabsClaimAnyVMResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsClaimAnyVMPollerResponse from the provided client and resume token.
func (l *LabsClaimAnyVMPollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.ClaimAnyVM", token, client.pl, client.claimAnyVMHandleError)
	if err != nil {
		return err
	}
	poller := &LabsClaimAnyVMPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsClaimAnyVMResponse contains the response from method Labs.ClaimAnyVM.
type LabsClaimAnyVMResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsCreateEnvironmentPollerResponse contains the response from method Labs.CreateEnvironment.
type LabsCreateEnvironmentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsCreateEnvironmentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsCreateEnvironmentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsCreateEnvironmentResponse, error) {
	respType := LabsCreateEnvironmentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsCreateEnvironmentPollerResponse from the provided client and resume token.
func (l *LabsCreateEnvironmentPollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.CreateEnvironment", token, client.pl, client.createEnvironmentHandleError)
	if err != nil {
		return err
	}
	poller := &LabsCreateEnvironmentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsCreateEnvironmentResponse contains the response from method Labs.CreateEnvironment.
type LabsCreateEnvironmentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsCreateOrUpdatePollerResponse contains the response from method Labs.CreateOrUpdate.
type LabsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsCreateOrUpdateResponse, error) {
	respType := LabsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Lab)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LabsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LabsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsCreateOrUpdateResponse contains the response from method Labs.CreateOrUpdate.
type LabsCreateOrUpdateResponse struct {
	LabsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsCreateOrUpdateResult contains the result from method Labs.CreateOrUpdate.
type LabsCreateOrUpdateResult struct {
	Lab
}

// LabsDeletePollerResponse contains the response from method Labs.Delete.
type LabsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsDeleteResponse, error) {
	respType := LabsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsDeletePollerResponse from the provided client and resume token.
func (l *LabsDeletePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LabsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsDeleteResponse contains the response from method Labs.Delete.
type LabsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsExportResourceUsagePollerResponse contains the response from method Labs.ExportResourceUsage.
type LabsExportResourceUsagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsExportResourceUsagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsExportResourceUsagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsExportResourceUsageResponse, error) {
	respType := LabsExportResourceUsageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsExportResourceUsagePollerResponse from the provided client and resume token.
func (l *LabsExportResourceUsagePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.ExportResourceUsage", token, client.pl, client.exportResourceUsageHandleError)
	if err != nil {
		return err
	}
	poller := &LabsExportResourceUsagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsExportResourceUsageResponse contains the response from method Labs.ExportResourceUsage.
type LabsExportResourceUsageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsGenerateUploadURIResponse contains the response from method Labs.GenerateUploadURI.
type LabsGenerateUploadURIResponse struct {
	LabsGenerateUploadURIResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsGenerateUploadURIResult contains the result from method Labs.GenerateUploadURI.
type LabsGenerateUploadURIResult struct {
	GenerateUploadURIResponse
}

// LabsGetResponse contains the response from method Labs.Get.
type LabsGetResponse struct {
	LabsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsGetResult contains the result from method Labs.Get.
type LabsGetResult struct {
	Lab
}

// LabsImportVirtualMachinePollerResponse contains the response from method Labs.ImportVirtualMachine.
type LabsImportVirtualMachinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsImportVirtualMachinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsImportVirtualMachinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsImportVirtualMachineResponse, error) {
	respType := LabsImportVirtualMachineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsImportVirtualMachinePollerResponse from the provided client and resume token.
func (l *LabsImportVirtualMachinePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.ImportVirtualMachine", token, client.pl, client.importVirtualMachineHandleError)
	if err != nil {
		return err
	}
	poller := &LabsImportVirtualMachinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsImportVirtualMachineResponse contains the response from method Labs.ImportVirtualMachine.
type LabsImportVirtualMachineResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsListByResourceGroupResponse contains the response from method Labs.ListByResourceGroup.
type LabsListByResourceGroupResponse struct {
	LabsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsListByResourceGroupResult contains the result from method Labs.ListByResourceGroup.
type LabsListByResourceGroupResult struct {
	LabList
}

// LabsListBySubscriptionResponse contains the response from method Labs.ListBySubscription.
type LabsListBySubscriptionResponse struct {
	LabsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsListBySubscriptionResult contains the result from method Labs.ListBySubscription.
type LabsListBySubscriptionResult struct {
	LabList
}

// LabsListVhdsResponse contains the response from method Labs.ListVhds.
type LabsListVhdsResponse struct {
	LabsListVhdsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsListVhdsResult contains the result from method Labs.ListVhds.
type LabsListVhdsResult struct {
	LabVhdList
}

// LabsUpdateResponse contains the response from method Labs.Update.
type LabsUpdateResponse struct {
	LabsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsUpdateResult contains the result from method Labs.Update.
type LabsUpdateResult struct {
	Lab
}

// NotificationChannelsCreateOrUpdateResponse contains the response from method NotificationChannels.CreateOrUpdate.
type NotificationChannelsCreateOrUpdateResponse struct {
	NotificationChannelsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotificationChannelsCreateOrUpdateResult contains the result from method NotificationChannels.CreateOrUpdate.
type NotificationChannelsCreateOrUpdateResult struct {
	NotificationChannel
}

// NotificationChannelsDeleteResponse contains the response from method NotificationChannels.Delete.
type NotificationChannelsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotificationChannelsGetResponse contains the response from method NotificationChannels.Get.
type NotificationChannelsGetResponse struct {
	NotificationChannelsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotificationChannelsGetResult contains the result from method NotificationChannels.Get.
type NotificationChannelsGetResult struct {
	NotificationChannel
}

// NotificationChannelsListResponse contains the response from method NotificationChannels.List.
type NotificationChannelsListResponse struct {
	NotificationChannelsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotificationChannelsListResult contains the result from method NotificationChannels.List.
type NotificationChannelsListResult struct {
	NotificationChannelList
}

// NotificationChannelsNotifyResponse contains the response from method NotificationChannels.Notify.
type NotificationChannelsNotifyResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotificationChannelsUpdateResponse contains the response from method NotificationChannels.Update.
type NotificationChannelsUpdateResponse struct {
	NotificationChannelsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotificationChannelsUpdateResult contains the result from method NotificationChannels.Update.
type NotificationChannelsUpdateResult struct {
	NotificationChannel
}

// OperationsGetResponse contains the response from method Operations.Get.
type OperationsGetResponse struct {
	OperationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsGetResult contains the result from method Operations.Get.
type OperationsGetResult struct {
	OperationResult
}

// PoliciesCreateOrUpdateResponse contains the response from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdateResponse struct {
	PoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesCreateOrUpdateResult contains the result from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdateResult struct {
	Policy
}

// PoliciesDeleteResponse contains the response from method Policies.Delete.
type PoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesGetResponse contains the response from method Policies.Get.
type PoliciesGetResponse struct {
	PoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesGetResult contains the result from method Policies.Get.
type PoliciesGetResult struct {
	Policy
}

// PoliciesListResponse contains the response from method Policies.List.
type PoliciesListResponse struct {
	PoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesListResult contains the result from method Policies.List.
type PoliciesListResult struct {
	PolicyList
}

// PoliciesUpdateResponse contains the response from method Policies.Update.
type PoliciesUpdateResponse struct {
	PoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesUpdateResult contains the result from method Policies.Update.
type PoliciesUpdateResult struct {
	Policy
}

// PolicySetsEvaluatePoliciesResponse contains the response from method PolicySets.EvaluatePolicies.
type PolicySetsEvaluatePoliciesResponse struct {
	PolicySetsEvaluatePoliciesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PolicySetsEvaluatePoliciesResult contains the result from method PolicySets.EvaluatePolicies.
type PolicySetsEvaluatePoliciesResult struct {
	EvaluatePoliciesResponse
}

// ProviderOperationsListResponse contains the response from method ProviderOperations.List.
type ProviderOperationsListResponse struct {
	ProviderOperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProviderOperationsListResult contains the result from method ProviderOperations.List.
type ProviderOperationsListResult struct {
	ProviderOperationResult
}

// SchedulesCreateOrUpdateResponse contains the response from method Schedules.CreateOrUpdate.
type SchedulesCreateOrUpdateResponse struct {
	SchedulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesCreateOrUpdateResult contains the result from method Schedules.CreateOrUpdate.
type SchedulesCreateOrUpdateResult struct {
	Schedule
}

// SchedulesDeleteResponse contains the response from method Schedules.Delete.
type SchedulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesExecutePollerResponse contains the response from method Schedules.Execute.
type SchedulesExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SchedulesExecutePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SchedulesExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SchedulesExecuteResponse, error) {
	respType := SchedulesExecuteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SchedulesExecutePollerResponse from the provided client and resume token.
func (l *SchedulesExecutePollerResponse) Resume(ctx context.Context, client *SchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SchedulesClient.Execute", token, client.pl, client.executeHandleError)
	if err != nil {
		return err
	}
	poller := &SchedulesExecutePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SchedulesExecuteResponse contains the response from method Schedules.Execute.
type SchedulesExecuteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesGetResponse contains the response from method Schedules.Get.
type SchedulesGetResponse struct {
	SchedulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesGetResult contains the result from method Schedules.Get.
type SchedulesGetResult struct {
	Schedule
}

// SchedulesListApplicableResponse contains the response from method Schedules.ListApplicable.
type SchedulesListApplicableResponse struct {
	SchedulesListApplicableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesListApplicableResult contains the result from method Schedules.ListApplicable.
type SchedulesListApplicableResult struct {
	ScheduleList
}

// SchedulesListResponse contains the response from method Schedules.List.
type SchedulesListResponse struct {
	SchedulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesListResult contains the result from method Schedules.List.
type SchedulesListResult struct {
	ScheduleList
}

// SchedulesUpdateResponse contains the response from method Schedules.Update.
type SchedulesUpdateResponse struct {
	SchedulesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesUpdateResult contains the result from method Schedules.Update.
type SchedulesUpdateResult struct {
	Schedule
}

// SecretsCreateOrUpdatePollerResponse contains the response from method Secrets.CreateOrUpdate.
type SecretsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsCreateOrUpdateResponse, error) {
	respType := SecretsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecretsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecretsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SecretsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecretsCreateOrUpdateResponse contains the response from method Secrets.CreateOrUpdate.
type SecretsCreateOrUpdateResponse struct {
	SecretsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsCreateOrUpdateResult contains the result from method Secrets.CreateOrUpdate.
type SecretsCreateOrUpdateResult struct {
	Secret
}

// SecretsDeleteResponse contains the response from method Secrets.Delete.
type SecretsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsGetResponse contains the response from method Secrets.Get.
type SecretsGetResponse struct {
	SecretsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsGetResult contains the result from method Secrets.Get.
type SecretsGetResult struct {
	Secret
}

// SecretsListResponse contains the response from method Secrets.List.
type SecretsListResponse struct {
	SecretsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsListResult contains the result from method Secrets.List.
type SecretsListResult struct {
	SecretList
}

// SecretsUpdateResponse contains the response from method Secrets.Update.
type SecretsUpdateResponse struct {
	SecretsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecretsUpdateResult contains the result from method Secrets.Update.
type SecretsUpdateResult struct {
	Secret
}

// ServiceFabricSchedulesCreateOrUpdateResponse contains the response from method ServiceFabricSchedules.CreateOrUpdate.
type ServiceFabricSchedulesCreateOrUpdateResponse struct {
	ServiceFabricSchedulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricSchedulesCreateOrUpdateResult contains the result from method ServiceFabricSchedules.CreateOrUpdate.
type ServiceFabricSchedulesCreateOrUpdateResult struct {
	Schedule
}

// ServiceFabricSchedulesDeleteResponse contains the response from method ServiceFabricSchedules.Delete.
type ServiceFabricSchedulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricSchedulesExecutePollerResponse contains the response from method ServiceFabricSchedules.Execute.
type ServiceFabricSchedulesExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricSchedulesExecutePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricSchedulesExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricSchedulesExecuteResponse, error) {
	respType := ServiceFabricSchedulesExecuteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceFabricSchedulesExecutePollerResponse from the provided client and resume token.
func (l *ServiceFabricSchedulesExecutePollerResponse) Resume(ctx context.Context, client *ServiceFabricSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricSchedulesClient.Execute", token, client.pl, client.executeHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceFabricSchedulesExecutePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceFabricSchedulesExecuteResponse contains the response from method ServiceFabricSchedules.Execute.
type ServiceFabricSchedulesExecuteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricSchedulesGetResponse contains the response from method ServiceFabricSchedules.Get.
type ServiceFabricSchedulesGetResponse struct {
	ServiceFabricSchedulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricSchedulesGetResult contains the result from method ServiceFabricSchedules.Get.
type ServiceFabricSchedulesGetResult struct {
	Schedule
}

// ServiceFabricSchedulesListResponse contains the response from method ServiceFabricSchedules.List.
type ServiceFabricSchedulesListResponse struct {
	ServiceFabricSchedulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricSchedulesListResult contains the result from method ServiceFabricSchedules.List.
type ServiceFabricSchedulesListResult struct {
	ScheduleList
}

// ServiceFabricSchedulesUpdateResponse contains the response from method ServiceFabricSchedules.Update.
type ServiceFabricSchedulesUpdateResponse struct {
	ServiceFabricSchedulesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricSchedulesUpdateResult contains the result from method ServiceFabricSchedules.Update.
type ServiceFabricSchedulesUpdateResult struct {
	Schedule
}

// ServiceFabricsCreateOrUpdatePollerResponse contains the response from method ServiceFabrics.CreateOrUpdate.
type ServiceFabricsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsCreateOrUpdateResponse, error) {
	respType := ServiceFabricsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceFabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceFabricsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServiceFabricsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceFabricsCreateOrUpdateResponse contains the response from method ServiceFabrics.CreateOrUpdate.
type ServiceFabricsCreateOrUpdateResponse struct {
	ServiceFabricsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsCreateOrUpdateResult contains the result from method ServiceFabrics.CreateOrUpdate.
type ServiceFabricsCreateOrUpdateResult struct {
	ServiceFabric
}

// ServiceFabricsDeletePollerResponse contains the response from method ServiceFabrics.Delete.
type ServiceFabricsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsDeleteResponse, error) {
	respType := ServiceFabricsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceFabricsDeletePollerResponse from the provided client and resume token.
func (l *ServiceFabricsDeletePollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceFabricsDeleteResponse contains the response from method ServiceFabrics.Delete.
type ServiceFabricsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsGetResponse contains the response from method ServiceFabrics.Get.
type ServiceFabricsGetResponse struct {
	ServiceFabricsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsGetResult contains the result from method ServiceFabrics.Get.
type ServiceFabricsGetResult struct {
	ServiceFabric
}

// ServiceFabricsListApplicableSchedulesResponse contains the response from method ServiceFabrics.ListApplicableSchedules.
type ServiceFabricsListApplicableSchedulesResponse struct {
	ServiceFabricsListApplicableSchedulesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsListApplicableSchedulesResult contains the result from method ServiceFabrics.ListApplicableSchedules.
type ServiceFabricsListApplicableSchedulesResult struct {
	ApplicableSchedule
}

// ServiceFabricsListResponse contains the response from method ServiceFabrics.List.
type ServiceFabricsListResponse struct {
	ServiceFabricsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsListResult contains the result from method ServiceFabrics.List.
type ServiceFabricsListResult struct {
	ServiceFabricList
}

// ServiceFabricsStartPollerResponse contains the response from method ServiceFabrics.Start.
type ServiceFabricsStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsStartResponse, error) {
	respType := ServiceFabricsStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceFabricsStartPollerResponse from the provided client and resume token.
func (l *ServiceFabricsStartPollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceFabricsStartResponse contains the response from method ServiceFabrics.Start.
type ServiceFabricsStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsStopPollerResponse contains the response from method ServiceFabrics.Stop.
type ServiceFabricsStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsStopResponse, error) {
	respType := ServiceFabricsStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceFabricsStopPollerResponse from the provided client and resume token.
func (l *ServiceFabricsStopPollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceFabricsStopResponse contains the response from method ServiceFabrics.Stop.
type ServiceFabricsStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsUpdateResponse contains the response from method ServiceFabrics.Update.
type ServiceFabricsUpdateResponse struct {
	ServiceFabricsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceFabricsUpdateResult contains the result from method ServiceFabrics.Update.
type ServiceFabricsUpdateResult struct {
	ServiceFabric
}

// ServiceRunnersCreateOrUpdateResponse contains the response from method ServiceRunners.CreateOrUpdate.
type ServiceRunnersCreateOrUpdateResponse struct {
	ServiceRunnersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRunnersCreateOrUpdateResult contains the result from method ServiceRunners.CreateOrUpdate.
type ServiceRunnersCreateOrUpdateResult struct {
	ServiceRunner
}

// ServiceRunnersDeleteResponse contains the response from method ServiceRunners.Delete.
type ServiceRunnersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRunnersGetResponse contains the response from method ServiceRunners.Get.
type ServiceRunnersGetResponse struct {
	ServiceRunnersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRunnersGetResult contains the result from method ServiceRunners.Get.
type ServiceRunnersGetResult struct {
	ServiceRunner
}

// UsersCreateOrUpdatePollerResponse contains the response from method Users.CreateOrUpdate.
type UsersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersCreateOrUpdateResponse, error) {
	respType := UsersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.User)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *UsersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &UsersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersCreateOrUpdateResponse contains the response from method Users.CreateOrUpdate.
type UsersCreateOrUpdateResponse struct {
	UsersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersCreateOrUpdateResult contains the result from method Users.CreateOrUpdate.
type UsersCreateOrUpdateResult struct {
	User
}

// UsersDeletePollerResponse contains the response from method Users.Delete.
type UsersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersDeleteResponse, error) {
	respType := UsersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersDeletePollerResponse from the provided client and resume token.
func (l *UsersDeletePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &UsersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersDeleteResponse contains the response from method Users.Delete.
type UsersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersGetResponse contains the response from method Users.Get.
type UsersGetResponse struct {
	UsersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersGetResult contains the result from method Users.Get.
type UsersGetResult struct {
	User
}

// UsersListResponse contains the response from method Users.List.
type UsersListResponse struct {
	UsersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersListResult contains the result from method Users.List.
type UsersListResult struct {
	UserList
}

// UsersUpdateResponse contains the response from method Users.Update.
type UsersUpdateResponse struct {
	UsersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersUpdateResult contains the result from method Users.Update.
type UsersUpdateResult struct {
	User
}

// VirtualMachineSchedulesCreateOrUpdateResponse contains the response from method VirtualMachineSchedules.CreateOrUpdate.
type VirtualMachineSchedulesCreateOrUpdateResponse struct {
	VirtualMachineSchedulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineSchedulesCreateOrUpdateResult contains the result from method VirtualMachineSchedules.CreateOrUpdate.
type VirtualMachineSchedulesCreateOrUpdateResult struct {
	Schedule
}

// VirtualMachineSchedulesDeleteResponse contains the response from method VirtualMachineSchedules.Delete.
type VirtualMachineSchedulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineSchedulesExecutePollerResponse contains the response from method VirtualMachineSchedules.Execute.
type VirtualMachineSchedulesExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineSchedulesExecutePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineSchedulesExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineSchedulesExecuteResponse, error) {
	respType := VirtualMachineSchedulesExecuteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineSchedulesExecutePollerResponse from the provided client and resume token.
func (l *VirtualMachineSchedulesExecutePollerResponse) Resume(ctx context.Context, client *VirtualMachineSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineSchedulesClient.Execute", token, client.pl, client.executeHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachineSchedulesExecutePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineSchedulesExecuteResponse contains the response from method VirtualMachineSchedules.Execute.
type VirtualMachineSchedulesExecuteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineSchedulesGetResponse contains the response from method VirtualMachineSchedules.Get.
type VirtualMachineSchedulesGetResponse struct {
	VirtualMachineSchedulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineSchedulesGetResult contains the result from method VirtualMachineSchedules.Get.
type VirtualMachineSchedulesGetResult struct {
	Schedule
}

// VirtualMachineSchedulesListResponse contains the response from method VirtualMachineSchedules.List.
type VirtualMachineSchedulesListResponse struct {
	VirtualMachineSchedulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineSchedulesListResult contains the result from method VirtualMachineSchedules.List.
type VirtualMachineSchedulesListResult struct {
	ScheduleList
}

// VirtualMachineSchedulesUpdateResponse contains the response from method VirtualMachineSchedules.Update.
type VirtualMachineSchedulesUpdateResponse struct {
	VirtualMachineSchedulesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineSchedulesUpdateResult contains the result from method VirtualMachineSchedules.Update.
type VirtualMachineSchedulesUpdateResult struct {
	Schedule
}

// VirtualMachinesAddDataDiskPollerResponse contains the response from method VirtualMachines.AddDataDisk.
type VirtualMachinesAddDataDiskPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesAddDataDiskPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesAddDataDiskPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesAddDataDiskResponse, error) {
	respType := VirtualMachinesAddDataDiskResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesAddDataDiskPollerResponse from the provided client and resume token.
func (l *VirtualMachinesAddDataDiskPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.AddDataDisk", token, client.pl, client.addDataDiskHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesAddDataDiskPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesAddDataDiskResponse contains the response from method VirtualMachines.AddDataDisk.
type VirtualMachinesAddDataDiskResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesApplyArtifactsPollerResponse contains the response from method VirtualMachines.ApplyArtifacts.
type VirtualMachinesApplyArtifactsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesApplyArtifactsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesApplyArtifactsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesApplyArtifactsResponse, error) {
	respType := VirtualMachinesApplyArtifactsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesApplyArtifactsPollerResponse from the provided client and resume token.
func (l *VirtualMachinesApplyArtifactsPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.ApplyArtifacts", token, client.pl, client.applyArtifactsHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesApplyArtifactsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesApplyArtifactsResponse contains the response from method VirtualMachines.ApplyArtifacts.
type VirtualMachinesApplyArtifactsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClaimPollerResponse contains the response from method VirtualMachines.Claim.
type VirtualMachinesClaimPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClaimPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClaimPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClaimResponse, error) {
	respType := VirtualMachinesClaimResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClaimPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClaimPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Claim", token, client.pl, client.claimHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClaimPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClaimResponse contains the response from method VirtualMachines.Claim.
type VirtualMachinesClaimResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesCreateOrUpdatePollerResponse contains the response from method VirtualMachines.CreateOrUpdate.
type VirtualMachinesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesCreateOrUpdateResponse, error) {
	respType := VirtualMachinesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LabVirtualMachine)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesCreateOrUpdateResponse contains the response from method VirtualMachines.CreateOrUpdate.
type VirtualMachinesCreateOrUpdateResponse struct {
	VirtualMachinesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesCreateOrUpdateResult contains the result from method VirtualMachines.CreateOrUpdate.
type VirtualMachinesCreateOrUpdateResult struct {
	LabVirtualMachine
}

// VirtualMachinesDeletePollerResponse contains the response from method VirtualMachines.Delete.
type VirtualMachinesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesDeleteResponse, error) {
	respType := VirtualMachinesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachinesDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesDeleteResponse contains the response from method VirtualMachines.Delete.
type VirtualMachinesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesDetachDataDiskPollerResponse contains the response from method VirtualMachines.DetachDataDisk.
type VirtualMachinesDetachDataDiskPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesDetachDataDiskPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesDetachDataDiskPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesDetachDataDiskResponse, error) {
	respType := VirtualMachinesDetachDataDiskResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesDetachDataDiskPollerResponse from the provided client and resume token.
func (l *VirtualMachinesDetachDataDiskPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.DetachDataDisk", token, client.pl, client.detachDataDiskHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesDetachDataDiskPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesDetachDataDiskResponse contains the response from method VirtualMachines.DetachDataDisk.
type VirtualMachinesDetachDataDiskResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesGetRdpFileContentsResponse contains the response from method VirtualMachines.GetRdpFileContents.
type VirtualMachinesGetRdpFileContentsResponse struct {
	VirtualMachinesGetRdpFileContentsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesGetRdpFileContentsResult contains the result from method VirtualMachines.GetRdpFileContents.
type VirtualMachinesGetRdpFileContentsResult struct {
	RdpConnection
}

// VirtualMachinesGetResponse contains the response from method VirtualMachines.Get.
type VirtualMachinesGetResponse struct {
	VirtualMachinesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesGetResult contains the result from method VirtualMachines.Get.
type VirtualMachinesGetResult struct {
	LabVirtualMachine
}

// VirtualMachinesListApplicableSchedulesResponse contains the response from method VirtualMachines.ListApplicableSchedules.
type VirtualMachinesListApplicableSchedulesResponse struct {
	VirtualMachinesListApplicableSchedulesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesListApplicableSchedulesResult contains the result from method VirtualMachines.ListApplicableSchedules.
type VirtualMachinesListApplicableSchedulesResult struct {
	ApplicableSchedule
}

// VirtualMachinesListResponse contains the response from method VirtualMachines.List.
type VirtualMachinesListResponse struct {
	VirtualMachinesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesListResult contains the result from method VirtualMachines.List.
type VirtualMachinesListResult struct {
	LabVirtualMachineList
}

// VirtualMachinesRedeployPollerResponse contains the response from method VirtualMachines.Redeploy.
type VirtualMachinesRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesRedeployPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesRedeployResponse, error) {
	respType := VirtualMachinesRedeployResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachinesRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Redeploy", token, client.pl, client.redeployHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesRedeployPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesRedeployResponse contains the response from method VirtualMachines.Redeploy.
type VirtualMachinesRedeployResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesResizePollerResponse contains the response from method VirtualMachines.Resize.
type VirtualMachinesResizePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesResizePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesResizePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesResizeResponse, error) {
	respType := VirtualMachinesResizeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesResizePollerResponse from the provided client and resume token.
func (l *VirtualMachinesResizePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Resize", token, client.pl, client.resizeHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesResizePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesResizeResponse contains the response from method VirtualMachines.Resize.
type VirtualMachinesResizeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesRestartPollerResponse contains the response from method VirtualMachines.Restart.
type VirtualMachinesRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesRestartResponse, error) {
	respType := VirtualMachinesRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesRestartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesRestartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Restart", token, client.pl, client.restartHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesRestartResponse contains the response from method VirtualMachines.Restart.
type VirtualMachinesRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesStartPollerResponse contains the response from method VirtualMachines.Start.
type VirtualMachinesStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesStartResponse, error) {
	respType := VirtualMachinesStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesStartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesStartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesStartResponse contains the response from method VirtualMachines.Start.
type VirtualMachinesStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesStopPollerResponse contains the response from method VirtualMachines.Stop.
type VirtualMachinesStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesStopResponse, error) {
	respType := VirtualMachinesStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesStopPollerResponse from the provided client and resume token.
func (l *VirtualMachinesStopPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesStopResponse contains the response from method VirtualMachines.Stop.
type VirtualMachinesStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesTransferDisksPollerResponse contains the response from method VirtualMachines.TransferDisks.
type VirtualMachinesTransferDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesTransferDisksPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesTransferDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesTransferDisksResponse, error) {
	respType := VirtualMachinesTransferDisksResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesTransferDisksPollerResponse from the provided client and resume token.
func (l *VirtualMachinesTransferDisksPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.TransferDisks", token, client.pl, client.transferDisksHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesTransferDisksPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesTransferDisksResponse contains the response from method VirtualMachines.TransferDisks.
type VirtualMachinesTransferDisksResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesUnClaimPollerResponse contains the response from method VirtualMachines.UnClaim.
type VirtualMachinesUnClaimPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesUnClaimPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesUnClaimPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesUnClaimResponse, error) {
	respType := VirtualMachinesUnClaimResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesUnClaimPollerResponse from the provided client and resume token.
func (l *VirtualMachinesUnClaimPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.UnClaim", token, client.pl, client.unClaimHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesUnClaimPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesUnClaimResponse contains the response from method VirtualMachines.UnClaim.
type VirtualMachinesUnClaimResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesUpdateResponse contains the response from method VirtualMachines.Update.
type VirtualMachinesUpdateResponse struct {
	VirtualMachinesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesUpdateResult contains the result from method VirtualMachines.Update.
type VirtualMachinesUpdateResult struct {
	LabVirtualMachine
}

// VirtualNetworksCreateOrUpdatePollerResponse contains the response from method VirtualNetworks.CreateOrUpdate.
type VirtualNetworksCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksCreateOrUpdateResponse, error) {
	respType := VirtualNetworksCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetwork)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworksCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworksCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworksCreateOrUpdateResponse contains the response from method VirtualNetworks.CreateOrUpdate.
type VirtualNetworksCreateOrUpdateResponse struct {
	VirtualNetworksCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksCreateOrUpdateResult contains the result from method VirtualNetworks.CreateOrUpdate.
type VirtualNetworksCreateOrUpdateResult struct {
	VirtualNetwork
}

// VirtualNetworksDeletePollerResponse contains the response from method VirtualNetworks.Delete.
type VirtualNetworksDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksDeleteResponse, error) {
	respType := VirtualNetworksDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworksDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworksDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworksDeleteResponse contains the response from method VirtualNetworks.Delete.
type VirtualNetworksDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksGetResponse contains the response from method VirtualNetworks.Get.
type VirtualNetworksGetResponse struct {
	VirtualNetworksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksGetResult contains the result from method VirtualNetworks.Get.
type VirtualNetworksGetResult struct {
	VirtualNetwork
}

// VirtualNetworksListResponse contains the response from method VirtualNetworks.List.
type VirtualNetworksListResponse struct {
	VirtualNetworksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksListResult contains the result from method VirtualNetworks.List.
type VirtualNetworksListResult struct {
	VirtualNetworkList
}

// VirtualNetworksUpdateResponse contains the response from method VirtualNetworks.Update.
type VirtualNetworksUpdateResponse struct {
	VirtualNetworksUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksUpdateResult contains the result from method VirtualNetworks.Update.
type VirtualNetworksUpdateResult struct {
	VirtualNetwork
}
