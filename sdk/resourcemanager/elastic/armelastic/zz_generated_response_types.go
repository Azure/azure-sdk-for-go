//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armelastic

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DeploymentInfoListResponse contains the response from method DeploymentInfo.List.
type DeploymentInfoListResponse struct {
	DeploymentInfoListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentInfoListResult contains the result from method DeploymentInfo.List.
type DeploymentInfoListResult struct {
	DeploymentInfoResponse
}

// MonitoredResourcesListResponse contains the response from method MonitoredResources.List.
type MonitoredResourcesListResponse struct {
	MonitoredResourcesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoredResourcesListResult contains the result from method MonitoredResources.List.
type MonitoredResourcesListResult struct {
	MonitoredResourceListResponse
}

// MonitorsCreatePollerResponse contains the response from method Monitors.Create.
type MonitorsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitorsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitorsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitorsCreateResponse, error) {
	respType := MonitorsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ElasticMonitorResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitorsCreatePollerResponse from the provided client and resume token.
func (l *MonitorsCreatePollerResponse) Resume(ctx context.Context, client *MonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitorsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &MonitorsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitorsCreateResponse contains the response from method Monitors.Create.
type MonitorsCreateResponse struct {
	MonitorsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitorsCreateResult contains the result from method Monitors.Create.
type MonitorsCreateResult struct {
	ElasticMonitorResource
}

// MonitorsDeletePollerResponse contains the response from method Monitors.Delete.
type MonitorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitorsDeleteResponse, error) {
	respType := MonitorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitorsDeletePollerResponse from the provided client and resume token.
func (l *MonitorsDeletePollerResponse) Resume(ctx context.Context, client *MonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &MonitorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitorsDeleteResponse contains the response from method Monitors.Delete.
type MonitorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitorsGetResponse contains the response from method Monitors.Get.
type MonitorsGetResponse struct {
	MonitorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitorsGetResult contains the result from method Monitors.Get.
type MonitorsGetResult struct {
	ElasticMonitorResource
}

// MonitorsListByResourceGroupResponse contains the response from method Monitors.ListByResourceGroup.
type MonitorsListByResourceGroupResponse struct {
	MonitorsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitorsListByResourceGroupResult contains the result from method Monitors.ListByResourceGroup.
type MonitorsListByResourceGroupResult struct {
	ElasticMonitorResourceListResponse
}

// MonitorsListResponse contains the response from method Monitors.List.
type MonitorsListResponse struct {
	MonitorsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitorsListResult contains the result from method Monitors.List.
type MonitorsListResult struct {
	ElasticMonitorResourceListResponse
}

// MonitorsUpdateResponse contains the response from method Monitors.Update.
type MonitorsUpdateResponse struct {
	MonitorsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitorsUpdateResult contains the result from method Monitors.Update.
type MonitorsUpdateResult struct {
	ElasticMonitorResource
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// TagRulesCreateOrUpdateResponse contains the response from method TagRules.CreateOrUpdate.
type TagRulesCreateOrUpdateResponse struct {
	TagRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagRulesCreateOrUpdateResult contains the result from method TagRules.CreateOrUpdate.
type TagRulesCreateOrUpdateResult struct {
	MonitoringTagRules
}

// TagRulesDeletePollerResponse contains the response from method TagRules.Delete.
type TagRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TagRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TagRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TagRulesDeleteResponse, error) {
	respType := TagRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TagRulesDeletePollerResponse from the provided client and resume token.
func (l *TagRulesDeletePollerResponse) Resume(ctx context.Context, client *TagRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TagRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &TagRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TagRulesDeleteResponse contains the response from method TagRules.Delete.
type TagRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagRulesGetResponse contains the response from method TagRules.Get.
type TagRulesGetResponse struct {
	TagRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagRulesGetResult contains the result from method TagRules.Get.
type TagRulesGetResult struct {
	MonitoringTagRules
}

// TagRulesListResponse contains the response from method TagRules.List.
type TagRulesListResponse struct {
	TagRulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagRulesListResult contains the result from method TagRules.List.
type TagRulesListResult struct {
	MonitoringTagRulesListResponse
}

// VMCollectionUpdateResponse contains the response from method VMCollection.Update.
type VMCollectionUpdateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VMHostListResponseEnvelope contains the response from method VMHost.List.
type VMHostListResponseEnvelope struct {
	VMHostListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VMHostListResult contains the result from method VMHost.List.
type VMHostListResult struct {
	VMHostListResponse
}

// VMIngestionDetailsResponseEnvelope contains the response from method VMIngestion.Details.
type VMIngestionDetailsResponseEnvelope struct {
	VMIngestionDetailsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VMIngestionDetailsResult contains the result from method VMIngestion.Details.
type VMIngestionDetailsResult struct {
	VMIngestionDetailsResponse
}
