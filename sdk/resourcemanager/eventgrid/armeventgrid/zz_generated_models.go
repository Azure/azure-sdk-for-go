//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armeventgrid

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AdvancedFilterClassification provides polymorphic access to related types.
// Call the interface's GetAdvancedFilter() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AdvancedFilter, *BoolEqualsAdvancedFilter, *NumberGreaterThanAdvancedFilter, *NumberGreaterThanOrEqualsAdvancedFilter,
// - *NumberInAdvancedFilter, *NumberLessThanAdvancedFilter, *NumberLessThanOrEqualsAdvancedFilter, *NumberNotInAdvancedFilter,
// - *StringBeginsWithAdvancedFilter, *StringContainsAdvancedFilter, *StringEndsWithAdvancedFilter, *StringInAdvancedFilter,
// - *StringNotInAdvancedFilter
type AdvancedFilterClassification interface {
	// GetAdvancedFilter returns the AdvancedFilter content of the underlying type.
	GetAdvancedFilter() *AdvancedFilter
}

// AdvancedFilter - This is the base type that represents an advanced filter. To configure an advanced filter, do not directly instantiate an object of
// this class. Instead, instantiate an object of a derived class such
// as BoolEqualsAdvancedFilter, NumberInAdvancedFilter, StringEqualsAdvancedFilter etc. depending on the type of the key based on which you want to filter.
type AdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type AdvancedFilter.
func (a *AdvancedFilter) GetAdvancedFilter() *AdvancedFilter { return a }

// UnmarshalJSON implements the json.Unmarshaller interface for type AdvancedFilter.
func (a *AdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AdvancedFilter) marshalInternal(objectMap map[string]interface{}, discValue AdvancedFilterOperatorType) {
	populate(objectMap, "key", a.Key)
	a.OperatorType = &discValue
	objectMap["operatorType"] = a.OperatorType
}

func (a *AdvancedFilter) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &a.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &a.OperatorType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFunctionEventSubscriptionDestination - Information about the azure function destination for an event subscription.
type AzureFunctionEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// Azure Function Properties of the event subscription destination.
	Properties *AzureFunctionEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionEventSubscriptionDestination.
func (a AzureFunctionEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeAzureFunction)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionEventSubscriptionDestination.
func (a *AzureFunctionEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureFunctionEventSubscriptionDestinationProperties - The properties that represent the Azure Function destination of an event subscription.
type AzureFunctionEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// Maximum number of events per batch.
	MaxEventsPerBatch *int32 `json:"maxEventsPerBatch,omitempty"`

	// Preferred batch size in Kilobytes.
	PreferredBatchSizeInKilobytes *int32 `json:"preferredBatchSizeInKilobytes,omitempty"`

	// The Azure Resource Id that represents the endpoint of the Azure Function destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionEventSubscriptionDestinationProperties.
func (a AzureFunctionEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", a.DeliveryAttributeMappings)
	populate(objectMap, "maxEventsPerBatch", a.MaxEventsPerBatch)
	populate(objectMap, "preferredBatchSizeInKilobytes", a.PreferredBatchSizeInKilobytes)
	populate(objectMap, "resourceId", a.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionEventSubscriptionDestinationProperties.
func (a *AzureFunctionEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			a.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "maxEventsPerBatch":
			err = unpopulate(val, &a.MaxEventsPerBatch)
			delete(rawMsg, key)
		case "preferredBatchSizeInKilobytes":
			err = unpopulate(val, &a.PreferredBatchSizeInKilobytes)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &a.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BoolEqualsAdvancedFilter - BoolEquals Advanced Filter.
type BoolEqualsAdvancedFilter struct {
	AdvancedFilter
	// The boolean filter value.
	Value *bool `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BoolEqualsAdvancedFilter.
func (b BoolEqualsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeBoolEquals)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BoolEqualsAdvancedFilter.
func (b *BoolEqualsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectionState information.
type ConnectionState struct {
	// Actions required (if any).
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description of the connection state.
	Description *string `json:"description,omitempty"`

	// Status of the connection.
	Status *PersistedConnectionStatus `json:"status,omitempty"`
}

// DeadLetterDestinationClassification provides polymorphic access to related types.
// Call the interface's GetDeadLetterDestination() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DeadLetterDestination, *StorageBlobDeadLetterDestination
type DeadLetterDestinationClassification interface {
	// GetDeadLetterDestination returns the DeadLetterDestination content of the underlying type.
	GetDeadLetterDestination() *DeadLetterDestination
}

// DeadLetterDestination - Information about the dead letter destination for an event subscription. To configure a deadletter destination, do not directly
// instantiate an object of this class. Instead, instantiate an object of a
// derived class. Currently, StorageBlobDeadLetterDestination is the only class that derives from this class.
type DeadLetterDestination struct {
	// REQUIRED; Type of the endpoint for the dead letter destination
	EndpointType *DeadLetterEndPointType `json:"endpointType,omitempty"`
}

// GetDeadLetterDestination implements the DeadLetterDestinationClassification interface for type DeadLetterDestination.
func (d *DeadLetterDestination) GetDeadLetterDestination() *DeadLetterDestination { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DeadLetterDestination.
func (d *DeadLetterDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DeadLetterDestination) marshalInternal(objectMap map[string]interface{}, discValue DeadLetterEndPointType) {
	d.EndpointType = &discValue
	objectMap["endpointType"] = d.EndpointType
}

func (d *DeadLetterDestination) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &d.EndpointType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeadLetterWithResourceIdentity - Information about the deadletter destination with resource identity.
type DeadLetterWithResourceIdentity struct {
	// Information about the destination where events have to be delivered for the event subscription. Uses the managed identity setup on the parent resource
	// (namely, topic or domain) to acquire the
	// authentication tokens being used during delivery / dead-lettering.
	DeadLetterDestination DeadLetterDestinationClassification `json:"deadLetterDestination,omitempty"`

	// The identity to use when dead-lettering events.
	Identity *EventSubscriptionIdentity `json:"identity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeadLetterWithResourceIdentity.
func (d DeadLetterWithResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deadLetterDestination", d.DeadLetterDestination)
	populate(objectMap, "identity", d.Identity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeadLetterWithResourceIdentity.
func (d *DeadLetterWithResourceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deadLetterDestination":
			d.DeadLetterDestination, err = unmarshalDeadLetterDestinationClassification(val)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &d.Identity)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryAttributeListResult - Result of the Get delivery attributes operation.
type DeliveryAttributeListResult struct {
	// A collection of DeliveryAttributeMapping
	Value []DeliveryAttributeMappingClassification `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryAttributeListResult.
func (d DeliveryAttributeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryAttributeListResult.
func (d *DeliveryAttributeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			d.Value, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryAttributeMappingClassification provides polymorphic access to related types.
// Call the interface's GetDeliveryAttributeMapping() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DeliveryAttributeMapping, *DynamicDeliveryAttributeMapping, *StaticDeliveryAttributeMapping
type DeliveryAttributeMappingClassification interface {
	// GetDeliveryAttributeMapping returns the DeliveryAttributeMapping content of the underlying type.
	GetDeliveryAttributeMapping() *DeliveryAttributeMapping
}

// DeliveryAttributeMapping - Delivery attribute mapping details.
type DeliveryAttributeMapping struct {
	// REQUIRED; Type of the delivery attribute or header name.
	Type *DeliveryAttributeMappingType `json:"type,omitempty"`

	// Name of the delivery attribute or header.
	Name *string `json:"name,omitempty"`
}

// GetDeliveryAttributeMapping implements the DeliveryAttributeMappingClassification interface for type DeliveryAttributeMapping.
func (d *DeliveryAttributeMapping) GetDeliveryAttributeMapping() *DeliveryAttributeMapping { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryAttributeMapping.
func (d *DeliveryAttributeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DeliveryAttributeMapping) marshalInternal(objectMap map[string]interface{}, discValue DeliveryAttributeMappingType) {
	populate(objectMap, "name", d.Name)
	d.Type = &discValue
	objectMap["type"] = d.Type
}

func (d *DeliveryAttributeMapping) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryWithResourceIdentity - Information about the delivery for an event subscription with resource identity.
type DeliveryWithResourceIdentity struct {
	// Information about the destination where events have to be delivered for the event subscription. Uses Azure Event Grid's identity to acquire the authentication
	// tokens being used during delivery /
	// dead-lettering.
	Destination EventSubscriptionDestinationClassification `json:"destination,omitempty"`

	// The identity to use when delivering events.
	Identity *EventSubscriptionIdentity `json:"identity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryWithResourceIdentity.
func (d DeliveryWithResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", d.Destination)
	populate(objectMap, "identity", d.Identity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryWithResourceIdentity.
func (d *DeliveryWithResourceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
			d.Destination, err = unmarshalEventSubscriptionDestinationClassification(val)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &d.Identity)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Domain - EventGrid Domain.
type Domain struct {
	TrackedResource
	// Identity information for the Event Grid Domain resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the Event Grid Domain resource.
	Properties *DomainProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to Domain resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Domain.
func (d Domain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	return json.Marshal(objectMap)
}

// DomainProperties - Properties of the Event Grid Domain Resource.
type DomainProperties struct {
	// This Boolean is used to specify the creation mechanism for 'all' the Event Grid Domain Topics associated with this Event Grid Domain resource. In this
	// context, creation of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property is null or set to true, Event
	// Grid is responsible of automatically creating the
	// domain topic when the first event subscription is created at the scope of the domain topic. If this property is set to false, then creating the first
	// event subscription will require creating a domain
	// topic by the user. The self-management mode can be used if the user wants full control of when the domain topic is created, while auto-managed mode provides
	// the flexibility to perform less operations
	// and manage fewer resources by the user. Also, note that in auto-managed creation mode, user is allowed to create the domain topic on demand if needed.
	AutoCreateTopicWithFirstSubscription *bool `json:"autoCreateTopicWithFirstSubscription,omitempty"`

	// This Boolean is used to specify the deletion mechanism for 'all' the Event Grid Domain Topics associated with this Event Grid Domain resource. In this
	// context, deletion of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property is set to true, Event Grid is
	// responsible of automatically deleting the domain
	// topic when the last event subscription at the scope of the domain topic is deleted. If this property is set to false, then the user needs to manually
	// delete the domain topic when it is no longer
	// needed (e.g., when last event subscription is deleted and the resource needs to be cleaned up). The self-management mode can be used if the user wants
	// full control of when the domain topic needs to be
	// deleted, while auto-managed mode provides the flexibility to perform less operations and manage fewer resources by the user.
	AutoDeleteTopicWithLastSubscription *bool `json:"autoDeleteTopicWithLastSubscription,omitempty"`

	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD token will be used to authenticate
	// if user is allowed to publish to the domain.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines the format that Event Grid should expect for incoming events published to the domain.
	InputSchema *InputSchema `json:"inputSchema,omitempty"`

	// Information about the InputSchemaMapping which specified the info about mapping event payload.
	InputSchemaMapping InputSchemaMappingClassification `json:"inputSchemaMapping,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// READ-ONLY; Endpoint for the domain.
	Endpoint *string `json:"endpoint,omitempty" azure:"ro"`

	// READ-ONLY; Metric resource id for the domain.
	MetricResourceID *string `json:"metricResourceId,omitempty" azure:"ro"`

	// READ-ONLY; List of private endpoint connections.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the Event Grid Domain Resource.
	ProvisioningState *DomainProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainProperties.
func (d DomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoCreateTopicWithFirstSubscription", d.AutoCreateTopicWithFirstSubscription)
	populate(objectMap, "autoDeleteTopicWithLastSubscription", d.AutoDeleteTopicWithLastSubscription)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "endpoint", d.Endpoint)
	populate(objectMap, "inboundIpRules", d.InboundIPRules)
	populate(objectMap, "inputSchema", d.InputSchema)
	populate(objectMap, "inputSchemaMapping", d.InputSchemaMapping)
	populate(objectMap, "metricResourceId", d.MetricResourceID)
	populate(objectMap, "privateEndpointConnections", d.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", d.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DomainProperties.
func (d *DomainProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoCreateTopicWithFirstSubscription":
			err = unpopulate(val, &d.AutoCreateTopicWithFirstSubscription)
			delete(rawMsg, key)
		case "autoDeleteTopicWithLastSubscription":
			err = unpopulate(val, &d.AutoDeleteTopicWithLastSubscription)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, &d.DisableLocalAuth)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &d.Endpoint)
			delete(rawMsg, key)
		case "inboundIpRules":
			err = unpopulate(val, &d.InboundIPRules)
			delete(rawMsg, key)
		case "inputSchema":
			err = unpopulate(val, &d.InputSchema)
			delete(rawMsg, key)
		case "inputSchemaMapping":
			d.InputSchemaMapping, err = unmarshalInputSchemaMappingClassification(val)
			delete(rawMsg, key)
		case "metricResourceId":
			err = unpopulate(val, &d.MetricResourceID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &d.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &d.PublicNetworkAccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DomainRegenerateKeyRequest - Domain regenerate share access key request.
type DomainRegenerateKeyRequest struct {
	// REQUIRED; Key name to regenerate key1 or key2.
	KeyName *string `json:"keyName,omitempty"`
}

// DomainSharedAccessKeys - Shared access keys of the Domain.
type DomainSharedAccessKeys struct {
	// Shared access key1 for the domain.
	Key1 *string `json:"key1,omitempty"`

	// Shared access key2 for the domain.
	Key2 *string `json:"key2,omitempty"`
}

// DomainTopic - Domain Topic.
type DomainTopic struct {
	Resource
	// READ-ONLY; Properties of the Domain Topic.
	Properties *DomainTopicProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to Domain Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainTopic.
func (d DomainTopic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	return json.Marshal(objectMap)
}

// DomainTopicProperties - Properties of the Domain Topic.
type DomainTopicProperties struct {
	// READ-ONLY; Provisioning state of the domain topic.
	ProvisioningState *DomainTopicProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// DomainTopicsBeginCreateOrUpdateOptions contains the optional parameters for the DomainTopics.BeginCreateOrUpdate method.
type DomainTopicsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DomainTopicsBeginDeleteOptions contains the optional parameters for the DomainTopics.BeginDelete method.
type DomainTopicsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DomainTopicsGetOptions contains the optional parameters for the DomainTopics.Get method.
type DomainTopicsGetOptions struct {
	// placeholder for future optional parameters
}

// DomainTopicsListByDomainOptions contains the optional parameters for the DomainTopics.ListByDomain method.
type DomainTopicsListByDomainOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// DomainTopicsListResult - Result of the List Domain Topics operation.
type DomainTopicsListResult struct {
	// A link for the next page of domain topics.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of Domain Topics.
	Value []*DomainTopic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainTopicsListResult.
func (d DomainTopicsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DomainUpdateParameterProperties - Information of domain update parameter properties.
type DomainUpdateParameterProperties struct {
	// This Boolean is used to specify the creation mechanism for 'all' the Event Grid Domain Topics associated with this Event Grid Domain resource. In this
	// context, creation of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property is null or set to true, Event
	// Grid is responsible of automatically creating the
	// domain topic when the first event subscription is created at the scope of the domain topic. If this property is set to false, then creating the first
	// event subscription will require creating a domain
	// topic by the user. The self-management mode can be used if the user wants full control of when the domain topic is created, while auto-managed mode provides
	// the flexibility to perform less operations
	// and manage fewer resources by the user. Also, note that in auto-managed creation mode, user is allowed to create the domain topic on demand if needed.
	AutoCreateTopicWithFirstSubscription *bool `json:"autoCreateTopicWithFirstSubscription,omitempty"`

	// This Boolean is used to specify the deletion mechanism for 'all' the Event Grid Domain Topics associated with this Event Grid Domain resource. In this
	// context, deletion of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property is set to true, Event Grid is
	// responsible of automatically deleting the domain
	// topic when the last event subscription at the scope of the domain topic is deleted. If this property is set to false, then the user needs to manually
	// delete the domain topic when it is no longer
	// needed (e.g., when last event subscription is deleted and the resource needs to be cleaned up). The self-management mode can be used if the user wants
	// full control of when the domain topic needs to be
	// deleted, while auto-managed mode provides the flexibility to perform less operations and manage fewer resources by the user.
	AutoDeleteTopicWithLastSubscription *bool `json:"autoDeleteTopicWithLastSubscription,omitempty"`

	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD token will be used to authenticate
	// if user is allowed to publish to the domain.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainUpdateParameterProperties.
func (d DomainUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoCreateTopicWithFirstSubscription", d.AutoCreateTopicWithFirstSubscription)
	populate(objectMap, "autoDeleteTopicWithLastSubscription", d.AutoDeleteTopicWithLastSubscription)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "inboundIpRules", d.InboundIPRules)
	populate(objectMap, "publicNetworkAccess", d.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// DomainUpdateParameters - Properties of the Domain update.
type DomainUpdateParameters struct {
	// Identity information for the resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the resource.
	Properties *DomainUpdateParameterProperties `json:"properties,omitempty"`

	// Tags of the domains resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainUpdateParameters.
func (d DomainUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DomainsBeginCreateOrUpdateOptions contains the optional parameters for the Domains.BeginCreateOrUpdate method.
type DomainsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DomainsBeginDeleteOptions contains the optional parameters for the Domains.BeginDelete method.
type DomainsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DomainsBeginUpdateOptions contains the optional parameters for the Domains.BeginUpdate method.
type DomainsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// DomainsGetOptions contains the optional parameters for the Domains.Get method.
type DomainsGetOptions struct {
	// placeholder for future optional parameters
}

// DomainsListByResourceGroupOptions contains the optional parameters for the Domains.ListByResourceGroup method.
type DomainsListByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// DomainsListBySubscriptionOptions contains the optional parameters for the Domains.ListBySubscription method.
type DomainsListBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// DomainsListResult - Result of the List Domains operation.
type DomainsListResult struct {
	// A link for the next page of domains.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of Domains.
	Value []*Domain `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainsListResult.
func (d DomainsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DomainsListSharedAccessKeysOptions contains the optional parameters for the Domains.ListSharedAccessKeys method.
type DomainsListSharedAccessKeysOptions struct {
	// placeholder for future optional parameters
}

// DomainsRegenerateKeyOptions contains the optional parameters for the Domains.RegenerateKey method.
type DomainsRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// DynamicDeliveryAttributeMapping - Dynamic delivery attribute mapping details.
type DynamicDeliveryAttributeMapping struct {
	DeliveryAttributeMapping
	// Properties of dynamic delivery attribute mapping.
	Properties *DynamicDeliveryAttributeMappingProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicDeliveryAttributeMapping.
func (d DynamicDeliveryAttributeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DeliveryAttributeMapping.marshalInternal(objectMap, DeliveryAttributeMappingTypeDynamic)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicDeliveryAttributeMapping.
func (d *DynamicDeliveryAttributeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DeliveryAttributeMapping.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DynamicDeliveryAttributeMappingProperties - Properties of dynamic delivery attribute mapping.
type DynamicDeliveryAttributeMappingProperties struct {
	// JSON path in the event which contains attribute value.
	SourceField *string `json:"sourceField,omitempty"`
}

// EventHubEventSubscriptionDestination - Information about the event hub destination for an event subscription.
type EventHubEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// Event Hub Properties of the event subscription destination.
	Properties *EventHubEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventHubEventSubscriptionDestination.
func (e EventHubEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeEventHub)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubEventSubscriptionDestination.
func (e *EventHubEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EventHubEventSubscriptionDestinationProperties - The properties for a event hub destination.
type EventHubEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource Id that represents the endpoint of an Event Hub destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventHubEventSubscriptionDestinationProperties.
func (e EventHubEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", e.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", e.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubEventSubscriptionDestinationProperties.
func (e *EventHubEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			e.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &e.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscription - Event Subscription
type EventSubscription struct {
	Resource
	// Properties of the event subscription.
	Properties *EventSubscriptionProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to Event Subscription resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscription.
func (e EventSubscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	return json.Marshal(objectMap)
}

// EventSubscriptionDestinationClassification provides polymorphic access to related types.
// Call the interface's GetEventSubscriptionDestination() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureFunctionEventSubscriptionDestination, *EventHubEventSubscriptionDestination, *EventSubscriptionDestination, *HybridConnectionEventSubscriptionDestination,
// - *ServiceBusQueueEventSubscriptionDestination, *ServiceBusTopicEventSubscriptionDestination, *StorageQueueEventSubscriptionDestination,
// - *WebHookEventSubscriptionDestination
type EventSubscriptionDestinationClassification interface {
	// GetEventSubscriptionDestination returns the EventSubscriptionDestination content of the underlying type.
	GetEventSubscriptionDestination() *EventSubscriptionDestination
}

// EventSubscriptionDestination - Information about the destination for an event subscription.
type EventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type EventSubscriptionDestination.
func (e *EventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return e
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionDestination.
func (e *EventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return e.unmarshalInternal(rawMsg)
}

func (e EventSubscriptionDestination) marshalInternal(objectMap map[string]interface{}, discValue EndpointType) {
	e.EndpointType = &discValue
	objectMap["endpointType"] = e.EndpointType
}

func (e *EventSubscriptionDestination) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &e.EndpointType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionFilter - Filter for the Event Subscription.
type EventSubscriptionFilter struct {
	// An array of advanced filters that are used for filtering event subscriptions.
	AdvancedFilters []AdvancedFilterClassification `json:"advancedFilters,omitempty"`

	// Allows advanced filters to be evaluated against an array of values instead of expecting a singular value.
	EnableAdvancedFilteringOnArrays *bool `json:"enableAdvancedFilteringOnArrays,omitempty"`

	// A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes
	// to null.
	IncludedEventTypes []*string `json:"includedEventTypes,omitempty"`

	// Specifies if the SubjectBeginsWith and SubjectEndsWith properties of the filter should be compared in a case sensitive manner.
	IsSubjectCaseSensitive *bool `json:"isSubjectCaseSensitive,omitempty"`

	// An optional string to filter events for an event subscription based on a resource path prefix. The format of this depends on the publisher of the events.
	// Wildcard characters are not supported in this
	// path.
	SubjectBeginsWith *string `json:"subjectBeginsWith,omitempty"`

	// An optional string to filter events for an event subscription based on a resource path suffix. Wildcard characters are not supported in this path.
	SubjectEndsWith *string `json:"subjectEndsWith,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionFilter.
func (e EventSubscriptionFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "advancedFilters", e.AdvancedFilters)
	populate(objectMap, "enableAdvancedFilteringOnArrays", e.EnableAdvancedFilteringOnArrays)
	populate(objectMap, "includedEventTypes", e.IncludedEventTypes)
	populate(objectMap, "isSubjectCaseSensitive", e.IsSubjectCaseSensitive)
	populate(objectMap, "subjectBeginsWith", e.SubjectBeginsWith)
	populate(objectMap, "subjectEndsWith", e.SubjectEndsWith)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionFilter.
func (e *EventSubscriptionFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advancedFilters":
			e.AdvancedFilters, err = unmarshalAdvancedFilterClassificationArray(val)
			delete(rawMsg, key)
		case "enableAdvancedFilteringOnArrays":
			err = unpopulate(val, &e.EnableAdvancedFilteringOnArrays)
			delete(rawMsg, key)
		case "includedEventTypes":
			err = unpopulate(val, &e.IncludedEventTypes)
			delete(rawMsg, key)
		case "isSubjectCaseSensitive":
			err = unpopulate(val, &e.IsSubjectCaseSensitive)
			delete(rawMsg, key)
		case "subjectBeginsWith":
			err = unpopulate(val, &e.SubjectBeginsWith)
			delete(rawMsg, key)
		case "subjectEndsWith":
			err = unpopulate(val, &e.SubjectEndsWith)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionFullURL - Full endpoint url of an event subscription
type EventSubscriptionFullURL struct {
	// The URL that represents the endpoint of the destination of an event subscription.
	EndpointURL *string `json:"endpointUrl,omitempty"`
}

// EventSubscriptionIdentity - The identity information with the event subscription.
type EventSubscriptionIdentity struct {
	// The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities.
	// The type 'None' will remove any identity.
	Type *EventSubscriptionIdentityType `json:"type,omitempty"`

	// The user identity associated with the resource.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// EventSubscriptionProperties - Properties of the Event Subscription.
type EventSubscriptionProperties struct {
	// The DeadLetter destination of the event subscription.
	DeadLetterDestination DeadLetterDestinationClassification `json:"deadLetterDestination,omitempty"`

	// The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to the dead letter destination.
	// Uses the managed identity setup on the parent
	// resource (namely, topic or domain) to acquire the authentication tokens being used during delivery / dead-lettering.
	DeadLetterWithResourceIdentity *DeadLetterWithResourceIdentity `json:"deadLetterWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription. Uses the managed identity setup on the parent resource
	// (namely, topic or domain) to acquire the
	// authentication tokens being used during delivery / dead-lettering.
	DeliveryWithResourceIdentity *DeliveryWithResourceIdentity `json:"deliveryWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription.
	Destination EventSubscriptionDestinationClassification `json:"destination,omitempty"`

	// The event delivery schema for the event subscription.
	EventDeliverySchema *EventDeliverySchema `json:"eventDeliverySchema,omitempty"`

	// Expiration time of the event subscription.
	ExpirationTimeUTC *time.Time `json:"expirationTimeUtc,omitempty"`

	// Information about the filter for the event subscription.
	Filter *EventSubscriptionFilter `json:"filter,omitempty"`

	// List of user defined labels.
	Labels []*string `json:"labels,omitempty"`

	// The retry policy for events. This can be used to configure maximum number of delivery attempts and time to live for events.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`

	// READ-ONLY; Provisioning state of the event subscription.
	ProvisioningState *EventSubscriptionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the topic of the event subscription.
	Topic *string `json:"topic,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionProperties.
func (e EventSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deadLetterDestination", e.DeadLetterDestination)
	populate(objectMap, "deadLetterWithResourceIdentity", e.DeadLetterWithResourceIdentity)
	populate(objectMap, "deliveryWithResourceIdentity", e.DeliveryWithResourceIdentity)
	populate(objectMap, "destination", e.Destination)
	populate(objectMap, "eventDeliverySchema", e.EventDeliverySchema)
	populateTimeRFC3339(objectMap, "expirationTimeUtc", e.ExpirationTimeUTC)
	populate(objectMap, "filter", e.Filter)
	populate(objectMap, "labels", e.Labels)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "retryPolicy", e.RetryPolicy)
	populate(objectMap, "topic", e.Topic)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionProperties.
func (e *EventSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deadLetterDestination":
			e.DeadLetterDestination, err = unmarshalDeadLetterDestinationClassification(val)
			delete(rawMsg, key)
		case "deadLetterWithResourceIdentity":
			err = unpopulate(val, &e.DeadLetterWithResourceIdentity)
			delete(rawMsg, key)
		case "deliveryWithResourceIdentity":
			err = unpopulate(val, &e.DeliveryWithResourceIdentity)
			delete(rawMsg, key)
		case "destination":
			e.Destination, err = unmarshalEventSubscriptionDestinationClassification(val)
			delete(rawMsg, key)
		case "eventDeliverySchema":
			err = unpopulate(val, &e.EventDeliverySchema)
			delete(rawMsg, key)
		case "expirationTimeUtc":
			err = unpopulateTimeRFC3339(val, &e.ExpirationTimeUTC)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &e.Filter)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &e.Labels)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &e.ProvisioningState)
			delete(rawMsg, key)
		case "retryPolicy":
			err = unpopulate(val, &e.RetryPolicy)
			delete(rawMsg, key)
		case "topic":
			err = unpopulate(val, &e.Topic)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionUpdateParameters - Properties of the Event Subscription update.
type EventSubscriptionUpdateParameters struct {
	// The DeadLetter destination of the event subscription.
	DeadLetterDestination DeadLetterDestinationClassification `json:"deadLetterDestination,omitempty"`

	// The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to the dead letter destination.
	// Uses the managed identity setup on the parent
	// resource (topic / domain) to acquire the authentication tokens being used during delivery / dead-lettering.
	DeadLetterWithResourceIdentity *DeadLetterWithResourceIdentity `json:"deadLetterWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription. Uses the managed identity setup on the parent resource
	// (topic / domain) to acquire the authentication
	// tokens being used during delivery / dead-lettering.
	DeliveryWithResourceIdentity *DeliveryWithResourceIdentity `json:"deliveryWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription.
	Destination EventSubscriptionDestinationClassification `json:"destination,omitempty"`

	// The event delivery schema for the event subscription.
	EventDeliverySchema *EventDeliverySchema `json:"eventDeliverySchema,omitempty"`

	// Information about the expiration time for the event subscription.
	ExpirationTimeUTC *time.Time `json:"expirationTimeUtc,omitempty"`

	// Information about the filter for the event subscription.
	Filter *EventSubscriptionFilter `json:"filter,omitempty"`

	// List of user defined labels.
	Labels []*string `json:"labels,omitempty"`

	// The retry policy for events. This can be used to configure maximum number of delivery attempts and time to live for events.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionUpdateParameters.
func (e EventSubscriptionUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deadLetterDestination", e.DeadLetterDestination)
	populate(objectMap, "deadLetterWithResourceIdentity", e.DeadLetterWithResourceIdentity)
	populate(objectMap, "deliveryWithResourceIdentity", e.DeliveryWithResourceIdentity)
	populate(objectMap, "destination", e.Destination)
	populate(objectMap, "eventDeliverySchema", e.EventDeliverySchema)
	populateTimeRFC3339(objectMap, "expirationTimeUtc", e.ExpirationTimeUTC)
	populate(objectMap, "filter", e.Filter)
	populate(objectMap, "labels", e.Labels)
	populate(objectMap, "retryPolicy", e.RetryPolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionUpdateParameters.
func (e *EventSubscriptionUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deadLetterDestination":
			e.DeadLetterDestination, err = unmarshalDeadLetterDestinationClassification(val)
			delete(rawMsg, key)
		case "deadLetterWithResourceIdentity":
			err = unpopulate(val, &e.DeadLetterWithResourceIdentity)
			delete(rawMsg, key)
		case "deliveryWithResourceIdentity":
			err = unpopulate(val, &e.DeliveryWithResourceIdentity)
			delete(rawMsg, key)
		case "destination":
			e.Destination, err = unmarshalEventSubscriptionDestinationClassification(val)
			delete(rawMsg, key)
		case "eventDeliverySchema":
			err = unpopulate(val, &e.EventDeliverySchema)
			delete(rawMsg, key)
		case "expirationTimeUtc":
			err = unpopulateTimeRFC3339(val, &e.ExpirationTimeUTC)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &e.Filter)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &e.Labels)
			delete(rawMsg, key)
		case "retryPolicy":
			err = unpopulate(val, &e.RetryPolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionsBeginCreateOrUpdateOptions contains the optional parameters for the EventSubscriptions.BeginCreateOrUpdate method.
type EventSubscriptionsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsBeginDeleteOptions contains the optional parameters for the EventSubscriptions.BeginDelete method.
type EventSubscriptionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsBeginUpdateOptions contains the optional parameters for the EventSubscriptions.BeginUpdate method.
type EventSubscriptionsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsGetDeliveryAttributesOptions contains the optional parameters for the EventSubscriptions.GetDeliveryAttributes method.
type EventSubscriptionsGetDeliveryAttributesOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsGetFullURLOptions contains the optional parameters for the EventSubscriptions.GetFullURL method.
type EventSubscriptionsGetFullURLOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsGetOptions contains the optional parameters for the EventSubscriptions.Get method.
type EventSubscriptionsGetOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsListByDomainTopicOptions contains the optional parameters for the EventSubscriptions.ListByDomainTopic method.
type EventSubscriptionsListByDomainTopicOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListByResourceOptions contains the optional parameters for the EventSubscriptions.ListByResource method.
type EventSubscriptionsListByResourceOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListGlobalByResourceGroupForTopicTypeOptions contains the optional parameters for the EventSubscriptions.ListGlobalByResourceGroupForTopicType
// method.
type EventSubscriptionsListGlobalByResourceGroupForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListGlobalByResourceGroupOptions contains the optional parameters for the EventSubscriptions.ListGlobalByResourceGroup method.
type EventSubscriptionsListGlobalByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListGlobalBySubscriptionForTopicTypeOptions contains the optional parameters for the EventSubscriptions.ListGlobalBySubscriptionForTopicType
// method.
type EventSubscriptionsListGlobalBySubscriptionForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListGlobalBySubscriptionOptions contains the optional parameters for the EventSubscriptions.ListGlobalBySubscription method.
type EventSubscriptionsListGlobalBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListRegionalByResourceGroupForTopicTypeOptions contains the optional parameters for the EventSubscriptions.ListRegionalByResourceGroupForTopicType
// method.
type EventSubscriptionsListRegionalByResourceGroupForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListRegionalByResourceGroupOptions contains the optional parameters for the EventSubscriptions.ListRegionalByResourceGroup method.
type EventSubscriptionsListRegionalByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListRegionalBySubscriptionForTopicTypeOptions contains the optional parameters for the EventSubscriptions.ListRegionalBySubscriptionForTopicType
// method.
type EventSubscriptionsListRegionalBySubscriptionForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListRegionalBySubscriptionOptions contains the optional parameters for the EventSubscriptions.ListRegionalBySubscription method.
type EventSubscriptionsListRegionalBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListResult - Result of the List EventSubscriptions operation
type EventSubscriptionsListResult struct {
	// A link for the next page of event subscriptions
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of EventSubscriptions
	Value []*EventSubscription `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionsListResult.
func (e EventSubscriptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EventType - Event Type for a subject under a topic
type EventType struct {
	Resource
	// Properties of the event type.
	Properties *EventTypeProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventType.
func (e EventType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// EventTypeProperties - Properties of the event type
type EventTypeProperties struct {
	// Description of the event type.
	Description *string `json:"description,omitempty"`

	// Display name of the event type.
	DisplayName *string `json:"displayName,omitempty"`

	// IsInDefaultSet flag of the event type.
	IsInDefaultSet *bool `json:"isInDefaultSet,omitempty"`

	// Url of the schema for this event type.
	SchemaURL *string `json:"schemaUrl,omitempty"`
}

// EventTypesListResult - Result of the List Event Types operation
type EventTypesListResult struct {
	// A collection of event types
	Value []*EventType `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventTypesListResult.
func (e EventTypesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExtensionTopic - Event grid Extension Topic. This is used for getting Event Grid related metrics for Azure resources.
type ExtensionTopic struct {
	Resource
	// Properties of the extension topic
	Properties *ExtensionTopicProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to the Extension Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionTopic.
func (e ExtensionTopic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	return json.Marshal(objectMap)
}

// ExtensionTopicProperties - Properties of the Extension Topic
type ExtensionTopicProperties struct {
	// Description of the extension topic.
	Description *string `json:"description,omitempty"`

	// System topic resource id which is mapped to the source.
	SystemTopic *string `json:"systemTopic,omitempty"`
}

// ExtensionTopicsGetOptions contains the optional parameters for the ExtensionTopics.Get method.
type ExtensionTopicsGetOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionEventSubscriptionDestination - Information about the HybridConnection destination for an event subscription.
type HybridConnectionEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// Hybrid connection Properties of the event subscription destination.
	Properties *HybridConnectionEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnectionEventSubscriptionDestination.
func (h HybridConnectionEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeHybridConnection)
	populate(objectMap, "properties", h.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HybridConnectionEventSubscriptionDestination.
func (h *HybridConnectionEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &h.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HybridConnectionEventSubscriptionDestinationProperties - The properties for a hybrid connection destination.
type HybridConnectionEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource ID of an hybrid connection that is the destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnectionEventSubscriptionDestinationProperties.
func (h HybridConnectionEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", h.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", h.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HybridConnectionEventSubscriptionDestinationProperties.
func (h *HybridConnectionEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			h.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &h.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IdentityInfo - The identity information for the resource.
type IdentityInfo struct {
	// The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`

	// The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`

	// The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities.
	// The type 'None' will remove any identity.
	Type *IdentityType `json:"type,omitempty"`

	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'. This
	// property is currently not used and reserved for
	// future usage.
	UserAssignedIdentities map[string]*UserIdentityProperties `json:"userAssignedIdentities,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IdentityInfo.
func (i IdentityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

type InboundIPRule struct {
	// Action to perform based on the match or no match of the IpMask.
	Action *IPActionType `json:"action,omitempty"`

	// IP Address in CIDR notation e.g., 10.0.0.0/8.
	IPMask *string `json:"ipMask,omitempty"`
}

// InputSchemaMappingClassification provides polymorphic access to related types.
// Call the interface's GetInputSchemaMapping() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *InputSchemaMapping, *JsonInputSchemaMapping
type InputSchemaMappingClassification interface {
	// GetInputSchemaMapping returns the InputSchemaMapping content of the underlying type.
	GetInputSchemaMapping() *InputSchemaMapping
}

// InputSchemaMapping - By default, Event Grid expects events to be in the Event Grid event schema. Specifying an input schema mapping enables publishing
// to Event Grid using a custom input schema. Currently, the only
// supported type of InputSchemaMapping is 'JsonInputSchemaMapping'.
type InputSchemaMapping struct {
	// REQUIRED; Type of the custom mapping
	InputSchemaMappingType *InputSchemaMappingType `json:"inputSchemaMappingType,omitempty"`
}

// GetInputSchemaMapping implements the InputSchemaMappingClassification interface for type InputSchemaMapping.
func (i *InputSchemaMapping) GetInputSchemaMapping() *InputSchemaMapping { return i }

// UnmarshalJSON implements the json.Unmarshaller interface for type InputSchemaMapping.
func (i *InputSchemaMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return i.unmarshalInternal(rawMsg)
}

func (i InputSchemaMapping) marshalInternal(objectMap map[string]interface{}, discValue InputSchemaMappingType) {
	i.InputSchemaMappingType = &discValue
	objectMap["inputSchemaMappingType"] = i.InputSchemaMappingType
}

func (i *InputSchemaMapping) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputSchemaMappingType":
			err = unpopulate(val, &i.InputSchemaMappingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONField - This is used to express the source of an input schema mapping for a single target field in the Event Grid Event schema. This is currently
// used in the mappings for the 'id', 'topic' and 'eventtime'
// properties. This represents a field in the input event schema.
type JSONField struct {
	// Name of a field in the input event schema that's to be used as the source of a mapping.
	SourceField *string `json:"sourceField,omitempty"`
}

// JSONFieldWithDefault - This is used to express the source of an input schema mapping for a single target field in the Event Grid Event schema. This is
// currently used in the mappings for the 'subject', 'eventtype' and
// 'dataversion' properties. This represents a field in the input event schema along with a default value to be used, and at least one of these two properties
// should be provided.
type JSONFieldWithDefault struct {
	// The default value to be used for mapping when a SourceField is not provided or if there's no property with the specified name in the published JSON event
	// payload.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Name of a field in the input event schema that's to be used as the source of a mapping.
	SourceField *string `json:"sourceField,omitempty"`
}

// JSONInputSchemaMapping - This enables publishing to Event Grid using a custom input schema. This can be used to map properties from a custom input JSON
// schema to the Event Grid event schema.
type JSONInputSchemaMapping struct {
	InputSchemaMapping
	// JSON Properties of the input schema mapping
	Properties *JSONInputSchemaMappingProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONInputSchemaMapping.
func (j JSONInputSchemaMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.InputSchemaMapping.marshalInternal(objectMap, InputSchemaMappingTypeJSON)
	populate(objectMap, "properties", j.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONInputSchemaMapping.
func (j *JSONInputSchemaMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.InputSchemaMapping.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JSONInputSchemaMappingProperties - This can be used to map properties of a source schema (or default values, for certain supported properties) to properties
// of the EventGridEvent schema.
type JSONInputSchemaMappingProperties struct {
	// The mapping information for the DataVersion property of the Event Grid Event.
	DataVersion *JSONFieldWithDefault `json:"dataVersion,omitempty"`

	// The mapping information for the EventTime property of the Event Grid Event.
	EventTime *JSONField `json:"eventTime,omitempty"`

	// The mapping information for the EventType property of the Event Grid Event.
	EventType *JSONFieldWithDefault `json:"eventType,omitempty"`

	// The mapping information for the Id property of the Event Grid Event.
	ID *JSONField `json:"id,omitempty"`

	// The mapping information for the Subject property of the Event Grid Event.
	Subject *JSONFieldWithDefault `json:"subject,omitempty"`

	// The mapping information for the Topic property of the Event Grid Event.
	Topic *JSONField `json:"topic,omitempty"`
}

// NumberGreaterThanAdvancedFilter - NumberGreaterThan Advanced Filter.
type NumberGreaterThanAdvancedFilter struct {
	AdvancedFilter
	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberGreaterThanAdvancedFilter.
func (n NumberGreaterThanAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeNumberGreaterThan)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberGreaterThanAdvancedFilter.
func (n *NumberGreaterThanAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NumberGreaterThanOrEqualsAdvancedFilter - NumberGreaterThanOrEquals Advanced Filter.
type NumberGreaterThanOrEqualsAdvancedFilter struct {
	AdvancedFilter
	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberGreaterThanOrEqualsAdvancedFilter.
func (n NumberGreaterThanOrEqualsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeNumberGreaterThanOrEquals)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberGreaterThanOrEqualsAdvancedFilter.
func (n *NumberGreaterThanOrEqualsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NumberInAdvancedFilter - NumberIn Advanced Filter.
type NumberInAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*float64 `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberInAdvancedFilter.
func (n NumberInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeNumberIn)
	populate(objectMap, "values", n.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberInAdvancedFilter.
func (n *NumberInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &n.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NumberLessThanAdvancedFilter - NumberLessThan Advanced Filter.
type NumberLessThanAdvancedFilter struct {
	AdvancedFilter
	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberLessThanAdvancedFilter.
func (n NumberLessThanAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeNumberLessThan)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberLessThanAdvancedFilter.
func (n *NumberLessThanAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NumberLessThanOrEqualsAdvancedFilter - NumberLessThanOrEquals Advanced Filter.
type NumberLessThanOrEqualsAdvancedFilter struct {
	AdvancedFilter
	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberLessThanOrEqualsAdvancedFilter.
func (n NumberLessThanOrEqualsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeNumberLessThanOrEquals)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberLessThanOrEqualsAdvancedFilter.
func (n *NumberLessThanOrEqualsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NumberNotInAdvancedFilter - NumberNotIn Advanced Filter.
type NumberNotInAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*float64 `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberNotInAdvancedFilter.
func (n NumberNotInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeNumberNotIn)
	populate(objectMap, "values", n.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberNotInAdvancedFilter.
func (n *NumberNotInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &n.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Operation - Represents an operation returned by the GetOperations request
type Operation struct {
	// Display name of the operation
	Display *OperationInfo `json:"display,omitempty"`

	// Name of the operation
	Name *string `json:"name,omitempty"`

	// Origin of the operation
	Origin *string `json:"origin,omitempty"`

	// Properties of the operation
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// OperationInfo - Information about an operation
type OperationInfo struct {
	// Description of the operation
	Description *string `json:"description,omitempty"`

	// Name of the operation
	Operation *string `json:"operation,omitempty"`

	// Name of the provider
	Provider *string `json:"provider,omitempty"`

	// Name of the resource type
	Resource *string `json:"resource,omitempty"`
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OperationsListResult - Result of the List Operations operation
type OperationsListResult struct {
	// A collection of operations
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationsListResult.
func (o OperationsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpoint information.
type PrivateEndpoint struct {
	// The ARM identifier for Private Endpoint.
	ID *string `json:"id,omitempty"`
}

type PrivateEndpointConnection struct {
	Resource
	// Properties of the PrivateEndpointConnection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionListResult - Result of the list of all private endpoint connections operation.
type PrivateEndpointConnectionListResult struct {
	// A link for the next page of private endpoint connection resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private endpoint connection resources.
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the private endpoint connection resource.
type PrivateEndpointConnectionProperties struct {
	// GroupIds from the private link service resource.
	GroupIDs []*string `json:"groupIds,omitempty"`

	// The Private Endpoint resource for this Connection.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// Details about the state of the connection.
	PrivateLinkServiceConnectionState *ConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// Provisioning state of the Private Endpoint Connection.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProperties.
func (p PrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupIds", p.GroupIDs)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionsBeginDeleteOptions contains the optional parameters for the PrivateEndpointConnections.BeginDelete method.
type PrivateEndpointConnectionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsBeginUpdateOptions contains the optional parameters for the PrivateEndpointConnections.BeginUpdate method.
type PrivateEndpointConnectionsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListByResourceOptions contains the optional parameters for the PrivateEndpointConnections.ListByResource method.
type PrivateEndpointConnectionsListByResourceOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// PrivateLinkResource - Information of the private link resource.
type PrivateLinkResource struct {
	// Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty"`

	// Name of the resource.
	Name *string `json:"name,omitempty"`

	// Properties of the private link resource.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// Type of the resource.
	Type *string `json:"type,omitempty"`
}

type PrivateLinkResourceProperties struct {
	DisplayName       *string   `json:"displayName,omitempty"`
	GroupID           *string   `json:"groupId,omitempty"`
	RequiredMembers   []*string `json:"requiredMembers,omitempty"`
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesGetOptions contains the optional parameters for the PrivateLinkResources.Get method.
type PrivateLinkResourcesGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesListByResourceOptions contains the optional parameters for the PrivateLinkResources.ListByResource method.
type PrivateLinkResourcesListByResourceOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// PrivateLinkResourcesListResult - Result of the List private link resources operation.
type PrivateLinkResourcesListResult struct {
	// A link for the next page of private link resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourcesListResult.
func (p PrivateLinkResourcesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// Resource - Definition of a Resource.
type Resource struct {
	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

// RetryPolicy - Information about the retry policy for an event subscription.
type RetryPolicy struct {
	// Time To Live (in minutes) for events.
	EventTimeToLiveInMinutes *int32 `json:"eventTimeToLiveInMinutes,omitempty"`

	// Maximum number of delivery retry attempts for events.
	MaxDeliveryAttempts *int32 `json:"maxDeliveryAttempts,omitempty"`
}

// ServiceBusQueueEventSubscriptionDestination - Information about the service bus destination for an event subscription.
type ServiceBusQueueEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// Service Bus Properties of the event subscription destination.
	Properties *ServiceBusQueueEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueEventSubscriptionDestination.
func (s ServiceBusQueueEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeServiceBusQueue)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusQueueEventSubscriptionDestination.
func (s *ServiceBusQueueEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceBusQueueEventSubscriptionDestinationProperties - The properties that represent the Service Bus destination of an event subscription.
type ServiceBusQueueEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource Id that represents the endpoint of the Service Bus destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueEventSubscriptionDestinationProperties.
func (s ServiceBusQueueEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", s.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", s.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusQueueEventSubscriptionDestinationProperties.
func (s *ServiceBusQueueEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			s.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &s.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceBusTopicEventSubscriptionDestination - Information about the service bus topic destination for an event subscription.
type ServiceBusTopicEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// Service Bus Topic Properties of the event subscription destination.
	Properties *ServiceBusTopicEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicEventSubscriptionDestination.
func (s ServiceBusTopicEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeServiceBusTopic)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusTopicEventSubscriptionDestination.
func (s *ServiceBusTopicEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceBusTopicEventSubscriptionDestinationProperties - The properties that represent the Service Bus Topic destination of an event subscription.
type ServiceBusTopicEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource Id that represents the endpoint of the Service Bus Topic destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicEventSubscriptionDestinationProperties.
func (s ServiceBusTopicEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", s.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", s.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusTopicEventSubscriptionDestinationProperties.
func (s *ServiceBusTopicEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			s.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &s.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StaticDeliveryAttributeMapping - Static delivery attribute mapping details.
type StaticDeliveryAttributeMapping struct {
	DeliveryAttributeMapping
	// Properties of static delivery attribute mapping.
	Properties *StaticDeliveryAttributeMappingProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StaticDeliveryAttributeMapping.
func (s StaticDeliveryAttributeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.DeliveryAttributeMapping.marshalInternal(objectMap, DeliveryAttributeMappingTypeStatic)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticDeliveryAttributeMapping.
func (s *StaticDeliveryAttributeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.DeliveryAttributeMapping.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StaticDeliveryAttributeMappingProperties - Properties of static delivery attribute mapping.
type StaticDeliveryAttributeMappingProperties struct {
	// Boolean flag to tell if the attribute contains sensitive information .
	IsSecret *bool `json:"isSecret,omitempty"`

	// Value of the delivery attribute.
	Value *string `json:"value,omitempty"`
}

// StorageBlobDeadLetterDestination - Information about the storage blob based dead letter destination.
type StorageBlobDeadLetterDestination struct {
	DeadLetterDestination
	// The properties of the Storage Blob based deadletter destination
	Properties *StorageBlobDeadLetterDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageBlobDeadLetterDestination.
func (s StorageBlobDeadLetterDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.DeadLetterDestination.marshalInternal(objectMap, DeadLetterEndPointTypeStorageBlob)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageBlobDeadLetterDestination.
func (s *StorageBlobDeadLetterDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.DeadLetterDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StorageBlobDeadLetterDestinationProperties - Properties of the storage blob based dead letter destination.
type StorageBlobDeadLetterDestinationProperties struct {
	// The name of the Storage blob container that is the destination of the deadletter events
	BlobContainerName *string `json:"blobContainerName,omitempty"`

	// The Azure Resource ID of the storage account that is the destination of the deadletter events
	ResourceID *string `json:"resourceId,omitempty"`
}

// StorageQueueEventSubscriptionDestination - Information about the storage queue destination for an event subscription.
type StorageQueueEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// Storage Queue Properties of the event subscription destination.
	Properties *StorageQueueEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageQueueEventSubscriptionDestination.
func (s StorageQueueEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeStorageQueue)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageQueueEventSubscriptionDestination.
func (s *StorageQueueEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StorageQueueEventSubscriptionDestinationProperties - The properties for a storage queue destination.
type StorageQueueEventSubscriptionDestinationProperties struct {
	// Storage queue message time to live in seconds.
	QueueMessageTimeToLiveInSeconds *int64 `json:"queueMessageTimeToLiveInSeconds,omitempty"`

	// The name of the Storage queue under a storage account that is the destination of an event subscription.
	QueueName *string `json:"queueName,omitempty"`

	// The Azure Resource ID of the storage account that contains the queue that is the destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// StringBeginsWithAdvancedFilter - StringBeginsWith Advanced Filter.
type StringBeginsWithAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StringBeginsWithAdvancedFilter.
func (s StringBeginsWithAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeStringBeginsWith)
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringBeginsWithAdvancedFilter.
func (s *StringBeginsWithAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StringContainsAdvancedFilter - StringContains Advanced Filter.
type StringContainsAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StringContainsAdvancedFilter.
func (s StringContainsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeStringContains)
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringContainsAdvancedFilter.
func (s *StringContainsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StringEndsWithAdvancedFilter - StringEndsWith Advanced Filter.
type StringEndsWithAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StringEndsWithAdvancedFilter.
func (s StringEndsWithAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeStringEndsWith)
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringEndsWithAdvancedFilter.
func (s *StringEndsWithAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StringInAdvancedFilter - StringIn Advanced Filter.
type StringInAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StringInAdvancedFilter.
func (s StringInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeStringIn)
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringInAdvancedFilter.
func (s *StringInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StringNotInAdvancedFilter - StringNotIn Advanced Filter.
type StringNotInAdvancedFilter struct {
	AdvancedFilter
	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StringNotInAdvancedFilter.
func (s StringNotInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AdvancedFilter.marshalInternal(objectMap, AdvancedFilterOperatorTypeStringNotIn)
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringNotInAdvancedFilter.
func (s *StringNotInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AdvancedFilter.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SystemTopic - EventGrid System Topic.
type SystemTopic struct {
	TrackedResource
	// Identity information for the resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the system topic.
	Properties *SystemTopicProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to System Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemTopic.
func (s SystemTopic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// SystemTopicEventSubscriptionsBeginCreateOrUpdateOptions contains the optional parameters for the SystemTopicEventSubscriptions.BeginCreateOrUpdate method.
type SystemTopicEventSubscriptionsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsBeginDeleteOptions contains the optional parameters for the SystemTopicEventSubscriptions.BeginDelete method.
type SystemTopicEventSubscriptionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsBeginUpdateOptions contains the optional parameters for the SystemTopicEventSubscriptions.BeginUpdate method.
type SystemTopicEventSubscriptionsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsGetDeliveryAttributesOptions contains the optional parameters for the SystemTopicEventSubscriptions.GetDeliveryAttributes
// method.
type SystemTopicEventSubscriptionsGetDeliveryAttributesOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsGetFullURLOptions contains the optional parameters for the SystemTopicEventSubscriptions.GetFullURL method.
type SystemTopicEventSubscriptionsGetFullURLOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsGetOptions contains the optional parameters for the SystemTopicEventSubscriptions.Get method.
type SystemTopicEventSubscriptionsGetOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsListBySystemTopicOptions contains the optional parameters for the SystemTopicEventSubscriptions.ListBySystemTopic method.
type SystemTopicEventSubscriptionsListBySystemTopicOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// SystemTopicProperties - Properties of the System Topic.
type SystemTopicProperties struct {
	// Source for the system topic.
	Source *string `json:"source,omitempty"`

	// TopicType for the system topic.
	TopicType *string `json:"topicType,omitempty"`

	// READ-ONLY; Metric resource id for the system topic.
	MetricResourceID *string `json:"metricResourceId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the system topic.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// SystemTopicUpdateParameters - Properties of the System Topic update.
type SystemTopicUpdateParameters struct {
	// Resource identity information.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Tags of the system topic.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemTopicUpdateParameters.
func (s SystemTopicUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SystemTopicsBeginCreateOrUpdateOptions contains the optional parameters for the SystemTopics.BeginCreateOrUpdate method.
type SystemTopicsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsBeginDeleteOptions contains the optional parameters for the SystemTopics.BeginDelete method.
type SystemTopicsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsBeginUpdateOptions contains the optional parameters for the SystemTopics.BeginUpdate method.
type SystemTopicsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsGetOptions contains the optional parameters for the SystemTopics.Get method.
type SystemTopicsGetOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsListByResourceGroupOptions contains the optional parameters for the SystemTopics.ListByResourceGroup method.
type SystemTopicsListByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// SystemTopicsListBySubscriptionOptions contains the optional parameters for the SystemTopics.ListBySubscription method.
type SystemTopicsListBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// SystemTopicsListResult - Result of the List System topics operation.
type SystemTopicsListResult struct {
	// A link for the next page of topics.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of system Topics.
	Value []*SystemTopic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemTopicsListResult.
func (s SystemTopicsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// Topic - EventGrid Topic
type Topic struct {
	TrackedResource
	// Identity information for the resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the topic.
	Properties *TopicProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Topic.
func (t Topic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	return json.Marshal(objectMap)
}

// TopicProperties - Properties of the Topic
type TopicProperties struct {
	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD token will be used to authenticate
	// if user is allowed to publish to the topic.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines the format that Event Grid should expect for incoming events published to the topic.
	InputSchema *InputSchema `json:"inputSchema,omitempty"`

	// This enables publishing using custom event schemas. An InputSchemaMapping can be specified to map various properties of a source schema to various required
	// properties of the EventGridEvent schema.
	InputSchemaMapping InputSchemaMappingClassification `json:"inputSchemaMapping,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// READ-ONLY; Endpoint for the topic.
	Endpoint *string `json:"endpoint,omitempty" azure:"ro"`

	// READ-ONLY; Metric resource id for the topic.
	MetricResourceID *string `json:"metricResourceId,omitempty" azure:"ro"`

	// READ-ONLY
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the topic.
	ProvisioningState *TopicProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicProperties.
func (t TopicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableLocalAuth", t.DisableLocalAuth)
	populate(objectMap, "endpoint", t.Endpoint)
	populate(objectMap, "inboundIpRules", t.InboundIPRules)
	populate(objectMap, "inputSchema", t.InputSchema)
	populate(objectMap, "inputSchemaMapping", t.InputSchemaMapping)
	populate(objectMap, "metricResourceId", t.MetricResourceID)
	populate(objectMap, "privateEndpointConnections", t.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", t.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopicProperties.
func (t *TopicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableLocalAuth":
			err = unpopulate(val, &t.DisableLocalAuth)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &t.Endpoint)
			delete(rawMsg, key)
		case "inboundIpRules":
			err = unpopulate(val, &t.InboundIPRules)
			delete(rawMsg, key)
		case "inputSchema":
			err = unpopulate(val, &t.InputSchema)
			delete(rawMsg, key)
		case "inputSchemaMapping":
			t.InputSchemaMapping, err = unmarshalInputSchemaMappingClassification(val)
			delete(rawMsg, key)
		case "metricResourceId":
			err = unpopulate(val, &t.MetricResourceID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &t.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &t.PublicNetworkAccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TopicRegenerateKeyRequest - Topic regenerate share access key request
type TopicRegenerateKeyRequest struct {
	// REQUIRED; Key name to regenerate key1 or key2
	KeyName *string `json:"keyName,omitempty"`
}

// TopicSharedAccessKeys - Shared access keys of the Topic
type TopicSharedAccessKeys struct {
	// Shared access key1 for the topic.
	Key1 *string `json:"key1,omitempty"`

	// Shared access key2 for the topic.
	Key2 *string `json:"key2,omitempty"`
}

// TopicTypeInfo - Properties of a topic type info.
type TopicTypeInfo struct {
	Resource
	// Properties of the topic type info
	Properties *TopicTypeProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicTypeInfo.
func (t TopicTypeInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// TopicTypeProperties - Properties of a topic type.
type TopicTypeProperties struct {
	// Description of the topic type.
	Description *string `json:"description,omitempty"`

	// Display Name for the topic type.
	DisplayName *string `json:"displayName,omitempty"`

	// Namespace of the provider of the topic type.
	Provider *string `json:"provider,omitempty"`

	// Provisioning state of the topic type
	ProvisioningState *TopicTypeProvisioningState `json:"provisioningState,omitempty"`

	// Region type of the resource.
	ResourceRegionType *ResourceRegionType `json:"resourceRegionType,omitempty"`

	// Source resource format.
	SourceResourceFormat *string `json:"sourceResourceFormat,omitempty"`

	// List of locations supported by this topic type.
	SupportedLocations []*string `json:"supportedLocations,omitempty"`

	// Supported source scopes.
	SupportedScopesForSource []*TopicTypePropertiesSupportedScopesForSourceItem `json:"supportedScopesForSource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicTypeProperties.
func (t TopicTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "provider", t.Provider)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "resourceRegionType", t.ResourceRegionType)
	populate(objectMap, "sourceResourceFormat", t.SourceResourceFormat)
	populate(objectMap, "supportedLocations", t.SupportedLocations)
	populate(objectMap, "supportedScopesForSource", t.SupportedScopesForSource)
	return json.Marshal(objectMap)
}

// TopicTypesGetOptions contains the optional parameters for the TopicTypes.Get method.
type TopicTypesGetOptions struct {
	// placeholder for future optional parameters
}

// TopicTypesListEventTypesOptions contains the optional parameters for the TopicTypes.ListEventTypes method.
type TopicTypesListEventTypesOptions struct {
	// placeholder for future optional parameters
}

// TopicTypesListOptions contains the optional parameters for the TopicTypes.List method.
type TopicTypesListOptions struct {
	// placeholder for future optional parameters
}

// TopicTypesListResult - Result of the List Topic Types operation
type TopicTypesListResult struct {
	// A collection of topic types
	Value []*TopicTypeInfo `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicTypesListResult.
func (t TopicTypesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TopicUpdateParameterProperties - Information of topic update parameter properties.
type TopicUpdateParameterProperties struct {
	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD token will be used to authenticate
	// if user is allowed to publish to the topic.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicUpdateParameterProperties.
func (t TopicUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableLocalAuth", t.DisableLocalAuth)
	populate(objectMap, "inboundIpRules", t.InboundIPRules)
	populate(objectMap, "publicNetworkAccess", t.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// TopicUpdateParameters - Properties of the Topic update
type TopicUpdateParameters struct {
	// Topic resource identity information.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the resource.
	Properties *TopicUpdateParameterProperties `json:"properties,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicUpdateParameters.
func (t TopicUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// TopicsBeginCreateOrUpdateOptions contains the optional parameters for the Topics.BeginCreateOrUpdate method.
type TopicsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TopicsBeginDeleteOptions contains the optional parameters for the Topics.BeginDelete method.
type TopicsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// TopicsBeginRegenerateKeyOptions contains the optional parameters for the Topics.BeginRegenerateKey method.
type TopicsBeginRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// TopicsBeginUpdateOptions contains the optional parameters for the Topics.BeginUpdate method.
type TopicsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// TopicsGetOptions contains the optional parameters for the Topics.Get method.
type TopicsGetOptions struct {
	// placeholder for future optional parameters
}

// TopicsListByResourceGroupOptions contains the optional parameters for the Topics.ListByResourceGroup method.
type TopicsListByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// TopicsListBySubscriptionOptions contains the optional parameters for the Topics.ListBySubscription method.
type TopicsListBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and with limited number of OData operations.
	// These operations are: the 'contains' function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example: $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a
	// valid filter example: $filter=location eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified, the default number of results
	// to be returned is 20 items per page.
	Top *int32
}

// TopicsListEventTypesOptions contains the optional parameters for the Topics.ListEventTypes method.
type TopicsListEventTypesOptions struct {
	// placeholder for future optional parameters
}

// TopicsListResult - Result of the List Topics operation
type TopicsListResult struct {
	// A link for the next page of topics
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of Topics
	Value []*Topic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicsListResult.
func (t TopicsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TopicsListSharedAccessKeysOptions contains the optional parameters for the Topics.ListSharedAccessKeys method.
type TopicsListSharedAccessKeysOptions struct {
	// placeholder for future optional parameters
}

// TrackedResource - Definition of a Tracked Resource.
type TrackedResource struct {
	Resource
	// REQUIRED; Location of the resource.
	Location *string `json:"location,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
}

// UserIdentityProperties - The information about the user identity.
type UserIdentityProperties struct {
	// The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty"`

	// The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty"`
}

// WebHookEventSubscriptionDestination - Information about the webhook destination for an event subscription.
type WebHookEventSubscriptionDestination struct {
	EventSubscriptionDestination
	// WebHook Properties of the event subscription destination.
	Properties *WebHookEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebHookEventSubscriptionDestination.
func (w WebHookEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.EventSubscriptionDestination.marshalInternal(objectMap, EndpointTypeWebHook)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookEventSubscriptionDestination.
func (w *WebHookEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := w.EventSubscriptionDestination.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// WebHookEventSubscriptionDestinationProperties - Information about the webhook destination properties for an event subscription.
type WebHookEventSubscriptionDestinationProperties struct {
	// The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
	AzureActiveDirectoryApplicationIDOrURI *string `json:"azureActiveDirectoryApplicationIdOrUri,omitempty"`

	// The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
	AzureActiveDirectoryTenantID *string `json:"azureActiveDirectoryTenantId,omitempty"`

	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The URL that represents the endpoint of the destination of an event subscription.
	EndpointURL *string `json:"endpointUrl,omitempty"`

	// Maximum number of events per batch.
	MaxEventsPerBatch *int32 `json:"maxEventsPerBatch,omitempty"`

	// Preferred batch size in Kilobytes.
	PreferredBatchSizeInKilobytes *int32 `json:"preferredBatchSizeInKilobytes,omitempty"`

	// READ-ONLY; The base URL that represents the endpoint of the destination of an event subscription.
	EndpointBaseURL *string `json:"endpointBaseUrl,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WebHookEventSubscriptionDestinationProperties.
func (w WebHookEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureActiveDirectoryApplicationIdOrUri", w.AzureActiveDirectoryApplicationIDOrURI)
	populate(objectMap, "azureActiveDirectoryTenantId", w.AzureActiveDirectoryTenantID)
	populate(objectMap, "deliveryAttributeMappings", w.DeliveryAttributeMappings)
	populate(objectMap, "endpointBaseUrl", w.EndpointBaseURL)
	populate(objectMap, "endpointUrl", w.EndpointURL)
	populate(objectMap, "maxEventsPerBatch", w.MaxEventsPerBatch)
	populate(objectMap, "preferredBatchSizeInKilobytes", w.PreferredBatchSizeInKilobytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookEventSubscriptionDestinationProperties.
func (w *WebHookEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureActiveDirectoryApplicationIdOrUri":
			err = unpopulate(val, &w.AzureActiveDirectoryApplicationIDOrURI)
			delete(rawMsg, key)
		case "azureActiveDirectoryTenantId":
			err = unpopulate(val, &w.AzureActiveDirectoryTenantID)
			delete(rawMsg, key)
		case "deliveryAttributeMappings":
			w.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "endpointBaseUrl":
			err = unpopulate(val, &w.EndpointBaseURL)
			delete(rawMsg, key)
		case "endpointUrl":
			err = unpopulate(val, &w.EndpointURL)
			delete(rawMsg, key)
		case "maxEventsPerBatch":
			err = unpopulate(val, &w.MaxEventsPerBatch)
			delete(rawMsg, key)
		case "preferredBatchSizeInKilobytes":
			err = unpopulate(val, &w.PreferredBatchSizeInKilobytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
