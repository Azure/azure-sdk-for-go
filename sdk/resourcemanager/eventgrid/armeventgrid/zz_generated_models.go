//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armeventgrid

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AdvancedFilterClassification provides polymorphic access to related types.
// Call the interface's GetAdvancedFilter() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AdvancedFilter, *BoolEqualsAdvancedFilter, *IsNotNullAdvancedFilter, *IsNullOrUndefinedAdvancedFilter, *NumberGreaterThanAdvancedFilter,
// - *NumberGreaterThanOrEqualsAdvancedFilter, *NumberInAdvancedFilter, *NumberInRangeAdvancedFilter, *NumberLessThanAdvancedFilter,
// - *NumberLessThanOrEqualsAdvancedFilter, *NumberNotInAdvancedFilter, *NumberNotInRangeAdvancedFilter, *StringBeginsWithAdvancedFilter,
// - *StringContainsAdvancedFilter, *StringEndsWithAdvancedFilter, *StringInAdvancedFilter, *StringNotBeginsWithAdvancedFilter,
// - *StringNotContainsAdvancedFilter, *StringNotEndsWithAdvancedFilter, *StringNotInAdvancedFilter
type AdvancedFilterClassification interface {
	// GetAdvancedFilter returns the AdvancedFilter content of the underlying type.
	GetAdvancedFilter() *AdvancedFilter
}

// AdvancedFilter - This is the base type that represents an advanced filter. To configure an advanced filter, do not directly
// instantiate an object of this class. Instead, instantiate an object of a derived class such
// as BoolEqualsAdvancedFilter, NumberInAdvancedFilter, StringEqualsAdvancedFilter etc. depending on the type of the key based
// on which you want to filter.
type AdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type AdvancedFilter.
func (a *AdvancedFilter) GetAdvancedFilter() *AdvancedFilter { return a }

// AzureFunctionEventSubscriptionDestination - Information about the azure function destination for an event subscription.
type AzureFunctionEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// Azure Function Properties of the event subscription destination.
	Properties *AzureFunctionEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type AzureFunctionEventSubscriptionDestination.
func (a *AzureFunctionEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: a.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionEventSubscriptionDestination.
func (a AzureFunctionEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeAzureFunction
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionEventSubscriptionDestination.
func (a *AzureFunctionEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &a.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureFunctionEventSubscriptionDestinationProperties - The properties that represent the Azure Function destination of an
// event subscription.
type AzureFunctionEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// Maximum number of events per batch.
	MaxEventsPerBatch *int32 `json:"maxEventsPerBatch,omitempty"`

	// Preferred batch size in Kilobytes.
	PreferredBatchSizeInKilobytes *int32 `json:"preferredBatchSizeInKilobytes,omitempty"`

	// The Azure Resource Id that represents the endpoint of the Azure Function destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionEventSubscriptionDestinationProperties.
func (a AzureFunctionEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", a.DeliveryAttributeMappings)
	populate(objectMap, "maxEventsPerBatch", a.MaxEventsPerBatch)
	populate(objectMap, "preferredBatchSizeInKilobytes", a.PreferredBatchSizeInKilobytes)
	populate(objectMap, "resourceId", a.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionEventSubscriptionDestinationProperties.
func (a *AzureFunctionEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			a.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "maxEventsPerBatch":
			err = unpopulate(val, &a.MaxEventsPerBatch)
			delete(rawMsg, key)
		case "preferredBatchSizeInKilobytes":
			err = unpopulate(val, &a.PreferredBatchSizeInKilobytes)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &a.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BoolEqualsAdvancedFilter - BoolEquals Advanced Filter.
type BoolEqualsAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The boolean filter value.
	Value *bool `json:"value,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type BoolEqualsAdvancedFilter.
func (b *BoolEqualsAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: b.OperatorType,
		Key:          b.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BoolEqualsAdvancedFilter.
func (b BoolEqualsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", b.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeBoolEquals
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BoolEqualsAdvancedFilter.
func (b *BoolEqualsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &b.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &b.OperatorType)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectionState information.
type ConnectionState struct {
	// Actions required (if any).
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description of the connection state.
	Description *string `json:"description,omitempty"`

	// Status of the connection.
	Status *PersistedConnectionStatus `json:"status,omitempty"`
}

// DeadLetterDestinationClassification provides polymorphic access to related types.
// Call the interface's GetDeadLetterDestination() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DeadLetterDestination, *StorageBlobDeadLetterDestination
type DeadLetterDestinationClassification interface {
	// GetDeadLetterDestination returns the DeadLetterDestination content of the underlying type.
	GetDeadLetterDestination() *DeadLetterDestination
}

// DeadLetterDestination - Information about the dead letter destination for an event subscription. To configure a deadletter
// destination, do not directly instantiate an object of this class. Instead, instantiate an object of a
// derived class. Currently, StorageBlobDeadLetterDestination is the only class that derives from this class.
type DeadLetterDestination struct {
	// REQUIRED; Type of the endpoint for the dead letter destination
	EndpointType *DeadLetterEndPointType `json:"endpointType,omitempty"`
}

// GetDeadLetterDestination implements the DeadLetterDestinationClassification interface for type DeadLetterDestination.
func (d *DeadLetterDestination) GetDeadLetterDestination() *DeadLetterDestination { return d }

// DeadLetterWithResourceIdentity - Information about the deadletter destination with resource identity.
type DeadLetterWithResourceIdentity struct {
	// Information about the destination where events have to be delivered for the event subscription. Uses the managed identity
	// setup on the parent resource (namely, topic or domain) to acquire the
	// authentication tokens being used during delivery / dead-lettering.
	DeadLetterDestination DeadLetterDestinationClassification `json:"deadLetterDestination,omitempty"`

	// The identity to use when dead-lettering events.
	Identity *EventSubscriptionIdentity `json:"identity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeadLetterWithResourceIdentity.
func (d DeadLetterWithResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deadLetterDestination", d.DeadLetterDestination)
	populate(objectMap, "identity", d.Identity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeadLetterWithResourceIdentity.
func (d *DeadLetterWithResourceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deadLetterDestination":
			d.DeadLetterDestination, err = unmarshalDeadLetterDestinationClassification(val)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &d.Identity)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryAttributeListResult - Result of the Get delivery attributes operation.
type DeliveryAttributeListResult struct {
	// A collection of DeliveryAttributeMapping
	Value []DeliveryAttributeMappingClassification `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryAttributeListResult.
func (d DeliveryAttributeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryAttributeListResult.
func (d *DeliveryAttributeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			d.Value, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeliveryAttributeMappingClassification provides polymorphic access to related types.
// Call the interface's GetDeliveryAttributeMapping() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DeliveryAttributeMapping, *DynamicDeliveryAttributeMapping, *StaticDeliveryAttributeMapping
type DeliveryAttributeMappingClassification interface {
	// GetDeliveryAttributeMapping returns the DeliveryAttributeMapping content of the underlying type.
	GetDeliveryAttributeMapping() *DeliveryAttributeMapping
}

// DeliveryAttributeMapping - Delivery attribute mapping details.
type DeliveryAttributeMapping struct {
	// REQUIRED; Type of the delivery attribute or header name.
	Type *DeliveryAttributeMappingType `json:"type,omitempty"`

	// Name of the delivery attribute or header.
	Name *string `json:"name,omitempty"`
}

// GetDeliveryAttributeMapping implements the DeliveryAttributeMappingClassification interface for type DeliveryAttributeMapping.
func (d *DeliveryAttributeMapping) GetDeliveryAttributeMapping() *DeliveryAttributeMapping { return d }

// DeliveryWithResourceIdentity - Information about the delivery for an event subscription with resource identity.
type DeliveryWithResourceIdentity struct {
	// Information about the destination where events have to be delivered for the event subscription. Uses Azure Event Grid's
	// identity to acquire the authentication tokens being used during delivery /
	// dead-lettering.
	Destination EventSubscriptionDestinationClassification `json:"destination,omitempty"`

	// The identity to use when delivering events.
	Identity *EventSubscriptionIdentity `json:"identity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeliveryWithResourceIdentity.
func (d DeliveryWithResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", d.Destination)
	populate(objectMap, "identity", d.Identity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeliveryWithResourceIdentity.
func (d *DeliveryWithResourceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
			d.Destination, err = unmarshalEventSubscriptionDestinationClassification(val)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, &d.Identity)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Domain - EventGrid Domain.
type Domain struct {
	// REQUIRED; Location of the resource.
	Location *string `json:"location,omitempty"`

	// Identity information for the Event Grid Domain resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the Event Grid Domain resource.
	Properties *DomainProperties `json:"properties,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to Domain resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Domain.
func (d Domain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// DomainProperties - Properties of the Event Grid Domain Resource.
type DomainProperties struct {
	// This Boolean is used to specify the creation mechanism for 'all' the Event Grid Domain Topics associated with this Event
	// Grid Domain resource. In this context, creation of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property
	// is null or set to true, Event Grid is responsible of automatically creating the
	// domain topic when the first event subscription is created at the scope of the domain topic. If this property is set to
	// false, then creating the first event subscription will require creating a domain
	// topic by the user. The self-management mode can be used if the user wants full control of when the domain topic is created,
	// while auto-managed mode provides the flexibility to perform less operations
	// and manage fewer resources by the user. Also, note that in auto-managed creation mode, user is allowed to create the domain
	// topic on demand if needed.
	AutoCreateTopicWithFirstSubscription *bool `json:"autoCreateTopicWithFirstSubscription,omitempty"`

	// This Boolean is used to specify the deletion mechanism for 'all' the Event Grid Domain Topics associated with this Event
	// Grid Domain resource. In this context, deletion of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property
	// is set to true, Event Grid is responsible of automatically deleting the domain
	// topic when the last event subscription at the scope of the domain topic is deleted. If this property is set to false, then
	// the user needs to manually delete the domain topic when it is no longer
	// needed (e.g., when last event subscription is deleted and the resource needs to be cleaned up). The self-management mode
	// can be used if the user wants full control of when the domain topic needs to be
	// deleted, while auto-managed mode provides the flexibility to perform less operations and manage fewer resources by the
	// user.
	AutoDeleteTopicWithLastSubscription *bool `json:"autoDeleteTopicWithLastSubscription,omitempty"`

	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD
	// token will be used to authenticate if user is allowed to publish to the domain.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess
	// is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines the format that Event Grid should expect for incoming events published to the domain.
	InputSchema *InputSchema `json:"inputSchema,omitempty"`

	// Information about the InputSchemaMapping which specified the info about mapping event payload.
	InputSchemaMapping InputSchemaMappingClassification `json:"inputSchemaMapping,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific
	// IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// READ-ONLY; Endpoint for the domain.
	Endpoint *string `json:"endpoint,omitempty" azure:"ro"`

	// READ-ONLY; Metric resource id for the domain.
	MetricResourceID *string `json:"metricResourceId,omitempty" azure:"ro"`

	// READ-ONLY; List of private endpoint connections.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the Event Grid Domain Resource.
	ProvisioningState *DomainProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainProperties.
func (d DomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoCreateTopicWithFirstSubscription", d.AutoCreateTopicWithFirstSubscription)
	populate(objectMap, "autoDeleteTopicWithLastSubscription", d.AutoDeleteTopicWithLastSubscription)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "endpoint", d.Endpoint)
	populate(objectMap, "inboundIpRules", d.InboundIPRules)
	populate(objectMap, "inputSchema", d.InputSchema)
	populate(objectMap, "inputSchemaMapping", d.InputSchemaMapping)
	populate(objectMap, "metricResourceId", d.MetricResourceID)
	populate(objectMap, "privateEndpointConnections", d.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", d.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DomainProperties.
func (d *DomainProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoCreateTopicWithFirstSubscription":
			err = unpopulate(val, &d.AutoCreateTopicWithFirstSubscription)
			delete(rawMsg, key)
		case "autoDeleteTopicWithLastSubscription":
			err = unpopulate(val, &d.AutoDeleteTopicWithLastSubscription)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, &d.DisableLocalAuth)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &d.Endpoint)
			delete(rawMsg, key)
		case "inboundIpRules":
			err = unpopulate(val, &d.InboundIPRules)
			delete(rawMsg, key)
		case "inputSchema":
			err = unpopulate(val, &d.InputSchema)
			delete(rawMsg, key)
		case "inputSchemaMapping":
			d.InputSchemaMapping, err = unmarshalInputSchemaMappingClassification(val)
			delete(rawMsg, key)
		case "metricResourceId":
			err = unpopulate(val, &d.MetricResourceID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &d.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &d.PublicNetworkAccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DomainRegenerateKeyRequest - Domain regenerate share access key request.
type DomainRegenerateKeyRequest struct {
	// REQUIRED; Key name to regenerate key1 or key2.
	KeyName *string `json:"keyName,omitempty"`
}

// DomainSharedAccessKeys - Shared access keys of the Domain.
type DomainSharedAccessKeys struct {
	// Shared access key1 for the domain.
	Key1 *string `json:"key1,omitempty"`

	// Shared access key2 for the domain.
	Key2 *string `json:"key2,omitempty"`
}

// DomainTopic - Domain Topic.
type DomainTopic struct {
	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Properties of the Domain Topic.
	Properties *DomainTopicProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to Domain Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DomainTopicProperties - Properties of the Domain Topic.
type DomainTopicProperties struct {
	// READ-ONLY; Provisioning state of the domain topic.
	ProvisioningState *DomainTopicProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// DomainTopicsClientBeginCreateOrUpdateOptions contains the optional parameters for the DomainTopicsClient.BeginCreateOrUpdate
// method.
type DomainTopicsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DomainTopicsClientBeginDeleteOptions contains the optional parameters for the DomainTopicsClient.BeginDelete method.
type DomainTopicsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DomainTopicsClientGetOptions contains the optional parameters for the DomainTopicsClient.Get method.
type DomainTopicsClientGetOptions struct {
	// placeholder for future optional parameters
}

// DomainTopicsClientListByDomainOptions contains the optional parameters for the DomainTopicsClient.ListByDomain method.
type DomainTopicsClientListByDomainOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// DomainTopicsListResult - Result of the List Domain Topics operation.
type DomainTopicsListResult struct {
	// A link for the next page of domain topics.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of Domain Topics.
	Value []*DomainTopic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainTopicsListResult.
func (d DomainTopicsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DomainUpdateParameterProperties - Information of domain update parameter properties.
type DomainUpdateParameterProperties struct {
	// This Boolean is used to specify the creation mechanism for 'all' the Event Grid Domain Topics associated with this Event
	// Grid Domain resource. In this context, creation of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property
	// is null or set to true, Event Grid is responsible of automatically creating the
	// domain topic when the first event subscription is created at the scope of the domain topic. If this property is set to
	// false, then creating the first event subscription will require creating a domain
	// topic by the user. The self-management mode can be used if the user wants full control of when the domain topic is created,
	// while auto-managed mode provides the flexibility to perform less operations
	// and manage fewer resources by the user. Also, note that in auto-managed creation mode, user is allowed to create the domain
	// topic on demand if needed.
	AutoCreateTopicWithFirstSubscription *bool `json:"autoCreateTopicWithFirstSubscription,omitempty"`

	// This Boolean is used to specify the deletion mechanism for 'all' the Event Grid Domain Topics associated with this Event
	// Grid Domain resource. In this context, deletion of domain topic can be
	// auto-managed (when true) or self-managed (when false). The default value for this property is true. When this property
	// is set to true, Event Grid is responsible of automatically deleting the domain
	// topic when the last event subscription at the scope of the domain topic is deleted. If this property is set to false, then
	// the user needs to manually delete the domain topic when it is no longer
	// needed (e.g., when last event subscription is deleted and the resource needs to be cleaned up). The self-management mode
	// can be used if the user wants full control of when the domain topic needs to be
	// deleted, while auto-managed mode provides the flexibility to perform less operations and manage fewer resources by the
	// user.
	AutoDeleteTopicWithLastSubscription *bool `json:"autoDeleteTopicWithLastSubscription,omitempty"`

	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD
	// token will be used to authenticate if user is allowed to publish to the domain.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess
	// is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific
	// IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainUpdateParameterProperties.
func (d DomainUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoCreateTopicWithFirstSubscription", d.AutoCreateTopicWithFirstSubscription)
	populate(objectMap, "autoDeleteTopicWithLastSubscription", d.AutoDeleteTopicWithLastSubscription)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "inboundIpRules", d.InboundIPRules)
	populate(objectMap, "publicNetworkAccess", d.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// DomainUpdateParameters - Properties of the Domain update.
type DomainUpdateParameters struct {
	// Identity information for the resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the resource.
	Properties *DomainUpdateParameterProperties `json:"properties,omitempty"`

	// Tags of the domains resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainUpdateParameters.
func (d DomainUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DomainsClientBeginCreateOrUpdateOptions contains the optional parameters for the DomainsClient.BeginCreateOrUpdate method.
type DomainsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DomainsClientBeginDeleteOptions contains the optional parameters for the DomainsClient.BeginDelete method.
type DomainsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DomainsClientBeginUpdateOptions contains the optional parameters for the DomainsClient.BeginUpdate method.
type DomainsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// DomainsClientGetOptions contains the optional parameters for the DomainsClient.Get method.
type DomainsClientGetOptions struct {
	// placeholder for future optional parameters
}

// DomainsClientListByResourceGroupOptions contains the optional parameters for the DomainsClient.ListByResourceGroup method.
type DomainsClientListByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// DomainsClientListBySubscriptionOptions contains the optional parameters for the DomainsClient.ListBySubscription method.
type DomainsClientListBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// DomainsClientListSharedAccessKeysOptions contains the optional parameters for the DomainsClient.ListSharedAccessKeys method.
type DomainsClientListSharedAccessKeysOptions struct {
	// placeholder for future optional parameters
}

// DomainsClientRegenerateKeyOptions contains the optional parameters for the DomainsClient.RegenerateKey method.
type DomainsClientRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// DomainsListResult - Result of the List Domains operation.
type DomainsListResult struct {
	// A link for the next page of domains.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of Domains.
	Value []*Domain `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DomainsListResult.
func (d DomainsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DynamicDeliveryAttributeMapping - Dynamic delivery attribute mapping details.
type DynamicDeliveryAttributeMapping struct {
	// REQUIRED; Type of the delivery attribute or header name.
	Type *DeliveryAttributeMappingType `json:"type,omitempty"`

	// Name of the delivery attribute or header.
	Name *string `json:"name,omitempty"`

	// Properties of dynamic delivery attribute mapping.
	Properties *DynamicDeliveryAttributeMappingProperties `json:"properties,omitempty"`
}

// GetDeliveryAttributeMapping implements the DeliveryAttributeMappingClassification interface for type DynamicDeliveryAttributeMapping.
func (d *DynamicDeliveryAttributeMapping) GetDeliveryAttributeMapping() *DeliveryAttributeMapping {
	return &DeliveryAttributeMapping{
		Name: d.Name,
		Type: d.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicDeliveryAttributeMapping.
func (d DynamicDeliveryAttributeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	objectMap["type"] = DeliveryAttributeMappingTypeDynamic
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicDeliveryAttributeMapping.
func (d *DynamicDeliveryAttributeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DynamicDeliveryAttributeMappingProperties - Properties of dynamic delivery attribute mapping.
type DynamicDeliveryAttributeMappingProperties struct {
	// JSON path in the event which contains attribute value.
	SourceField *string `json:"sourceField,omitempty"`
}

// EventHubEventSubscriptionDestination - Information about the event hub destination for an event subscription.
type EventHubEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// Event Hub Properties of the event subscription destination.
	Properties *EventHubEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type EventHubEventSubscriptionDestination.
func (e *EventHubEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: e.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EventHubEventSubscriptionDestination.
func (e EventHubEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeEventHub
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubEventSubscriptionDestination.
func (e *EventHubEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &e.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventHubEventSubscriptionDestinationProperties - The properties for a event hub destination.
type EventHubEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource Id that represents the endpoint of an Event Hub destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventHubEventSubscriptionDestinationProperties.
func (e EventHubEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", e.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", e.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubEventSubscriptionDestinationProperties.
func (e *EventHubEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			e.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &e.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscription - Event Subscription
type EventSubscription struct {
	// Properties of the event subscription.
	Properties *EventSubscriptionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to Event Subscription resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// EventSubscriptionDestinationClassification provides polymorphic access to related types.
// Call the interface's GetEventSubscriptionDestination() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureFunctionEventSubscriptionDestination, *EventHubEventSubscriptionDestination, *EventSubscriptionDestination, *HybridConnectionEventSubscriptionDestination,
// - *ServiceBusQueueEventSubscriptionDestination, *ServiceBusTopicEventSubscriptionDestination, *StorageQueueEventSubscriptionDestination,
// - *WebHookEventSubscriptionDestination
type EventSubscriptionDestinationClassification interface {
	// GetEventSubscriptionDestination returns the EventSubscriptionDestination content of the underlying type.
	GetEventSubscriptionDestination() *EventSubscriptionDestination
}

// EventSubscriptionDestination - Information about the destination for an event subscription.
type EventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type EventSubscriptionDestination.
func (e *EventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return e
}

// EventSubscriptionFilter - Filter for the Event Subscription.
type EventSubscriptionFilter struct {
	// An array of advanced filters that are used for filtering event subscriptions.
	AdvancedFilters []AdvancedFilterClassification `json:"advancedFilters,omitempty"`

	// Allows advanced filters to be evaluated against an array of values instead of expecting a singular value.
	EnableAdvancedFilteringOnArrays *bool `json:"enableAdvancedFilteringOnArrays,omitempty"`

	// A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default
	// event types, set the IncludedEventTypes to null.
	IncludedEventTypes []*string `json:"includedEventTypes,omitempty"`

	// Specifies if the SubjectBeginsWith and SubjectEndsWith properties of the filter should be compared in a case sensitive
	// manner.
	IsSubjectCaseSensitive *bool `json:"isSubjectCaseSensitive,omitempty"`

	// An optional string to filter events for an event subscription based on a resource path prefix. The format of this depends
	// on the publisher of the events. Wildcard characters are not supported in this
	// path.
	SubjectBeginsWith *string `json:"subjectBeginsWith,omitempty"`

	// An optional string to filter events for an event subscription based on a resource path suffix. Wildcard characters are
	// not supported in this path.
	SubjectEndsWith *string `json:"subjectEndsWith,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionFilter.
func (e EventSubscriptionFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "advancedFilters", e.AdvancedFilters)
	populate(objectMap, "enableAdvancedFilteringOnArrays", e.EnableAdvancedFilteringOnArrays)
	populate(objectMap, "includedEventTypes", e.IncludedEventTypes)
	populate(objectMap, "isSubjectCaseSensitive", e.IsSubjectCaseSensitive)
	populate(objectMap, "subjectBeginsWith", e.SubjectBeginsWith)
	populate(objectMap, "subjectEndsWith", e.SubjectEndsWith)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionFilter.
func (e *EventSubscriptionFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advancedFilters":
			e.AdvancedFilters, err = unmarshalAdvancedFilterClassificationArray(val)
			delete(rawMsg, key)
		case "enableAdvancedFilteringOnArrays":
			err = unpopulate(val, &e.EnableAdvancedFilteringOnArrays)
			delete(rawMsg, key)
		case "includedEventTypes":
			err = unpopulate(val, &e.IncludedEventTypes)
			delete(rawMsg, key)
		case "isSubjectCaseSensitive":
			err = unpopulate(val, &e.IsSubjectCaseSensitive)
			delete(rawMsg, key)
		case "subjectBeginsWith":
			err = unpopulate(val, &e.SubjectBeginsWith)
			delete(rawMsg, key)
		case "subjectEndsWith":
			err = unpopulate(val, &e.SubjectEndsWith)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionFullURL - Full endpoint url of an event subscription
type EventSubscriptionFullURL struct {
	// The URL that represents the endpoint of the destination of an event subscription.
	EndpointURL *string `json:"endpointUrl,omitempty"`
}

// EventSubscriptionIdentity - The identity information with the event subscription.
type EventSubscriptionIdentity struct {
	// The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity
	// and a set of user-assigned identities. The type 'None' will remove any identity.
	Type *EventSubscriptionIdentityType `json:"type,omitempty"`

	// The user identity associated with the resource.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// EventSubscriptionProperties - Properties of the Event Subscription.
type EventSubscriptionProperties struct {
	// The DeadLetter destination of the event subscription.
	DeadLetterDestination DeadLetterDestinationClassification `json:"deadLetterDestination,omitempty"`

	// The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to
	// the dead letter destination. Uses the managed identity setup on the parent
	// resource (namely, topic or domain) to acquire the authentication tokens being used during delivery / dead-lettering.
	DeadLetterWithResourceIdentity *DeadLetterWithResourceIdentity `json:"deadLetterWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription. Uses the managed identity
	// setup on the parent resource (namely, topic or domain) to acquire the
	// authentication tokens being used during delivery / dead-lettering.
	DeliveryWithResourceIdentity *DeliveryWithResourceIdentity `json:"deliveryWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription.
	Destination EventSubscriptionDestinationClassification `json:"destination,omitempty"`

	// The event delivery schema for the event subscription.
	EventDeliverySchema *EventDeliverySchema `json:"eventDeliverySchema,omitempty"`

	// Expiration time of the event subscription.
	ExpirationTimeUTC *time.Time `json:"expirationTimeUtc,omitempty"`

	// Information about the filter for the event subscription.
	Filter *EventSubscriptionFilter `json:"filter,omitempty"`

	// List of user defined labels.
	Labels []*string `json:"labels,omitempty"`

	// The retry policy for events. This can be used to configure maximum number of delivery attempts and time to live for events.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`

	// READ-ONLY; Provisioning state of the event subscription.
	ProvisioningState *EventSubscriptionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the topic of the event subscription.
	Topic *string `json:"topic,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionProperties.
func (e EventSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deadLetterDestination", e.DeadLetterDestination)
	populate(objectMap, "deadLetterWithResourceIdentity", e.DeadLetterWithResourceIdentity)
	populate(objectMap, "deliveryWithResourceIdentity", e.DeliveryWithResourceIdentity)
	populate(objectMap, "destination", e.Destination)
	populate(objectMap, "eventDeliverySchema", e.EventDeliverySchema)
	populateTimeRFC3339(objectMap, "expirationTimeUtc", e.ExpirationTimeUTC)
	populate(objectMap, "filter", e.Filter)
	populate(objectMap, "labels", e.Labels)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "retryPolicy", e.RetryPolicy)
	populate(objectMap, "topic", e.Topic)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionProperties.
func (e *EventSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deadLetterDestination":
			e.DeadLetterDestination, err = unmarshalDeadLetterDestinationClassification(val)
			delete(rawMsg, key)
		case "deadLetterWithResourceIdentity":
			err = unpopulate(val, &e.DeadLetterWithResourceIdentity)
			delete(rawMsg, key)
		case "deliveryWithResourceIdentity":
			err = unpopulate(val, &e.DeliveryWithResourceIdentity)
			delete(rawMsg, key)
		case "destination":
			e.Destination, err = unmarshalEventSubscriptionDestinationClassification(val)
			delete(rawMsg, key)
		case "eventDeliverySchema":
			err = unpopulate(val, &e.EventDeliverySchema)
			delete(rawMsg, key)
		case "expirationTimeUtc":
			err = unpopulateTimeRFC3339(val, &e.ExpirationTimeUTC)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &e.Filter)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &e.Labels)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &e.ProvisioningState)
			delete(rawMsg, key)
		case "retryPolicy":
			err = unpopulate(val, &e.RetryPolicy)
			delete(rawMsg, key)
		case "topic":
			err = unpopulate(val, &e.Topic)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionUpdateParameters - Properties of the Event Subscription update.
type EventSubscriptionUpdateParameters struct {
	// The DeadLetter destination of the event subscription.
	DeadLetterDestination DeadLetterDestinationClassification `json:"deadLetterDestination,omitempty"`

	// The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to
	// the dead letter destination. Uses the managed identity setup on the parent
	// resource (topic / domain) to acquire the authentication tokens being used during delivery / dead-lettering.
	DeadLetterWithResourceIdentity *DeadLetterWithResourceIdentity `json:"deadLetterWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription. Uses the managed identity
	// setup on the parent resource (topic / domain) to acquire the authentication
	// tokens being used during delivery / dead-lettering.
	DeliveryWithResourceIdentity *DeliveryWithResourceIdentity `json:"deliveryWithResourceIdentity,omitempty"`

	// Information about the destination where events have to be delivered for the event subscription.
	Destination EventSubscriptionDestinationClassification `json:"destination,omitempty"`

	// The event delivery schema for the event subscription.
	EventDeliverySchema *EventDeliverySchema `json:"eventDeliverySchema,omitempty"`

	// Information about the expiration time for the event subscription.
	ExpirationTimeUTC *time.Time `json:"expirationTimeUtc,omitempty"`

	// Information about the filter for the event subscription.
	Filter *EventSubscriptionFilter `json:"filter,omitempty"`

	// List of user defined labels.
	Labels []*string `json:"labels,omitempty"`

	// The retry policy for events. This can be used to configure maximum number of delivery attempts and time to live for events.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionUpdateParameters.
func (e EventSubscriptionUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deadLetterDestination", e.DeadLetterDestination)
	populate(objectMap, "deadLetterWithResourceIdentity", e.DeadLetterWithResourceIdentity)
	populate(objectMap, "deliveryWithResourceIdentity", e.DeliveryWithResourceIdentity)
	populate(objectMap, "destination", e.Destination)
	populate(objectMap, "eventDeliverySchema", e.EventDeliverySchema)
	populateTimeRFC3339(objectMap, "expirationTimeUtc", e.ExpirationTimeUTC)
	populate(objectMap, "filter", e.Filter)
	populate(objectMap, "labels", e.Labels)
	populate(objectMap, "retryPolicy", e.RetryPolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventSubscriptionUpdateParameters.
func (e *EventSubscriptionUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deadLetterDestination":
			e.DeadLetterDestination, err = unmarshalDeadLetterDestinationClassification(val)
			delete(rawMsg, key)
		case "deadLetterWithResourceIdentity":
			err = unpopulate(val, &e.DeadLetterWithResourceIdentity)
			delete(rawMsg, key)
		case "deliveryWithResourceIdentity":
			err = unpopulate(val, &e.DeliveryWithResourceIdentity)
			delete(rawMsg, key)
		case "destination":
			e.Destination, err = unmarshalEventSubscriptionDestinationClassification(val)
			delete(rawMsg, key)
		case "eventDeliverySchema":
			err = unpopulate(val, &e.EventDeliverySchema)
			delete(rawMsg, key)
		case "expirationTimeUtc":
			err = unpopulateTimeRFC3339(val, &e.ExpirationTimeUTC)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &e.Filter)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &e.Labels)
			delete(rawMsg, key)
		case "retryPolicy":
			err = unpopulate(val, &e.RetryPolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EventSubscriptionsClientBeginCreateOrUpdateOptions contains the optional parameters for the EventSubscriptionsClient.BeginCreateOrUpdate
// method.
type EventSubscriptionsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsClientBeginDeleteOptions contains the optional parameters for the EventSubscriptionsClient.BeginDelete
// method.
type EventSubscriptionsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsClientBeginUpdateOptions contains the optional parameters for the EventSubscriptionsClient.BeginUpdate
// method.
type EventSubscriptionsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsClientGetDeliveryAttributesOptions contains the optional parameters for the EventSubscriptionsClient.GetDeliveryAttributes
// method.
type EventSubscriptionsClientGetDeliveryAttributesOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsClientGetFullURLOptions contains the optional parameters for the EventSubscriptionsClient.GetFullURL
// method.
type EventSubscriptionsClientGetFullURLOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsClientGetOptions contains the optional parameters for the EventSubscriptionsClient.Get method.
type EventSubscriptionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// EventSubscriptionsClientListByDomainTopicOptions contains the optional parameters for the EventSubscriptionsClient.ListByDomainTopic
// method.
type EventSubscriptionsClientListByDomainTopicOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListByResourceOptions contains the optional parameters for the EventSubscriptionsClient.ListByResource
// method.
type EventSubscriptionsClientListByResourceOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeOptions contains the optional parameters for the EventSubscriptionsClient.ListGlobalByResourceGroupForTopicType
// method.
type EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListGlobalByResourceGroupOptions contains the optional parameters for the EventSubscriptionsClient.ListGlobalByResourceGroup
// method.
type EventSubscriptionsClientListGlobalByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeOptions contains the optional parameters for the EventSubscriptionsClient.ListGlobalBySubscriptionForTopicType
// method.
type EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListGlobalBySubscriptionOptions contains the optional parameters for the EventSubscriptionsClient.ListGlobalBySubscription
// method.
type EventSubscriptionsClientListGlobalBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeOptions contains the optional parameters for the EventSubscriptionsClient.ListRegionalByResourceGroupForTopicType
// method.
type EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListRegionalByResourceGroupOptions contains the optional parameters for the EventSubscriptionsClient.ListRegionalByResourceGroup
// method.
type EventSubscriptionsClientListRegionalByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeOptions contains the optional parameters for the EventSubscriptionsClient.ListRegionalBySubscriptionForTopicType
// method.
type EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsClientListRegionalBySubscriptionOptions contains the optional parameters for the EventSubscriptionsClient.ListRegionalBySubscription
// method.
type EventSubscriptionsClientListRegionalBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// EventSubscriptionsListResult - Result of the List EventSubscriptions operation
type EventSubscriptionsListResult struct {
	// A link for the next page of event subscriptions
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of EventSubscriptions
	Value []*EventSubscription `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventSubscriptionsListResult.
func (e EventSubscriptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EventType - Event Type for a subject under a topic
type EventType struct {
	// Properties of the event type.
	Properties *EventTypeProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// EventTypeProperties - Properties of the event type
type EventTypeProperties struct {
	// Description of the event type.
	Description *string `json:"description,omitempty"`

	// Display name of the event type.
	DisplayName *string `json:"displayName,omitempty"`

	// IsInDefaultSet flag of the event type.
	IsInDefaultSet *bool `json:"isInDefaultSet,omitempty"`

	// Url of the schema for this event type.
	SchemaURL *string `json:"schemaUrl,omitempty"`
}

// EventTypesListResult - Result of the List Event Types operation
type EventTypesListResult struct {
	// A collection of event types
	Value []*EventType `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventTypesListResult.
func (e EventTypesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExtensionTopic - Event grid Extension Topic. This is used for getting Event Grid related metrics for Azure resources.
type ExtensionTopic struct {
	// Properties of the extension topic
	Properties *ExtensionTopicProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to the Extension Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ExtensionTopicProperties - Properties of the Extension Topic
type ExtensionTopicProperties struct {
	// Description of the extension topic.
	Description *string `json:"description,omitempty"`

	// System topic resource id which is mapped to the source.
	SystemTopic *string `json:"systemTopic,omitempty"`
}

// ExtensionTopicsClientGetOptions contains the optional parameters for the ExtensionTopicsClient.Get method.
type ExtensionTopicsClientGetOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionEventSubscriptionDestination - Information about the HybridConnection destination for an event subscription.
type HybridConnectionEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// Hybrid connection Properties of the event subscription destination.
	Properties *HybridConnectionEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type HybridConnectionEventSubscriptionDestination.
func (h *HybridConnectionEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: h.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnectionEventSubscriptionDestination.
func (h HybridConnectionEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeHybridConnection
	populate(objectMap, "properties", h.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HybridConnectionEventSubscriptionDestination.
func (h *HybridConnectionEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &h.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &h.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HybridConnectionEventSubscriptionDestinationProperties - The properties for a hybrid connection destination.
type HybridConnectionEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource ID of an hybrid connection that is the destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnectionEventSubscriptionDestinationProperties.
func (h HybridConnectionEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", h.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", h.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HybridConnectionEventSubscriptionDestinationProperties.
func (h *HybridConnectionEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			h.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &h.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IdentityInfo - The identity information for the resource.
type IdentityInfo struct {
	// The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`

	// The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`

	// The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity
	// and a set of user-assigned identities. The type 'None' will remove any identity.
	Type *IdentityType `json:"type,omitempty"`

	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource
	// ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	// This property is currently not used and reserved for
	// future usage.
	UserAssignedIdentities map[string]*UserIdentityProperties `json:"userAssignedIdentities,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IdentityInfo.
func (i IdentityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

type InboundIPRule struct {
	// Action to perform based on the match or no match of the IpMask.
	Action *IPActionType `json:"action,omitempty"`

	// IP Address in CIDR notation e.g., 10.0.0.0/8.
	IPMask *string `json:"ipMask,omitempty"`
}

// InputSchemaMappingClassification provides polymorphic access to related types.
// Call the interface's GetInputSchemaMapping() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *InputSchemaMapping, *JSONInputSchemaMapping
type InputSchemaMappingClassification interface {
	// GetInputSchemaMapping returns the InputSchemaMapping content of the underlying type.
	GetInputSchemaMapping() *InputSchemaMapping
}

// InputSchemaMapping - By default, Event Grid expects events to be in the Event Grid event schema. Specifying an input schema
// mapping enables publishing to Event Grid using a custom input schema. Currently, the only
// supported type of InputSchemaMapping is 'JsonInputSchemaMapping'.
type InputSchemaMapping struct {
	// REQUIRED; Type of the custom mapping
	InputSchemaMappingType *InputSchemaMappingType `json:"inputSchemaMappingType,omitempty"`
}

// GetInputSchemaMapping implements the InputSchemaMappingClassification interface for type InputSchemaMapping.
func (i *InputSchemaMapping) GetInputSchemaMapping() *InputSchemaMapping { return i }

// IsNotNullAdvancedFilter - IsNotNull Advanced Filter.
type IsNotNullAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type IsNotNullAdvancedFilter.
func (i *IsNotNullAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: i.OperatorType,
		Key:          i.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IsNotNullAdvancedFilter.
func (i IsNotNullAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", i.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeIsNotNull
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IsNotNullAdvancedFilter.
func (i *IsNotNullAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &i.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &i.OperatorType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IsNullOrUndefinedAdvancedFilter - IsNullOrUndefined Advanced Filter.
type IsNullOrUndefinedAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type IsNullOrUndefinedAdvancedFilter.
func (i *IsNullOrUndefinedAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: i.OperatorType,
		Key:          i.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IsNullOrUndefinedAdvancedFilter.
func (i IsNullOrUndefinedAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", i.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeIsNullOrUndefined
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IsNullOrUndefinedAdvancedFilter.
func (i *IsNullOrUndefinedAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &i.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &i.OperatorType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONField - This is used to express the source of an input schema mapping for a single target field in the Event Grid Event
// schema. This is currently used in the mappings for the 'id', 'topic' and 'eventtime'
// properties. This represents a field in the input event schema.
type JSONField struct {
	// Name of a field in the input event schema that's to be used as the source of a mapping.
	SourceField *string `json:"sourceField,omitempty"`
}

// JSONFieldWithDefault - This is used to express the source of an input schema mapping for a single target field in the Event
// Grid Event schema. This is currently used in the mappings for the 'subject', 'eventtype' and
// 'dataversion' properties. This represents a field in the input event schema along with a default value to be used, and
// at least one of these two properties should be provided.
type JSONFieldWithDefault struct {
	// The default value to be used for mapping when a SourceField is not provided or if there's no property with the specified
	// name in the published JSON event payload.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Name of a field in the input event schema that's to be used as the source of a mapping.
	SourceField *string `json:"sourceField,omitempty"`
}

// JSONInputSchemaMapping - This enables publishing to Event Grid using a custom input schema. This can be used to map properties
// from a custom input JSON schema to the Event Grid event schema.
type JSONInputSchemaMapping struct {
	// REQUIRED; Type of the custom mapping
	InputSchemaMappingType *InputSchemaMappingType `json:"inputSchemaMappingType,omitempty"`

	// JSON Properties of the input schema mapping
	Properties *JSONInputSchemaMappingProperties `json:"properties,omitempty"`
}

// GetInputSchemaMapping implements the InputSchemaMappingClassification interface for type JSONInputSchemaMapping.
func (j *JSONInputSchemaMapping) GetInputSchemaMapping() *InputSchemaMapping {
	return &InputSchemaMapping{
		InputSchemaMappingType: j.InputSchemaMappingType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONInputSchemaMapping.
func (j JSONInputSchemaMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["inputSchemaMappingType"] = InputSchemaMappingTypeJSON
	populate(objectMap, "properties", j.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONInputSchemaMapping.
func (j *JSONInputSchemaMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputSchemaMappingType":
			err = unpopulate(val, &j.InputSchemaMappingType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JSONInputSchemaMappingProperties - This can be used to map properties of a source schema (or default values, for certain
// supported properties) to properties of the EventGridEvent schema.
type JSONInputSchemaMappingProperties struct {
	// The mapping information for the DataVersion property of the Event Grid Event.
	DataVersion *JSONFieldWithDefault `json:"dataVersion,omitempty"`

	// The mapping information for the EventTime property of the Event Grid Event.
	EventTime *JSONField `json:"eventTime,omitempty"`

	// The mapping information for the EventType property of the Event Grid Event.
	EventType *JSONFieldWithDefault `json:"eventType,omitempty"`

	// The mapping information for the Id property of the Event Grid Event.
	ID *JSONField `json:"id,omitempty"`

	// The mapping information for the Subject property of the Event Grid Event.
	Subject *JSONFieldWithDefault `json:"subject,omitempty"`

	// The mapping information for the Topic property of the Event Grid Event.
	Topic *JSONField `json:"topic,omitempty"`
}

// NumberGreaterThanAdvancedFilter - NumberGreaterThan Advanced Filter.
type NumberGreaterThanAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberGreaterThanAdvancedFilter.
func (n *NumberGreaterThanAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberGreaterThanAdvancedFilter.
func (n NumberGreaterThanAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberGreaterThan
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberGreaterThanAdvancedFilter.
func (n *NumberGreaterThanAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberGreaterThanOrEqualsAdvancedFilter - NumberGreaterThanOrEquals Advanced Filter.
type NumberGreaterThanOrEqualsAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberGreaterThanOrEqualsAdvancedFilter.
func (n *NumberGreaterThanOrEqualsAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberGreaterThanOrEqualsAdvancedFilter.
func (n NumberGreaterThanOrEqualsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberGreaterThanOrEquals
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberGreaterThanOrEqualsAdvancedFilter.
func (n *NumberGreaterThanOrEqualsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberInAdvancedFilter - NumberIn Advanced Filter.
type NumberInAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*float64 `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberInAdvancedFilter.
func (n *NumberInAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberInAdvancedFilter.
func (n NumberInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberIn
	populate(objectMap, "values", n.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberInAdvancedFilter.
func (n *NumberInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &n.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberInRangeAdvancedFilter - NumberInRange Advanced Filter.
type NumberInRangeAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values [][]*float64 `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberInRangeAdvancedFilter.
func (n *NumberInRangeAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberInRangeAdvancedFilter.
func (n NumberInRangeAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberInRange
	populate(objectMap, "values", n.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberInRangeAdvancedFilter.
func (n *NumberInRangeAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &n.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberLessThanAdvancedFilter - NumberLessThan Advanced Filter.
type NumberLessThanAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberLessThanAdvancedFilter.
func (n *NumberLessThanAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberLessThanAdvancedFilter.
func (n NumberLessThanAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberLessThan
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberLessThanAdvancedFilter.
func (n *NumberLessThanAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberLessThanOrEqualsAdvancedFilter - NumberLessThanOrEquals Advanced Filter.
type NumberLessThanOrEqualsAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The filter value.
	Value *float64 `json:"value,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberLessThanOrEqualsAdvancedFilter.
func (n *NumberLessThanOrEqualsAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberLessThanOrEqualsAdvancedFilter.
func (n NumberLessThanOrEqualsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberLessThanOrEquals
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberLessThanOrEqualsAdvancedFilter.
func (n *NumberLessThanOrEqualsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberNotInAdvancedFilter - NumberNotIn Advanced Filter.
type NumberNotInAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*float64 `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberNotInAdvancedFilter.
func (n *NumberNotInAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberNotInAdvancedFilter.
func (n NumberNotInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberNotIn
	populate(objectMap, "values", n.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberNotInAdvancedFilter.
func (n *NumberNotInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &n.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NumberNotInRangeAdvancedFilter - NumberNotInRange Advanced Filter.
type NumberNotInRangeAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values [][]*float64 `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type NumberNotInRangeAdvancedFilter.
func (n *NumberNotInRangeAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: n.OperatorType,
		Key:          n.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NumberNotInRangeAdvancedFilter.
func (n NumberNotInRangeAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", n.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeNumberNotInRange
	populate(objectMap, "values", n.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberNotInRangeAdvancedFilter.
func (n *NumberNotInRangeAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &n.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &n.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &n.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Operation - Represents an operation returned by the GetOperations request
type Operation struct {
	// Display name of the operation
	Display *OperationInfo `json:"display,omitempty"`

	// Name of the operation
	Name *string `json:"name,omitempty"`

	// Origin of the operation
	Origin *string `json:"origin,omitempty"`

	// Properties of the operation
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// OperationInfo - Information about an operation
type OperationInfo struct {
	// Description of the operation
	Description *string `json:"description,omitempty"`

	// Name of the operation
	Operation *string `json:"operation,omitempty"`

	// Name of the provider
	Provider *string `json:"provider,omitempty"`

	// Name of the resource type
	Resource *string `json:"resource,omitempty"`
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// OperationsListResult - Result of the List Operations operation
type OperationsListResult struct {
	// A collection of operations
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationsListResult.
func (o OperationsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpoint information.
type PrivateEndpoint struct {
	// The ARM identifier for Private Endpoint.
	ID *string `json:"id,omitempty"`
}

type PrivateEndpointConnection struct {
	// Properties of the PrivateEndpointConnection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionListResult - Result of the list of all private endpoint connections operation.
type PrivateEndpointConnectionListResult struct {
	// A link for the next page of private endpoint connection resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private endpoint connection resources.
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the private endpoint connection resource.
type PrivateEndpointConnectionProperties struct {
	// GroupIds from the private link service resource.
	GroupIDs []*string `json:"groupIds,omitempty"`

	// The Private Endpoint resource for this Connection.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// Details about the state of the connection.
	PrivateLinkServiceConnectionState *ConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// Provisioning state of the Private Endpoint Connection.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProperties.
func (p PrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupIds", p.GroupIDs)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionsClientBeginDeleteOptions contains the optional parameters for the PrivateEndpointConnectionsClient.BeginDelete
// method.
type PrivateEndpointConnectionsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientBeginUpdateOptions contains the optional parameters for the PrivateEndpointConnectionsClient.BeginUpdate
// method.
type PrivateEndpointConnectionsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientGetOptions contains the optional parameters for the PrivateEndpointConnectionsClient.Get
// method.
type PrivateEndpointConnectionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientListByResourceOptions contains the optional parameters for the PrivateEndpointConnectionsClient.ListByResource
// method.
type PrivateEndpointConnectionsClientListByResourceOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// PrivateLinkResource - Information of the private link resource.
type PrivateLinkResource struct {
	// Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty"`

	// Name of the resource.
	Name *string `json:"name,omitempty"`

	// Properties of the private link resource.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// Type of the resource.
	Type *string `json:"type,omitempty"`
}

type PrivateLinkResourceProperties struct {
	DisplayName       *string   `json:"displayName,omitempty"`
	GroupID           *string   `json:"groupId,omitempty"`
	RequiredMembers   []*string `json:"requiredMembers,omitempty"`
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesClientGetOptions contains the optional parameters for the PrivateLinkResourcesClient.Get method.
type PrivateLinkResourcesClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesClientListByResourceOptions contains the optional parameters for the PrivateLinkResourcesClient.ListByResource
// method.
type PrivateLinkResourcesClientListByResourceOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// PrivateLinkResourcesListResult - Result of the List private link resources operation.
type PrivateLinkResourcesListResult struct {
	// A link for the next page of private link resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourcesListResult.
func (p PrivateLinkResourcesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// Resource - Definition of a Resource.
type Resource struct {
	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RetryPolicy - Information about the retry policy for an event subscription.
type RetryPolicy struct {
	// Time To Live (in minutes) for events.
	EventTimeToLiveInMinutes *int32 `json:"eventTimeToLiveInMinutes,omitempty"`

	// Maximum number of delivery retry attempts for events.
	MaxDeliveryAttempts *int32 `json:"maxDeliveryAttempts,omitempty"`
}

// ServiceBusQueueEventSubscriptionDestination - Information about the service bus destination for an event subscription.
type ServiceBusQueueEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// Service Bus Properties of the event subscription destination.
	Properties *ServiceBusQueueEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type ServiceBusQueueEventSubscriptionDestination.
func (s *ServiceBusQueueEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: s.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueEventSubscriptionDestination.
func (s ServiceBusQueueEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeServiceBusQueue
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusQueueEventSubscriptionDestination.
func (s *ServiceBusQueueEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &s.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceBusQueueEventSubscriptionDestinationProperties - The properties that represent the Service Bus destination of an
// event subscription.
type ServiceBusQueueEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource Id that represents the endpoint of the Service Bus destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueEventSubscriptionDestinationProperties.
func (s ServiceBusQueueEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", s.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", s.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusQueueEventSubscriptionDestinationProperties.
func (s *ServiceBusQueueEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			s.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &s.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceBusTopicEventSubscriptionDestination - Information about the service bus topic destination for an event subscription.
type ServiceBusTopicEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// Service Bus Topic Properties of the event subscription destination.
	Properties *ServiceBusTopicEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type ServiceBusTopicEventSubscriptionDestination.
func (s *ServiceBusTopicEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: s.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicEventSubscriptionDestination.
func (s ServiceBusTopicEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeServiceBusTopic
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusTopicEventSubscriptionDestination.
func (s *ServiceBusTopicEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &s.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceBusTopicEventSubscriptionDestinationProperties - The properties that represent the Service Bus Topic destination
// of an event subscription.
type ServiceBusTopicEventSubscriptionDestinationProperties struct {
	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The Azure Resource Id that represents the endpoint of the Service Bus Topic destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicEventSubscriptionDestinationProperties.
func (s ServiceBusTopicEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deliveryAttributeMappings", s.DeliveryAttributeMappings)
	populate(objectMap, "resourceId", s.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusTopicEventSubscriptionDestinationProperties.
func (s *ServiceBusTopicEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deliveryAttributeMappings":
			s.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &s.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StaticDeliveryAttributeMapping - Static delivery attribute mapping details.
type StaticDeliveryAttributeMapping struct {
	// REQUIRED; Type of the delivery attribute or header name.
	Type *DeliveryAttributeMappingType `json:"type,omitempty"`

	// Name of the delivery attribute or header.
	Name *string `json:"name,omitempty"`

	// Properties of static delivery attribute mapping.
	Properties *StaticDeliveryAttributeMappingProperties `json:"properties,omitempty"`
}

// GetDeliveryAttributeMapping implements the DeliveryAttributeMappingClassification interface for type StaticDeliveryAttributeMapping.
func (s *StaticDeliveryAttributeMapping) GetDeliveryAttributeMapping() *DeliveryAttributeMapping {
	return &DeliveryAttributeMapping{
		Name: s.Name,
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StaticDeliveryAttributeMapping.
func (s StaticDeliveryAttributeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	objectMap["type"] = DeliveryAttributeMappingTypeStatic
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticDeliveryAttributeMapping.
func (s *StaticDeliveryAttributeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StaticDeliveryAttributeMappingProperties - Properties of static delivery attribute mapping.
type StaticDeliveryAttributeMappingProperties struct {
	// Boolean flag to tell if the attribute contains sensitive information .
	IsSecret *bool `json:"isSecret,omitempty"`

	// Value of the delivery attribute.
	Value *string `json:"value,omitempty"`
}

// StorageBlobDeadLetterDestination - Information about the storage blob based dead letter destination.
type StorageBlobDeadLetterDestination struct {
	// REQUIRED; Type of the endpoint for the dead letter destination
	EndpointType *DeadLetterEndPointType `json:"endpointType,omitempty"`

	// The properties of the Storage Blob based deadletter destination
	Properties *StorageBlobDeadLetterDestinationProperties `json:"properties,omitempty"`
}

// GetDeadLetterDestination implements the DeadLetterDestinationClassification interface for type StorageBlobDeadLetterDestination.
func (s *StorageBlobDeadLetterDestination) GetDeadLetterDestination() *DeadLetterDestination {
	return &DeadLetterDestination{
		EndpointType: s.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StorageBlobDeadLetterDestination.
func (s StorageBlobDeadLetterDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = DeadLetterEndPointTypeStorageBlob
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageBlobDeadLetterDestination.
func (s *StorageBlobDeadLetterDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &s.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageBlobDeadLetterDestinationProperties - Properties of the storage blob based dead letter destination.
type StorageBlobDeadLetterDestinationProperties struct {
	// The name of the Storage blob container that is the destination of the deadletter events
	BlobContainerName *string `json:"blobContainerName,omitempty"`

	// The Azure Resource ID of the storage account that is the destination of the deadletter events
	ResourceID *string `json:"resourceId,omitempty"`
}

// StorageQueueEventSubscriptionDestination - Information about the storage queue destination for an event subscription.
type StorageQueueEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// Storage Queue Properties of the event subscription destination.
	Properties *StorageQueueEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type StorageQueueEventSubscriptionDestination.
func (s *StorageQueueEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: s.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StorageQueueEventSubscriptionDestination.
func (s StorageQueueEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeStorageQueue
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageQueueEventSubscriptionDestination.
func (s *StorageQueueEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &s.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageQueueEventSubscriptionDestinationProperties - The properties for a storage queue destination.
type StorageQueueEventSubscriptionDestinationProperties struct {
	// Storage queue message time to live in seconds.
	QueueMessageTimeToLiveInSeconds *int64 `json:"queueMessageTimeToLiveInSeconds,omitempty"`

	// The name of the Storage queue under a storage account that is the destination of an event subscription.
	QueueName *string `json:"queueName,omitempty"`

	// The Azure Resource ID of the storage account that contains the queue that is the destination of an event subscription.
	ResourceID *string `json:"resourceId,omitempty"`
}

// StringBeginsWithAdvancedFilter - StringBeginsWith Advanced Filter.
type StringBeginsWithAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringBeginsWithAdvancedFilter.
func (s *StringBeginsWithAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringBeginsWithAdvancedFilter.
func (s StringBeginsWithAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringBeginsWith
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringBeginsWithAdvancedFilter.
func (s *StringBeginsWithAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringContainsAdvancedFilter - StringContains Advanced Filter.
type StringContainsAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringContainsAdvancedFilter.
func (s *StringContainsAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringContainsAdvancedFilter.
func (s StringContainsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringContains
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringContainsAdvancedFilter.
func (s *StringContainsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringEndsWithAdvancedFilter - StringEndsWith Advanced Filter.
type StringEndsWithAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringEndsWithAdvancedFilter.
func (s *StringEndsWithAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringEndsWithAdvancedFilter.
func (s StringEndsWithAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringEndsWith
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringEndsWithAdvancedFilter.
func (s *StringEndsWithAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringInAdvancedFilter - StringIn Advanced Filter.
type StringInAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringInAdvancedFilter.
func (s *StringInAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringInAdvancedFilter.
func (s StringInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringIn
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringInAdvancedFilter.
func (s *StringInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringNotBeginsWithAdvancedFilter - StringNotBeginsWith Advanced Filter.
type StringNotBeginsWithAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringNotBeginsWithAdvancedFilter.
func (s *StringNotBeginsWithAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringNotBeginsWithAdvancedFilter.
func (s StringNotBeginsWithAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringNotBeginsWith
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringNotBeginsWithAdvancedFilter.
func (s *StringNotBeginsWithAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringNotContainsAdvancedFilter - StringNotContains Advanced Filter.
type StringNotContainsAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringNotContainsAdvancedFilter.
func (s *StringNotContainsAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringNotContainsAdvancedFilter.
func (s StringNotContainsAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringNotContains
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringNotContainsAdvancedFilter.
func (s *StringNotContainsAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringNotEndsWithAdvancedFilter - StringNotEndsWith Advanced Filter.
type StringNotEndsWithAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringNotEndsWithAdvancedFilter.
func (s *StringNotEndsWithAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringNotEndsWithAdvancedFilter.
func (s StringNotEndsWithAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringNotEndsWith
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringNotEndsWithAdvancedFilter.
func (s *StringNotEndsWithAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StringNotInAdvancedFilter - StringNotIn Advanced Filter.
type StringNotInAdvancedFilter struct {
	// REQUIRED; The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
	OperatorType *AdvancedFilterOperatorType `json:"operatorType,omitempty"`

	// The field/property in the event based on which you want to filter.
	Key *string `json:"key,omitempty"`

	// The set of filter values.
	Values []*string `json:"values,omitempty"`
}

// GetAdvancedFilter implements the AdvancedFilterClassification interface for type StringNotInAdvancedFilter.
func (s *StringNotInAdvancedFilter) GetAdvancedFilter() *AdvancedFilter {
	return &AdvancedFilter{
		OperatorType: s.OperatorType,
		Key:          s.Key,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StringNotInAdvancedFilter.
func (s StringNotInAdvancedFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", s.Key)
	objectMap["operatorType"] = AdvancedFilterOperatorTypeStringNotIn
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringNotInAdvancedFilter.
func (s *StringNotInAdvancedFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &s.Key)
			delete(rawMsg, key)
		case "operatorType":
			err = unpopulate(val, &s.OperatorType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &s.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SystemTopic - EventGrid System Topic.
type SystemTopic struct {
	// REQUIRED; Location of the resource.
	Location *string `json:"location,omitempty"`

	// Identity information for the resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the system topic.
	Properties *SystemTopicProperties `json:"properties,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to System Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemTopic.
func (s SystemTopic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// SystemTopicEventSubscriptionsClientBeginCreateOrUpdateOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.BeginCreateOrUpdate
// method.
type SystemTopicEventSubscriptionsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsClientBeginDeleteOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.BeginDelete
// method.
type SystemTopicEventSubscriptionsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsClientBeginUpdateOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.BeginUpdate
// method.
type SystemTopicEventSubscriptionsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsClientGetDeliveryAttributesOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.GetDeliveryAttributes
// method.
type SystemTopicEventSubscriptionsClientGetDeliveryAttributesOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsClientGetFullURLOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.GetFullURL
// method.
type SystemTopicEventSubscriptionsClientGetFullURLOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsClientGetOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.Get
// method.
type SystemTopicEventSubscriptionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicEventSubscriptionsClientListBySystemTopicOptions contains the optional parameters for the SystemTopicEventSubscriptionsClient.ListBySystemTopic
// method.
type SystemTopicEventSubscriptionsClientListBySystemTopicOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// SystemTopicProperties - Properties of the System Topic.
type SystemTopicProperties struct {
	// Source for the system topic.
	Source *string `json:"source,omitempty"`

	// TopicType for the system topic.
	TopicType *string `json:"topicType,omitempty"`

	// READ-ONLY; Metric resource id for the system topic.
	MetricResourceID *string `json:"metricResourceId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the system topic.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// SystemTopicUpdateParameters - Properties of the System Topic update.
type SystemTopicUpdateParameters struct {
	// Resource identity information.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Tags of the system topic.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemTopicUpdateParameters.
func (s SystemTopicUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SystemTopicsClientBeginCreateOrUpdateOptions contains the optional parameters for the SystemTopicsClient.BeginCreateOrUpdate
// method.
type SystemTopicsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsClientBeginDeleteOptions contains the optional parameters for the SystemTopicsClient.BeginDelete method.
type SystemTopicsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsClientBeginUpdateOptions contains the optional parameters for the SystemTopicsClient.BeginUpdate method.
type SystemTopicsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsClientGetOptions contains the optional parameters for the SystemTopicsClient.Get method.
type SystemTopicsClientGetOptions struct {
	// placeholder for future optional parameters
}

// SystemTopicsClientListByResourceGroupOptions contains the optional parameters for the SystemTopicsClient.ListByResourceGroup
// method.
type SystemTopicsClientListByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// SystemTopicsClientListBySubscriptionOptions contains the optional parameters for the SystemTopicsClient.ListBySubscription
// method.
type SystemTopicsClientListBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// SystemTopicsListResult - Result of the List System topics operation.
type SystemTopicsListResult struct {
	// A link for the next page of topics.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of system Topics.
	Value []*SystemTopic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemTopicsListResult.
func (s SystemTopicsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// Topic - EventGrid Topic
type Topic struct {
	// REQUIRED; Location of the resource.
	Location *string `json:"location,omitempty"`

	// Identity information for the resource.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the topic.
	Properties *TopicProperties `json:"properties,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to Topic resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Topic.
func (t Topic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// TopicProperties - Properties of the Topic
type TopicProperties struct {
	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD
	// token will be used to authenticate if user is allowed to publish to the topic.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess
	// is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines the format that Event Grid should expect for incoming events published to the topic.
	InputSchema *InputSchema `json:"inputSchema,omitempty"`

	// This enables publishing using custom event schemas. An InputSchemaMapping can be specified to map various properties of
	// a source schema to various required properties of the EventGridEvent schema.
	InputSchemaMapping InputSchemaMappingClassification `json:"inputSchemaMapping,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific
	// IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// READ-ONLY; Endpoint for the topic.
	Endpoint *string `json:"endpoint,omitempty" azure:"ro"`

	// READ-ONLY; Metric resource id for the topic.
	MetricResourceID *string `json:"metricResourceId,omitempty" azure:"ro"`

	// READ-ONLY
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the topic.
	ProvisioningState *TopicProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicProperties.
func (t TopicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableLocalAuth", t.DisableLocalAuth)
	populate(objectMap, "endpoint", t.Endpoint)
	populate(objectMap, "inboundIpRules", t.InboundIPRules)
	populate(objectMap, "inputSchema", t.InputSchema)
	populate(objectMap, "inputSchemaMapping", t.InputSchemaMapping)
	populate(objectMap, "metricResourceId", t.MetricResourceID)
	populate(objectMap, "privateEndpointConnections", t.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", t.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopicProperties.
func (t *TopicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableLocalAuth":
			err = unpopulate(val, &t.DisableLocalAuth)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, &t.Endpoint)
			delete(rawMsg, key)
		case "inboundIpRules":
			err = unpopulate(val, &t.InboundIPRules)
			delete(rawMsg, key)
		case "inputSchema":
			err = unpopulate(val, &t.InputSchema)
			delete(rawMsg, key)
		case "inputSchemaMapping":
			t.InputSchemaMapping, err = unmarshalInputSchemaMappingClassification(val)
			delete(rawMsg, key)
		case "metricResourceId":
			err = unpopulate(val, &t.MetricResourceID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &t.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &t.PublicNetworkAccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TopicRegenerateKeyRequest - Topic regenerate share access key request
type TopicRegenerateKeyRequest struct {
	// REQUIRED; Key name to regenerate key1 or key2
	KeyName *string `json:"keyName,omitempty"`
}

// TopicSharedAccessKeys - Shared access keys of the Topic
type TopicSharedAccessKeys struct {
	// Shared access key1 for the topic.
	Key1 *string `json:"key1,omitempty"`

	// Shared access key2 for the topic.
	Key2 *string `json:"key2,omitempty"`
}

// TopicTypeInfo - Properties of a topic type info.
type TopicTypeInfo struct {
	// Properties of the topic type info
	Properties *TopicTypeProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// TopicTypeProperties - Properties of a topic type.
type TopicTypeProperties struct {
	// Description of the topic type.
	Description *string `json:"description,omitempty"`

	// Display Name for the topic type.
	DisplayName *string `json:"displayName,omitempty"`

	// Namespace of the provider of the topic type.
	Provider *string `json:"provider,omitempty"`

	// Provisioning state of the topic type
	ProvisioningState *TopicTypeProvisioningState `json:"provisioningState,omitempty"`

	// Region type of the resource.
	ResourceRegionType *ResourceRegionType `json:"resourceRegionType,omitempty"`

	// Source resource format.
	SourceResourceFormat *string `json:"sourceResourceFormat,omitempty"`

	// List of locations supported by this topic type.
	SupportedLocations []*string `json:"supportedLocations,omitempty"`

	// Supported source scopes.
	SupportedScopesForSource []*TopicTypePropertiesSupportedScopesForSourceItem `json:"supportedScopesForSource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicTypeProperties.
func (t TopicTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "provider", t.Provider)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	populate(objectMap, "resourceRegionType", t.ResourceRegionType)
	populate(objectMap, "sourceResourceFormat", t.SourceResourceFormat)
	populate(objectMap, "supportedLocations", t.SupportedLocations)
	populate(objectMap, "supportedScopesForSource", t.SupportedScopesForSource)
	return json.Marshal(objectMap)
}

// TopicTypesClientGetOptions contains the optional parameters for the TopicTypesClient.Get method.
type TopicTypesClientGetOptions struct {
	// placeholder for future optional parameters
}

// TopicTypesClientListEventTypesOptions contains the optional parameters for the TopicTypesClient.ListEventTypes method.
type TopicTypesClientListEventTypesOptions struct {
	// placeholder for future optional parameters
}

// TopicTypesClientListOptions contains the optional parameters for the TopicTypesClient.List method.
type TopicTypesClientListOptions struct {
	// placeholder for future optional parameters
}

// TopicTypesListResult - Result of the List Topic Types operation
type TopicTypesListResult struct {
	// A collection of topic types
	Value []*TopicTypeInfo `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicTypesListResult.
func (t TopicTypesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TopicUpdateParameterProperties - Information of topic update parameter properties.
type TopicUpdateParameterProperties struct {
	// This boolean is used to enable or disable local auth. Default value is false. When the property is set to true, only AAD
	// token will be used to authenticate if user is allowed to publish to the topic.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess
	// is enabled.
	InboundIPRules []*InboundIPRule `json:"inboundIpRules,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled. You can further restrict to specific
	// IPs by configuring
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicUpdateParameterProperties.
func (t TopicUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableLocalAuth", t.DisableLocalAuth)
	populate(objectMap, "inboundIpRules", t.InboundIPRules)
	populate(objectMap, "publicNetworkAccess", t.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// TopicUpdateParameters - Properties of the Topic update
type TopicUpdateParameters struct {
	// Topic resource identity information.
	Identity *IdentityInfo `json:"identity,omitempty"`

	// Properties of the resource.
	Properties *TopicUpdateParameterProperties `json:"properties,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicUpdateParameters.
func (t TopicUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", t.Identity)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// TopicsClientBeginCreateOrUpdateOptions contains the optional parameters for the TopicsClient.BeginCreateOrUpdate method.
type TopicsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientBeginDeleteOptions contains the optional parameters for the TopicsClient.BeginDelete method.
type TopicsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientBeginRegenerateKeyOptions contains the optional parameters for the TopicsClient.BeginRegenerateKey method.
type TopicsClientBeginRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientBeginUpdateOptions contains the optional parameters for the TopicsClient.BeginUpdate method.
type TopicsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientGetOptions contains the optional parameters for the TopicsClient.Get method.
type TopicsClientGetOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientListByResourceGroupOptions contains the optional parameters for the TopicsClient.ListByResourceGroup method.
type TopicsClientListByResourceGroupOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// TopicsClientListBySubscriptionOptions contains the optional parameters for the TopicsClient.ListBySubscription method.
type TopicsClientListBySubscriptionOptions struct {
	// The query used to filter the search results using OData syntax. Filtering is permitted on the 'name' property only and
	// with limited number of OData operations. These operations are: the 'contains'
	// function as well as the following logical operations: not, and, or, eq (for equal), and ne (for not equal). No arithmetic
	// operations are supported. The following is a valid filter example:
	// $filter=contains(namE, 'PATTERN') and name ne 'PATTERN-1'. The following is not a valid filter example: $filter=location
	// eq 'westus'.
	Filter *string
	// The number of results to return per page for the list operation. Valid range for top parameter is 1 to 100. If not specified,
	// the default number of results to be returned is 20 items per page.
	Top *int32
}

// TopicsClientListEventTypesOptions contains the optional parameters for the TopicsClient.ListEventTypes method.
type TopicsClientListEventTypesOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientListSharedAccessKeysOptions contains the optional parameters for the TopicsClient.ListSharedAccessKeys method.
type TopicsClientListSharedAccessKeysOptions struct {
	// placeholder for future optional parameters
}

// TopicsListResult - Result of the List Topics operation
type TopicsListResult struct {
	// A link for the next page of topics
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of Topics
	Value []*Topic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicsListResult.
func (t TopicsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TrackedResource - Definition of a Tracked Resource.
type TrackedResource struct {
	// REQUIRED; Location of the resource.
	Location *string `json:"location,omitempty"`

	// Tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UserIdentityProperties - The information about the user identity.
type UserIdentityProperties struct {
	// The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty"`

	// The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty"`
}

// WebHookEventSubscriptionDestination - Information about the webhook destination for an event subscription.
type WebHookEventSubscriptionDestination struct {
	// REQUIRED; Type of the endpoint for the event subscription destination.
	EndpointType *EndpointType `json:"endpointType,omitempty"`

	// WebHook Properties of the event subscription destination.
	Properties *WebHookEventSubscriptionDestinationProperties `json:"properties,omitempty"`
}

// GetEventSubscriptionDestination implements the EventSubscriptionDestinationClassification interface for type WebHookEventSubscriptionDestination.
func (w *WebHookEventSubscriptionDestination) GetEventSubscriptionDestination() *EventSubscriptionDestination {
	return &EventSubscriptionDestination{
		EndpointType: w.EndpointType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebHookEventSubscriptionDestination.
func (w WebHookEventSubscriptionDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["endpointType"] = EndpointTypeWebHook
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookEventSubscriptionDestination.
func (w *WebHookEventSubscriptionDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpointType":
			err = unpopulate(val, &w.EndpointType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WebHookEventSubscriptionDestinationProperties - Information about the webhook destination properties for an event subscription.
type WebHookEventSubscriptionDestinationProperties struct {
	// The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery
	// requests.
	AzureActiveDirectoryApplicationIDOrURI *string `json:"azureActiveDirectoryApplicationIdOrUri,omitempty"`

	// The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
	AzureActiveDirectoryTenantID *string `json:"azureActiveDirectoryTenantId,omitempty"`

	// Delivery attribute details.
	DeliveryAttributeMappings []DeliveryAttributeMappingClassification `json:"deliveryAttributeMappings,omitempty"`

	// The URL that represents the endpoint of the destination of an event subscription.
	EndpointURL *string `json:"endpointUrl,omitempty"`

	// Maximum number of events per batch.
	MaxEventsPerBatch *int32 `json:"maxEventsPerBatch,omitempty"`

	// Preferred batch size in Kilobytes.
	PreferredBatchSizeInKilobytes *int32 `json:"preferredBatchSizeInKilobytes,omitempty"`

	// READ-ONLY; The base URL that represents the endpoint of the destination of an event subscription.
	EndpointBaseURL *string `json:"endpointBaseUrl,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WebHookEventSubscriptionDestinationProperties.
func (w WebHookEventSubscriptionDestinationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureActiveDirectoryApplicationIdOrUri", w.AzureActiveDirectoryApplicationIDOrURI)
	populate(objectMap, "azureActiveDirectoryTenantId", w.AzureActiveDirectoryTenantID)
	populate(objectMap, "deliveryAttributeMappings", w.DeliveryAttributeMappings)
	populate(objectMap, "endpointBaseUrl", w.EndpointBaseURL)
	populate(objectMap, "endpointUrl", w.EndpointURL)
	populate(objectMap, "maxEventsPerBatch", w.MaxEventsPerBatch)
	populate(objectMap, "preferredBatchSizeInKilobytes", w.PreferredBatchSizeInKilobytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookEventSubscriptionDestinationProperties.
func (w *WebHookEventSubscriptionDestinationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureActiveDirectoryApplicationIdOrUri":
			err = unpopulate(val, &w.AzureActiveDirectoryApplicationIDOrURI)
			delete(rawMsg, key)
		case "azureActiveDirectoryTenantId":
			err = unpopulate(val, &w.AzureActiveDirectoryTenantID)
			delete(rawMsg, key)
		case "deliveryAttributeMappings":
			w.DeliveryAttributeMappings, err = unmarshalDeliveryAttributeMappingClassificationArray(val)
			delete(rawMsg, key)
		case "endpointBaseUrl":
			err = unpopulate(val, &w.EndpointBaseURL)
			delete(rawMsg, key)
		case "endpointUrl":
			err = unpopulate(val, &w.EndpointURL)
			delete(rawMsg, key)
		case "maxEventsPerBatch":
			err = unpopulate(val, &w.MaxEventsPerBatch)
			delete(rawMsg, key)
		case "preferredBatchSizeInKilobytes":
			err = unpopulate(val, &w.PreferredBatchSizeInKilobytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
