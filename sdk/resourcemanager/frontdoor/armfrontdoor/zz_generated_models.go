//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armfrontdoor

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AzureAsyncOperationResult - The response body contains the status of the specified asynchronous operation, indicating whether it has succeeded, is in
// progress, or has failed. Note that this status is distinct from the HTTP
// status code returned for the Get Operation Status operation itself. If the asynchronous operation succeeded, the response body includes the HTTP status
// code for the successful request. If the
// asynchronous operation failed, the response body includes the HTTP status code for the failed request and error information regarding the failure.
type AzureAsyncOperationResult struct {
	Error *Error `json:"error,omitempty"`

	// Status of the Azure async operation. Possible values are: 'InProgress', 'Succeeded', and 'Failed'.
	Status *NetworkOperationStatus `json:"status,omitempty"`
}

// Backend address of a frontDoor load balancer.
type Backend struct {
	// Location of the backend (IP address or FQDN)
	Address *string `json:"address,omitempty"`

	// The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
	BackendHostHeader *string `json:"backendHostHeader,omitempty"`

	// Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *BackendEnabledState `json:"enabledState,omitempty"`

	// The HTTP TCP port number. Must be between 1 and 65535.
	HTTPPort *int32 `json:"httpPort,omitempty"`

	// The HTTPS TCP port number. Must be between 1 and 65535.
	HTTPSPort *int32 `json:"httpsPort,omitempty"`

	// Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
	Priority *int32 `json:"priority,omitempty"`

	// The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// A custom message to be included in the approval request to connect to the Private Link
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`

	// Weight of this endpoint for load balancing purposes.
	Weight *int32 `json:"weight,omitempty"`

	// READ-ONLY; The Approval status for the connection to the Private Link
	PrivateEndpointStatus *PrivateEndpointStatus `json:"privateEndpointStatus,omitempty" azure:"ro"`
}

// BackendPool - A backend pool is a collection of backends that can be routed to.
type BackendPool struct {
	SubResource
	// Resource name.
	Name *string `json:"name,omitempty"`

	// Properties of the Front Door Backend Pool
	Properties *BackendPoolProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// BackendPoolListResult - Result of the request to list Backend Pools. It contains a list of Backend Pools objects and a URL link to get the next set of
// results.
type BackendPoolListResult struct {
	// URL to get the next set of BackendPool objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Backend Pools within a Front Door.
	Value []*BackendPool `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackendPoolListResult.
func (b BackendPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BackendPoolProperties - The JSON object that contains the properties required to create a Backend Pool.
type BackendPoolProperties struct {
	BackendPoolUpdateParameters
	// READ-ONLY; Resource status.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackendPoolProperties.
func (b BackendPoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.BackendPoolUpdateParameters.marshalInternal(objectMap)
	populate(objectMap, "resourceState", b.ResourceState)
	return json.Marshal(objectMap)
}

// BackendPoolUpdateParameters - A collection of backends that can be routed to.
type BackendPoolUpdateParameters struct {
	// The set of backends for this pool
	Backends []*Backend `json:"backends,omitempty"`

	// L7 health probe settings for a backend pool
	HealthProbeSettings *SubResource `json:"healthProbeSettings,omitempty"`

	// Load balancing settings for a backend pool
	LoadBalancingSettings *SubResource `json:"loadBalancingSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackendPoolUpdateParameters.
func (b BackendPoolUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (b BackendPoolUpdateParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "backends", b.Backends)
	populate(objectMap, "healthProbeSettings", b.HealthProbeSettings)
	populate(objectMap, "loadBalancingSettings", b.LoadBalancingSettings)
}

// BackendPoolsSettings - Settings that apply to all backend pools.
type BackendPoolsSettings struct {
	// Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
	EnforceCertificateNameCheck *EnforceCertificateNameCheckEnabledState `json:"enforceCertificateNameCheck,omitempty"`

	// Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
	SendRecvTimeoutSeconds *int32 `json:"sendRecvTimeoutSeconds,omitempty"`
}

// CacheConfiguration - Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration struct {
	// The duration for which the content needs to be cached. Allowed format is in ISO 8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires
	// the value to be no more than a year
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// Whether to use dynamic compression for cached content
	DynamicCompression *DynamicCompressionEnabled `json:"dynamicCompression,omitempty"`

	// Treatment of URL query terms when forming the cache key.
	QueryParameterStripDirective *FrontDoorQuery `json:"queryParameterStripDirective,omitempty"`

	// query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`
}

// CheckNameAvailabilityInput - Input of CheckNameAvailability API.
type CheckNameAvailabilityInput struct {
	// REQUIRED; The resource name to validate.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of the resource whose name is to be validated.
	Type *ResourceType `json:"type,omitempty"`
}

// CheckNameAvailabilityOutput - Output of check name availability API.
type CheckNameAvailabilityOutput struct {
	// READ-ONLY; The detailed error message describing why the name is not available.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether the name is available.
	NameAvailability *Availability `json:"nameAvailability,omitempty" azure:"ro"`

	// READ-ONLY; The reason why the name is not available.
	Reason *string `json:"reason,omitempty" azure:"ro"`
}

// CustomHTTPSConfiguration - Https settings for a domain
type CustomHTTPSConfiguration struct {
	// REQUIRED; Defines the source of the SSL certificate
	CertificateSource *FrontDoorCertificateSource `json:"certificateSource,omitempty"`

	// REQUIRED; The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
	MinimumTLSVersion *MinimumTLSVersion `json:"minimumTlsVersion,omitempty"`

	// REQUIRED; Defines the TLS extension protocol that is used for secure delivery
	ProtocolType *FrontDoorTLSProtocolType `json:"protocolType,omitempty"`

	// Parameters required for enabling SSL with Front Door-managed certificates (if certificateSource=FrontDoor)
	FrontDoorCertificateSourceParameters *FrontDoorCertificateSourceParameters `json:"frontDoorCertificateSourceParameters,omitempty"`

	// KeyVault certificate source parameters (if certificateSource=AzureKeyVault)
	KeyVaultCertificateSourceParameters *KeyVaultCertificateSourceParameters `json:"keyVaultCertificateSourceParameters,omitempty"`
}

// CustomRule - Defines contents of a web application rule
type CustomRule struct {
	// REQUIRED; Describes what action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// REQUIRED; List of match conditions.
	MatchConditions []*MatchCondition `json:"matchConditions,omitempty"`

	// REQUIRED; Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int32 `json:"priority,omitempty"`

	// REQUIRED; Describes type of rule.
	RuleType *RuleType `json:"ruleType,omitempty"`

	// Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *CustomRuleEnabledState `json:"enabledState,omitempty"`

	// Describes the name of the rule.
	Name *string `json:"name,omitempty"`

	// Time window for resetting the rate limit count. Default is 1 minute.
	RateLimitDurationInMinutes *int32 `json:"rateLimitDurationInMinutes,omitempty"`

	// Number of allowed requests per client within the time window.
	RateLimitThreshold *int32 `json:"rateLimitThreshold,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomRule.
func (c CustomRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", c.Action)
	populate(objectMap, "enabledState", c.EnabledState)
	populate(objectMap, "matchConditions", c.MatchConditions)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "priority", c.Priority)
	populate(objectMap, "rateLimitDurationInMinutes", c.RateLimitDurationInMinutes)
	populate(objectMap, "rateLimitThreshold", c.RateLimitThreshold)
	populate(objectMap, "ruleType", c.RuleType)
	return json.Marshal(objectMap)
}

// CustomRuleList - Defines contents of custom rules
type CustomRuleList struct {
	// List of rules
	Rules []*CustomRule `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomRuleList.
func (c CustomRuleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rules", c.Rules)
	return json.Marshal(objectMap)
}

// Endpoint - Defines the endpoint properties
type Endpoint struct {
	// The endpoint URL
	Endpoint *string `json:"endpoint,omitempty"`

	// The name of the endpoint
	Name *string `json:"name,omitempty"`
}

// EndpointsBeginPurgeContentOptions contains the optional parameters for the Endpoints.BeginPurgeContent method.
type EndpointsBeginPurgeContentOptions struct {
	// placeholder for future optional parameters
}

type Error struct {
	Code       *string         `json:"code,omitempty"`
	Details    []*ErrorDetails `json:"details,omitempty"`
	InnerError *string         `json:"innerError,omitempty"`
	Message    *string         `json:"message,omitempty"`
	Target     *string         `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "innerError", e.InnerError)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

type ErrorDetails struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
	Target  *string `json:"target,omitempty"`
}

// ErrorResponse - Error response indicates Front Door service is not able to process the incoming request. The reason is provided in the error message.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// Experiment - Defines the properties of an Experiment
type Experiment struct {
	Resource
	// The properties of an Experiment
	Properties *ExperimentProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Experiment.
func (e Experiment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// ExperimentList - Defines a list of Experiments. It contains a list of Experiment objects and a URL link to get the next set of results.
type ExperimentList struct {
	// URL to get the next set of Experiment objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Experiments within a resource group.
	Value []*Experiment `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExperimentList.
func (e ExperimentList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExperimentProperties - Defines the properties of an experiment
type ExperimentProperties struct {
	// The description of the details or intents of the Experiment
	Description *string `json:"description,omitempty"`

	// The state of the Experiment
	EnabledState *State `json:"enabledState,omitempty"`

	// The endpoint A of an experiment
	EndpointA *Endpoint `json:"endpointA,omitempty"`

	// The endpoint B of an experiment
	EndpointB *Endpoint `json:"endpointB,omitempty"`

	// READ-ONLY; Resource status.
	ResourceState *NetworkExperimentResourceState `json:"resourceState,omitempty" azure:"ro"`

	// READ-ONLY; The uri to the Script used in the Experiment
	ScriptFileURI *string `json:"scriptFileUri,omitempty" azure:"ro"`

	// READ-ONLY; The description of Experiment status from the server side
	Status *string `json:"status,omitempty" azure:"ro"`
}

// ExperimentUpdateModel - Defines modifiable attributes of an Experiment
type ExperimentUpdateModel struct {
	// The properties of a Profile
	Properties *ExperimentUpdateProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExperimentUpdateModel.
func (e ExperimentUpdateModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// ExperimentUpdateProperties - Defines the properties of an experiment
type ExperimentUpdateProperties struct {
	// The description of the intent or details of the Experiment
	Description *string `json:"description,omitempty"`

	// The state of the Experiment
	EnabledState *State `json:"enabledState,omitempty"`
}

// ExperimentsBeginCreateOrUpdateOptions contains the optional parameters for the Experiments.BeginCreateOrUpdate method.
type ExperimentsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ExperimentsBeginDeleteOptions contains the optional parameters for the Experiments.BeginDelete method.
type ExperimentsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ExperimentsBeginUpdateOptions contains the optional parameters for the Experiments.BeginUpdate method.
type ExperimentsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ExperimentsGetOptions contains the optional parameters for the Experiments.Get method.
type ExperimentsGetOptions struct {
	// placeholder for future optional parameters
}

// ExperimentsListByProfileOptions contains the optional parameters for the Experiments.ListByProfile method.
type ExperimentsListByProfileOptions struct {
	// placeholder for future optional parameters
}

// ForwardingConfiguration - Describes Forwarding Route.
type ForwardingConfiguration struct {
	RouteConfiguration
	// A reference to the BackendPool which this rule routes to.
	BackendPool *SubResource `json:"backendPool,omitempty"`

	// The caching configuration associated with this rule.
	CacheConfiguration *CacheConfiguration `json:"cacheConfiguration,omitempty"`

	// A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming path.
	CustomForwardingPath *string `json:"customForwardingPath,omitempty"`

	// Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *FrontDoorForwardingProtocol `json:"forwardingProtocol,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ForwardingConfiguration.
func (f ForwardingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.RouteConfiguration.marshalInternal(objectMap, "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration")
	populate(objectMap, "backendPool", f.BackendPool)
	populate(objectMap, "cacheConfiguration", f.CacheConfiguration)
	populate(objectMap, "customForwardingPath", f.CustomForwardingPath)
	populate(objectMap, "forwardingProtocol", f.ForwardingProtocol)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForwardingConfiguration.
func (f *ForwardingConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPool":
			err = unpopulate(val, &f.BackendPool)
			delete(rawMsg, key)
		case "cacheConfiguration":
			err = unpopulate(val, &f.CacheConfiguration)
			delete(rawMsg, key)
		case "customForwardingPath":
			err = unpopulate(val, &f.CustomForwardingPath)
			delete(rawMsg, key)
		case "forwardingProtocol":
			err = unpopulate(val, &f.ForwardingProtocol)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := f.RouteConfiguration.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// FrontDoor - Front Door represents a collection of backend endpoints to route traffic to along with rules that specify how traffic is sent there.
type FrontDoor struct {
	Resource
	// Properties of the Front Door Load Balancer
	Properties *FrontDoorProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FrontDoor.
func (f FrontDoor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", f.Properties)
	return json.Marshal(objectMap)
}

// FrontDoorCertificateSourceParameters - Parameters required for enabling SSL with Front Door-managed certificates
type FrontDoorCertificateSourceParameters struct {
	// Defines the type of the certificate used for secure connections to a frontendEndpoint
	CertificateType *FrontDoorCertificateType `json:"certificateType,omitempty"`
}

// FrontDoorListResult - Result of the request to list Front Doors. It contains a list of Front Door objects and a URL link to get the next set of results.
type FrontDoorListResult struct {
	// URL to get the next set of Front Door objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Front Doors within a resource group.
	Value []*FrontDoor `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FrontDoorListResult.
func (f FrontDoorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FrontDoorNameAvailabilityCheckOptions contains the optional parameters for the FrontDoorNameAvailability.Check method.
type FrontDoorNameAvailabilityCheckOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorNameAvailabilityWithSubscriptionCheckOptions contains the optional parameters for the FrontDoorNameAvailabilityWithSubscription.Check method.
type FrontDoorNameAvailabilityWithSubscriptionCheckOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorProperties - The JSON object that contains the properties required to create an endpoint.
type FrontDoorProperties struct {
	FrontDoorUpdateParameters
	// READ-ONLY; The host that each frontendEndpoint must CNAME to.
	Cname *string `json:"cname,omitempty" azure:"ro"`

	// READ-ONLY; The Id of the frontdoor.
	FrontdoorID *string `json:"frontdoorId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the Front Door.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the Front Door.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`

	// READ-ONLY; Rules Engine Configurations available to routing rules.
	RulesEngines []*RulesEngine `json:"rulesEngines,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FrontDoorProperties.
func (f FrontDoorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.FrontDoorUpdateParameters.marshalInternal(objectMap)
	populate(objectMap, "cname", f.Cname)
	populate(objectMap, "frontdoorId", f.FrontdoorID)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "resourceState", f.ResourceState)
	populate(objectMap, "rulesEngines", f.RulesEngines)
	return json.Marshal(objectMap)
}

// FrontDoorUpdateParameters - The properties needed to update a Front Door
type FrontDoorUpdateParameters struct {
	// Backend pools available to routing rules.
	BackendPools []*BackendPool `json:"backendPools,omitempty"`

	// Settings for all backendPools
	BackendPoolsSettings *BackendPoolsSettings `json:"backendPoolsSettings,omitempty"`

	// Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *FrontDoorEnabledState `json:"enabledState,omitempty"`

	// A friendly name for the frontDoor
	FriendlyName *string `json:"friendlyName,omitempty"`

	// Frontend endpoints available to routing rules.
	FrontendEndpoints []*FrontendEndpoint `json:"frontendEndpoints,omitempty"`

	// Health probe settings associated with this Front Door instance.
	HealthProbeSettings []*HealthProbeSettingsModel `json:"healthProbeSettings,omitempty"`

	// Load balancing settings associated with this Front Door instance.
	LoadBalancingSettings []*LoadBalancingSettingsModel `json:"loadBalancingSettings,omitempty"`

	// Routing rules associated with this Front Door.
	RoutingRules []*RoutingRule `json:"routingRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FrontDoorUpdateParameters.
func (f FrontDoorUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (f FrontDoorUpdateParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "backendPools", f.BackendPools)
	populate(objectMap, "backendPoolsSettings", f.BackendPoolsSettings)
	populate(objectMap, "enabledState", f.EnabledState)
	populate(objectMap, "friendlyName", f.FriendlyName)
	populate(objectMap, "frontendEndpoints", f.FrontendEndpoints)
	populate(objectMap, "healthProbeSettings", f.HealthProbeSettings)
	populate(objectMap, "loadBalancingSettings", f.LoadBalancingSettings)
	populate(objectMap, "routingRules", f.RoutingRules)
}

// FrontDoorsBeginCreateOrUpdateOptions contains the optional parameters for the FrontDoors.BeginCreateOrUpdate method.
type FrontDoorsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorsBeginDeleteOptions contains the optional parameters for the FrontDoors.BeginDelete method.
type FrontDoorsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorsGetOptions contains the optional parameters for the FrontDoors.Get method.
type FrontDoorsGetOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorsListByResourceGroupOptions contains the optional parameters for the FrontDoors.ListByResourceGroup method.
type FrontDoorsListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorsListOptions contains the optional parameters for the FrontDoors.List method.
type FrontDoorsListOptions struct {
	// placeholder for future optional parameters
}

// FrontDoorsValidateCustomDomainOptions contains the optional parameters for the FrontDoors.ValidateCustomDomain method.
type FrontDoorsValidateCustomDomainOptions struct {
	// placeholder for future optional parameters
}

// FrontendEndpoint - A frontend endpoint used for routing.
type FrontendEndpoint struct {
	SubResource
	// Resource name.
	Name *string `json:"name,omitempty"`

	// Properties of the Frontend endpoint
	Properties *FrontendEndpointProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// FrontendEndpointLink - Defines the Resource ID for a Frontend Endpoint.
type FrontendEndpointLink struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// FrontendEndpointProperties - The JSON object that contains the properties required to create a frontend endpoint.
type FrontendEndpointProperties struct {
	FrontendEndpointUpdateParameters
	// READ-ONLY; The configuration specifying how to enable HTTPS
	CustomHTTPSConfiguration *CustomHTTPSConfiguration `json:"customHttpsConfiguration,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status of Custom Https of the frontendEndpoint.
	CustomHTTPSProvisioningState *CustomHTTPSProvisioningState `json:"customHttpsProvisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
	CustomHTTPSProvisioningSubstate *CustomHTTPSProvisioningSubstate `json:"customHttpsProvisioningSubstate,omitempty" azure:"ro"`

	// READ-ONLY; Resource status.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// FrontendEndpointUpdateParameters - Frontend endpoint used in routing rule
type FrontendEndpointUpdateParameters struct {
	// The host name of the frontendEndpoint. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
	SessionAffinityEnabledState *SessionAffinityEnabledState `json:"sessionAffinityEnabledState,omitempty"`

	// UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
	SessionAffinityTTLSeconds *int32 `json:"sessionAffinityTtlSeconds,omitempty"`

	// Defines the Web Application Firewall policy for each host (if applicable)
	WebApplicationFirewallPolicyLink *FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

// FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink - Defines the Web Application Firewall policy for each host (if applicable)
type FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// FrontendEndpointsBeginDisableHTTPSOptions contains the optional parameters for the FrontendEndpoints.BeginDisableHTTPS method.
type FrontendEndpointsBeginDisableHTTPSOptions struct {
	// placeholder for future optional parameters
}

// FrontendEndpointsBeginEnableHTTPSOptions contains the optional parameters for the FrontendEndpoints.BeginEnableHTTPS method.
type FrontendEndpointsBeginEnableHTTPSOptions struct {
	// placeholder for future optional parameters
}

// FrontendEndpointsGetOptions contains the optional parameters for the FrontendEndpoints.Get method.
type FrontendEndpointsGetOptions struct {
	// placeholder for future optional parameters
}

// FrontendEndpointsListByFrontDoorOptions contains the optional parameters for the FrontendEndpoints.ListByFrontDoor method.
type FrontendEndpointsListByFrontDoorOptions struct {
	// placeholder for future optional parameters
}

// FrontendEndpointsListResult - Result of the request to list frontend endpoints. It contains a list of Frontend endpoint objects and a URL link to get
// the next set of results.
type FrontendEndpointsListResult struct {
	// URL to get the next set of frontend endpoints if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Frontend endpoints within a Front Door.
	Value []*FrontendEndpoint `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FrontendEndpointsListResult.
func (f FrontendEndpointsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// HeaderAction - An action that can manipulate an http header.
type HeaderAction struct {
	// REQUIRED; Which type of manipulation to apply to the header.
	HeaderActionType *HeaderActionType `json:"headerActionType,omitempty"`

	// REQUIRED; The name of the header this action will apply to.
	HeaderName *string `json:"headerName,omitempty"`

	// The value to update the given header name with. This value is not used if the actionType is Delete.
	Value *string `json:"value,omitempty"`
}

// HealthProbeSettingsListResult - Result of the request to list HealthProbeSettings. It contains a list of HealthProbeSettings objects and a URL link to
// get the next set of results.
type HealthProbeSettingsListResult struct {
	// URL to get the next set of HealthProbeSettings objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of HealthProbeSettings within a Front Door.
	Value []*HealthProbeSettingsModel `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HealthProbeSettingsListResult.
func (h HealthProbeSettingsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// HealthProbeSettingsModel - Load balancing settings for a backend pool
type HealthProbeSettingsModel struct {
	SubResource
	// Resource name.
	Name *string `json:"name,omitempty"`

	// Properties of the health probe settings
	Properties *HealthProbeSettingsProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// HealthProbeSettingsProperties - The JSON object that contains the properties required to create a health probe settings.
type HealthProbeSettingsProperties struct {
	HealthProbeSettingsUpdateParameters
	// READ-ONLY; Resource status.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// HealthProbeSettingsUpdateParameters - L7 health probe settings for a backend pool
type HealthProbeSettingsUpdateParameters struct {
	// Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled
	// backend in single enabled backend pool.
	EnabledState *HealthProbeEnabled `json:"enabledState,omitempty"`

	// Configures which HTTP method to use to probe the backends defined under backendPools.
	HealthProbeMethod *FrontDoorHealthProbeMethod `json:"healthProbeMethod,omitempty"`

	// The number of seconds between health probes.
	IntervalInSeconds *int32 `json:"intervalInSeconds,omitempty"`

	// The path to use for the health probe. Default is /
	Path *string `json:"path,omitempty"`

	// Protocol scheme to use for this probe
	Protocol *FrontDoorProtocol `json:"protocol,omitempty"`
}

// KeyVaultCertificateSourceParameters - Parameters required for bring-your-own-certification via Key Vault
type KeyVaultCertificateSourceParameters struct {
	// The name of the Key Vault secret representing the full certificate PFX
	SecretName *string `json:"secretName,omitempty"`

	// The version of the Key Vault secret representing the full certificate PFX
	SecretVersion *string `json:"secretVersion,omitempty"`

	// The Key Vault containing the SSL certificate
	Vault *KeyVaultCertificateSourceParametersVault `json:"vault,omitempty"`
}

// KeyVaultCertificateSourceParametersVault - The Key Vault containing the SSL certificate
type KeyVaultCertificateSourceParametersVault struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// LatencyMetric - Defines the properties of a latency metric used in the latency scorecard
type LatencyMetric struct {
	// READ-ONLY; The lower end of the 95% confidence interval for endpoint A
	ACLower95CI *float32 `json:"aCLower95CI,omitempty" azure:"ro"`

	// READ-ONLY; The upper end of the 95% confidence interval for endpoint A
	AHUpper95CI *float32 `json:"aHUpper95CI,omitempty" azure:"ro"`

	// READ-ONLY; The metric value of the A endpoint
	AValue *float32 `json:"aValue,omitempty" azure:"ro"`

	// READ-ONLY; The lower end of the 95% confidence interval for endpoint B
	BCLower95CI *float32 `json:"bCLower95CI,omitempty" azure:"ro"`

	// READ-ONLY; The upper end of the 95% confidence interval for endpoint B
	BUpper95CI *float32 `json:"bUpper95CI,omitempty" azure:"ro"`

	// READ-ONLY; The metric value of the B endpoint
	BValue *float32 `json:"bValue,omitempty" azure:"ro"`

	// READ-ONLY; The difference in value between endpoint A and B
	Delta *float32 `json:"delta,omitempty" azure:"ro"`

	// READ-ONLY; The percent difference between endpoint A and B
	DeltaPercent *float32 `json:"deltaPercent,omitempty" azure:"ro"`

	// READ-ONLY; The end time of the Latency Scorecard in UTC
	EndDateTimeUTC *string `json:"endDateTimeUTC,omitempty" azure:"ro"`

	// READ-ONLY; The name of the Latency Metric
	Name *string `json:"name,omitempty" azure:"ro"`
}

// LatencyScorecard - Defines the LatencyScorecard
type LatencyScorecard struct {
	Resource
	// The properties of a latency scorecard
	Properties *LatencyScorecardProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LatencyScorecard.
func (l LatencyScorecard) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// LatencyScorecardProperties - Defines a the properties of a Latency Scorecard
type LatencyScorecardProperties struct {
	// The latency metrics of the Latency Scorecard
	LatencyMetrics []*LatencyMetric `json:"latencyMetrics,omitempty"`

	// READ-ONLY; The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html
	Country *string `json:"country,omitempty" azure:"ro"`

	// READ-ONLY; The description of the Latency Scorecard
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The end time of the Latency Scorecard in UTC
	EndDateTimeUTC *time.Time `json:"endDateTimeUTC,omitempty" azure:"ro"`

	// READ-ONLY; The A endpoint in the scorecard
	EndpointA *string `json:"endpointA,omitempty" azure:"ro"`

	// READ-ONLY; The B endpoint in the scorecard
	EndpointB *string `json:"endpointB,omitempty" azure:"ro"`

	// READ-ONLY; The unique identifier of the Latency Scorecard
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the Latency Scorecard
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the Latency Scorecard in UTC
	StartDateTimeUTC *time.Time `json:"startDateTimeUTC,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LatencyScorecardProperties.
func (l LatencyScorecardProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "country", l.Country)
	populate(objectMap, "description", l.Description)
	populateTimeRFC3339(objectMap, "endDateTimeUTC", l.EndDateTimeUTC)
	populate(objectMap, "endpointA", l.EndpointA)
	populate(objectMap, "endpointB", l.EndpointB)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "latencyMetrics", l.LatencyMetrics)
	populate(objectMap, "name", l.Name)
	populateTimeRFC3339(objectMap, "startDateTimeUTC", l.StartDateTimeUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LatencyScorecardProperties.
func (l *LatencyScorecardProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "country":
			err = unpopulate(val, &l.Country)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "endDateTimeUTC":
			err = unpopulateTimeRFC3339(val, &l.EndDateTimeUTC)
			delete(rawMsg, key)
		case "endpointA":
			err = unpopulate(val, &l.EndpointA)
			delete(rawMsg, key)
		case "endpointB":
			err = unpopulate(val, &l.EndpointB)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &l.ID)
			delete(rawMsg, key)
		case "latencyMetrics":
			err = unpopulate(val, &l.LatencyMetrics)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "startDateTimeUTC":
			err = unpopulateTimeRFC3339(val, &l.StartDateTimeUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LoadBalancingSettingsListResult - Result of the request to list load balancing settings. It contains a list of load balancing settings objects and a
// URL link to get the next set of results.
type LoadBalancingSettingsListResult struct {
	// URL to get the next set of LoadBalancingSettings objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Backend Pools within a Front Door.
	Value []*LoadBalancingSettingsModel `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LoadBalancingSettingsListResult.
func (l LoadBalancingSettingsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LoadBalancingSettingsModel - Load balancing settings for a backend pool
type LoadBalancingSettingsModel struct {
	SubResource
	// Resource name.
	Name *string `json:"name,omitempty"`

	// Properties of the load balancing settings
	Properties *LoadBalancingSettingsProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// LoadBalancingSettingsProperties - The JSON object that contains the properties required to create load balancing settings
type LoadBalancingSettingsProperties struct {
	LoadBalancingSettingsUpdateParameters
	// READ-ONLY; Resource status.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// LoadBalancingSettingsUpdateParameters - Round-Robin load balancing settings for a backend pool
type LoadBalancingSettingsUpdateParameters struct {
	// The additional latency in milliseconds for probes to fall into the lowest latency bucket
	AdditionalLatencyMilliseconds *int32 `json:"additionalLatencyMilliseconds,omitempty"`

	// The number of samples to consider for load balancing decisions
	SampleSize *int32 `json:"sampleSize,omitempty"`

	// The number of samples within the sample period that must succeed
	SuccessfulSamplesRequired *int32 `json:"successfulSamplesRequired,omitempty"`
}

// ManagedRuleDefinition - Describes a managed rule definition.
type ManagedRuleDefinition struct {
	// READ-ONLY; Describes the default action to be applied when the managed rule matches.
	DefaultAction *ActionType `json:"defaultAction,omitempty" azure:"ro"`

	// READ-ONLY; Describes the default state for the managed rule.
	DefaultState *ManagedRuleEnabledState `json:"defaultState,omitempty" azure:"ro"`

	// READ-ONLY; Describes the functionality of the managed rule.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the managed rule.
	RuleID *string `json:"ruleId,omitempty" azure:"ro"`
}

// ManagedRuleExclusion - Exclude variables from managed rule evaluation.
type ManagedRuleExclusion struct {
	// REQUIRED; The variable type to be excluded.
	MatchVariable *ManagedRuleExclusionMatchVariable `json:"matchVariable,omitempty"`

	// REQUIRED; Selector value for which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`

	// REQUIRED; Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
	SelectorMatchOperator *ManagedRuleExclusionSelectorMatchOperator `json:"selectorMatchOperator,omitempty"`
}

// ManagedRuleGroupDefinition - Describes a managed rule group.
type ManagedRuleGroupDefinition struct {
	// READ-ONLY; Description of the managed rule group.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Name of the managed rule group.
	RuleGroupName *string `json:"ruleGroupName,omitempty" azure:"ro"`

	// READ-ONLY; List of rules within the managed rule group.
	Rules []*ManagedRuleDefinition `json:"rules,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleGroupDefinition.
func (m ManagedRuleGroupDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "ruleGroupName", m.RuleGroupName)
	populate(objectMap, "rules", m.Rules)
	return json.Marshal(objectMap)
}

// ManagedRuleGroupOverride - Defines a managed rule group override setting.
type ManagedRuleGroupOverride struct {
	// REQUIRED; Describes the managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Describes the exclusions that are applied to all rules in the group.
	Exclusions []*ManagedRuleExclusion `json:"exclusions,omitempty"`

	// List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []*ManagedRuleOverride `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleGroupOverride.
func (m ManagedRuleGroupOverride) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "exclusions", m.Exclusions)
	populate(objectMap, "ruleGroupName", m.RuleGroupName)
	populate(objectMap, "rules", m.Rules)
	return json.Marshal(objectMap)
}

// ManagedRuleOverride - Defines a managed rule group override setting.
type ManagedRuleOverride struct {
	// REQUIRED; Identifier for the managed rule.
	RuleID *string `json:"ruleId,omitempty"`

	// Describes the override action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
	EnabledState *ManagedRuleEnabledState `json:"enabledState,omitempty"`

	// Describes the exclusions that are applied to this specific rule.
	Exclusions []*ManagedRuleExclusion `json:"exclusions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleOverride.
func (m ManagedRuleOverride) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", m.Action)
	populate(objectMap, "enabledState", m.EnabledState)
	populate(objectMap, "exclusions", m.Exclusions)
	populate(objectMap, "ruleId", m.RuleID)
	return json.Marshal(objectMap)
}

// ManagedRuleSet - Defines a managed rule set.
type ManagedRuleSet struct {
	// REQUIRED; Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// REQUIRED; Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`

	// Describes the exclusions that are applied to all rules in the set.
	Exclusions []*ManagedRuleExclusion `json:"exclusions,omitempty"`

	// Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []*ManagedRuleGroupOverride `json:"ruleGroupOverrides,omitempty"`

	// Defines the action to take when a managed rule set score threshold is met.
	RuleSetAction *ManagedRuleSetActionType `json:"ruleSetAction,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSet.
func (m ManagedRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "exclusions", m.Exclusions)
	populate(objectMap, "ruleGroupOverrides", m.RuleGroupOverrides)
	populate(objectMap, "ruleSetAction", m.RuleSetAction)
	populate(objectMap, "ruleSetType", m.RuleSetType)
	populate(objectMap, "ruleSetVersion", m.RuleSetVersion)
	return json.Marshal(objectMap)
}

// ManagedRuleSetDefinition - Describes the a managed rule set definition.
type ManagedRuleSetDefinition struct {
	Resource
	// Properties for a managed rule set definition.
	Properties *ManagedRuleSetDefinitionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetDefinition.
func (m ManagedRuleSetDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// ManagedRuleSetDefinitionList - List of managed rule set definitions available for use in a policy.
type ManagedRuleSetDefinitionList struct {
	// URL to retrieve next set of managed rule set definitions.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of managed rule set definitions.
	Value []*ManagedRuleSetDefinition `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetDefinitionList.
func (m ManagedRuleSetDefinitionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// ManagedRuleSetDefinitionProperties - Properties for a managed rule set definition.
type ManagedRuleSetDefinitionProperties struct {
	// READ-ONLY; Provisioning state of the managed rule set.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Rule groups of the managed rule set.
	RuleGroups []*ManagedRuleGroupDefinition `json:"ruleGroups,omitempty" azure:"ro"`

	// READ-ONLY; Id of the managed rule set.
	RuleSetID *string `json:"ruleSetId,omitempty" azure:"ro"`

	// READ-ONLY; Type of the managed rule set.
	RuleSetType *string `json:"ruleSetType,omitempty" azure:"ro"`

	// READ-ONLY; Version of the managed rule set type.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetDefinitionProperties.
func (m ManagedRuleSetDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "ruleGroups", m.RuleGroups)
	populate(objectMap, "ruleSetId", m.RuleSetID)
	populate(objectMap, "ruleSetType", m.RuleSetType)
	populate(objectMap, "ruleSetVersion", m.RuleSetVersion)
	return json.Marshal(objectMap)
}

// ManagedRuleSetList - Defines the list of managed rule sets for the policy.
type ManagedRuleSetList struct {
	// List of rule sets.
	ManagedRuleSets []*ManagedRuleSet `json:"managedRuleSets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRuleSetList.
func (m ManagedRuleSetList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "managedRuleSets", m.ManagedRuleSets)
	return json.Marshal(objectMap)
}

// ManagedRuleSetsListOptions contains the optional parameters for the ManagedRuleSets.List method.
type ManagedRuleSetsListOptions struct {
	// placeholder for future optional parameters
}

// MatchCondition - Define a match condition.
type MatchCondition struct {
	// REQUIRED; List of possible match values.
	MatchValue []*string `json:"matchValue,omitempty"`

	// REQUIRED; Request variable to compare with.
	MatchVariable *MatchVariable `json:"matchVariable,omitempty"`

	// REQUIRED; Comparison type to use for matching with the variable value.
	Operator *Operator `json:"operator,omitempty"`

	// Describes if the result of this condition should be negated.
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null.
	Selector *string `json:"selector,omitempty"`

	// List of transforms.
	Transforms []*TransformType `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MatchCondition.
func (m MatchCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "matchValue", m.MatchValue)
	populate(objectMap, "matchVariable", m.MatchVariable)
	populate(objectMap, "negateCondition", m.NegateCondition)
	populate(objectMap, "operator", m.Operator)
	populate(objectMap, "selector", m.Selector)
	populate(objectMap, "transforms", m.Transforms)
	return json.Marshal(objectMap)
}

// NetworkExperimentProfilesBeginCreateOrUpdateOptions contains the optional parameters for the NetworkExperimentProfiles.BeginCreateOrUpdate method.
type NetworkExperimentProfilesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// NetworkExperimentProfilesBeginDeleteOptions contains the optional parameters for the NetworkExperimentProfiles.BeginDelete method.
type NetworkExperimentProfilesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// NetworkExperimentProfilesBeginUpdateOptions contains the optional parameters for the NetworkExperimentProfiles.BeginUpdate method.
type NetworkExperimentProfilesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// NetworkExperimentProfilesGetOptions contains the optional parameters for the NetworkExperimentProfiles.Get method.
type NetworkExperimentProfilesGetOptions struct {
	// placeholder for future optional parameters
}

// NetworkExperimentProfilesListByResourceGroupOptions contains the optional parameters for the NetworkExperimentProfiles.ListByResourceGroup method.
type NetworkExperimentProfilesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// NetworkExperimentProfilesListOptions contains the optional parameters for the NetworkExperimentProfiles.List method.
type NetworkExperimentProfilesListOptions struct {
	// placeholder for future optional parameters
}

// PoliciesBeginCreateOrUpdateOptions contains the optional parameters for the Policies.BeginCreateOrUpdate method.
type PoliciesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PoliciesBeginDeleteOptions contains the optional parameters for the Policies.BeginDelete method.
type PoliciesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PoliciesGetOptions contains the optional parameters for the Policies.Get method.
type PoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// PoliciesListOptions contains the optional parameters for the Policies.List method.
type PoliciesListOptions struct {
	// placeholder for future optional parameters
}

// PolicySettings - Defines top-level WebApplicationFirewallPolicy configuration settings.
type PolicySettings struct {
	// If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int32 `json:"customBlockResponseStatusCode,omitempty"`

	// Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *PolicyEnabledState `json:"enabledState,omitempty"`

	// Describes if it is in detection mode or prevention mode at policy level.
	Mode *PolicyMode `json:"mode,omitempty"`

	// If action type is redirect, this field represents redirect URL for the client.
	RedirectURL *string `json:"redirectUrl,omitempty"`

	// Describes if policy managed rules will inspect the request body content.
	RequestBodyCheck *PolicyRequestBodyCheck `json:"requestBodyCheck,omitempty"`
}

// PreconfiguredEndpoint - Defines the properties of a preconfigured endpoint
type PreconfiguredEndpoint struct {
	Resource
	// The properties of a preconfiguredEndpoint
	Properties *PreconfiguredEndpointProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PreconfiguredEndpoint.
func (p PreconfiguredEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PreconfiguredEndpointList - Defines a list of preconfigured endpoints.
type PreconfiguredEndpointList struct {
	// URL to get the next set of PreconfiguredEndpoints if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of PreconfiguredEndpoints supported by NetworkExperiment.
	Value []*PreconfiguredEndpoint `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PreconfiguredEndpointList.
func (p PreconfiguredEndpointList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PreconfiguredEndpointProperties - Defines the properties of a preconfigured endpoint
type PreconfiguredEndpointProperties struct {
	// The preconfigured endpoint backend
	Backend *string `json:"backend,omitempty"`

	// The description of the endpoint
	Description *string `json:"description,omitempty"`

	// The endpoint that is preconfigured
	Endpoint *string `json:"endpoint,omitempty"`

	// The type of endpoint
	EndpointType *EndpointType `json:"endpointType,omitempty"`
}

// PreconfiguredEndpointsListOptions contains the optional parameters for the PreconfiguredEndpoints.List method.
type PreconfiguredEndpointsListOptions struct {
	// placeholder for future optional parameters
}

// Profile - Defines an Network Experiment Profile and lists of Experiments
type Profile struct {
	Resource
	// Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// The properties of a Profile
	Properties *ProfileProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Profile.
func (p Profile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// ProfileList - Defines a list of Profiles. It contains a list of Profile objects and a URL link to get the next set of results.
type ProfileList struct {
	// URL to get the next set of Profile objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Profiles within a resource group.
	Value []*Profile `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProfileList.
func (p ProfileList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ProfileProperties - Defines the properties of an experiment
type ProfileProperties struct {
	// The state of the Experiment
	EnabledState *State `json:"enabledState,omitempty"`

	// READ-ONLY; Resource status.
	ResourceState *NetworkExperimentResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// ProfileUpdateModel - Defines modifiable attributes of a Profile
type ProfileUpdateModel struct {
	// The properties of a Profile
	Properties *ProfileUpdateProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ProfileUpdateModel.
func (p ProfileUpdateModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// ProfileUpdateProperties - Defines the properties of an experiment
type ProfileUpdateProperties struct {
	// The enabled state of the Profile
	EnabledState *State `json:"enabledState,omitempty"`
}

// PurgeParameters - Parameters required for content purge.
type PurgeParameters struct {
	// REQUIRED; The path to the content to be purged. Can describe a file path or a wild card directory.
	ContentPaths []*string `json:"contentPaths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PurgeParameters.
func (p PurgeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentPaths", p.ContentPaths)
	return json.Marshal(objectMap)
}

// RedirectConfiguration - Describes Redirect Route.
type RedirectConfiguration struct {
	RouteConfiguration
	// Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHost *string `json:"customHost,omitempty"`

	// The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming
	// query string. Query string must be in =
	// format. The first ? and & will be added automatically so do not include them in the front, but do separate multiple query strings with &.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// The protocol of the destination to where the traffic is redirected
	RedirectProtocol *FrontDoorRedirectProtocol `json:"redirectProtocol,omitempty"`

	// The redirect type the rule will use when redirecting traffic.
	RedirectType *FrontDoorRedirectType `json:"redirectType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedirectConfiguration.
func (r RedirectConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RouteConfiguration.marshalInternal(objectMap, "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration")
	populate(objectMap, "customFragment", r.CustomFragment)
	populate(objectMap, "customHost", r.CustomHost)
	populate(objectMap, "customPath", r.CustomPath)
	populate(objectMap, "customQueryString", r.CustomQueryString)
	populate(objectMap, "redirectProtocol", r.RedirectProtocol)
	populate(objectMap, "redirectType", r.RedirectType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedirectConfiguration.
func (r *RedirectConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customFragment":
			err = unpopulate(val, &r.CustomFragment)
			delete(rawMsg, key)
		case "customHost":
			err = unpopulate(val, &r.CustomHost)
			delete(rawMsg, key)
		case "customPath":
			err = unpopulate(val, &r.CustomPath)
			delete(rawMsg, key)
		case "customQueryString":
			err = unpopulate(val, &r.CustomQueryString)
			delete(rawMsg, key)
		case "redirectProtocol":
			err = unpopulate(val, &r.RedirectProtocol)
			delete(rawMsg, key)
		case "redirectType":
			err = unpopulate(val, &r.RedirectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RouteConfiguration.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReportsGetLatencyScorecardsOptions contains the optional parameters for the Reports.GetLatencyScorecards method.
type ReportsGetLatencyScorecardsOptions struct {
	// The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html
	Country *string
	// The end DateTime of the Latency Scorecard in UTC
	EndDateTimeUTC *string
}

// ReportsGetTimeseriesOptions contains the optional parameters for the Reports.GetTimeseries method.
type ReportsGetTimeseriesOptions struct {
	// The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html
	Country *string
	// The specific endpoint
	Endpoint *string
}

// Resource - Common resource representation.
type Resource struct {
	// Resource location.
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// RouteConfigurationClassification provides polymorphic access to related types.
// Call the interface's GetRouteConfiguration() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ForwardingConfiguration, *RedirectConfiguration, *RouteConfiguration
type RouteConfigurationClassification interface {
	// GetRouteConfiguration returns the RouteConfiguration content of the underlying type.
	GetRouteConfiguration() *RouteConfiguration
}

// RouteConfiguration - Base class for all types of Route.
type RouteConfiguration struct {
	// REQUIRED
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetRouteConfiguration implements the RouteConfigurationClassification interface for type RouteConfiguration.
func (r *RouteConfiguration) GetRouteConfiguration() *RouteConfiguration { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type RouteConfiguration.
func (r *RouteConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RouteConfiguration) marshalInternal(objectMap map[string]interface{}, discValue string) {
	r.ODataType = &discValue
	objectMap["@odata.type"] = r.ODataType
}

func (r *RouteConfiguration) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &r.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoutingRule - A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
type RoutingRule struct {
	SubResource
	// Resource name.
	Name *string `json:"name,omitempty"`

	// Properties of the Front Door Routing Rule
	Properties *RoutingRuleProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoutingRuleLink - Defines the Resource ID for a Routing Rule.
type RoutingRuleLink struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// RoutingRuleListResult - Result of the request to list Routing Rules. It contains a list of Routing Rule objects and a URL link to get the next set of
// results.
type RoutingRuleListResult struct {
	// URL to get the next set of RoutingRule objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of Routing Rules within a Front Door.
	Value []*RoutingRule `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoutingRuleListResult.
func (r RoutingRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoutingRuleProperties - The JSON object that contains the properties required to create a routing rule.
type RoutingRuleProperties struct {
	RoutingRuleUpdateParameters
	// READ-ONLY; Resource status.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoutingRuleProperties.
func (r RoutingRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RoutingRuleUpdateParameters.marshalInternal(objectMap)
	populate(objectMap, "resourceState", r.ResourceState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutingRuleProperties.
func (r *RoutingRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceState":
			err = unpopulate(val, &r.ResourceState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RoutingRuleUpdateParameters.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoutingRuleUpdateParameters - Routing rules to apply to an endpoint
type RoutingRuleUpdateParameters struct {
	// Protocol schemes to match for this rule
	AcceptedProtocols []*FrontDoorProtocol `json:"acceptedProtocols,omitempty"`

	// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *RoutingRuleEnabledState `json:"enabledState,omitempty"`

	// Frontend endpoints associated with this rule
	FrontendEndpoints []*SubResource `json:"frontendEndpoints,omitempty"`

	// The route patterns of the rule.
	PatternsToMatch []*string `json:"patternsToMatch,omitempty"`

	// A reference to the routing configuration.
	RouteConfiguration RouteConfigurationClassification `json:"routeConfiguration,omitempty"`

	// A reference to a specific Rules Engine Configuration to apply to this route.
	RulesEngine *SubResource `json:"rulesEngine,omitempty"`

	// Defines the Web Application Firewall policy for each routing rule (if applicable)
	WebApplicationFirewallPolicyLink *RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoutingRuleUpdateParameters.
func (r RoutingRuleUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutingRuleUpdateParameters.
func (r *RoutingRuleUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RoutingRuleUpdateParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "acceptedProtocols", r.AcceptedProtocols)
	populate(objectMap, "enabledState", r.EnabledState)
	populate(objectMap, "frontendEndpoints", r.FrontendEndpoints)
	populate(objectMap, "patternsToMatch", r.PatternsToMatch)
	populate(objectMap, "routeConfiguration", r.RouteConfiguration)
	populate(objectMap, "rulesEngine", r.RulesEngine)
	populate(objectMap, "webApplicationFirewallPolicyLink", r.WebApplicationFirewallPolicyLink)
}

func (r *RoutingRuleUpdateParameters) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "acceptedProtocols":
			err = unpopulate(val, &r.AcceptedProtocols)
			delete(rawMsg, key)
		case "enabledState":
			err = unpopulate(val, &r.EnabledState)
			delete(rawMsg, key)
		case "frontendEndpoints":
			err = unpopulate(val, &r.FrontendEndpoints)
			delete(rawMsg, key)
		case "patternsToMatch":
			err = unpopulate(val, &r.PatternsToMatch)
			delete(rawMsg, key)
		case "routeConfiguration":
			r.RouteConfiguration, err = unmarshalRouteConfigurationClassification(val)
			delete(rawMsg, key)
		case "rulesEngine":
			err = unpopulate(val, &r.RulesEngine)
			delete(rawMsg, key)
		case "webApplicationFirewallPolicyLink":
			err = unpopulate(val, &r.WebApplicationFirewallPolicyLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink - Defines the Web Application Firewall policy for each routing rule (if applicable)
type RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// RulesEngine - A rules engine configuration containing a list of rules that will run to modify the runtime behavior of the request and response.
type RulesEngine struct {
	// Properties of the Rules Engine Configuration.
	Properties *RulesEngineProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RulesEngineAction - One or more actions that will execute, modifying the request and/or response.
type RulesEngineAction struct {
	// A list of header actions to apply from the request from AFD to the origin.
	RequestHeaderActions []*HeaderAction `json:"requestHeaderActions,omitempty"`

	// A list of header actions to apply from the response from AFD to the client.
	ResponseHeaderActions []*HeaderAction `json:"responseHeaderActions,omitempty"`

	// Override the route configuration.
	RouteConfigurationOverride RouteConfigurationClassification `json:"routeConfigurationOverride,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RulesEngineAction.
func (r RulesEngineAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "requestHeaderActions", r.RequestHeaderActions)
	populate(objectMap, "responseHeaderActions", r.ResponseHeaderActions)
	populate(objectMap, "routeConfigurationOverride", r.RouteConfigurationOverride)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RulesEngineAction.
func (r *RulesEngineAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "requestHeaderActions":
			err = unpopulate(val, &r.RequestHeaderActions)
			delete(rawMsg, key)
		case "responseHeaderActions":
			err = unpopulate(val, &r.ResponseHeaderActions)
			delete(rawMsg, key)
		case "routeConfigurationOverride":
			r.RouteConfigurationOverride, err = unmarshalRouteConfigurationClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RulesEngineListResult - Result of the request to list Rules Engine Configurations. It contains a list of RulesEngine objects and a URL link to get the
// next set of results.
type RulesEngineListResult struct {
	// URL to get the next set of RulesEngine objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of rulesEngines within a Front Door.
	Value []*RulesEngine `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RulesEngineListResult.
func (r RulesEngineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RulesEngineMatchCondition - Define a match condition
type RulesEngineMatchCondition struct {
	// REQUIRED; Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the
	// given operator this match condition is considered a match.
	RulesEngineMatchValue []*string `json:"rulesEngineMatchValue,omitempty"`

	// REQUIRED; Match Variable
	RulesEngineMatchVariable *RulesEngineMatchVariable `json:"rulesEngineMatchVariable,omitempty"`

	// REQUIRED; Describes operator to apply to the match condition.
	RulesEngineOperator *RulesEngineOperator `json:"rulesEngineOperator,omitempty"`

	// Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Name of selector in RequestHeader or RequestBody to be matched
	Selector *string `json:"selector,omitempty"`

	// List of transforms
	Transforms []*Transform `json:"transforms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RulesEngineMatchCondition.
func (r RulesEngineMatchCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "negateCondition", r.NegateCondition)
	populate(objectMap, "rulesEngineMatchValue", r.RulesEngineMatchValue)
	populate(objectMap, "rulesEngineMatchVariable", r.RulesEngineMatchVariable)
	populate(objectMap, "rulesEngineOperator", r.RulesEngineOperator)
	populate(objectMap, "selector", r.Selector)
	populate(objectMap, "transforms", r.Transforms)
	return json.Marshal(objectMap)
}

// RulesEngineProperties - The JSON object that contains the properties required to create a Rules Engine Configuration.
type RulesEngineProperties struct {
	RulesEngineUpdateParameters
	// READ-ONLY; Resource status.
	ResourceState *FrontDoorResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RulesEngineProperties.
func (r RulesEngineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RulesEngineUpdateParameters.marshalInternal(objectMap)
	populate(objectMap, "resourceState", r.ResourceState)
	return json.Marshal(objectMap)
}

// RulesEngineRule - Contains a list of match conditions, and an action on how to modify the request/response. If multiple rules match, the actions from
// one rule that conflict with a previous rule overwrite for a singular
// action, or append in the case of headers manipulation.
type RulesEngineRule struct {
	// REQUIRED; Actions to perform on the request and response if all of the match conditions are met.
	Action *RulesEngineAction `json:"action,omitempty"`

	// REQUIRED; A name to refer to this specific rule.
	Name *string `json:"name,omitempty"`

	// REQUIRED; A priority assigned to this rule.
	Priority *int32 `json:"priority,omitempty"`

	// A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run.
	MatchConditions []*RulesEngineMatchCondition `json:"matchConditions,omitempty"`

	// If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
	MatchProcessingBehavior *MatchProcessingBehavior `json:"matchProcessingBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RulesEngineRule.
func (r RulesEngineRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", r.Action)
	populate(objectMap, "matchConditions", r.MatchConditions)
	populate(objectMap, "matchProcessingBehavior", r.MatchProcessingBehavior)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "priority", r.Priority)
	return json.Marshal(objectMap)
}

// RulesEngineUpdateParameters - Rules Engine Configuration to apply to a Routing Rule.
type RulesEngineUpdateParameters struct {
	// A list of rules that define a particular Rules Engine Configuration.
	Rules []*RulesEngineRule `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RulesEngineUpdateParameters.
func (r RulesEngineUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r RulesEngineUpdateParameters) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "rules", r.Rules)
}

// RulesEnginesBeginCreateOrUpdateOptions contains the optional parameters for the RulesEngines.BeginCreateOrUpdate method.
type RulesEnginesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RulesEnginesBeginDeleteOptions contains the optional parameters for the RulesEngines.BeginDelete method.
type RulesEnginesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RulesEnginesGetOptions contains the optional parameters for the RulesEngines.Get method.
type RulesEnginesGetOptions struct {
	// placeholder for future optional parameters
}

// RulesEnginesListByFrontDoorOptions contains the optional parameters for the RulesEngines.ListByFrontDoor method.
type RulesEnginesListByFrontDoorOptions struct {
	// placeholder for future optional parameters
}

// SKU - The pricing tier of the web application firewall policy.
type SKU struct {
	// Name of the pricing tier.
	Name *SKUName `json:"name,omitempty"`
}

// SecurityPolicyLink - Defines the Resource ID for a Security Policy.
type SecurityPolicyLink struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// SubResource - Reference to another subresource.
type SubResource struct {
	// Resource ID.
	ID *string `json:"id,omitempty"`
}

// TagsObject - Tags object for patch operations.
type TagsObject struct {
	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TagsObject.
func (t TagsObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// Timeseries - Defines the Timeseries
type Timeseries struct {
	Resource
	// The properties of a Timeseries
	Properties *TimeseriesProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Timeseries.
func (t Timeseries) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// TimeseriesDataPoint - Defines a timeseries datapoint used in a timeseries
type TimeseriesDataPoint struct {
	// The DateTime of the Timeseries data point in UTC
	DateTimeUTC *string `json:"dateTimeUTC,omitempty"`

	// The Value of the Timeseries data point
	Value *float32 `json:"value,omitempty"`
}

// TimeseriesProperties - Defines the properties of a timeseries
type TimeseriesProperties struct {
	// The aggregation interval of the Timeseries
	AggregationInterval *AggregationInterval `json:"aggregationInterval,omitempty"`

	// The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html
	Country *string `json:"country,omitempty"`

	// The end DateTime of the Timeseries in UTC
	EndDateTimeUTC *string `json:"endDateTimeUTC,omitempty"`

	// The endpoint associated with the Timeseries data point
	Endpoint *string `json:"endpoint,omitempty"`

	// The start DateTime of the Timeseries in UTC
	StartDateTimeUTC *string `json:"startDateTimeUTC,omitempty"`

	// The set of data points for the timeseries
	TimeseriesData []*TimeseriesDataPoint `json:"timeseriesData,omitempty"`

	// The type of Timeseries
	TimeseriesType *TimeseriesType `json:"timeseriesType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TimeseriesProperties.
func (t TimeseriesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationInterval", t.AggregationInterval)
	populate(objectMap, "country", t.Country)
	populate(objectMap, "endDateTimeUTC", t.EndDateTimeUTC)
	populate(objectMap, "endpoint", t.Endpoint)
	populate(objectMap, "startDateTimeUTC", t.StartDateTimeUTC)
	populate(objectMap, "timeseriesData", t.TimeseriesData)
	populate(objectMap, "timeseriesType", t.TimeseriesType)
	return json.Marshal(objectMap)
}

// ValidateCustomDomainInput - Input of the custom domain to be validated for DNS mapping.
type ValidateCustomDomainInput struct {
	// REQUIRED; The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`
}

// ValidateCustomDomainOutput - Output of custom domain validation.
type ValidateCustomDomainOutput struct {
	// READ-ONLY; Indicates whether the custom domain is valid or not.
	CustomDomainValidated *bool `json:"customDomainValidated,omitempty" azure:"ro"`

	// READ-ONLY; Error message describing why the custom domain is not valid.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The reason why the custom domain is not valid.
	Reason *string `json:"reason,omitempty" azure:"ro"`
}

// WebApplicationFirewallPolicy - Defines web application firewall policy.
type WebApplicationFirewallPolicy struct {
	Resource
	// Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Properties of the web application firewall policy.
	Properties *WebApplicationFirewallPolicyProperties `json:"properties,omitempty"`

	// The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified.
	SKU *SKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebApplicationFirewallPolicy.
func (w WebApplicationFirewallPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", w.Etag)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "sku", w.SKU)
	return json.Marshal(objectMap)
}

// WebApplicationFirewallPolicyList - Defines a list of WebApplicationFirewallPolicies. It contains a list of WebApplicationFirewallPolicy objects and a
// URL link to get the next set of results.
type WebApplicationFirewallPolicyList struct {
	// URL to get the next set of WebApplicationFirewallPolicy objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; List of WebApplicationFirewallPolicies within a resource group.
	Value []*WebApplicationFirewallPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WebApplicationFirewallPolicyList.
func (w WebApplicationFirewallPolicyList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WebApplicationFirewallPolicyProperties - Defines web application firewall policy properties.
type WebApplicationFirewallPolicyProperties struct {
	// Describes custom rules inside the policy.
	CustomRules *CustomRuleList `json:"customRules,omitempty"`

	// Describes managed rules inside the policy.
	ManagedRules *ManagedRuleSetList `json:"managedRules,omitempty"`

	// Describes settings for the policy.
	PolicySettings *PolicySettings `json:"policySettings,omitempty"`

	// READ-ONLY; Describes Frontend Endpoints associated with this Web Application Firewall policy.
	FrontendEndpointLinks []*FrontendEndpointLink `json:"frontendEndpointLinks,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the policy.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Resource status of the policy.
	ResourceState *PolicyResourceState `json:"resourceState,omitempty" azure:"ro"`

	// READ-ONLY; Describes Routing Rules associated with this Web Application Firewall policy.
	RoutingRuleLinks []*RoutingRuleLink `json:"routingRuleLinks,omitempty" azure:"ro"`

	// READ-ONLY; Describes Security Policy associated with this Web Application Firewall policy.
	SecurityPolicyLinks []*SecurityPolicyLink `json:"securityPolicyLinks,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WebApplicationFirewallPolicyProperties.
func (w WebApplicationFirewallPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customRules", w.CustomRules)
	populate(objectMap, "frontendEndpointLinks", w.FrontendEndpointLinks)
	populate(objectMap, "managedRules", w.ManagedRules)
	populate(objectMap, "policySettings", w.PolicySettings)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "resourceState", w.ResourceState)
	populate(objectMap, "routingRuleLinks", w.RoutingRuleLinks)
	populate(objectMap, "securityPolicyLinks", w.SecurityPolicyLinks)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
