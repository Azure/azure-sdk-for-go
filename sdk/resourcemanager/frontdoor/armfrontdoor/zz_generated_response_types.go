//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armfrontdoor

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// EndpointsPurgeContentPollerResponse contains the response from method Endpoints.PurgeContent.
type EndpointsPurgeContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsPurgeContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsPurgeContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsPurgeContentResponse, error) {
	respType := EndpointsPurgeContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsPurgeContentPollerResponse from the provided client and resume token.
func (l *EndpointsPurgeContentPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.PurgeContent", token, client.pl, client.purgeContentHandleError)
	if err != nil {
		return err
	}
	poller := &EndpointsPurgeContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsPurgeContentResponse contains the response from method Endpoints.PurgeContent.
type EndpointsPurgeContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsCreateOrUpdatePollerResponse contains the response from method Experiments.CreateOrUpdate.
type ExperimentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExperimentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExperimentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExperimentsCreateOrUpdateResponse, error) {
	respType := ExperimentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Experiment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExperimentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExperimentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExperimentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExperimentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExperimentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExperimentsCreateOrUpdateResponse contains the response from method Experiments.CreateOrUpdate.
type ExperimentsCreateOrUpdateResponse struct {
	ExperimentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsCreateOrUpdateResult contains the result from method Experiments.CreateOrUpdate.
type ExperimentsCreateOrUpdateResult struct {
	Experiment
}

// ExperimentsDeletePollerResponse contains the response from method Experiments.Delete.
type ExperimentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExperimentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExperimentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExperimentsDeleteResponse, error) {
	respType := ExperimentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExperimentsDeletePollerResponse from the provided client and resume token.
func (l *ExperimentsDeletePollerResponse) Resume(ctx context.Context, client *ExperimentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExperimentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExperimentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExperimentsDeleteResponse contains the response from method Experiments.Delete.
type ExperimentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsGetResponse contains the response from method Experiments.Get.
type ExperimentsGetResponse struct {
	ExperimentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsGetResult contains the result from method Experiments.Get.
type ExperimentsGetResult struct {
	Experiment
}

// ExperimentsListByProfileResponse contains the response from method Experiments.ListByProfile.
type ExperimentsListByProfileResponse struct {
	ExperimentsListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsListByProfileResult contains the result from method Experiments.ListByProfile.
type ExperimentsListByProfileResult struct {
	ExperimentList
}

// ExperimentsUpdatePollerResponse contains the response from method Experiments.Update.
type ExperimentsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExperimentsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExperimentsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExperimentsUpdateResponse, error) {
	respType := ExperimentsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Experiment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExperimentsUpdatePollerResponse from the provided client and resume token.
func (l *ExperimentsUpdatePollerResponse) Resume(ctx context.Context, client *ExperimentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExperimentsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ExperimentsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExperimentsUpdateResponse contains the response from method Experiments.Update.
type ExperimentsUpdateResponse struct {
	ExperimentsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsUpdateResult contains the result from method Experiments.Update.
type ExperimentsUpdateResult struct {
	Experiment
}

// FrontDoorNameAvailabilityCheckResponse contains the response from method FrontDoorNameAvailability.Check.
type FrontDoorNameAvailabilityCheckResponse struct {
	FrontDoorNameAvailabilityCheckResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorNameAvailabilityCheckResult contains the result from method FrontDoorNameAvailability.Check.
type FrontDoorNameAvailabilityCheckResult struct {
	CheckNameAvailabilityOutput
}

// FrontDoorNameAvailabilityWithSubscriptionCheckResponse contains the response from method FrontDoorNameAvailabilityWithSubscription.Check.
type FrontDoorNameAvailabilityWithSubscriptionCheckResponse struct {
	FrontDoorNameAvailabilityWithSubscriptionCheckResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorNameAvailabilityWithSubscriptionCheckResult contains the result from method FrontDoorNameAvailabilityWithSubscription.Check.
type FrontDoorNameAvailabilityWithSubscriptionCheckResult struct {
	CheckNameAvailabilityOutput
}

// FrontDoorsCreateOrUpdatePollerResponse contains the response from method FrontDoors.CreateOrUpdate.
type FrontDoorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontDoorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontDoorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontDoorsCreateOrUpdateResponse, error) {
	respType := FrontDoorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FrontDoor)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontDoorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FrontDoorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FrontDoorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontDoorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FrontDoorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontDoorsCreateOrUpdateResponse contains the response from method FrontDoors.CreateOrUpdate.
type FrontDoorsCreateOrUpdateResponse struct {
	FrontDoorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsCreateOrUpdateResult contains the result from method FrontDoors.CreateOrUpdate.
type FrontDoorsCreateOrUpdateResult struct {
	FrontDoor
}

// FrontDoorsDeletePollerResponse contains the response from method FrontDoors.Delete.
type FrontDoorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontDoorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontDoorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontDoorsDeleteResponse, error) {
	respType := FrontDoorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontDoorsDeletePollerResponse from the provided client and resume token.
func (l *FrontDoorsDeletePollerResponse) Resume(ctx context.Context, client *FrontDoorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontDoorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FrontDoorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontDoorsDeleteResponse contains the response from method FrontDoors.Delete.
type FrontDoorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsGetResponse contains the response from method FrontDoors.Get.
type FrontDoorsGetResponse struct {
	FrontDoorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsGetResult contains the result from method FrontDoors.Get.
type FrontDoorsGetResult struct {
	FrontDoor
}

// FrontDoorsListByResourceGroupResponse contains the response from method FrontDoors.ListByResourceGroup.
type FrontDoorsListByResourceGroupResponse struct {
	FrontDoorsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsListByResourceGroupResult contains the result from method FrontDoors.ListByResourceGroup.
type FrontDoorsListByResourceGroupResult struct {
	FrontDoorListResult
}

// FrontDoorsListResponse contains the response from method FrontDoors.List.
type FrontDoorsListResponse struct {
	FrontDoorsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsListResult contains the result from method FrontDoors.List.
type FrontDoorsListResult struct {
	FrontDoorListResult
}

// FrontDoorsValidateCustomDomainResponse contains the response from method FrontDoors.ValidateCustomDomain.
type FrontDoorsValidateCustomDomainResponse struct {
	FrontDoorsValidateCustomDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsValidateCustomDomainResult contains the result from method FrontDoors.ValidateCustomDomain.
type FrontDoorsValidateCustomDomainResult struct {
	ValidateCustomDomainOutput
}

// FrontendEndpointsDisableHTTPSPollerResponse contains the response from method FrontendEndpoints.DisableHTTPS.
type FrontendEndpointsDisableHTTPSPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontendEndpointsDisableHTTPSPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontendEndpointsDisableHTTPSPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontendEndpointsDisableHTTPSResponse, error) {
	respType := FrontendEndpointsDisableHTTPSResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontendEndpointsDisableHTTPSPollerResponse from the provided client and resume token.
func (l *FrontendEndpointsDisableHTTPSPollerResponse) Resume(ctx context.Context, client *FrontendEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontendEndpointsClient.DisableHTTPS", token, client.pl, client.disableHTTPSHandleError)
	if err != nil {
		return err
	}
	poller := &FrontendEndpointsDisableHTTPSPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontendEndpointsDisableHTTPSResponse contains the response from method FrontendEndpoints.DisableHTTPS.
type FrontendEndpointsDisableHTTPSResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsEnableHTTPSPollerResponse contains the response from method FrontendEndpoints.EnableHTTPS.
type FrontendEndpointsEnableHTTPSPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontendEndpointsEnableHTTPSPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontendEndpointsEnableHTTPSPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontendEndpointsEnableHTTPSResponse, error) {
	respType := FrontendEndpointsEnableHTTPSResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontendEndpointsEnableHTTPSPollerResponse from the provided client and resume token.
func (l *FrontendEndpointsEnableHTTPSPollerResponse) Resume(ctx context.Context, client *FrontendEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontendEndpointsClient.EnableHTTPS", token, client.pl, client.enableHTTPSHandleError)
	if err != nil {
		return err
	}
	poller := &FrontendEndpointsEnableHTTPSPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontendEndpointsEnableHTTPSResponse contains the response from method FrontendEndpoints.EnableHTTPS.
type FrontendEndpointsEnableHTTPSResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsGetResponse contains the response from method FrontendEndpoints.Get.
type FrontendEndpointsGetResponse struct {
	FrontendEndpointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsGetResult contains the result from method FrontendEndpoints.Get.
type FrontendEndpointsGetResult struct {
	FrontendEndpoint
}

// FrontendEndpointsListByFrontDoorResponse contains the response from method FrontendEndpoints.ListByFrontDoor.
type FrontendEndpointsListByFrontDoorResponse struct {
	FrontendEndpointsListByFrontDoorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsListByFrontDoorResult contains the result from method FrontendEndpoints.ListByFrontDoor.
type FrontendEndpointsListByFrontDoorResult struct {
	FrontendEndpointsListResult
}

// ManagedRuleSetsListResponse contains the response from method ManagedRuleSets.List.
type ManagedRuleSetsListResponse struct {
	ManagedRuleSetsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRuleSetsListResult contains the result from method ManagedRuleSets.List.
type ManagedRuleSetsListResult struct {
	ManagedRuleSetDefinitionList
}

// NetworkExperimentProfilesCreateOrUpdatePollerResponse contains the response from method NetworkExperimentProfiles.CreateOrUpdate.
type NetworkExperimentProfilesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkExperimentProfilesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkExperimentProfilesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkExperimentProfilesCreateOrUpdateResponse, error) {
	respType := NetworkExperimentProfilesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkExperimentProfilesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkExperimentProfilesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkExperimentProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkExperimentProfilesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkExperimentProfilesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkExperimentProfilesCreateOrUpdateResponse contains the response from method NetworkExperimentProfiles.CreateOrUpdate.
type NetworkExperimentProfilesCreateOrUpdateResponse struct {
	NetworkExperimentProfilesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesCreateOrUpdateResult contains the result from method NetworkExperimentProfiles.CreateOrUpdate.
type NetworkExperimentProfilesCreateOrUpdateResult struct {
	Profile
}

// NetworkExperimentProfilesDeletePollerResponse contains the response from method NetworkExperimentProfiles.Delete.
type NetworkExperimentProfilesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkExperimentProfilesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkExperimentProfilesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkExperimentProfilesDeleteResponse, error) {
	respType := NetworkExperimentProfilesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkExperimentProfilesDeletePollerResponse from the provided client and resume token.
func (l *NetworkExperimentProfilesDeletePollerResponse) Resume(ctx context.Context, client *NetworkExperimentProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkExperimentProfilesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkExperimentProfilesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkExperimentProfilesDeleteResponse contains the response from method NetworkExperimentProfiles.Delete.
type NetworkExperimentProfilesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesGetResponse contains the response from method NetworkExperimentProfiles.Get.
type NetworkExperimentProfilesGetResponse struct {
	NetworkExperimentProfilesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesGetResult contains the result from method NetworkExperimentProfiles.Get.
type NetworkExperimentProfilesGetResult struct {
	Profile
}

// NetworkExperimentProfilesListByResourceGroupResponse contains the response from method NetworkExperimentProfiles.ListByResourceGroup.
type NetworkExperimentProfilesListByResourceGroupResponse struct {
	NetworkExperimentProfilesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesListByResourceGroupResult contains the result from method NetworkExperimentProfiles.ListByResourceGroup.
type NetworkExperimentProfilesListByResourceGroupResult struct {
	ProfileList
}

// NetworkExperimentProfilesListResponse contains the response from method NetworkExperimentProfiles.List.
type NetworkExperimentProfilesListResponse struct {
	NetworkExperimentProfilesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesListResult contains the result from method NetworkExperimentProfiles.List.
type NetworkExperimentProfilesListResult struct {
	ProfileList
}

// NetworkExperimentProfilesUpdatePollerResponse contains the response from method NetworkExperimentProfiles.Update.
type NetworkExperimentProfilesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkExperimentProfilesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkExperimentProfilesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkExperimentProfilesUpdateResponse, error) {
	respType := NetworkExperimentProfilesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkExperimentProfilesUpdatePollerResponse from the provided client and resume token.
func (l *NetworkExperimentProfilesUpdatePollerResponse) Resume(ctx context.Context, client *NetworkExperimentProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkExperimentProfilesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkExperimentProfilesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkExperimentProfilesUpdateResponse contains the response from method NetworkExperimentProfiles.Update.
type NetworkExperimentProfilesUpdateResponse struct {
	NetworkExperimentProfilesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesUpdateResult contains the result from method NetworkExperimentProfiles.Update.
type NetworkExperimentProfilesUpdateResult struct {
	Profile
}

// PoliciesCreateOrUpdatePollerResponse contains the response from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesCreateOrUpdateResponse, error) {
	respType := PoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WebApplicationFirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesCreateOrUpdateResponse contains the response from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdateResponse struct {
	PoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesCreateOrUpdateResult contains the result from method Policies.CreateOrUpdate.
type PoliciesCreateOrUpdateResult struct {
	WebApplicationFirewallPolicy
}

// PoliciesDeletePollerResponse contains the response from method Policies.Delete.
type PoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesDeleteResponse, error) {
	respType := PoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesDeletePollerResponse from the provided client and resume token.
func (l *PoliciesDeletePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesDeleteResponse contains the response from method Policies.Delete.
type PoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesGetResponse contains the response from method Policies.Get.
type PoliciesGetResponse struct {
	PoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesGetResult contains the result from method Policies.Get.
type PoliciesGetResult struct {
	WebApplicationFirewallPolicy
}

// PoliciesListResponse contains the response from method Policies.List.
type PoliciesListResponse struct {
	PoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesListResult contains the result from method Policies.List.
type PoliciesListResult struct {
	WebApplicationFirewallPolicyList
}

// PreconfiguredEndpointsListResponse contains the response from method PreconfiguredEndpoints.List.
type PreconfiguredEndpointsListResponse struct {
	PreconfiguredEndpointsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PreconfiguredEndpointsListResult contains the result from method PreconfiguredEndpoints.List.
type PreconfiguredEndpointsListResult struct {
	PreconfiguredEndpointList
}

// ReportsGetLatencyScorecardsResponse contains the response from method Reports.GetLatencyScorecards.
type ReportsGetLatencyScorecardsResponse struct {
	ReportsGetLatencyScorecardsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReportsGetLatencyScorecardsResult contains the result from method Reports.GetLatencyScorecards.
type ReportsGetLatencyScorecardsResult struct {
	LatencyScorecard
}

// ReportsGetTimeseriesResponse contains the response from method Reports.GetTimeseries.
type ReportsGetTimeseriesResponse struct {
	ReportsGetTimeseriesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReportsGetTimeseriesResult contains the result from method Reports.GetTimeseries.
type ReportsGetTimeseriesResult struct {
	Timeseries
}

// RulesEnginesCreateOrUpdatePollerResponse contains the response from method RulesEngines.CreateOrUpdate.
type RulesEnginesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesEnginesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesEnginesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesEnginesCreateOrUpdateResponse, error) {
	respType := RulesEnginesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RulesEngine)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesEnginesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RulesEnginesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RulesEnginesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesEnginesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RulesEnginesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesEnginesCreateOrUpdateResponse contains the response from method RulesEngines.CreateOrUpdate.
type RulesEnginesCreateOrUpdateResponse struct {
	RulesEnginesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesCreateOrUpdateResult contains the result from method RulesEngines.CreateOrUpdate.
type RulesEnginesCreateOrUpdateResult struct {
	RulesEngine
}

// RulesEnginesDeletePollerResponse contains the response from method RulesEngines.Delete.
type RulesEnginesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesEnginesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesEnginesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesEnginesDeleteResponse, error) {
	respType := RulesEnginesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesEnginesDeletePollerResponse from the provided client and resume token.
func (l *RulesEnginesDeletePollerResponse) Resume(ctx context.Context, client *RulesEnginesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesEnginesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RulesEnginesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesEnginesDeleteResponse contains the response from method RulesEngines.Delete.
type RulesEnginesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesGetResponse contains the response from method RulesEngines.Get.
type RulesEnginesGetResponse struct {
	RulesEnginesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesGetResult contains the result from method RulesEngines.Get.
type RulesEnginesGetResult struct {
	RulesEngine
}

// RulesEnginesListByFrontDoorResponse contains the response from method RulesEngines.ListByFrontDoor.
type RulesEnginesListByFrontDoorResponse struct {
	RulesEnginesListByFrontDoorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesListByFrontDoorResult contains the result from method RulesEngines.ListByFrontDoor.
type RulesEnginesListByFrontDoorResult struct {
	RulesEngineListResult
}
