//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armfrontdoor

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// EndpointsClientPurgeContentPollerResponse contains the response from method EndpointsClient.PurgeContent.
type EndpointsClientPurgeContentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EndpointsClientPurgeContentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EndpointsClientPurgeContentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EndpointsClientPurgeContentResponse, error) {
	respType := EndpointsClientPurgeContentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EndpointsClientPurgeContentPollerResponse from the provided client and resume token.
func (l *EndpointsClientPurgeContentPollerResponse) Resume(ctx context.Context, client *EndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EndpointsClient.PurgeContent", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EndpointsClientPurgeContentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EndpointsClientPurgeContentResponse contains the response from method EndpointsClient.PurgeContent.
type EndpointsClientPurgeContentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsClientCreateOrUpdatePollerResponse contains the response from method ExperimentsClient.CreateOrUpdate.
type ExperimentsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExperimentsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExperimentsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExperimentsClientCreateOrUpdateResponse, error) {
	respType := ExperimentsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Experiment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExperimentsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExperimentsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExperimentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExperimentsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExperimentsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExperimentsClientCreateOrUpdateResponse contains the response from method ExperimentsClient.CreateOrUpdate.
type ExperimentsClientCreateOrUpdateResponse struct {
	ExperimentsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsClientCreateOrUpdateResult contains the result from method ExperimentsClient.CreateOrUpdate.
type ExperimentsClientCreateOrUpdateResult struct {
	Experiment
}

// ExperimentsClientDeletePollerResponse contains the response from method ExperimentsClient.Delete.
type ExperimentsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExperimentsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExperimentsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExperimentsClientDeleteResponse, error) {
	respType := ExperimentsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExperimentsClientDeletePollerResponse from the provided client and resume token.
func (l *ExperimentsClientDeletePollerResponse) Resume(ctx context.Context, client *ExperimentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExperimentsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExperimentsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExperimentsClientDeleteResponse contains the response from method ExperimentsClient.Delete.
type ExperimentsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsClientGetResponse contains the response from method ExperimentsClient.Get.
type ExperimentsClientGetResponse struct {
	ExperimentsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsClientGetResult contains the result from method ExperimentsClient.Get.
type ExperimentsClientGetResult struct {
	Experiment
}

// ExperimentsClientListByProfileResponse contains the response from method ExperimentsClient.ListByProfile.
type ExperimentsClientListByProfileResponse struct {
	ExperimentsClientListByProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsClientListByProfileResult contains the result from method ExperimentsClient.ListByProfile.
type ExperimentsClientListByProfileResult struct {
	ExperimentList
}

// ExperimentsClientUpdatePollerResponse contains the response from method ExperimentsClient.Update.
type ExperimentsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExperimentsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExperimentsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExperimentsClientUpdateResponse, error) {
	respType := ExperimentsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Experiment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExperimentsClientUpdatePollerResponse from the provided client and resume token.
func (l *ExperimentsClientUpdatePollerResponse) Resume(ctx context.Context, client *ExperimentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExperimentsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExperimentsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExperimentsClientUpdateResponse contains the response from method ExperimentsClient.Update.
type ExperimentsClientUpdateResponse struct {
	ExperimentsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExperimentsClientUpdateResult contains the result from method ExperimentsClient.Update.
type ExperimentsClientUpdateResult struct {
	Experiment
}

// FrontDoorsClientCreateOrUpdatePollerResponse contains the response from method FrontDoorsClient.CreateOrUpdate.
type FrontDoorsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontDoorsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontDoorsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontDoorsClientCreateOrUpdateResponse, error) {
	respType := FrontDoorsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FrontDoor)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontDoorsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FrontDoorsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FrontDoorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontDoorsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FrontDoorsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontDoorsClientCreateOrUpdateResponse contains the response from method FrontDoorsClient.CreateOrUpdate.
type FrontDoorsClientCreateOrUpdateResponse struct {
	FrontDoorsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsClientCreateOrUpdateResult contains the result from method FrontDoorsClient.CreateOrUpdate.
type FrontDoorsClientCreateOrUpdateResult struct {
	FrontDoor
}

// FrontDoorsClientDeletePollerResponse contains the response from method FrontDoorsClient.Delete.
type FrontDoorsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontDoorsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontDoorsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontDoorsClientDeleteResponse, error) {
	respType := FrontDoorsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontDoorsClientDeletePollerResponse from the provided client and resume token.
func (l *FrontDoorsClientDeletePollerResponse) Resume(ctx context.Context, client *FrontDoorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontDoorsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FrontDoorsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontDoorsClientDeleteResponse contains the response from method FrontDoorsClient.Delete.
type FrontDoorsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsClientGetResponse contains the response from method FrontDoorsClient.Get.
type FrontDoorsClientGetResponse struct {
	FrontDoorsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsClientGetResult contains the result from method FrontDoorsClient.Get.
type FrontDoorsClientGetResult struct {
	FrontDoor
}

// FrontDoorsClientListByResourceGroupResponse contains the response from method FrontDoorsClient.ListByResourceGroup.
type FrontDoorsClientListByResourceGroupResponse struct {
	FrontDoorsClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsClientListByResourceGroupResult contains the result from method FrontDoorsClient.ListByResourceGroup.
type FrontDoorsClientListByResourceGroupResult struct {
	ListResult
}

// FrontDoorsClientListResponse contains the response from method FrontDoorsClient.List.
type FrontDoorsClientListResponse struct {
	FrontDoorsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsClientListResult contains the result from method FrontDoorsClient.List.
type FrontDoorsClientListResult struct {
	ListResult
}

// FrontDoorsClientValidateCustomDomainResponse contains the response from method FrontDoorsClient.ValidateCustomDomain.
type FrontDoorsClientValidateCustomDomainResponse struct {
	FrontDoorsClientValidateCustomDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontDoorsClientValidateCustomDomainResult contains the result from method FrontDoorsClient.ValidateCustomDomain.
type FrontDoorsClientValidateCustomDomainResult struct {
	ValidateCustomDomainOutput
}

// FrontendEndpointsClientDisableHTTPSPollerResponse contains the response from method FrontendEndpointsClient.DisableHTTPS.
type FrontendEndpointsClientDisableHTTPSPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontendEndpointsClientDisableHTTPSPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontendEndpointsClientDisableHTTPSPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontendEndpointsClientDisableHTTPSResponse, error) {
	respType := FrontendEndpointsClientDisableHTTPSResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontendEndpointsClientDisableHTTPSPollerResponse from the provided client and resume token.
func (l *FrontendEndpointsClientDisableHTTPSPollerResponse) Resume(ctx context.Context, client *FrontendEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontendEndpointsClient.DisableHTTPS", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FrontendEndpointsClientDisableHTTPSPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontendEndpointsClientDisableHTTPSResponse contains the response from method FrontendEndpointsClient.DisableHTTPS.
type FrontendEndpointsClientDisableHTTPSResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsClientEnableHTTPSPollerResponse contains the response from method FrontendEndpointsClient.EnableHTTPS.
type FrontendEndpointsClientEnableHTTPSPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FrontendEndpointsClientEnableHTTPSPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FrontendEndpointsClientEnableHTTPSPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FrontendEndpointsClientEnableHTTPSResponse, error) {
	respType := FrontendEndpointsClientEnableHTTPSResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FrontendEndpointsClientEnableHTTPSPollerResponse from the provided client and resume token.
func (l *FrontendEndpointsClientEnableHTTPSPollerResponse) Resume(ctx context.Context, client *FrontendEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FrontendEndpointsClient.EnableHTTPS", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FrontendEndpointsClientEnableHTTPSPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FrontendEndpointsClientEnableHTTPSResponse contains the response from method FrontendEndpointsClient.EnableHTTPS.
type FrontendEndpointsClientEnableHTTPSResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsClientGetResponse contains the response from method FrontendEndpointsClient.Get.
type FrontendEndpointsClientGetResponse struct {
	FrontendEndpointsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsClientGetResult contains the result from method FrontendEndpointsClient.Get.
type FrontendEndpointsClientGetResult struct {
	FrontendEndpoint
}

// FrontendEndpointsClientListByFrontDoorResponse contains the response from method FrontendEndpointsClient.ListByFrontDoor.
type FrontendEndpointsClientListByFrontDoorResponse struct {
	FrontendEndpointsClientListByFrontDoorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FrontendEndpointsClientListByFrontDoorResult contains the result from method FrontendEndpointsClient.ListByFrontDoor.
type FrontendEndpointsClientListByFrontDoorResult struct {
	FrontendEndpointsListResult
}

// ManagedRuleSetsClientListResponse contains the response from method ManagedRuleSetsClient.List.
type ManagedRuleSetsClientListResponse struct {
	ManagedRuleSetsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRuleSetsClientListResult contains the result from method ManagedRuleSetsClient.List.
type ManagedRuleSetsClientListResult struct {
	ManagedRuleSetDefinitionList
}

// NameAvailabilityClientCheckResponse contains the response from method NameAvailabilityClient.Check.
type NameAvailabilityClientCheckResponse struct {
	NameAvailabilityClientCheckResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NameAvailabilityClientCheckResult contains the result from method NameAvailabilityClient.Check.
type NameAvailabilityClientCheckResult struct {
	CheckNameAvailabilityOutput
}

// NameAvailabilityWithSubscriptionClientCheckResponse contains the response from method NameAvailabilityWithSubscriptionClient.Check.
type NameAvailabilityWithSubscriptionClientCheckResponse struct {
	NameAvailabilityWithSubscriptionClientCheckResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NameAvailabilityWithSubscriptionClientCheckResult contains the result from method NameAvailabilityWithSubscriptionClient.Check.
type NameAvailabilityWithSubscriptionClientCheckResult struct {
	CheckNameAvailabilityOutput
}

// NetworkExperimentProfilesClientCreateOrUpdatePollerResponse contains the response from method NetworkExperimentProfilesClient.CreateOrUpdate.
type NetworkExperimentProfilesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkExperimentProfilesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkExperimentProfilesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkExperimentProfilesClientCreateOrUpdateResponse, error) {
	respType := NetworkExperimentProfilesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkExperimentProfilesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkExperimentProfilesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkExperimentProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkExperimentProfilesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NetworkExperimentProfilesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkExperimentProfilesClientCreateOrUpdateResponse contains the response from method NetworkExperimentProfilesClient.CreateOrUpdate.
type NetworkExperimentProfilesClientCreateOrUpdateResponse struct {
	NetworkExperimentProfilesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesClientCreateOrUpdateResult contains the result from method NetworkExperimentProfilesClient.CreateOrUpdate.
type NetworkExperimentProfilesClientCreateOrUpdateResult struct {
	Profile
}

// NetworkExperimentProfilesClientDeletePollerResponse contains the response from method NetworkExperimentProfilesClient.Delete.
type NetworkExperimentProfilesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkExperimentProfilesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkExperimentProfilesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkExperimentProfilesClientDeleteResponse, error) {
	respType := NetworkExperimentProfilesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkExperimentProfilesClientDeletePollerResponse from the provided client and resume token.
func (l *NetworkExperimentProfilesClientDeletePollerResponse) Resume(ctx context.Context, client *NetworkExperimentProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkExperimentProfilesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NetworkExperimentProfilesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkExperimentProfilesClientDeleteResponse contains the response from method NetworkExperimentProfilesClient.Delete.
type NetworkExperimentProfilesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesClientGetResponse contains the response from method NetworkExperimentProfilesClient.Get.
type NetworkExperimentProfilesClientGetResponse struct {
	NetworkExperimentProfilesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesClientGetResult contains the result from method NetworkExperimentProfilesClient.Get.
type NetworkExperimentProfilesClientGetResult struct {
	Profile
}

// NetworkExperimentProfilesClientListByResourceGroupResponse contains the response from method NetworkExperimentProfilesClient.ListByResourceGroup.
type NetworkExperimentProfilesClientListByResourceGroupResponse struct {
	NetworkExperimentProfilesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesClientListByResourceGroupResult contains the result from method NetworkExperimentProfilesClient.ListByResourceGroup.
type NetworkExperimentProfilesClientListByResourceGroupResult struct {
	ProfileList
}

// NetworkExperimentProfilesClientListResponse contains the response from method NetworkExperimentProfilesClient.List.
type NetworkExperimentProfilesClientListResponse struct {
	NetworkExperimentProfilesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesClientListResult contains the result from method NetworkExperimentProfilesClient.List.
type NetworkExperimentProfilesClientListResult struct {
	ProfileList
}

// NetworkExperimentProfilesClientUpdatePollerResponse contains the response from method NetworkExperimentProfilesClient.Update.
type NetworkExperimentProfilesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkExperimentProfilesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkExperimentProfilesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkExperimentProfilesClientUpdateResponse, error) {
	respType := NetworkExperimentProfilesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkExperimentProfilesClientUpdatePollerResponse from the provided client and resume token.
func (l *NetworkExperimentProfilesClientUpdatePollerResponse) Resume(ctx context.Context, client *NetworkExperimentProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkExperimentProfilesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NetworkExperimentProfilesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkExperimentProfilesClientUpdateResponse contains the response from method NetworkExperimentProfilesClient.Update.
type NetworkExperimentProfilesClientUpdateResponse struct {
	NetworkExperimentProfilesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkExperimentProfilesClientUpdateResult contains the result from method NetworkExperimentProfilesClient.Update.
type NetworkExperimentProfilesClientUpdateResult struct {
	Profile
}

// PoliciesClientCreateOrUpdatePollerResponse contains the response from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesClientCreateOrUpdateResponse, error) {
	respType := PoliciesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WebApplicationFirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PoliciesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PoliciesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesClientCreateOrUpdateResponse contains the response from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdateResponse struct {
	PoliciesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientCreateOrUpdateResult contains the result from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdateResult struct {
	WebApplicationFirewallPolicy
}

// PoliciesClientDeletePollerResponse contains the response from method PoliciesClient.Delete.
type PoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoliciesClientDeleteResponse, error) {
	respType := PoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *PoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *PoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoliciesClientDeleteResponse contains the response from method PoliciesClient.Delete.
type PoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientGetResponse contains the response from method PoliciesClient.Get.
type PoliciesClientGetResponse struct {
	PoliciesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientGetResult contains the result from method PoliciesClient.Get.
type PoliciesClientGetResult struct {
	WebApplicationFirewallPolicy
}

// PoliciesClientListResponse contains the response from method PoliciesClient.List.
type PoliciesClientListResponse struct {
	PoliciesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoliciesClientListResult contains the result from method PoliciesClient.List.
type PoliciesClientListResult struct {
	WebApplicationFirewallPolicyList
}

// PreconfiguredEndpointsClientListResponse contains the response from method PreconfiguredEndpointsClient.List.
type PreconfiguredEndpointsClientListResponse struct {
	PreconfiguredEndpointsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PreconfiguredEndpointsClientListResult contains the result from method PreconfiguredEndpointsClient.List.
type PreconfiguredEndpointsClientListResult struct {
	PreconfiguredEndpointList
}

// ReportsClientGetLatencyScorecardsResponse contains the response from method ReportsClient.GetLatencyScorecards.
type ReportsClientGetLatencyScorecardsResponse struct {
	ReportsClientGetLatencyScorecardsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReportsClientGetLatencyScorecardsResult contains the result from method ReportsClient.GetLatencyScorecards.
type ReportsClientGetLatencyScorecardsResult struct {
	LatencyScorecard
}

// ReportsClientGetTimeseriesResponse contains the response from method ReportsClient.GetTimeseries.
type ReportsClientGetTimeseriesResponse struct {
	ReportsClientGetTimeseriesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReportsClientGetTimeseriesResult contains the result from method ReportsClient.GetTimeseries.
type ReportsClientGetTimeseriesResult struct {
	Timeseries
}

// RulesEnginesClientCreateOrUpdatePollerResponse contains the response from method RulesEnginesClient.CreateOrUpdate.
type RulesEnginesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesEnginesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesEnginesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesEnginesClientCreateOrUpdateResponse, error) {
	respType := RulesEnginesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RulesEngine)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesEnginesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RulesEnginesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RulesEnginesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesEnginesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RulesEnginesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesEnginesClientCreateOrUpdateResponse contains the response from method RulesEnginesClient.CreateOrUpdate.
type RulesEnginesClientCreateOrUpdateResponse struct {
	RulesEnginesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesClientCreateOrUpdateResult contains the result from method RulesEnginesClient.CreateOrUpdate.
type RulesEnginesClientCreateOrUpdateResult struct {
	RulesEngine
}

// RulesEnginesClientDeletePollerResponse contains the response from method RulesEnginesClient.Delete.
type RulesEnginesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RulesEnginesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RulesEnginesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RulesEnginesClientDeleteResponse, error) {
	respType := RulesEnginesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RulesEnginesClientDeletePollerResponse from the provided client and resume token.
func (l *RulesEnginesClientDeletePollerResponse) Resume(ctx context.Context, client *RulesEnginesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RulesEnginesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RulesEnginesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RulesEnginesClientDeleteResponse contains the response from method RulesEnginesClient.Delete.
type RulesEnginesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesClientGetResponse contains the response from method RulesEnginesClient.Get.
type RulesEnginesClientGetResponse struct {
	RulesEnginesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesClientGetResult contains the result from method RulesEnginesClient.Get.
type RulesEnginesClientGetResult struct {
	RulesEngine
}

// RulesEnginesClientListByFrontDoorResponse contains the response from method RulesEnginesClient.ListByFrontDoor.
type RulesEnginesClientListByFrontDoorResponse struct {
	RulesEnginesClientListByFrontDoorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RulesEnginesClientListByFrontDoorResult contains the result from method RulesEnginesClient.ListByFrontDoor.
type RulesEnginesClientListByFrontDoorResult struct {
	RulesEngineListResult
}
