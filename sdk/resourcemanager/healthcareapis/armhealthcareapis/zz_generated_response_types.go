//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armhealthcareapis

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DicomServicesCreateOrUpdatePollerResponse contains the response from method DicomServices.CreateOrUpdate.
type DicomServicesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DicomServicesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DicomServicesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DicomServicesCreateOrUpdateResponse, error) {
	respType := DicomServicesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DicomService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DicomServicesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DicomServicesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DicomServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DicomServicesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DicomServicesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DicomServicesCreateOrUpdateResponse contains the response from method DicomServices.CreateOrUpdate.
type DicomServicesCreateOrUpdateResponse struct {
	DicomServicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesCreateOrUpdateResult contains the result from method DicomServices.CreateOrUpdate.
type DicomServicesCreateOrUpdateResult struct {
	DicomService
}

// DicomServicesDeletePollerResponse contains the response from method DicomServices.Delete.
type DicomServicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DicomServicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DicomServicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DicomServicesDeleteResponse, error) {
	respType := DicomServicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DicomServicesDeletePollerResponse from the provided client and resume token.
func (l *DicomServicesDeletePollerResponse) Resume(ctx context.Context, client *DicomServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DicomServicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DicomServicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DicomServicesDeleteResponse contains the response from method DicomServices.Delete.
type DicomServicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesGetResponse contains the response from method DicomServices.Get.
type DicomServicesGetResponse struct {
	DicomServicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesGetResult contains the result from method DicomServices.Get.
type DicomServicesGetResult struct {
	DicomService
}

// DicomServicesListByWorkspaceResponse contains the response from method DicomServices.ListByWorkspace.
type DicomServicesListByWorkspaceResponse struct {
	DicomServicesListByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesListByWorkspaceResult contains the result from method DicomServices.ListByWorkspace.
type DicomServicesListByWorkspaceResult struct {
	DicomServiceCollection
}

// DicomServicesUpdatePollerResponse contains the response from method DicomServices.Update.
type DicomServicesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DicomServicesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DicomServicesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DicomServicesUpdateResponse, error) {
	respType := DicomServicesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DicomService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DicomServicesUpdatePollerResponse from the provided client and resume token.
func (l *DicomServicesUpdatePollerResponse) Resume(ctx context.Context, client *DicomServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DicomServicesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &DicomServicesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DicomServicesUpdateResponse contains the response from method DicomServices.Update.
type DicomServicesUpdateResponse struct {
	DicomServicesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesUpdateResult contains the result from method DicomServices.Update.
type DicomServicesUpdateResult struct {
	DicomService
}

// FhirDestinationsListByIotConnectorResponse contains the response from method FhirDestinations.ListByIotConnector.
type FhirDestinationsListByIotConnectorResponse struct {
	FhirDestinationsListByIotConnectorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirDestinationsListByIotConnectorResult contains the result from method FhirDestinations.ListByIotConnector.
type FhirDestinationsListByIotConnectorResult struct {
	IotFhirDestinationCollection
}

// FhirServicesCreateOrUpdatePollerResponse contains the response from method FhirServices.CreateOrUpdate.
type FhirServicesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FhirServicesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FhirServicesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FhirServicesCreateOrUpdateResponse, error) {
	respType := FhirServicesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FhirService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FhirServicesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FhirServicesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FhirServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FhirServicesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FhirServicesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FhirServicesCreateOrUpdateResponse contains the response from method FhirServices.CreateOrUpdate.
type FhirServicesCreateOrUpdateResponse struct {
	FhirServicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesCreateOrUpdateResult contains the result from method FhirServices.CreateOrUpdate.
type FhirServicesCreateOrUpdateResult struct {
	FhirService
}

// FhirServicesDeletePollerResponse contains the response from method FhirServices.Delete.
type FhirServicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FhirServicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FhirServicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FhirServicesDeleteResponse, error) {
	respType := FhirServicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FhirServicesDeletePollerResponse from the provided client and resume token.
func (l *FhirServicesDeletePollerResponse) Resume(ctx context.Context, client *FhirServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FhirServicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FhirServicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FhirServicesDeleteResponse contains the response from method FhirServices.Delete.
type FhirServicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesGetResponse contains the response from method FhirServices.Get.
type FhirServicesGetResponse struct {
	FhirServicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesGetResult contains the result from method FhirServices.Get.
type FhirServicesGetResult struct {
	FhirService
}

// FhirServicesListByWorkspaceResponse contains the response from method FhirServices.ListByWorkspace.
type FhirServicesListByWorkspaceResponse struct {
	FhirServicesListByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesListByWorkspaceResult contains the result from method FhirServices.ListByWorkspace.
type FhirServicesListByWorkspaceResult struct {
	FhirServiceCollection
}

// FhirServicesUpdatePollerResponse contains the response from method FhirServices.Update.
type FhirServicesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FhirServicesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FhirServicesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FhirServicesUpdateResponse, error) {
	respType := FhirServicesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FhirService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FhirServicesUpdatePollerResponse from the provided client and resume token.
func (l *FhirServicesUpdatePollerResponse) Resume(ctx context.Context, client *FhirServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FhirServicesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &FhirServicesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FhirServicesUpdateResponse contains the response from method FhirServices.Update.
type FhirServicesUpdateResponse struct {
	FhirServicesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesUpdateResult contains the result from method FhirServices.Update.
type FhirServicesUpdateResult struct {
	FhirService
}

// IotConnectorFhirDestinationCreateOrUpdatePollerResponse contains the response from method IotConnectorFhirDestination.CreateOrUpdate.
type IotConnectorFhirDestinationCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorFhirDestinationCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorFhirDestinationCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorFhirDestinationCreateOrUpdateResponse, error) {
	respType := IotConnectorFhirDestinationCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IotFhirDestination)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorFhirDestinationCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IotConnectorFhirDestinationCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IotConnectorFhirDestinationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorFhirDestinationClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &IotConnectorFhirDestinationCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorFhirDestinationCreateOrUpdateResponse contains the response from method IotConnectorFhirDestination.CreateOrUpdate.
type IotConnectorFhirDestinationCreateOrUpdateResponse struct {
	IotConnectorFhirDestinationCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorFhirDestinationCreateOrUpdateResult contains the result from method IotConnectorFhirDestination.CreateOrUpdate.
type IotConnectorFhirDestinationCreateOrUpdateResult struct {
	IotFhirDestination
}

// IotConnectorFhirDestinationDeletePollerResponse contains the response from method IotConnectorFhirDestination.Delete.
type IotConnectorFhirDestinationDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorFhirDestinationDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorFhirDestinationDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorFhirDestinationDeleteResponse, error) {
	respType := IotConnectorFhirDestinationDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorFhirDestinationDeletePollerResponse from the provided client and resume token.
func (l *IotConnectorFhirDestinationDeletePollerResponse) Resume(ctx context.Context, client *IotConnectorFhirDestinationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorFhirDestinationClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &IotConnectorFhirDestinationDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorFhirDestinationDeleteResponse contains the response from method IotConnectorFhirDestination.Delete.
type IotConnectorFhirDestinationDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorFhirDestinationGetResponse contains the response from method IotConnectorFhirDestination.Get.
type IotConnectorFhirDestinationGetResponse struct {
	IotConnectorFhirDestinationGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorFhirDestinationGetResult contains the result from method IotConnectorFhirDestination.Get.
type IotConnectorFhirDestinationGetResult struct {
	IotFhirDestination
}

// IotConnectorsCreateOrUpdatePollerResponse contains the response from method IotConnectors.CreateOrUpdate.
type IotConnectorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorsCreateOrUpdateResponse, error) {
	respType := IotConnectorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IotConnector)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IotConnectorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IotConnectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &IotConnectorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorsCreateOrUpdateResponse contains the response from method IotConnectors.CreateOrUpdate.
type IotConnectorsCreateOrUpdateResponse struct {
	IotConnectorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsCreateOrUpdateResult contains the result from method IotConnectors.CreateOrUpdate.
type IotConnectorsCreateOrUpdateResult struct {
	IotConnector
}

// IotConnectorsDeletePollerResponse contains the response from method IotConnectors.Delete.
type IotConnectorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorsDeleteResponse, error) {
	respType := IotConnectorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorsDeletePollerResponse from the provided client and resume token.
func (l *IotConnectorsDeletePollerResponse) Resume(ctx context.Context, client *IotConnectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &IotConnectorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorsDeleteResponse contains the response from method IotConnectors.Delete.
type IotConnectorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsGetResponse contains the response from method IotConnectors.Get.
type IotConnectorsGetResponse struct {
	IotConnectorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsGetResult contains the result from method IotConnectors.Get.
type IotConnectorsGetResult struct {
	IotConnector
}

// IotConnectorsListByWorkspaceResponse contains the response from method IotConnectors.ListByWorkspace.
type IotConnectorsListByWorkspaceResponse struct {
	IotConnectorsListByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsListByWorkspaceResult contains the result from method IotConnectors.ListByWorkspace.
type IotConnectorsListByWorkspaceResult struct {
	IotConnectorCollection
}

// IotConnectorsUpdatePollerResponse contains the response from method IotConnectors.Update.
type IotConnectorsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorsUpdateResponse, error) {
	respType := IotConnectorsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IotConnector)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorsUpdatePollerResponse from the provided client and resume token.
func (l *IotConnectorsUpdatePollerResponse) Resume(ctx context.Context, client *IotConnectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &IotConnectorsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorsUpdateResponse contains the response from method IotConnectors.Update.
type IotConnectorsUpdateResponse struct {
	IotConnectorsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsUpdateResult contains the result from method IotConnectors.Update.
type IotConnectorsUpdateResult struct {
	IotConnector
}

// OperationResultsGetResponse contains the response from method OperationResults.Get.
type OperationResultsGetResponse struct {
	OperationResultsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationResultsGetResult contains the result from method OperationResults.Get.
type OperationResultsGetResult struct {
	OperationResultsDescription
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	ListOperations
}

// PrivateEndpointConnectionsCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnectionDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsCreateOrUpdateResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsCreateOrUpdateResult contains the result from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResult struct {
	PrivateEndpointConnectionDescription
}

// PrivateEndpointConnectionsDeletePollerResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsDeleteResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResponse contains the response from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResponse struct {
	PrivateEndpointConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResult contains the result from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResult struct {
	PrivateEndpointConnectionDescription
}

// PrivateEndpointConnectionsListByServiceResponse contains the response from method PrivateEndpointConnections.ListByService.
type PrivateEndpointConnectionsListByServiceResponse struct {
	PrivateEndpointConnectionsListByServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsListByServiceResult contains the result from method PrivateEndpointConnections.ListByService.
type PrivateEndpointConnectionsListByServiceResult struct {
	PrivateEndpointConnectionListResultDescription
}

// PrivateLinkResourcesGetResponse contains the response from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResponse struct {
	PrivateLinkResourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesGetResult contains the result from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResult struct {
	PrivateLinkResourceDescription
}

// PrivateLinkResourcesListByServiceResponse contains the response from method PrivateLinkResources.ListByService.
type PrivateLinkResourcesListByServiceResponse struct {
	PrivateLinkResourcesListByServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesListByServiceResult contains the result from method PrivateLinkResources.ListByService.
type PrivateLinkResourcesListByServiceResult struct {
	PrivateLinkResourceListResultDescription
}

// ServicesCheckNameAvailabilityResponse contains the response from method Services.CheckNameAvailability.
type ServicesCheckNameAvailabilityResponse struct {
	ServicesCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesCheckNameAvailabilityResult contains the result from method Services.CheckNameAvailability.
type ServicesCheckNameAvailabilityResult struct {
	ServicesNameAvailabilityInfo
}

// ServicesCreateOrUpdatePollerResponse contains the response from method Services.CreateOrUpdate.
type ServicesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesCreateOrUpdateResponse, error) {
	respType := ServicesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServicesDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServicesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServicesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesCreateOrUpdateResponse contains the response from method Services.CreateOrUpdate.
type ServicesCreateOrUpdateResponse struct {
	ServicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesCreateOrUpdateResult contains the result from method Services.CreateOrUpdate.
type ServicesCreateOrUpdateResult struct {
	ServicesDescription
}

// ServicesDeletePollerResponse contains the response from method Services.Delete.
type ServicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesDeleteResponse, error) {
	respType := ServicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesDeletePollerResponse from the provided client and resume token.
func (l *ServicesDeletePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesDeleteResponse contains the response from method Services.Delete.
type ServicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesGetResponse contains the response from method Services.Get.
type ServicesGetResponse struct {
	ServicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesGetResult contains the result from method Services.Get.
type ServicesGetResult struct {
	ServicesDescription
}

// ServicesListByResourceGroupResponse contains the response from method Services.ListByResourceGroup.
type ServicesListByResourceGroupResponse struct {
	ServicesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesListByResourceGroupResult contains the result from method Services.ListByResourceGroup.
type ServicesListByResourceGroupResult struct {
	ServicesDescriptionListResult
}

// ServicesListResponse contains the response from method Services.List.
type ServicesListResponse struct {
	ServicesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesListResult contains the result from method Services.List.
type ServicesListResult struct {
	ServicesDescriptionListResult
}

// ServicesUpdatePollerResponse contains the response from method Services.Update.
type ServicesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesUpdateResponse, error) {
	respType := ServicesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServicesDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesUpdatePollerResponse from the provided client and resume token.
func (l *ServicesUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ServicesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesUpdateResponse contains the response from method Services.Update.
type ServicesUpdateResponse struct {
	ServicesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesUpdateResult contains the result from method Services.Update.
type ServicesUpdateResult struct {
	ServicesDescription
}

// WorkspacesCreateOrUpdatePollerResponse contains the response from method Workspaces.CreateOrUpdate.
type WorkspacesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkspacesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkspacesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesCreateOrUpdateResponse, error) {
	respType := WorkspacesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Workspace)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkspacesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *WorkspacesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *WorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkspacesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &WorkspacesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkspacesCreateOrUpdateResponse contains the response from method Workspaces.CreateOrUpdate.
type WorkspacesCreateOrUpdateResponse struct {
	WorkspacesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesCreateOrUpdateResult contains the result from method Workspaces.CreateOrUpdate.
type WorkspacesCreateOrUpdateResult struct {
	Workspace
}

// WorkspacesDeletePollerResponse contains the response from method Workspaces.Delete.
type WorkspacesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkspacesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkspacesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesDeleteResponse, error) {
	respType := WorkspacesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkspacesDeletePollerResponse from the provided client and resume token.
func (l *WorkspacesDeletePollerResponse) Resume(ctx context.Context, client *WorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkspacesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &WorkspacesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkspacesDeleteResponse contains the response from method Workspaces.Delete.
type WorkspacesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesGetResponse contains the response from method Workspaces.Get.
type WorkspacesGetResponse struct {
	WorkspacesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesGetResult contains the result from method Workspaces.Get.
type WorkspacesGetResult struct {
	Workspace
}

// WorkspacesListByResourceGroupResponse contains the response from method Workspaces.ListByResourceGroup.
type WorkspacesListByResourceGroupResponse struct {
	WorkspacesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesListByResourceGroupResult contains the result from method Workspaces.ListByResourceGroup.
type WorkspacesListByResourceGroupResult struct {
	WorkspaceList
}

// WorkspacesListBySubscriptionResponse contains the response from method Workspaces.ListBySubscription.
type WorkspacesListBySubscriptionResponse struct {
	WorkspacesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesListBySubscriptionResult contains the result from method Workspaces.ListBySubscription.
type WorkspacesListBySubscriptionResult struct {
	WorkspaceList
}

// WorkspacesUpdatePollerResponse contains the response from method Workspaces.Update.
type WorkspacesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkspacesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkspacesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesUpdateResponse, error) {
	respType := WorkspacesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Workspace)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkspacesUpdatePollerResponse from the provided client and resume token.
func (l *WorkspacesUpdatePollerResponse) Resume(ctx context.Context, client *WorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkspacesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &WorkspacesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkspacesUpdateResponse contains the response from method Workspaces.Update.
type WorkspacesUpdateResponse struct {
	WorkspacesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesUpdateResult contains the result from method Workspaces.Update.
type WorkspacesUpdateResult struct {
	Workspace
}
