//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armhealthcareapis

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DicomServicesClientCreateOrUpdatePollerResponse contains the response from method DicomServicesClient.CreateOrUpdate.
type DicomServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DicomServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DicomServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DicomServicesClientCreateOrUpdateResponse, error) {
	respType := DicomServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DicomService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DicomServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DicomServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DicomServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DicomServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DicomServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DicomServicesClientCreateOrUpdateResponse contains the response from method DicomServicesClient.CreateOrUpdate.
type DicomServicesClientCreateOrUpdateResponse struct {
	DicomServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesClientCreateOrUpdateResult contains the result from method DicomServicesClient.CreateOrUpdate.
type DicomServicesClientCreateOrUpdateResult struct {
	DicomService
}

// DicomServicesClientDeletePollerResponse contains the response from method DicomServicesClient.Delete.
type DicomServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DicomServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DicomServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DicomServicesClientDeleteResponse, error) {
	respType := DicomServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DicomServicesClientDeletePollerResponse from the provided client and resume token.
func (l *DicomServicesClientDeletePollerResponse) Resume(ctx context.Context, client *DicomServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DicomServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DicomServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DicomServicesClientDeleteResponse contains the response from method DicomServicesClient.Delete.
type DicomServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesClientGetResponse contains the response from method DicomServicesClient.Get.
type DicomServicesClientGetResponse struct {
	DicomServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesClientGetResult contains the result from method DicomServicesClient.Get.
type DicomServicesClientGetResult struct {
	DicomService
}

// DicomServicesClientListByWorkspaceResponse contains the response from method DicomServicesClient.ListByWorkspace.
type DicomServicesClientListByWorkspaceResponse struct {
	DicomServicesClientListByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesClientListByWorkspaceResult contains the result from method DicomServicesClient.ListByWorkspace.
type DicomServicesClientListByWorkspaceResult struct {
	DicomServiceCollection
}

// DicomServicesClientUpdatePollerResponse contains the response from method DicomServicesClient.Update.
type DicomServicesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DicomServicesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DicomServicesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DicomServicesClientUpdateResponse, error) {
	respType := DicomServicesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DicomService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DicomServicesClientUpdatePollerResponse from the provided client and resume token.
func (l *DicomServicesClientUpdatePollerResponse) Resume(ctx context.Context, client *DicomServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DicomServicesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DicomServicesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DicomServicesClientUpdateResponse contains the response from method DicomServicesClient.Update.
type DicomServicesClientUpdateResponse struct {
	DicomServicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DicomServicesClientUpdateResult contains the result from method DicomServicesClient.Update.
type DicomServicesClientUpdateResult struct {
	DicomService
}

// FhirDestinationsClientListByIotConnectorResponse contains the response from method FhirDestinationsClient.ListByIotConnector.
type FhirDestinationsClientListByIotConnectorResponse struct {
	FhirDestinationsClientListByIotConnectorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirDestinationsClientListByIotConnectorResult contains the result from method FhirDestinationsClient.ListByIotConnector.
type FhirDestinationsClientListByIotConnectorResult struct {
	IotFhirDestinationCollection
}

// FhirServicesClientCreateOrUpdatePollerResponse contains the response from method FhirServicesClient.CreateOrUpdate.
type FhirServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FhirServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FhirServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FhirServicesClientCreateOrUpdateResponse, error) {
	respType := FhirServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FhirService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FhirServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FhirServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FhirServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FhirServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FhirServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FhirServicesClientCreateOrUpdateResponse contains the response from method FhirServicesClient.CreateOrUpdate.
type FhirServicesClientCreateOrUpdateResponse struct {
	FhirServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesClientCreateOrUpdateResult contains the result from method FhirServicesClient.CreateOrUpdate.
type FhirServicesClientCreateOrUpdateResult struct {
	FhirService
}

// FhirServicesClientDeletePollerResponse contains the response from method FhirServicesClient.Delete.
type FhirServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FhirServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FhirServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FhirServicesClientDeleteResponse, error) {
	respType := FhirServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FhirServicesClientDeletePollerResponse from the provided client and resume token.
func (l *FhirServicesClientDeletePollerResponse) Resume(ctx context.Context, client *FhirServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FhirServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FhirServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FhirServicesClientDeleteResponse contains the response from method FhirServicesClient.Delete.
type FhirServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesClientGetResponse contains the response from method FhirServicesClient.Get.
type FhirServicesClientGetResponse struct {
	FhirServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesClientGetResult contains the result from method FhirServicesClient.Get.
type FhirServicesClientGetResult struct {
	FhirService
}

// FhirServicesClientListByWorkspaceResponse contains the response from method FhirServicesClient.ListByWorkspace.
type FhirServicesClientListByWorkspaceResponse struct {
	FhirServicesClientListByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesClientListByWorkspaceResult contains the result from method FhirServicesClient.ListByWorkspace.
type FhirServicesClientListByWorkspaceResult struct {
	FhirServiceCollection
}

// FhirServicesClientUpdatePollerResponse contains the response from method FhirServicesClient.Update.
type FhirServicesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FhirServicesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FhirServicesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FhirServicesClientUpdateResponse, error) {
	respType := FhirServicesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FhirService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FhirServicesClientUpdatePollerResponse from the provided client and resume token.
func (l *FhirServicesClientUpdatePollerResponse) Resume(ctx context.Context, client *FhirServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FhirServicesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FhirServicesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FhirServicesClientUpdateResponse contains the response from method FhirServicesClient.Update.
type FhirServicesClientUpdateResponse struct {
	FhirServicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FhirServicesClientUpdateResult contains the result from method FhirServicesClient.Update.
type FhirServicesClientUpdateResult struct {
	FhirService
}

// IotConnectorFhirDestinationClientCreateOrUpdatePollerResponse contains the response from method IotConnectorFhirDestinationClient.CreateOrUpdate.
type IotConnectorFhirDestinationClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorFhirDestinationClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorFhirDestinationClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorFhirDestinationClientCreateOrUpdateResponse, error) {
	respType := IotConnectorFhirDestinationClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IotFhirDestination)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorFhirDestinationClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IotConnectorFhirDestinationClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IotConnectorFhirDestinationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorFhirDestinationClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IotConnectorFhirDestinationClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorFhirDestinationClientCreateOrUpdateResponse contains the response from method IotConnectorFhirDestinationClient.CreateOrUpdate.
type IotConnectorFhirDestinationClientCreateOrUpdateResponse struct {
	IotConnectorFhirDestinationClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorFhirDestinationClientCreateOrUpdateResult contains the result from method IotConnectorFhirDestinationClient.CreateOrUpdate.
type IotConnectorFhirDestinationClientCreateOrUpdateResult struct {
	IotFhirDestination
}

// IotConnectorFhirDestinationClientDeletePollerResponse contains the response from method IotConnectorFhirDestinationClient.Delete.
type IotConnectorFhirDestinationClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorFhirDestinationClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorFhirDestinationClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorFhirDestinationClientDeleteResponse, error) {
	respType := IotConnectorFhirDestinationClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorFhirDestinationClientDeletePollerResponse from the provided client and resume token.
func (l *IotConnectorFhirDestinationClientDeletePollerResponse) Resume(ctx context.Context, client *IotConnectorFhirDestinationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorFhirDestinationClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IotConnectorFhirDestinationClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorFhirDestinationClientDeleteResponse contains the response from method IotConnectorFhirDestinationClient.Delete.
type IotConnectorFhirDestinationClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorFhirDestinationClientGetResponse contains the response from method IotConnectorFhirDestinationClient.Get.
type IotConnectorFhirDestinationClientGetResponse struct {
	IotConnectorFhirDestinationClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorFhirDestinationClientGetResult contains the result from method IotConnectorFhirDestinationClient.Get.
type IotConnectorFhirDestinationClientGetResult struct {
	IotFhirDestination
}

// IotConnectorsClientCreateOrUpdatePollerResponse contains the response from method IotConnectorsClient.CreateOrUpdate.
type IotConnectorsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorsClientCreateOrUpdateResponse, error) {
	respType := IotConnectorsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IotConnector)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IotConnectorsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IotConnectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IotConnectorsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorsClientCreateOrUpdateResponse contains the response from method IotConnectorsClient.CreateOrUpdate.
type IotConnectorsClientCreateOrUpdateResponse struct {
	IotConnectorsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsClientCreateOrUpdateResult contains the result from method IotConnectorsClient.CreateOrUpdate.
type IotConnectorsClientCreateOrUpdateResult struct {
	IotConnector
}

// IotConnectorsClientDeletePollerResponse contains the response from method IotConnectorsClient.Delete.
type IotConnectorsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorsClientDeleteResponse, error) {
	respType := IotConnectorsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorsClientDeletePollerResponse from the provided client and resume token.
func (l *IotConnectorsClientDeletePollerResponse) Resume(ctx context.Context, client *IotConnectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IotConnectorsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorsClientDeleteResponse contains the response from method IotConnectorsClient.Delete.
type IotConnectorsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsClientGetResponse contains the response from method IotConnectorsClient.Get.
type IotConnectorsClientGetResponse struct {
	IotConnectorsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsClientGetResult contains the result from method IotConnectorsClient.Get.
type IotConnectorsClientGetResult struct {
	IotConnector
}

// IotConnectorsClientListByWorkspaceResponse contains the response from method IotConnectorsClient.ListByWorkspace.
type IotConnectorsClientListByWorkspaceResponse struct {
	IotConnectorsClientListByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsClientListByWorkspaceResult contains the result from method IotConnectorsClient.ListByWorkspace.
type IotConnectorsClientListByWorkspaceResult struct {
	IotConnectorCollection
}

// IotConnectorsClientUpdatePollerResponse contains the response from method IotConnectorsClient.Update.
type IotConnectorsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IotConnectorsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IotConnectorsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IotConnectorsClientUpdateResponse, error) {
	respType := IotConnectorsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IotConnector)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IotConnectorsClientUpdatePollerResponse from the provided client and resume token.
func (l *IotConnectorsClientUpdatePollerResponse) Resume(ctx context.Context, client *IotConnectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IotConnectorsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IotConnectorsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IotConnectorsClientUpdateResponse contains the response from method IotConnectorsClient.Update.
type IotConnectorsClientUpdateResponse struct {
	IotConnectorsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IotConnectorsClientUpdateResult contains the result from method IotConnectorsClient.Update.
type IotConnectorsClientUpdateResult struct {
	IotConnector
}

// OperationResultsClientGetResponse contains the response from method OperationResultsClient.Get.
type OperationResultsClientGetResponse struct {
	OperationResultsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationResultsClientGetResult contains the result from method OperationResultsClient.Get.
type OperationResultsClientGetResult struct {
	OperationResultsDescription
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	ListOperations
}

// PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnectionDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientCreateOrUpdateResponse contains the response from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientCreateOrUpdateResult contains the result from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdateResult struct {
	PrivateEndpointConnectionDescription
}

// PrivateEndpointConnectionsClientDeletePollerResponse contains the response from method PrivateEndpointConnectionsClient.Delete.
type PrivateEndpointConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientDeleteResponse contains the response from method PrivateEndpointConnectionsClient.Delete.
type PrivateEndpointConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientGetResponse contains the response from method PrivateEndpointConnectionsClient.Get.
type PrivateEndpointConnectionsClientGetResponse struct {
	PrivateEndpointConnectionsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientGetResult contains the result from method PrivateEndpointConnectionsClient.Get.
type PrivateEndpointConnectionsClientGetResult struct {
	PrivateEndpointConnectionDescription
}

// PrivateEndpointConnectionsClientListByServiceResponse contains the response from method PrivateEndpointConnectionsClient.ListByService.
type PrivateEndpointConnectionsClientListByServiceResponse struct {
	PrivateEndpointConnectionsClientListByServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientListByServiceResult contains the result from method PrivateEndpointConnectionsClient.ListByService.
type PrivateEndpointConnectionsClientListByServiceResult struct {
	PrivateEndpointConnectionListResultDescription
}

// PrivateLinkResourcesClientGetResponse contains the response from method PrivateLinkResourcesClient.Get.
type PrivateLinkResourcesClientGetResponse struct {
	PrivateLinkResourcesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesClientGetResult contains the result from method PrivateLinkResourcesClient.Get.
type PrivateLinkResourcesClientGetResult struct {
	PrivateLinkResourceDescription
}

// PrivateLinkResourcesClientListByServiceResponse contains the response from method PrivateLinkResourcesClient.ListByService.
type PrivateLinkResourcesClientListByServiceResponse struct {
	PrivateLinkResourcesClientListByServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesClientListByServiceResult contains the result from method PrivateLinkResourcesClient.ListByService.
type PrivateLinkResourcesClientListByServiceResult struct {
	PrivateLinkResourceListResultDescription
}

// ServicesClientCheckNameAvailabilityResponse contains the response from method ServicesClient.CheckNameAvailability.
type ServicesClientCheckNameAvailabilityResponse struct {
	ServicesClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCheckNameAvailabilityResult contains the result from method ServicesClient.CheckNameAvailability.
type ServicesClientCheckNameAvailabilityResult struct {
	ServicesNameAvailabilityInfo
}

// ServicesClientCreateOrUpdatePollerResponse contains the response from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientCreateOrUpdateResponse, error) {
	respType := ServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServicesDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientCreateOrUpdateResponse contains the response from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdateResponse struct {
	ServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCreateOrUpdateResult contains the result from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdateResult struct {
	ServicesDescription
}

// ServicesClientDeletePollerResponse contains the response from method ServicesClient.Delete.
type ServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientDeleteResponse, error) {
	respType := ServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientDeletePollerResponse from the provided client and resume token.
func (l *ServicesClientDeletePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientDeleteResponse contains the response from method ServicesClient.Delete.
type ServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientGetResponse contains the response from method ServicesClient.Get.
type ServicesClientGetResponse struct {
	ServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientGetResult contains the result from method ServicesClient.Get.
type ServicesClientGetResult struct {
	ServicesDescription
}

// ServicesClientListByResourceGroupResponse contains the response from method ServicesClient.ListByResourceGroup.
type ServicesClientListByResourceGroupResponse struct {
	ServicesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListByResourceGroupResult contains the result from method ServicesClient.ListByResourceGroup.
type ServicesClientListByResourceGroupResult struct {
	ServicesDescriptionListResult
}

// ServicesClientListResponse contains the response from method ServicesClient.List.
type ServicesClientListResponse struct {
	ServicesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListResult contains the result from method ServicesClient.List.
type ServicesClientListResult struct {
	ServicesDescriptionListResult
}

// ServicesClientUpdatePollerResponse contains the response from method ServicesClient.Update.
type ServicesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientUpdateResponse, error) {
	respType := ServicesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServicesDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientUpdatePollerResponse from the provided client and resume token.
func (l *ServicesClientUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientUpdateResponse contains the response from method ServicesClient.Update.
type ServicesClientUpdateResponse struct {
	ServicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientUpdateResult contains the result from method ServicesClient.Update.
type ServicesClientUpdateResult struct {
	ServicesDescription
}

// WorkspacesClientCreateOrUpdatePollerResponse contains the response from method WorkspacesClient.CreateOrUpdate.
type WorkspacesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkspacesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkspacesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesClientCreateOrUpdateResponse, error) {
	respType := WorkspacesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Workspace)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkspacesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *WorkspacesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *WorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkspacesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WorkspacesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkspacesClientCreateOrUpdateResponse contains the response from method WorkspacesClient.CreateOrUpdate.
type WorkspacesClientCreateOrUpdateResponse struct {
	WorkspacesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesClientCreateOrUpdateResult contains the result from method WorkspacesClient.CreateOrUpdate.
type WorkspacesClientCreateOrUpdateResult struct {
	Workspace
}

// WorkspacesClientDeletePollerResponse contains the response from method WorkspacesClient.Delete.
type WorkspacesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkspacesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkspacesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesClientDeleteResponse, error) {
	respType := WorkspacesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkspacesClientDeletePollerResponse from the provided client and resume token.
func (l *WorkspacesClientDeletePollerResponse) Resume(ctx context.Context, client *WorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkspacesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WorkspacesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkspacesClientDeleteResponse contains the response from method WorkspacesClient.Delete.
type WorkspacesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesClientGetResponse contains the response from method WorkspacesClient.Get.
type WorkspacesClientGetResponse struct {
	WorkspacesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesClientGetResult contains the result from method WorkspacesClient.Get.
type WorkspacesClientGetResult struct {
	Workspace
}

// WorkspacesClientListByResourceGroupResponse contains the response from method WorkspacesClient.ListByResourceGroup.
type WorkspacesClientListByResourceGroupResponse struct {
	WorkspacesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesClientListByResourceGroupResult contains the result from method WorkspacesClient.ListByResourceGroup.
type WorkspacesClientListByResourceGroupResult struct {
	WorkspaceList
}

// WorkspacesClientListBySubscriptionResponse contains the response from method WorkspacesClient.ListBySubscription.
type WorkspacesClientListBySubscriptionResponse struct {
	WorkspacesClientListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesClientListBySubscriptionResult contains the result from method WorkspacesClient.ListBySubscription.
type WorkspacesClientListBySubscriptionResult struct {
	WorkspaceList
}

// WorkspacesClientUpdatePollerResponse contains the response from method WorkspacesClient.Update.
type WorkspacesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkspacesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkspacesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesClientUpdateResponse, error) {
	respType := WorkspacesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Workspace)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkspacesClientUpdatePollerResponse from the provided client and resume token.
func (l *WorkspacesClientUpdatePollerResponse) Resume(ctx context.Context, client *WorkspacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkspacesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WorkspacesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkspacesClientUpdateResponse contains the response from method WorkspacesClient.Update.
type WorkspacesClientUpdateResponse struct {
	WorkspacesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspacesClientUpdateResult contains the result from method WorkspacesClient.Update.
type WorkspacesClientUpdateResult struct {
	Workspace
}
