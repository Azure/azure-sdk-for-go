//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armhybriddatamanager

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AvailableProviderOperation - Class represents provider operation
type AvailableProviderOperation struct {
	// REQUIRED; Gets or Sets Name of the operations
	Name *string `json:"name,omitempty"`

	// Gets or sets Display information Contains the localized display information for this particular operation/action
	Display *AvailableProviderOperationDisplay `json:"display,omitempty"`

	// Gets or sets Origin The intended executor of the operation; governs the display of the operation in the RBAC UX and the
	// audit logs UX. Default value is “user,system”
	Origin *string `json:"origin,omitempty"`

	// Gets or sets Properties Reserved for future use
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// AvailableProviderOperationDisplay - Contains the localized display information for this particular operation / action.
// These value will be used by several clients for (1) custom role definitions for RBAC; (2) complex query filters for
// the event service; and (3) audit history / records for management operations.
type AvailableProviderOperationDisplay struct {
	// Gets or sets Description The localized friendly description for the operation, as it should be shown to the user. It should
	// be thorough, yet concise – it will be used in tool tips and detailed views.
	Description *string `json:"description,omitempty"`

	// Gets or sets Operation The localized friendly name for the operation, as it should be shown to the user. It should be concise
	// (to fit in drop downs) but clear (i.e. self-documenting). It should use
	// Title Casing and include the entity/resource to which it applies.
	Operation *string `json:"operation,omitempty"`

	// Gets or sets Provider The localized friendly form of the resource provider name – it is expected to also include the publisher/company
	// responsible. It should use Title Casing and begin with
	// “Microsoft” for 1st party services.
	Provider *string `json:"provider,omitempty"`

	// Gets or sets Resource The localized friendly form of the resource type related to this action/operation – it should match
	// the public documentation for the resource provider. It should use Title Casing
	// – for examples, please refer to the “name” section.
	Resource *string `json:"resource,omitempty"`
}

// AvailableProviderOperations - Class for set of operations used for discovery of available provider operations.
type AvailableProviderOperations struct {
	// Link for the next set of operations.
	NextLink *string `json:"nextLink,omitempty"`

	// List of operations.
	Value []*AvailableProviderOperation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableProviderOperations.
func (a AvailableProviderOperations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// CustomerSecret - The pair of customer secret.
type CustomerSecret struct {
	// REQUIRED; The encryption algorithm used to encrypt data.
	Algorithm *SupportedAlgorithm `json:"algorithm,omitempty"`

	// REQUIRED; The identifier to the data service input object which this secret corresponds to.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// REQUIRED; It contains the encrypted customer secret.
	KeyValue *string `json:"keyValue,omitempty"`
}

// DataManager - The DataManager resource.
type DataManager struct {
	// REQUIRED; The location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US,
	// East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it
	// is created, but if an identical geo region is specified on update the request will succeed.
	Location *string `json:"location,omitempty"`

	// Etag of the Resource.
	Etag *string `json:"etag,omitempty"`

	// The sku type.
	SKU *SKU `json:"sku,omitempty"`

	// The list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across
	// resource groups).
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The Resource Name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataManager.
func (d DataManager) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "sku", d.SKU)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// DataManagerList - DataManager resources Collection.
type DataManagerList struct {
	// Link for the next set of data stores.
	NextLink *string `json:"nextLink,omitempty"`

	// List of data manager resources.
	Value []*DataManager `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataManagerList.
func (d DataManagerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataManagerUpdateParameter - The DataManagerUpdateParameter.
type DataManagerUpdateParameter struct {
	// The sku type.
	SKU *SKU `json:"sku,omitempty"`

	// The list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across
	// resource groups).
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataManagerUpdateParameter.
func (d DataManagerUpdateParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "sku", d.SKU)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DataManagersClientBeginCreateOptions contains the optional parameters for the DataManagersClient.BeginCreate method.
type DataManagersClientBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// DataManagersClientBeginDeleteOptions contains the optional parameters for the DataManagersClient.BeginDelete method.
type DataManagersClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DataManagersClientBeginUpdateOptions contains the optional parameters for the DataManagersClient.BeginUpdate method.
type DataManagersClientBeginUpdateOptions struct {
	// Defines the If-Match condition. The patch will be performed only if the ETag of the data manager resource on the server
	// matches this value.
	IfMatch *string
}

// DataManagersClientGetOptions contains the optional parameters for the DataManagersClient.Get method.
type DataManagersClientGetOptions struct {
	// placeholder for future optional parameters
}

// DataManagersClientListByResourceGroupOptions contains the optional parameters for the DataManagersClient.ListByResourceGroup
// method.
type DataManagersClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// DataManagersClientListOptions contains the optional parameters for the DataManagersClient.List method.
type DataManagersClientListOptions struct {
	// placeholder for future optional parameters
}

// DataService - Data Service.
type DataService struct {
	// REQUIRED; DataService properties.
	Properties *DataServiceProperties `json:"properties,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DataServiceList - Data Service Collection.
type DataServiceList struct {
	// Link for the next set of data services.
	NextLink *string `json:"nextLink,omitempty"`

	// List of data services.
	Value []*DataService `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataServiceList.
func (d DataServiceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataServiceProperties - Data Service properties.
type DataServiceProperties struct {
	// REQUIRED; State of the data service.
	State *State `json:"state,omitempty"`

	// Supported data store types which can be used as a sink.
	SupportedDataSinkTypes []*string `json:"supportedDataSinkTypes,omitempty"`

	// Supported data store types which can be used as a source.
	SupportedDataSourceTypes []*string `json:"supportedDataSourceTypes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataServiceProperties.
func (d DataServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "state", d.State)
	populate(objectMap, "supportedDataSinkTypes", d.SupportedDataSinkTypes)
	populate(objectMap, "supportedDataSourceTypes", d.SupportedDataSourceTypes)
	return json.Marshal(objectMap)
}

// DataServicesClientGetOptions contains the optional parameters for the DataServicesClient.Get method.
type DataServicesClientGetOptions struct {
	// placeholder for future optional parameters
}

// DataServicesClientListByDataManagerOptions contains the optional parameters for the DataServicesClient.ListByDataManager
// method.
type DataServicesClientListByDataManagerOptions struct {
	// placeholder for future optional parameters
}

// DataStore - Data store.
type DataStore struct {
	// REQUIRED; DataStore properties.
	Properties *DataStoreProperties `json:"properties,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DataStoreFilter - Contains the information about the filters for the DataStore.
type DataStoreFilter struct {
	// The data store type id.
	DataStoreTypeID *string `json:"dataStoreTypeId,omitempty"`
}

// DataStoreList - Data Store Collection.
type DataStoreList struct {
	// Link for the next set of data stores.
	NextLink *string `json:"nextLink,omitempty"`

	// List of data stores.
	Value []*DataStore `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataStoreList.
func (d DataStoreList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataStoreProperties - Data Store for sources and sinks
type DataStoreProperties struct {
	// REQUIRED; The arm id of the data store type.
	DataStoreTypeID *string `json:"dataStoreTypeId,omitempty"`

	// REQUIRED; State of the data source.
	State *State `json:"state,omitempty"`

	// List of customer secrets containing a key identifier and key value. The key identifier is a way for the specific data source
	// to understand the key. Value contains customer secret encrypted by the
	// encryptionKeys.
	CustomerSecrets []*CustomerSecret `json:"customerSecrets,omitempty"`

	// A generic json used differently by each data source type.
	ExtendedProperties map[string]interface{} `json:"extendedProperties,omitempty"`

	// Arm Id for the manager resource to which the data source is associated. This is optional.
	RepositoryID *string `json:"repositoryId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataStoreProperties.
func (d DataStoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customerSecrets", d.CustomerSecrets)
	populate(objectMap, "dataStoreTypeId", d.DataStoreTypeID)
	populate(objectMap, "extendedProperties", d.ExtendedProperties)
	populate(objectMap, "repositoryId", d.RepositoryID)
	populate(objectMap, "state", d.State)
	return json.Marshal(objectMap)
}

// DataStoreType - Data Store Type.
type DataStoreType struct {
	// REQUIRED; DataStoreType properties.
	Properties *DataStoreTypeProperties `json:"properties,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DataStoreTypeList - Data Store Type Collection.
type DataStoreTypeList struct {
	// Link for the next set of data store types.
	NextLink *string `json:"nextLink,omitempty"`

	// List of DataStoreType.
	Value []*DataStoreType `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataStoreTypeList.
func (d DataStoreTypeList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataStoreTypeProperties - Data Store Type properties.
type DataStoreTypeProperties struct {
	// REQUIRED; State of the data store type.
	State *State `json:"state,omitempty"`

	// Arm type for the manager resource to which the data source type is associated. This is optional.
	RepositoryType *string `json:"repositoryType,omitempty"`

	// Supported data services where it can be used as a sink.
	SupportedDataServicesAsSink []*string `json:"supportedDataServicesAsSink,omitempty"`

	// Supported data services where it can be used as a source.
	SupportedDataServicesAsSource []*string `json:"supportedDataServicesAsSource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataStoreTypeProperties.
func (d DataStoreTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "repositoryType", d.RepositoryType)
	populate(objectMap, "state", d.State)
	populate(objectMap, "supportedDataServicesAsSink", d.SupportedDataServicesAsSink)
	populate(objectMap, "supportedDataServicesAsSource", d.SupportedDataServicesAsSource)
	return json.Marshal(objectMap)
}

// DataStoreTypesClientGetOptions contains the optional parameters for the DataStoreTypesClient.Get method.
type DataStoreTypesClientGetOptions struct {
	// placeholder for future optional parameters
}

// DataStoreTypesClientListByDataManagerOptions contains the optional parameters for the DataStoreTypesClient.ListByDataManager
// method.
type DataStoreTypesClientListByDataManagerOptions struct {
	// placeholder for future optional parameters
}

// DataStoresClientBeginCreateOrUpdateOptions contains the optional parameters for the DataStoresClient.BeginCreateOrUpdate
// method.
type DataStoresClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DataStoresClientBeginDeleteOptions contains the optional parameters for the DataStoresClient.BeginDelete method.
type DataStoresClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DataStoresClientGetOptions contains the optional parameters for the DataStoresClient.Get method.
type DataStoresClientGetOptions struct {
	// placeholder for future optional parameters
}

// DataStoresClientListByDataManagerOptions contains the optional parameters for the DataStoresClient.ListByDataManager method.
type DataStoresClientListByDataManagerOptions struct {
	// OData Filter options
	Filter *string
}

// DmsBaseObject - Base class for all objects under DataManager Service
type DmsBaseObject struct {
	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// Error - Top level error for the job.
type Error struct {
	// REQUIRED; Error code that can be used to programmatically identify the error.
	Code *string `json:"code,omitempty"`

	// Describes the error in detail and provides debugging information.
	Message *string `json:"message,omitempty"`
}

// ErrorDetails - Error Details
type ErrorDetails struct {
	// Error code.
	ErrorCode *int32 `json:"errorCode,omitempty"`

	// Error message.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Contains the non localized exception message
	ExceptionMessage *string `json:"exceptionMessage,omitempty"`

	// Recommended action for the error.
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

// Job - Data service job.
type Job struct {
	// REQUIRED; Job properties.
	Properties *JobProperties `json:"properties,omitempty"`

	// REQUIRED; Time at which the job was started in UTC ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`

	// REQUIRED; Status of the job.
	Status *JobStatus `json:"status,omitempty"`

	// Time at which the job ended in UTC ISO 8601 format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Top level error for the job.
	Error *Error `json:"error,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Job.
func (j *Job) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &j.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &j.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobDefinition - Job Definition.
type JobDefinition struct {
	// REQUIRED; JobDefinition properties.
	Properties *JobDefinitionProperties `json:"properties,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// JobDefinitionFilter - Contains the supported job definition filters.
type JobDefinitionFilter struct {
	// REQUIRED; The state of the job definition.
	State *State `json:"state,omitempty"`

	// The data source associated with the job definition
	DataSource *string `json:"dataSource,omitempty"`

	// The last modified date time of the data source.
	LastModified *time.Time `json:"lastModified,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobDefinitionFilter.
func (j JobDefinitionFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSource", j.DataSource)
	populateTimeRFC3339(objectMap, "lastModified", j.LastModified)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobDefinitionFilter.
func (j *JobDefinitionFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSource":
			err = unpopulate(val, &j.DataSource)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &j.LastModified)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobDefinitionList - Job Definition Collection.
type JobDefinitionList struct {
	// Link for the next set of job definitions.
	NextLink *string `json:"nextLink,omitempty"`

	// List of job definitions.
	Value []*JobDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobDefinitionList.
func (j JobDefinitionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// JobDefinitionProperties - Job Definition
type JobDefinitionProperties struct {
	// REQUIRED; Data Sink Id associated to the job definition.
	DataSinkID *string `json:"dataSinkId,omitempty"`

	// REQUIRED; Data Source Id associated to the job definition.
	DataSourceID *string `json:"dataSourceId,omitempty"`

	// REQUIRED; State of the job definition.
	State *State `json:"state,omitempty"`

	// List of customer secrets containing a key identifier and key value. The key identifier is a way for the specific data source
	// to understand the key. Value contains customer secret encrypted by the
	// encryptionKeys.
	CustomerSecrets []*CustomerSecret `json:"customerSecrets,omitempty"`

	// A generic json used differently by each data service type.
	DataServiceInput map[string]interface{} `json:"dataServiceInput,omitempty"`

	// Last modified time of the job definition.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty"`

	// This is the preferred geo location for the job to run.
	RunLocation *RunLocation `json:"runLocation,omitempty"`

	// Schedule for running the job definition
	Schedules []*Schedule `json:"schedules,omitempty"`

	// Enum to detect if user confirmation is required. If not passed will default to NotRequired.
	UserConfirmation *UserConfirmation `json:"userConfirmation,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobDefinitionProperties.
func (j JobDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customerSecrets", j.CustomerSecrets)
	populate(objectMap, "dataServiceInput", j.DataServiceInput)
	populate(objectMap, "dataSinkId", j.DataSinkID)
	populate(objectMap, "dataSourceId", j.DataSourceID)
	populateTimeRFC3339(objectMap, "lastModifiedTime", j.LastModifiedTime)
	populate(objectMap, "runLocation", j.RunLocation)
	populate(objectMap, "schedules", j.Schedules)
	populate(objectMap, "state", j.State)
	populate(objectMap, "userConfirmation", j.UserConfirmation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobDefinitionProperties.
func (j *JobDefinitionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customerSecrets":
			err = unpopulate(val, &j.CustomerSecrets)
			delete(rawMsg, key)
		case "dataServiceInput":
			err = unpopulate(val, &j.DataServiceInput)
			delete(rawMsg, key)
		case "dataSinkId":
			err = unpopulate(val, &j.DataSinkID)
			delete(rawMsg, key)
		case "dataSourceId":
			err = unpopulate(val, &j.DataSourceID)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &j.LastModifiedTime)
			delete(rawMsg, key)
		case "runLocation":
			err = unpopulate(val, &j.RunLocation)
			delete(rawMsg, key)
		case "schedules":
			err = unpopulate(val, &j.Schedules)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		case "userConfirmation":
			err = unpopulate(val, &j.UserConfirmation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobDefinitionsClientBeginCreateOrUpdateOptions contains the optional parameters for the JobDefinitionsClient.BeginCreateOrUpdate
// method.
type JobDefinitionsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// JobDefinitionsClientBeginDeleteOptions contains the optional parameters for the JobDefinitionsClient.BeginDelete method.
type JobDefinitionsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobDefinitionsClientBeginRunOptions contains the optional parameters for the JobDefinitionsClient.BeginRun method.
type JobDefinitionsClientBeginRunOptions struct {
	// placeholder for future optional parameters
}

// JobDefinitionsClientGetOptions contains the optional parameters for the JobDefinitionsClient.Get method.
type JobDefinitionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// JobDefinitionsClientListByDataManagerOptions contains the optional parameters for the JobDefinitionsClient.ListByDataManager
// method.
type JobDefinitionsClientListByDataManagerOptions struct {
	// OData Filter options
	Filter *string
}

// JobDefinitionsClientListByDataServiceOptions contains the optional parameters for the JobDefinitionsClient.ListByDataService
// method.
type JobDefinitionsClientListByDataServiceOptions struct {
	// OData Filter options
	Filter *string
}

// JobDetails - Job details.
type JobDetails struct {
	// Error details for failure. This is optional.
	ErrorDetails []*ErrorDetails `json:"errorDetails,omitempty"`

	// Item Details Link to download files or see details
	ItemDetailsLink *string `json:"itemDetailsLink,omitempty"`

	// JobDefinition at the time of the run
	JobDefinition *JobDefinition `json:"jobDefinition,omitempty"`

	// List of stages that ran in the job
	JobStages []*JobStages `json:"jobStages,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobDetails.
func (j JobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorDetails", j.ErrorDetails)
	populate(objectMap, "itemDetailsLink", j.ItemDetailsLink)
	populate(objectMap, "jobDefinition", j.JobDefinition)
	populate(objectMap, "jobStages", j.JobStages)
	return json.Marshal(objectMap)
}

// JobFilter - Contains the information about the filters for the job.
type JobFilter struct {
	// REQUIRED; The status of the job.
	Status *JobStatus `json:"status,omitempty"`

	// The start time of the job.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobFilter.
func (j JobFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobFilter.
func (j *JobFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobList - Job Collection.
type JobList struct {
	// Link for the next set of jobs.
	NextLink *string `json:"nextLink,omitempty"`

	// List of jobs.
	Value []*Job `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobList.
func (j JobList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// JobProperties - Job Properties
type JobProperties struct {
	// REQUIRED; Describes whether the job is cancellable.
	IsCancellable *IsJobCancellable `json:"isCancellable,omitempty"`

	// Number of bytes processed by the job as of now.
	BytesProcessed *int64 `json:"bytesProcessed,omitempty"`

	// Name of the data sink on which the job was triggered.
	DataSinkName *string `json:"dataSinkName,omitempty"`

	// Name of the data source on which the job was triggered.
	DataSourceName *string `json:"dataSourceName,omitempty"`

	// Details of a job run. This field will only be sent for expand details filter.
	Details *JobDetails `json:"details,omitempty"`

	// Number of items processed by the job as of now
	ItemsProcessed *int64 `json:"itemsProcessed,omitempty"`

	// Number of bytes to be processed by the job in total.
	TotalBytesToProcess *int64 `json:"totalBytesToProcess,omitempty"`

	// Number of items to be processed by the job in total
	TotalItemsToProcess *int64 `json:"totalItemsToProcess,omitempty"`
}

// JobStages - Job stages.
type JobStages struct {
	// REQUIRED; Status of the job stage.
	StageStatus *JobStatus `json:"stageStatus,omitempty"`

	// Error details for the stage. This is optional
	ErrorDetails []*ErrorDetails `json:"errorDetails,omitempty"`

	// Job Stage Details
	JobStageDetails map[string]interface{} `json:"jobStageDetails,omitempty"`

	// Name of the job stage.
	StageName *string `json:"stageName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobStages.
func (j JobStages) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorDetails", j.ErrorDetails)
	populate(objectMap, "jobStageDetails", j.JobStageDetails)
	populate(objectMap, "stageName", j.StageName)
	populate(objectMap, "stageStatus", j.StageStatus)
	return json.Marshal(objectMap)
}

// JobsClientBeginCancelOptions contains the optional parameters for the JobsClient.BeginCancel method.
type JobsClientBeginCancelOptions struct {
	// placeholder for future optional parameters
}

// JobsClientBeginResumeOptions contains the optional parameters for the JobsClient.BeginResume method.
type JobsClientBeginResumeOptions struct {
	// placeholder for future optional parameters
}

// JobsClientGetOptions contains the optional parameters for the JobsClient.Get method.
type JobsClientGetOptions struct {
	// $expand is supported on details parameter for job, which provides details on the job stages.
	Expand *string
}

// JobsClientListByDataManagerOptions contains the optional parameters for the JobsClient.ListByDataManager method.
type JobsClientListByDataManagerOptions struct {
	// OData Filter options
	Filter *string
}

// JobsClientListByDataServiceOptions contains the optional parameters for the JobsClient.ListByDataService method.
type JobsClientListByDataServiceOptions struct {
	// OData Filter options
	Filter *string
}

// JobsClientListByJobDefinitionOptions contains the optional parameters for the JobsClient.ListByJobDefinition method.
type JobsClientListByJobDefinitionOptions struct {
	// OData Filter options
	Filter *string
}

// Key - Encryption Key.
type Key struct {
	// REQUIRED; The maximum byte size that can be encrypted by the key. For a key size larger than the size, break into chunks
	// and encrypt each chunk, append each encrypted chunk with : to mark the end of the chunk.
	EncryptionChunkSizeInBytes *int32 `json:"encryptionChunkSizeInBytes,omitempty"`

	// REQUIRED; Exponent of the encryption key.
	KeyExponent *string `json:"keyExponent,omitempty"`

	// REQUIRED; Modulus of the encryption key.
	KeyModulus *string `json:"keyModulus,omitempty"`
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// PublicKey - Public key
type PublicKey struct {
	// REQUIRED; Public key property.
	Properties *PublicKeyProperties `json:"properties,omitempty"`

	// READ-ONLY; Id of the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PublicKeyList - PublicKey Collection
type PublicKeyList struct {
	// Link for the next set of public keys.
	NextLink *string `json:"nextLink,omitempty"`

	// List of public keys.
	Value []*PublicKey `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PublicKeyList.
func (p PublicKeyList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PublicKeyProperties - PublicKey Properties
type PublicKeyProperties struct {
	// REQUIRED; Level one public key for encryption
	DataServiceLevel1Key *Key `json:"dataServiceLevel1Key,omitempty"`

	// REQUIRED; Level two public key for encryption
	DataServiceLevel2Key *Key `json:"dataServiceLevel2Key,omitempty"`
}

// PublicKeysClientGetOptions contains the optional parameters for the PublicKeysClient.Get method.
type PublicKeysClientGetOptions struct {
	// placeholder for future optional parameters
}

// PublicKeysClientListByDataManagerOptions contains the optional parameters for the PublicKeysClient.ListByDataManager method.
type PublicKeysClientListByDataManagerOptions struct {
	// placeholder for future optional parameters
}

// Resource - Model of the Resource.
type Resource struct {
	// REQUIRED; The location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US,
	// East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it
	// is created, but if an identical geo region is specified on update the request will succeed.
	Location *string `json:"location,omitempty"`

	// The sku type.
	SKU *SKU `json:"sku,omitempty"`

	// The list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across
	// resource groups).
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The Resource Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The Resource Name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// RunParameters - Run parameters for a job.
type RunParameters struct {
	// List of customer secrets containing a key identifier and key value. The key identifier is a way for the specific data source
	// to understand the key. Value contains customer secret encrypted by the
	// encryptionKeys.
	CustomerSecrets []*CustomerSecret `json:"customerSecrets,omitempty"`

	// A generic json used differently by each data service type.
	DataServiceInput map[string]interface{} `json:"dataServiceInput,omitempty"`

	// Enum to detect if user confirmation is required. If not passed will default to NotRequired.
	UserConfirmation *UserConfirmation `json:"userConfirmation,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunParameters.
func (r RunParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customerSecrets", r.CustomerSecrets)
	populate(objectMap, "dataServiceInput", r.DataServiceInput)
	populate(objectMap, "userConfirmation", r.UserConfirmation)
	return json.Marshal(objectMap)
}

// SKU - The sku type.
type SKU struct {
	// The sku name. Required for data manager creation, optional for update.
	Name *string `json:"name,omitempty"`

	// The sku tier. This is based on the SKU name.
	Tier *string `json:"tier,omitempty"`
}

// Schedule for the job run.
type Schedule struct {
	// Name of the schedule.
	Name *string `json:"name,omitempty"`

	// A list of repetition intervals in ISO 8601 format.
	PolicyList []*string `json:"policyList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Schedule.
func (s Schedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "policyList", s.PolicyList)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
