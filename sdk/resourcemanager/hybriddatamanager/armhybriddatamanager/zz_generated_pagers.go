//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armhybriddatamanager

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// DataServicesListByDataManagerPager provides operations for iterating over paged responses.
type DataServicesListByDataManagerPager struct {
	client    *DataServicesClient
	current   DataServicesListByDataManagerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataServicesListByDataManagerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataServicesListByDataManagerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataServicesListByDataManagerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataServiceList.NextLink == nil || len(*p.current.DataServiceList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataManagerHandleError(resp)
		return false
	}
	result, err := p.client.listByDataManagerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataServicesListByDataManagerResponse page.
func (p *DataServicesListByDataManagerPager) PageResponse() DataServicesListByDataManagerResponse {
	return p.current
}

// DataStoreTypesListByDataManagerPager provides operations for iterating over paged responses.
type DataStoreTypesListByDataManagerPager struct {
	client    *DataStoreTypesClient
	current   DataStoreTypesListByDataManagerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataStoreTypesListByDataManagerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataStoreTypesListByDataManagerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataStoreTypesListByDataManagerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataStoreTypeList.NextLink == nil || len(*p.current.DataStoreTypeList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataManagerHandleError(resp)
		return false
	}
	result, err := p.client.listByDataManagerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataStoreTypesListByDataManagerResponse page.
func (p *DataStoreTypesListByDataManagerPager) PageResponse() DataStoreTypesListByDataManagerResponse {
	return p.current
}

// DataStoresListByDataManagerPager provides operations for iterating over paged responses.
type DataStoresListByDataManagerPager struct {
	client    *DataStoresClient
	current   DataStoresListByDataManagerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataStoresListByDataManagerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataStoresListByDataManagerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataStoresListByDataManagerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataStoreList.NextLink == nil || len(*p.current.DataStoreList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataManagerHandleError(resp)
		return false
	}
	result, err := p.client.listByDataManagerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataStoresListByDataManagerResponse page.
func (p *DataStoresListByDataManagerPager) PageResponse() DataStoresListByDataManagerResponse {
	return p.current
}

// JobDefinitionsListByDataManagerPager provides operations for iterating over paged responses.
type JobDefinitionsListByDataManagerPager struct {
	client    *JobDefinitionsClient
	current   JobDefinitionsListByDataManagerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobDefinitionsListByDataManagerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobDefinitionsListByDataManagerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobDefinitionsListByDataManagerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobDefinitionList.NextLink == nil || len(*p.current.JobDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataManagerHandleError(resp)
		return false
	}
	result, err := p.client.listByDataManagerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobDefinitionsListByDataManagerResponse page.
func (p *JobDefinitionsListByDataManagerPager) PageResponse() JobDefinitionsListByDataManagerResponse {
	return p.current
}

// JobDefinitionsListByDataServicePager provides operations for iterating over paged responses.
type JobDefinitionsListByDataServicePager struct {
	client    *JobDefinitionsClient
	current   JobDefinitionsListByDataServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobDefinitionsListByDataServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobDefinitionsListByDataServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobDefinitionsListByDataServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobDefinitionList.NextLink == nil || len(*p.current.JobDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobDefinitionsListByDataServiceResponse page.
func (p *JobDefinitionsListByDataServicePager) PageResponse() JobDefinitionsListByDataServiceResponse {
	return p.current
}

// JobsListByDataManagerPager provides operations for iterating over paged responses.
type JobsListByDataManagerPager struct {
	client    *JobsClient
	current   JobsListByDataManagerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsListByDataManagerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobsListByDataManagerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobsListByDataManagerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataManagerHandleError(resp)
		return false
	}
	result, err := p.client.listByDataManagerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobsListByDataManagerResponse page.
func (p *JobsListByDataManagerPager) PageResponse() JobsListByDataManagerResponse {
	return p.current
}

// JobsListByDataServicePager provides operations for iterating over paged responses.
type JobsListByDataServicePager struct {
	client    *JobsClient
	current   JobsListByDataServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsListByDataServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobsListByDataServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobsListByDataServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByDataServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobsListByDataServiceResponse page.
func (p *JobsListByDataServicePager) PageResponse() JobsListByDataServiceResponse {
	return p.current
}

// JobsListByJobDefinitionPager provides operations for iterating over paged responses.
type JobsListByJobDefinitionPager struct {
	client    *JobsClient
	current   JobsListByJobDefinitionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsListByJobDefinitionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobsListByJobDefinitionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobsListByJobDefinitionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobDefinitionHandleError(resp)
		return false
	}
	result, err := p.client.listByJobDefinitionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobsListByJobDefinitionResponse page.
func (p *JobsListByJobDefinitionPager) PageResponse() JobsListByJobDefinitionResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableProviderOperations.NextLink == nil || len(*p.current.AvailableProviderOperations.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// PublicKeysListByDataManagerPager provides operations for iterating over paged responses.
type PublicKeysListByDataManagerPager struct {
	client    *PublicKeysClient
	current   PublicKeysListByDataManagerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicKeysListByDataManagerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicKeysListByDataManagerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicKeysListByDataManagerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicKeyList.NextLink == nil || len(*p.current.PublicKeyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDataManagerHandleError(resp)
		return false
	}
	result, err := p.client.listByDataManagerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicKeysListByDataManagerResponse page.
func (p *PublicKeysListByDataManagerPager) PageResponse() PublicKeysListByDataManagerResponse {
	return p.current
}
