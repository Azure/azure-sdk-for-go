//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armhybridnetwork

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DevicesCreateOrUpdatePollerResponse contains the response from method Devices.CreateOrUpdate.
type DevicesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesCreateOrUpdateResponse, error) {
	respType := DevicesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Device)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DevicesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesCreateOrUpdateResponse contains the response from method Devices.CreateOrUpdate.
type DevicesCreateOrUpdateResponse struct {
	DevicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesCreateOrUpdateResult contains the result from method Devices.CreateOrUpdate.
type DevicesCreateOrUpdateResult struct {
	Device
}

// DevicesDeletePollerResponse contains the response from method Devices.Delete.
type DevicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DevicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DevicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesDeleteResponse, error) {
	respType := DevicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DevicesDeletePollerResponse from the provided client and resume token.
func (l *DevicesDeletePollerResponse) Resume(ctx context.Context, client *DevicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DevicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DevicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DevicesDeleteResponse contains the response from method Devices.Delete.
type DevicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGetResponse contains the response from method Devices.Get.
type DevicesGetResponse struct {
	DevicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesGetResult contains the result from method Devices.Get.
type DevicesGetResult struct {
	Device
}

// DevicesListByResourceGroupResponse contains the response from method Devices.ListByResourceGroup.
type DevicesListByResourceGroupResponse struct {
	DevicesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesListByResourceGroupResult contains the result from method Devices.ListByResourceGroup.
type DevicesListByResourceGroupResult struct {
	DeviceListResult
}

// DevicesListBySubscriptionResponse contains the response from method Devices.ListBySubscription.
type DevicesListBySubscriptionResponse struct {
	DevicesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesListBySubscriptionResult contains the result from method Devices.ListBySubscription.
type DevicesListBySubscriptionResult struct {
	DeviceListResult
}

// DevicesListRegistrationKeyResponse contains the response from method Devices.ListRegistrationKey.
type DevicesListRegistrationKeyResponse struct {
	DevicesListRegistrationKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesListRegistrationKeyResult contains the result from method Devices.ListRegistrationKey.
type DevicesListRegistrationKeyResult struct {
	DeviceRegistrationKey
}

// DevicesUpdateTagsResponse contains the response from method Devices.UpdateTags.
type DevicesUpdateTagsResponse struct {
	DevicesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DevicesUpdateTagsResult contains the result from method Devices.UpdateTags.
type DevicesUpdateTagsResult struct {
	Device
}

// NetworkFunctionVendorSKUsListBySKUResponse contains the response from method NetworkFunctionVendorSKUs.ListBySKU.
type NetworkFunctionVendorSKUsListBySKUResponse struct {
	NetworkFunctionVendorSKUsListBySKUResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionVendorSKUsListBySKUResult contains the result from method NetworkFunctionVendorSKUs.ListBySKU.
type NetworkFunctionVendorSKUsListBySKUResult struct {
	NetworkFunctionSKUDetails
}

// NetworkFunctionVendorSKUsListByVendorResponse contains the response from method NetworkFunctionVendorSKUs.ListByVendor.
type NetworkFunctionVendorSKUsListByVendorResponse struct {
	NetworkFunctionVendorSKUsListByVendorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionVendorSKUsListByVendorResult contains the result from method NetworkFunctionVendorSKUs.ListByVendor.
type NetworkFunctionVendorSKUsListByVendorResult struct {
	NetworkFunctionSKUListResult
}

// NetworkFunctionVendorsListResponse contains the response from method NetworkFunctionVendors.List.
type NetworkFunctionVendorsListResponse struct {
	NetworkFunctionVendorsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionVendorsListResult contains the result from method NetworkFunctionVendors.List.
type NetworkFunctionVendorsListResult struct {
	NetworkFunctionVendorListResult
}

// NetworkFunctionsCreateOrUpdatePollerResponse contains the response from method NetworkFunctions.CreateOrUpdate.
type NetworkFunctionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkFunctionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkFunctionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkFunctionsCreateOrUpdateResponse, error) {
	respType := NetworkFunctionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkFunction)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkFunctionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkFunctionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkFunctionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkFunctionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkFunctionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkFunctionsCreateOrUpdateResponse contains the response from method NetworkFunctions.CreateOrUpdate.
type NetworkFunctionsCreateOrUpdateResponse struct {
	NetworkFunctionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionsCreateOrUpdateResult contains the result from method NetworkFunctions.CreateOrUpdate.
type NetworkFunctionsCreateOrUpdateResult struct {
	NetworkFunction
}

// NetworkFunctionsDeletePollerResponse contains the response from method NetworkFunctions.Delete.
type NetworkFunctionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkFunctionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkFunctionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkFunctionsDeleteResponse, error) {
	respType := NetworkFunctionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkFunctionsDeletePollerResponse from the provided client and resume token.
func (l *NetworkFunctionsDeletePollerResponse) Resume(ctx context.Context, client *NetworkFunctionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkFunctionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkFunctionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkFunctionsDeleteResponse contains the response from method NetworkFunctions.Delete.
type NetworkFunctionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionsGetResponse contains the response from method NetworkFunctions.Get.
type NetworkFunctionsGetResponse struct {
	NetworkFunctionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionsGetResult contains the result from method NetworkFunctions.Get.
type NetworkFunctionsGetResult struct {
	NetworkFunction
}

// NetworkFunctionsListByResourceGroupResponse contains the response from method NetworkFunctions.ListByResourceGroup.
type NetworkFunctionsListByResourceGroupResponse struct {
	NetworkFunctionsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionsListByResourceGroupResult contains the result from method NetworkFunctions.ListByResourceGroup.
type NetworkFunctionsListByResourceGroupResult struct {
	NetworkFunctionListResult
}

// NetworkFunctionsListBySubscriptionResponse contains the response from method NetworkFunctions.ListBySubscription.
type NetworkFunctionsListBySubscriptionResponse struct {
	NetworkFunctionsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionsListBySubscriptionResult contains the result from method NetworkFunctions.ListBySubscription.
type NetworkFunctionsListBySubscriptionResult struct {
	NetworkFunctionListResult
}

// NetworkFunctionsUpdateTagsResponse contains the response from method NetworkFunctions.UpdateTags.
type NetworkFunctionsUpdateTagsResponse struct {
	NetworkFunctionsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkFunctionsUpdateTagsResult contains the result from method NetworkFunctions.UpdateTags.
type NetworkFunctionsUpdateTagsResult struct {
	NetworkFunction
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationList
}

// RoleInstancesGetResponse contains the response from method RoleInstances.Get.
type RoleInstancesGetResponse struct {
	RoleInstancesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoleInstancesGetResult contains the result from method RoleInstances.Get.
type RoleInstancesGetResult struct {
	RoleInstance
}

// RoleInstancesListResponse contains the response from method RoleInstances.List.
type RoleInstancesListResponse struct {
	RoleInstancesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoleInstancesListResult contains the result from method RoleInstances.List.
type RoleInstancesListResult struct {
	NetworkFunctionRoleInstanceListResult
}

// RoleInstancesRestartPollerResponse contains the response from method RoleInstances.Restart.
type RoleInstancesRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoleInstancesRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoleInstancesRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoleInstancesRestartResponse, error) {
	respType := RoleInstancesRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoleInstancesRestartPollerResponse from the provided client and resume token.
func (l *RoleInstancesRestartPollerResponse) Resume(ctx context.Context, client *RoleInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoleInstancesClient.Restart", token, client.pl, client.restartHandleError)
	if err != nil {
		return err
	}
	poller := &RoleInstancesRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoleInstancesRestartResponse contains the response from method RoleInstances.Restart.
type RoleInstancesRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoleInstancesStartPollerResponse contains the response from method RoleInstances.Start.
type RoleInstancesStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoleInstancesStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoleInstancesStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoleInstancesStartResponse, error) {
	respType := RoleInstancesStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoleInstancesStartPollerResponse from the provided client and resume token.
func (l *RoleInstancesStartPollerResponse) Resume(ctx context.Context, client *RoleInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoleInstancesClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &RoleInstancesStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoleInstancesStartResponse contains the response from method RoleInstances.Start.
type RoleInstancesStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoleInstancesStopPollerResponse contains the response from method RoleInstances.Stop.
type RoleInstancesStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoleInstancesStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoleInstancesStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoleInstancesStopResponse, error) {
	respType := RoleInstancesStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoleInstancesStopPollerResponse from the provided client and resume token.
func (l *RoleInstancesStopPollerResponse) Resume(ctx context.Context, client *RoleInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoleInstancesClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &RoleInstancesStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoleInstancesStopResponse contains the response from method RoleInstances.Stop.
type RoleInstancesStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorNetworkFunctionsCreateOrUpdatePollerResponse contains the response from method VendorNetworkFunctions.CreateOrUpdate.
type VendorNetworkFunctionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorNetworkFunctionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorNetworkFunctionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorNetworkFunctionsCreateOrUpdateResponse, error) {
	respType := VendorNetworkFunctionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VendorNetworkFunction)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorNetworkFunctionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VendorNetworkFunctionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VendorNetworkFunctionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorNetworkFunctionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VendorNetworkFunctionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorNetworkFunctionsCreateOrUpdateResponse contains the response from method VendorNetworkFunctions.CreateOrUpdate.
type VendorNetworkFunctionsCreateOrUpdateResponse struct {
	VendorNetworkFunctionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorNetworkFunctionsCreateOrUpdateResult contains the result from method VendorNetworkFunctions.CreateOrUpdate.
type VendorNetworkFunctionsCreateOrUpdateResult struct {
	VendorNetworkFunction
}

// VendorNetworkFunctionsGetResponse contains the response from method VendorNetworkFunctions.Get.
type VendorNetworkFunctionsGetResponse struct {
	VendorNetworkFunctionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorNetworkFunctionsGetResult contains the result from method VendorNetworkFunctions.Get.
type VendorNetworkFunctionsGetResult struct {
	VendorNetworkFunction
}

// VendorNetworkFunctionsListResponse contains the response from method VendorNetworkFunctions.List.
type VendorNetworkFunctionsListResponse struct {
	VendorNetworkFunctionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorNetworkFunctionsListResult contains the result from method VendorNetworkFunctions.List.
type VendorNetworkFunctionsListResult struct {
	VendorNetworkFunctionListResult
}

// VendorSKUPreviewCreateOrUpdatePollerResponse contains the response from method VendorSKUPreview.CreateOrUpdate.
type VendorSKUPreviewCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorSKUPreviewCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorSKUPreviewCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorSKUPreviewCreateOrUpdateResponse, error) {
	respType := VendorSKUPreviewCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PreviewSubscription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorSKUPreviewCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VendorSKUPreviewCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VendorSKUPreviewClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorSKUPreviewClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VendorSKUPreviewCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorSKUPreviewCreateOrUpdateResponse contains the response from method VendorSKUPreview.CreateOrUpdate.
type VendorSKUPreviewCreateOrUpdateResponse struct {
	VendorSKUPreviewCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUPreviewCreateOrUpdateResult contains the result from method VendorSKUPreview.CreateOrUpdate.
type VendorSKUPreviewCreateOrUpdateResult struct {
	PreviewSubscription
}

// VendorSKUPreviewDeletePollerResponse contains the response from method VendorSKUPreview.Delete.
type VendorSKUPreviewDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorSKUPreviewDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorSKUPreviewDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorSKUPreviewDeleteResponse, error) {
	respType := VendorSKUPreviewDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorSKUPreviewDeletePollerResponse from the provided client and resume token.
func (l *VendorSKUPreviewDeletePollerResponse) Resume(ctx context.Context, client *VendorSKUPreviewClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorSKUPreviewClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VendorSKUPreviewDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorSKUPreviewDeleteResponse contains the response from method VendorSKUPreview.Delete.
type VendorSKUPreviewDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUPreviewGetResponse contains the response from method VendorSKUPreview.Get.
type VendorSKUPreviewGetResponse struct {
	VendorSKUPreviewGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUPreviewGetResult contains the result from method VendorSKUPreview.Get.
type VendorSKUPreviewGetResult struct {
	PreviewSubscription
}

// VendorSKUPreviewListResponse contains the response from method VendorSKUPreview.List.
type VendorSKUPreviewListResponse struct {
	VendorSKUPreviewListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUPreviewListResult contains the result from method VendorSKUPreview.List.
type VendorSKUPreviewListResult struct {
	PreviewSubscriptionsList
}

// VendorSKUsCreateOrUpdatePollerResponse contains the response from method VendorSKUs.CreateOrUpdate.
type VendorSKUsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorSKUsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorSKUsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorSKUsCreateOrUpdateResponse, error) {
	respType := VendorSKUsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VendorSKU)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorSKUsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VendorSKUsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VendorSKUsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorSKUsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VendorSKUsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorSKUsCreateOrUpdateResponse contains the response from method VendorSKUs.CreateOrUpdate.
type VendorSKUsCreateOrUpdateResponse struct {
	VendorSKUsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUsCreateOrUpdateResult contains the result from method VendorSKUs.CreateOrUpdate.
type VendorSKUsCreateOrUpdateResult struct {
	VendorSKU
}

// VendorSKUsDeletePollerResponse contains the response from method VendorSKUs.Delete.
type VendorSKUsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorSKUsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorSKUsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorSKUsDeleteResponse, error) {
	respType := VendorSKUsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorSKUsDeletePollerResponse from the provided client and resume token.
func (l *VendorSKUsDeletePollerResponse) Resume(ctx context.Context, client *VendorSKUsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorSKUsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VendorSKUsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorSKUsDeleteResponse contains the response from method VendorSKUs.Delete.
type VendorSKUsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUsGetResponse contains the response from method VendorSKUs.Get.
type VendorSKUsGetResponse struct {
	VendorSKUsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUsGetResult contains the result from method VendorSKUs.Get.
type VendorSKUsGetResult struct {
	VendorSKU
}

// VendorSKUsListResponse contains the response from method VendorSKUs.List.
type VendorSKUsListResponse struct {
	VendorSKUsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorSKUsListResult contains the result from method VendorSKUs.List.
type VendorSKUsListResult struct {
	VendorSKUListResult
}

// VendorsCreateOrUpdatePollerResponse contains the response from method Vendors.CreateOrUpdate.
type VendorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorsCreateOrUpdateResponse, error) {
	respType := VendorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Vendor)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VendorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VendorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VendorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorsCreateOrUpdateResponse contains the response from method Vendors.CreateOrUpdate.
type VendorsCreateOrUpdateResponse struct {
	VendorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorsCreateOrUpdateResult contains the result from method Vendors.CreateOrUpdate.
type VendorsCreateOrUpdateResult struct {
	Vendor
}

// VendorsDeletePollerResponse contains the response from method Vendors.Delete.
type VendorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VendorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VendorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VendorsDeleteResponse, error) {
	respType := VendorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VendorsDeletePollerResponse from the provided client and resume token.
func (l *VendorsDeletePollerResponse) Resume(ctx context.Context, client *VendorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VendorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VendorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VendorsDeleteResponse contains the response from method Vendors.Delete.
type VendorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorsGetResponse contains the response from method Vendors.Get.
type VendorsGetResponse struct {
	VendorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorsGetResult contains the result from method Vendors.Get.
type VendorsGetResult struct {
	Vendor
}

// VendorsListBySubscriptionResponse contains the response from method Vendors.ListBySubscription.
type VendorsListBySubscriptionResponse struct {
	VendorsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VendorsListBySubscriptionResult contains the result from method Vendors.ListBySubscription.
type VendorsListBySubscriptionResult struct {
	VendorListResult
}
