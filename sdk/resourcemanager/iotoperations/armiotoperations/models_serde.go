// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armiotoperations

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime/datetime"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type AdvancedSettings.
func (a AdvancedSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clients", a.Clients)
	populate(objectMap, "encryptInternalTraffic", a.EncryptInternalTraffic)
	populate(objectMap, "internalCerts", a.InternalCerts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdvancedSettings.
func (a *AdvancedSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clients":
			err = unpopulate(val, "Clients", &a.Clients)
			delete(rawMsg, key)
		case "encryptInternalTraffic":
			err = unpopulate(val, "EncryptInternalTraffic", &a.EncryptInternalTraffic)
			delete(rawMsg, key)
		case "internalCerts":
			err = unpopulate(val, "InternalCerts", &a.InternalCerts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthorizationConfig.
func (a AuthorizationConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cache", a.Cache)
	populate(objectMap, "rules", a.Rules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthorizationConfig.
func (a *AuthorizationConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cache":
			err = unpopulate(val, "Cache", &a.Cache)
			delete(rawMsg, key)
		case "rules":
			err = unpopulate(val, "Rules", &a.Rules)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthorizationRule.
func (a AuthorizationRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "brokerResources", a.BrokerResources)
	populate(objectMap, "principals", a.Principals)
	populate(objectMap, "stateStoreResources", a.StateStoreResources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthorizationRule.
func (a *AuthorizationRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "brokerResources":
			err = unpopulate(val, "BrokerResources", &a.BrokerResources)
			delete(rawMsg, key)
		case "principals":
			err = unpopulate(val, "Principals", &a.Principals)
			delete(rawMsg, key)
		case "stateStoreResources":
			err = unpopulate(val, "StateStoreResources", &a.StateStoreResources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackendChain.
func (b BackendChain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "partitions", b.Partitions)
	populate(objectMap, "redundancyFactor", b.RedundancyFactor)
	populate(objectMap, "workers", b.Workers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackendChain.
func (b *BackendChain) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitions":
			err = unpopulate(val, "Partitions", &b.Partitions)
			delete(rawMsg, key)
		case "redundancyFactor":
			err = unpopulate(val, "RedundancyFactor", &b.RedundancyFactor)
			delete(rawMsg, key)
		case "workers":
			err = unpopulate(val, "Workers", &b.Workers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchingConfiguration.
func (b BatchingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "latencySeconds", b.LatencySeconds)
	populate(objectMap, "maxMessages", b.MaxMessages)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchingConfiguration.
func (b *BatchingConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "latencySeconds":
			err = unpopulate(val, "LatencySeconds", &b.LatencySeconds)
			delete(rawMsg, key)
		case "maxMessages":
			err = unpopulate(val, "MaxMessages", &b.MaxMessages)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticationProperties.
func (b BrokerAuthenticationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationMethods", b.AuthenticationMethods)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticationProperties.
func (b *BrokerAuthenticationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationMethods":
			err = unpopulate(val, "AuthenticationMethods", &b.AuthenticationMethods)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticationResource.
func (b BrokerAuthenticationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", b.ExtendedLocation)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticationResource.
func (b *BrokerAuthenticationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &b.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &b.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticationResourceListResult.
func (b BrokerAuthenticationResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticationResourceListResult.
func (b *BrokerAuthenticationResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &b.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticatorCustomAuth.
func (b BrokerAuthenticatorCustomAuth) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "x509", b.X509)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticatorCustomAuth.
func (b *BrokerAuthenticatorCustomAuth) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "x509":
			err = unpopulate(val, "X509", &b.X509)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticatorMethodCustom.
func (b BrokerAuthenticatorMethodCustom) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "auth", b.Auth)
	populate(objectMap, "caCertConfigMap", b.CaCertConfigMap)
	populate(objectMap, "endpoint", b.Endpoint)
	populate(objectMap, "headers", b.Headers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticatorMethodCustom.
func (b *BrokerAuthenticatorMethodCustom) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "auth":
			err = unpopulate(val, "Auth", &b.Auth)
			delete(rawMsg, key)
		case "caCertConfigMap":
			err = unpopulate(val, "CaCertConfigMap", &b.CaCertConfigMap)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &b.Endpoint)
			delete(rawMsg, key)
		case "headers":
			err = unpopulate(val, "Headers", &b.Headers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticatorMethodSat.
func (b BrokerAuthenticatorMethodSat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "audiences", b.Audiences)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticatorMethodSat.
func (b *BrokerAuthenticatorMethodSat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audiences":
			err = unpopulate(val, "Audiences", &b.Audiences)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticatorMethodX509.
func (b BrokerAuthenticatorMethodX509) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authorizationAttributes", b.AuthorizationAttributes)
	populate(objectMap, "trustedClientCaCert", b.TrustedClientCaCert)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticatorMethodX509.
func (b *BrokerAuthenticatorMethodX509) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationAttributes":
			err = unpopulate(val, "AuthorizationAttributes", &b.AuthorizationAttributes)
			delete(rawMsg, key)
		case "trustedClientCaCert":
			err = unpopulate(val, "TrustedClientCaCert", &b.TrustedClientCaCert)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticatorMethodX509Attributes.
func (b BrokerAuthenticatorMethodX509Attributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attributes", b.Attributes)
	populate(objectMap, "subject", b.Subject)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticatorMethodX509Attributes.
func (b *BrokerAuthenticatorMethodX509Attributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, "Attributes", &b.Attributes)
			delete(rawMsg, key)
		case "subject":
			err = unpopulate(val, "Subject", &b.Subject)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthenticatorMethods.
func (b BrokerAuthenticatorMethods) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customSettings", b.CustomSettings)
	populate(objectMap, "method", b.Method)
	populate(objectMap, "serviceAccountTokenSettings", b.ServiceAccountTokenSettings)
	populate(objectMap, "x509Settings", b.X509Settings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthenticatorMethods.
func (b *BrokerAuthenticatorMethods) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customSettings":
			err = unpopulate(val, "CustomSettings", &b.CustomSettings)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &b.Method)
			delete(rawMsg, key)
		case "serviceAccountTokenSettings":
			err = unpopulate(val, "ServiceAccountTokenSettings", &b.ServiceAccountTokenSettings)
			delete(rawMsg, key)
		case "x509Settings":
			err = unpopulate(val, "X509Settings", &b.X509Settings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthorizationProperties.
func (b BrokerAuthorizationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authorizationPolicies", b.AuthorizationPolicies)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthorizationProperties.
func (b *BrokerAuthorizationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationPolicies":
			err = unpopulate(val, "AuthorizationPolicies", &b.AuthorizationPolicies)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthorizationResource.
func (b BrokerAuthorizationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", b.ExtendedLocation)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthorizationResource.
func (b *BrokerAuthorizationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &b.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &b.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerAuthorizationResourceListResult.
func (b BrokerAuthorizationResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerAuthorizationResourceListResult.
func (b *BrokerAuthorizationResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &b.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerDiagnostics.
func (b BrokerDiagnostics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logs", b.Logs)
	populate(objectMap, "metrics", b.Metrics)
	populate(objectMap, "selfCheck", b.SelfCheck)
	populate(objectMap, "traces", b.Traces)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerDiagnostics.
func (b *BrokerDiagnostics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logs":
			err = unpopulate(val, "Logs", &b.Logs)
			delete(rawMsg, key)
		case "metrics":
			err = unpopulate(val, "Metrics", &b.Metrics)
			delete(rawMsg, key)
		case "selfCheck":
			err = unpopulate(val, "SelfCheck", &b.SelfCheck)
			delete(rawMsg, key)
		case "traces":
			err = unpopulate(val, "Traces", &b.Traces)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerListenerProperties.
func (b BrokerListenerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ports", b.Ports)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "serviceName", b.ServiceName)
	populate(objectMap, "serviceType", b.ServiceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerListenerProperties.
func (b *BrokerListenerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ports":
			err = unpopulate(val, "Ports", &b.Ports)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		case "serviceName":
			err = unpopulate(val, "ServiceName", &b.ServiceName)
			delete(rawMsg, key)
		case "serviceType":
			err = unpopulate(val, "ServiceType", &b.ServiceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerListenerResource.
func (b BrokerListenerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", b.ExtendedLocation)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerListenerResource.
func (b *BrokerListenerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &b.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &b.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerListenerResourceListResult.
func (b BrokerListenerResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerListenerResourceListResult.
func (b *BrokerListenerResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &b.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerProperties.
func (b BrokerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "advanced", b.Advanced)
	populate(objectMap, "cardinality", b.Cardinality)
	populate(objectMap, "diagnostics", b.Diagnostics)
	populate(objectMap, "diskBackedMessageBuffer", b.DiskBackedMessageBuffer)
	populate(objectMap, "generateResourceLimits", b.GenerateResourceLimits)
	populate(objectMap, "memoryProfile", b.MemoryProfile)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerProperties.
func (b *BrokerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advanced":
			err = unpopulate(val, "Advanced", &b.Advanced)
			delete(rawMsg, key)
		case "cardinality":
			err = unpopulate(val, "Cardinality", &b.Cardinality)
			delete(rawMsg, key)
		case "diagnostics":
			err = unpopulate(val, "Diagnostics", &b.Diagnostics)
			delete(rawMsg, key)
		case "diskBackedMessageBuffer":
			err = unpopulate(val, "DiskBackedMessageBuffer", &b.DiskBackedMessageBuffer)
			delete(rawMsg, key)
		case "generateResourceLimits":
			err = unpopulate(val, "GenerateResourceLimits", &b.GenerateResourceLimits)
			delete(rawMsg, key)
		case "memoryProfile":
			err = unpopulate(val, "MemoryProfile", &b.MemoryProfile)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerResource.
func (b BrokerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", b.ExtendedLocation)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerResource.
func (b *BrokerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &b.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &b.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerResourceListResult.
func (b BrokerResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerResourceListResult.
func (b *BrokerResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &b.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BrokerResourceRule.
func (b BrokerResourceRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientIds", b.ClientIDs)
	populate(objectMap, "method", b.Method)
	populate(objectMap, "topics", b.Topics)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BrokerResourceRule.
func (b *BrokerResourceRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientIds":
			err = unpopulate(val, "ClientIDs", &b.ClientIDs)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &b.Method)
			delete(rawMsg, key)
		case "topics":
			err = unpopulate(val, "Topics", &b.Topics)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Cardinality.
func (c Cardinality) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendChain", c.BackendChain)
	populate(objectMap, "frontend", c.Frontend)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Cardinality.
func (c *Cardinality) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendChain":
			err = unpopulate(val, "BackendChain", &c.BackendChain)
			delete(rawMsg, key)
		case "frontend":
			err = unpopulate(val, "Frontend", &c.Frontend)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertManagerCertOptions.
func (c CertManagerCertOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", c.Duration)
	populate(objectMap, "privateKey", c.PrivateKey)
	populate(objectMap, "renewBefore", c.RenewBefore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertManagerCertOptions.
func (c *CertManagerCertOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &c.Duration)
			delete(rawMsg, key)
		case "privateKey":
			err = unpopulate(val, "PrivateKey", &c.PrivateKey)
			delete(rawMsg, key)
		case "renewBefore":
			err = unpopulate(val, "RenewBefore", &c.RenewBefore)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertManagerCertificateSpec.
func (c CertManagerCertificateSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", c.Duration)
	populate(objectMap, "issuerRef", c.IssuerRef)
	populate(objectMap, "privateKey", c.PrivateKey)
	populate(objectMap, "renewBefore", c.RenewBefore)
	populate(objectMap, "san", c.San)
	populate(objectMap, "secretName", c.SecretName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertManagerCertificateSpec.
func (c *CertManagerCertificateSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &c.Duration)
			delete(rawMsg, key)
		case "issuerRef":
			err = unpopulate(val, "IssuerRef", &c.IssuerRef)
			delete(rawMsg, key)
		case "privateKey":
			err = unpopulate(val, "PrivateKey", &c.PrivateKey)
			delete(rawMsg, key)
		case "renewBefore":
			err = unpopulate(val, "RenewBefore", &c.RenewBefore)
			delete(rawMsg, key)
		case "san":
			err = unpopulate(val, "San", &c.San)
			delete(rawMsg, key)
		case "secretName":
			err = unpopulate(val, "SecretName", &c.SecretName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertManagerIssuerRef.
func (c CertManagerIssuerRef) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "group", c.Group)
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "name", c.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertManagerIssuerRef.
func (c *CertManagerIssuerRef) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "group":
			err = unpopulate(val, "Group", &c.Group)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertManagerPrivateKey.
func (c CertManagerPrivateKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "algorithm", c.Algorithm)
	populate(objectMap, "rotationPolicy", c.RotationPolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertManagerPrivateKey.
func (c *CertManagerPrivateKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "algorithm":
			err = unpopulate(val, "Algorithm", &c.Algorithm)
			delete(rawMsg, key)
		case "rotationPolicy":
			err = unpopulate(val, "RotationPolicy", &c.RotationPolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClientConfig.
func (c ClientConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxKeepAliveSeconds", c.MaxKeepAliveSeconds)
	populate(objectMap, "maxMessageExpirySeconds", c.MaxMessageExpirySeconds)
	populate(objectMap, "maxPacketSizeBytes", c.MaxPacketSizeBytes)
	populate(objectMap, "maxReceiveMaximum", c.MaxReceiveMaximum)
	populate(objectMap, "maxSessionExpirySeconds", c.MaxSessionExpirySeconds)
	populate(objectMap, "subscriberQueueLimit", c.SubscriberQueueLimit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientConfig.
func (c *ClientConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxKeepAliveSeconds":
			err = unpopulate(val, "MaxKeepAliveSeconds", &c.MaxKeepAliveSeconds)
			delete(rawMsg, key)
		case "maxMessageExpirySeconds":
			err = unpopulate(val, "MaxMessageExpirySeconds", &c.MaxMessageExpirySeconds)
			delete(rawMsg, key)
		case "maxPacketSizeBytes":
			err = unpopulate(val, "MaxPacketSizeBytes", &c.MaxPacketSizeBytes)
			delete(rawMsg, key)
		case "maxReceiveMaximum":
			err = unpopulate(val, "MaxReceiveMaximum", &c.MaxReceiveMaximum)
			delete(rawMsg, key)
		case "maxSessionExpirySeconds":
			err = unpopulate(val, "MaxSessionExpirySeconds", &c.MaxSessionExpirySeconds)
			delete(rawMsg, key)
		case "subscriberQueueLimit":
			err = unpopulate(val, "SubscriberQueueLimit", &c.SubscriberQueueLimit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowBuiltInTransformationDataset.
func (d DataflowBuiltInTransformationDataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "expression", d.Expression)
	populate(objectMap, "inputs", d.Inputs)
	populate(objectMap, "key", d.Key)
	populate(objectMap, "schemaRef", d.SchemaRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowBuiltInTransformationDataset.
func (d *DataflowBuiltInTransformationDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, "Expression", &d.Expression)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, "Inputs", &d.Inputs)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, "Key", &d.Key)
			delete(rawMsg, key)
		case "schemaRef":
			err = unpopulate(val, "SchemaRef", &d.SchemaRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowBuiltInTransformationFilter.
func (d DataflowBuiltInTransformationFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "expression", d.Expression)
	populate(objectMap, "inputs", d.Inputs)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowBuiltInTransformationFilter.
func (d *DataflowBuiltInTransformationFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, "Expression", &d.Expression)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, "Inputs", &d.Inputs)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowBuiltInTransformationMap.
func (d DataflowBuiltInTransformationMap) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "expression", d.Expression)
	populate(objectMap, "inputs", d.Inputs)
	populate(objectMap, "output", d.Output)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowBuiltInTransformationMap.
func (d *DataflowBuiltInTransformationMap) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "expression":
			err = unpopulate(val, "Expression", &d.Expression)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, "Inputs", &d.Inputs)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, "Output", &d.Output)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowBuiltInTransformationSettings.
func (d DataflowBuiltInTransformationSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "datasets", d.Datasets)
	populate(objectMap, "filter", d.Filter)
	populate(objectMap, "map", d.Map)
	populate(objectMap, "schemaRef", d.SchemaRef)
	populate(objectMap, "serializationFormat", d.SerializationFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowBuiltInTransformationSettings.
func (d *DataflowBuiltInTransformationSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasets":
			err = unpopulate(val, "Datasets", &d.Datasets)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &d.Filter)
			delete(rawMsg, key)
		case "map":
			err = unpopulate(val, "Map", &d.Map)
			delete(rawMsg, key)
		case "schemaRef":
			err = unpopulate(val, "SchemaRef", &d.SchemaRef)
			delete(rawMsg, key)
		case "serializationFormat":
			err = unpopulate(val, "SerializationFormat", &d.SerializationFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowDestinationOperationSettings.
func (d DataflowDestinationOperationSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataDestination", d.DataDestination)
	populate(objectMap, "endpointRef", d.EndpointRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowDestinationOperationSettings.
func (d *DataflowDestinationOperationSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataDestination":
			err = unpopulate(val, "DataDestination", &d.DataDestination)
			delete(rawMsg, key)
		case "endpointRef":
			err = unpopulate(val, "EndpointRef", &d.EndpointRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointAuthenticationAccessToken.
func (d DataflowEndpointAuthenticationAccessToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretRef", d.SecretRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointAuthenticationAccessToken.
func (d *DataflowEndpointAuthenticationAccessToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretRef":
			err = unpopulate(val, "SecretRef", &d.SecretRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointAuthenticationSasl.
func (d DataflowEndpointAuthenticationSasl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "saslType", d.SaslType)
	populate(objectMap, "secretRef", d.SecretRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointAuthenticationSasl.
func (d *DataflowEndpointAuthenticationSasl) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "saslType":
			err = unpopulate(val, "SaslType", &d.SaslType)
			delete(rawMsg, key)
		case "secretRef":
			err = unpopulate(val, "SecretRef", &d.SecretRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointAuthenticationServiceAccountToken.
func (d DataflowEndpointAuthenticationServiceAccountToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "audience", d.Audience)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointAuthenticationServiceAccountToken.
func (d *DataflowEndpointAuthenticationServiceAccountToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audience":
			err = unpopulate(val, "Audience", &d.Audience)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointAuthenticationSystemAssignedManagedIdentity.
func (d DataflowEndpointAuthenticationSystemAssignedManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "audience", d.Audience)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointAuthenticationSystemAssignedManagedIdentity.
func (d *DataflowEndpointAuthenticationSystemAssignedManagedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audience":
			err = unpopulate(val, "Audience", &d.Audience)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointAuthenticationUserAssignedManagedIdentity.
func (d DataflowEndpointAuthenticationUserAssignedManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", d.ClientID)
	populate(objectMap, "scope", d.Scope)
	populate(objectMap, "tenantId", d.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointAuthenticationUserAssignedManagedIdentity.
func (d *DataflowEndpointAuthenticationUserAssignedManagedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &d.ClientID)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &d.Scope)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &d.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointAuthenticationX509.
func (d DataflowEndpointAuthenticationX509) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretRef", d.SecretRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointAuthenticationX509.
func (d *DataflowEndpointAuthenticationX509) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretRef":
			err = unpopulate(val, "SecretRef", &d.SecretRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointDataExplorer.
func (d DataflowEndpointDataExplorer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", d.Authentication)
	populate(objectMap, "batching", d.Batching)
	populate(objectMap, "database", d.Database)
	populate(objectMap, "host", d.Host)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointDataExplorer.
func (d *DataflowEndpointDataExplorer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &d.Authentication)
			delete(rawMsg, key)
		case "batching":
			err = unpopulate(val, "Batching", &d.Batching)
			delete(rawMsg, key)
		case "database":
			err = unpopulate(val, "Database", &d.Database)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &d.Host)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointDataExplorerAuthentication.
func (d DataflowEndpointDataExplorerAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "method", d.Method)
	populate(objectMap, "systemAssignedManagedIdentitySettings", d.SystemAssignedManagedIdentitySettings)
	populate(objectMap, "userAssignedManagedIdentitySettings", d.UserAssignedManagedIdentitySettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointDataExplorerAuthentication.
func (d *DataflowEndpointDataExplorerAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "method":
			err = unpopulate(val, "Method", &d.Method)
			delete(rawMsg, key)
		case "systemAssignedManagedIdentitySettings":
			err = unpopulate(val, "SystemAssignedManagedIdentitySettings", &d.SystemAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "userAssignedManagedIdentitySettings":
			err = unpopulate(val, "UserAssignedManagedIdentitySettings", &d.UserAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointDataLakeStorage.
func (d DataflowEndpointDataLakeStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", d.Authentication)
	populate(objectMap, "batching", d.Batching)
	populate(objectMap, "host", d.Host)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointDataLakeStorage.
func (d *DataflowEndpointDataLakeStorage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &d.Authentication)
			delete(rawMsg, key)
		case "batching":
			err = unpopulate(val, "Batching", &d.Batching)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &d.Host)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointDataLakeStorageAuthentication.
func (d DataflowEndpointDataLakeStorageAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessTokenSettings", d.AccessTokenSettings)
	populate(objectMap, "method", d.Method)
	populate(objectMap, "systemAssignedManagedIdentitySettings", d.SystemAssignedManagedIdentitySettings)
	populate(objectMap, "userAssignedManagedIdentitySettings", d.UserAssignedManagedIdentitySettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointDataLakeStorageAuthentication.
func (d *DataflowEndpointDataLakeStorageAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTokenSettings":
			err = unpopulate(val, "AccessTokenSettings", &d.AccessTokenSettings)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &d.Method)
			delete(rawMsg, key)
		case "systemAssignedManagedIdentitySettings":
			err = unpopulate(val, "SystemAssignedManagedIdentitySettings", &d.SystemAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "userAssignedManagedIdentitySettings":
			err = unpopulate(val, "UserAssignedManagedIdentitySettings", &d.UserAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointFabricOneLake.
func (d DataflowEndpointFabricOneLake) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", d.Authentication)
	populate(objectMap, "batching", d.Batching)
	populate(objectMap, "host", d.Host)
	populate(objectMap, "names", d.Names)
	populate(objectMap, "oneLakePathType", d.OneLakePathType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointFabricOneLake.
func (d *DataflowEndpointFabricOneLake) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &d.Authentication)
			delete(rawMsg, key)
		case "batching":
			err = unpopulate(val, "Batching", &d.Batching)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &d.Host)
			delete(rawMsg, key)
		case "names":
			err = unpopulate(val, "Names", &d.Names)
			delete(rawMsg, key)
		case "oneLakePathType":
			err = unpopulate(val, "OneLakePathType", &d.OneLakePathType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointFabricOneLakeAuthentication.
func (d DataflowEndpointFabricOneLakeAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "method", d.Method)
	populate(objectMap, "systemAssignedManagedIdentitySettings", d.SystemAssignedManagedIdentitySettings)
	populate(objectMap, "userAssignedManagedIdentitySettings", d.UserAssignedManagedIdentitySettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointFabricOneLakeAuthentication.
func (d *DataflowEndpointFabricOneLakeAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "method":
			err = unpopulate(val, "Method", &d.Method)
			delete(rawMsg, key)
		case "systemAssignedManagedIdentitySettings":
			err = unpopulate(val, "SystemAssignedManagedIdentitySettings", &d.SystemAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "userAssignedManagedIdentitySettings":
			err = unpopulate(val, "UserAssignedManagedIdentitySettings", &d.UserAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointFabricOneLakeNames.
func (d DataflowEndpointFabricOneLakeNames) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lakehouseName", d.LakehouseName)
	populate(objectMap, "workspaceName", d.WorkspaceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointFabricOneLakeNames.
func (d *DataflowEndpointFabricOneLakeNames) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lakehouseName":
			err = unpopulate(val, "LakehouseName", &d.LakehouseName)
			delete(rawMsg, key)
		case "workspaceName":
			err = unpopulate(val, "WorkspaceName", &d.WorkspaceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointKafka.
func (d DataflowEndpointKafka) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", d.Authentication)
	populate(objectMap, "batching", d.Batching)
	populate(objectMap, "cloudEventAttributes", d.CloudEventAttributes)
	populate(objectMap, "compression", d.Compression)
	populate(objectMap, "consumerGroupId", d.ConsumerGroupID)
	populate(objectMap, "copyMqttProperties", d.CopyMqttProperties)
	populate(objectMap, "host", d.Host)
	populate(objectMap, "kafkaAcks", d.KafkaAcks)
	populate(objectMap, "partitionStrategy", d.PartitionStrategy)
	populate(objectMap, "tls", d.TLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointKafka.
func (d *DataflowEndpointKafka) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &d.Authentication)
			delete(rawMsg, key)
		case "batching":
			err = unpopulate(val, "Batching", &d.Batching)
			delete(rawMsg, key)
		case "cloudEventAttributes":
			err = unpopulate(val, "CloudEventAttributes", &d.CloudEventAttributes)
			delete(rawMsg, key)
		case "compression":
			err = unpopulate(val, "Compression", &d.Compression)
			delete(rawMsg, key)
		case "consumerGroupId":
			err = unpopulate(val, "ConsumerGroupID", &d.ConsumerGroupID)
			delete(rawMsg, key)
		case "copyMqttProperties":
			err = unpopulate(val, "CopyMqttProperties", &d.CopyMqttProperties)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &d.Host)
			delete(rawMsg, key)
		case "kafkaAcks":
			err = unpopulate(val, "KafkaAcks", &d.KafkaAcks)
			delete(rawMsg, key)
		case "partitionStrategy":
			err = unpopulate(val, "PartitionStrategy", &d.PartitionStrategy)
			delete(rawMsg, key)
		case "tls":
			err = unpopulate(val, "TLS", &d.TLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointKafkaAuthentication.
func (d DataflowEndpointKafkaAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "method", d.Method)
	populate(objectMap, "saslSettings", d.SaslSettings)
	populate(objectMap, "systemAssignedManagedIdentitySettings", d.SystemAssignedManagedIdentitySettings)
	populate(objectMap, "userAssignedManagedIdentitySettings", d.UserAssignedManagedIdentitySettings)
	populate(objectMap, "x509CertificateSettings", d.X509CertificateSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointKafkaAuthentication.
func (d *DataflowEndpointKafkaAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "method":
			err = unpopulate(val, "Method", &d.Method)
			delete(rawMsg, key)
		case "saslSettings":
			err = unpopulate(val, "SaslSettings", &d.SaslSettings)
			delete(rawMsg, key)
		case "systemAssignedManagedIdentitySettings":
			err = unpopulate(val, "SystemAssignedManagedIdentitySettings", &d.SystemAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "userAssignedManagedIdentitySettings":
			err = unpopulate(val, "UserAssignedManagedIdentitySettings", &d.UserAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "x509CertificateSettings":
			err = unpopulate(val, "X509CertificateSettings", &d.X509CertificateSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointKafkaBatching.
func (d DataflowEndpointKafkaBatching) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "latencyMs", d.LatencyMs)
	populate(objectMap, "maxBytes", d.MaxBytes)
	populate(objectMap, "maxMessages", d.MaxMessages)
	populate(objectMap, "mode", d.Mode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointKafkaBatching.
func (d *DataflowEndpointKafkaBatching) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "latencyMs":
			err = unpopulate(val, "LatencyMs", &d.LatencyMs)
			delete(rawMsg, key)
		case "maxBytes":
			err = unpopulate(val, "MaxBytes", &d.MaxBytes)
			delete(rawMsg, key)
		case "maxMessages":
			err = unpopulate(val, "MaxMessages", &d.MaxMessages)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &d.Mode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointLocalStorage.
func (d DataflowEndpointLocalStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "persistentVolumeClaimRef", d.PersistentVolumeClaimRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointLocalStorage.
func (d *DataflowEndpointLocalStorage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "persistentVolumeClaimRef":
			err = unpopulate(val, "PersistentVolumeClaimRef", &d.PersistentVolumeClaimRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointMqtt.
func (d DataflowEndpointMqtt) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", d.Authentication)
	populate(objectMap, "clientIdPrefix", d.ClientIDPrefix)
	populate(objectMap, "cloudEventAttributes", d.CloudEventAttributes)
	populate(objectMap, "host", d.Host)
	populate(objectMap, "keepAliveSeconds", d.KeepAliveSeconds)
	populate(objectMap, "maxInflightMessages", d.MaxInflightMessages)
	populate(objectMap, "protocol", d.Protocol)
	populate(objectMap, "qos", d.Qos)
	populate(objectMap, "retain", d.Retain)
	populate(objectMap, "sessionExpirySeconds", d.SessionExpirySeconds)
	populate(objectMap, "tls", d.TLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointMqtt.
func (d *DataflowEndpointMqtt) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, "Authentication", &d.Authentication)
			delete(rawMsg, key)
		case "clientIdPrefix":
			err = unpopulate(val, "ClientIDPrefix", &d.ClientIDPrefix)
			delete(rawMsg, key)
		case "cloudEventAttributes":
			err = unpopulate(val, "CloudEventAttributes", &d.CloudEventAttributes)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, "Host", &d.Host)
			delete(rawMsg, key)
		case "keepAliveSeconds":
			err = unpopulate(val, "KeepAliveSeconds", &d.KeepAliveSeconds)
			delete(rawMsg, key)
		case "maxInflightMessages":
			err = unpopulate(val, "MaxInflightMessages", &d.MaxInflightMessages)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &d.Protocol)
			delete(rawMsg, key)
		case "qos":
			err = unpopulate(val, "Qos", &d.Qos)
			delete(rawMsg, key)
		case "retain":
			err = unpopulate(val, "Retain", &d.Retain)
			delete(rawMsg, key)
		case "sessionExpirySeconds":
			err = unpopulate(val, "SessionExpirySeconds", &d.SessionExpirySeconds)
			delete(rawMsg, key)
		case "tls":
			err = unpopulate(val, "TLS", &d.TLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointMqttAuthentication.
func (d DataflowEndpointMqttAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "method", d.Method)
	populate(objectMap, "serviceAccountTokenSettings", d.ServiceAccountTokenSettings)
	populate(objectMap, "systemAssignedManagedIdentitySettings", d.SystemAssignedManagedIdentitySettings)
	populate(objectMap, "userAssignedManagedIdentitySettings", d.UserAssignedManagedIdentitySettings)
	populate(objectMap, "x509CertificateSettings", d.X509CertificateSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointMqttAuthentication.
func (d *DataflowEndpointMqttAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "method":
			err = unpopulate(val, "Method", &d.Method)
			delete(rawMsg, key)
		case "serviceAccountTokenSettings":
			err = unpopulate(val, "ServiceAccountTokenSettings", &d.ServiceAccountTokenSettings)
			delete(rawMsg, key)
		case "systemAssignedManagedIdentitySettings":
			err = unpopulate(val, "SystemAssignedManagedIdentitySettings", &d.SystemAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "userAssignedManagedIdentitySettings":
			err = unpopulate(val, "UserAssignedManagedIdentitySettings", &d.UserAssignedManagedIdentitySettings)
			delete(rawMsg, key)
		case "x509CertificateSettings":
			err = unpopulate(val, "X509CertificateSettings", &d.X509CertificateSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointProperties.
func (d DataflowEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataExplorerSettings", d.DataExplorerSettings)
	populate(objectMap, "dataLakeStorageSettings", d.DataLakeStorageSettings)
	populate(objectMap, "endpointType", d.EndpointType)
	populate(objectMap, "fabricOneLakeSettings", d.FabricOneLakeSettings)
	populate(objectMap, "kafkaSettings", d.KafkaSettings)
	populate(objectMap, "localStorageSettings", d.LocalStorageSettings)
	populate(objectMap, "mqttSettings", d.MqttSettings)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointProperties.
func (d *DataflowEndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataExplorerSettings":
			err = unpopulate(val, "DataExplorerSettings", &d.DataExplorerSettings)
			delete(rawMsg, key)
		case "dataLakeStorageSettings":
			err = unpopulate(val, "DataLakeStorageSettings", &d.DataLakeStorageSettings)
			delete(rawMsg, key)
		case "endpointType":
			err = unpopulate(val, "EndpointType", &d.EndpointType)
			delete(rawMsg, key)
		case "fabricOneLakeSettings":
			err = unpopulate(val, "FabricOneLakeSettings", &d.FabricOneLakeSettings)
			delete(rawMsg, key)
		case "kafkaSettings":
			err = unpopulate(val, "KafkaSettings", &d.KafkaSettings)
			delete(rawMsg, key)
		case "localStorageSettings":
			err = unpopulate(val, "LocalStorageSettings", &d.LocalStorageSettings)
			delete(rawMsg, key)
		case "mqttSettings":
			err = unpopulate(val, "MqttSettings", &d.MqttSettings)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointResource.
func (d DataflowEndpointResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", d.ExtendedLocation)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointResource.
func (d *DataflowEndpointResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &d.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowEndpointResourceListResult.
func (d DataflowEndpointResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowEndpointResourceListResult.
func (d *DataflowEndpointResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowOperation.
func (d DataflowOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "builtInTransformationSettings", d.BuiltInTransformationSettings)
	populate(objectMap, "destinationSettings", d.DestinationSettings)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "operationType", d.OperationType)
	populate(objectMap, "sourceSettings", d.SourceSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowOperation.
func (d *DataflowOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "builtInTransformationSettings":
			err = unpopulate(val, "BuiltInTransformationSettings", &d.BuiltInTransformationSettings)
			delete(rawMsg, key)
		case "destinationSettings":
			err = unpopulate(val, "DestinationSettings", &d.DestinationSettings)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "operationType":
			err = unpopulate(val, "OperationType", &d.OperationType)
			delete(rawMsg, key)
		case "sourceSettings":
			err = unpopulate(val, "SourceSettings", &d.SourceSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowProfileProperties.
func (d DataflowProfileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diagnostics", d.Diagnostics)
	populate(objectMap, "instanceCount", d.InstanceCount)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowProfileProperties.
func (d *DataflowProfileProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diagnostics":
			err = unpopulate(val, "Diagnostics", &d.Diagnostics)
			delete(rawMsg, key)
		case "instanceCount":
			err = unpopulate(val, "InstanceCount", &d.InstanceCount)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowProfileResource.
func (d DataflowProfileResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", d.ExtendedLocation)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowProfileResource.
func (d *DataflowProfileResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &d.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowProfileResourceListResult.
func (d DataflowProfileResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowProfileResourceListResult.
func (d *DataflowProfileResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowProperties.
func (d DataflowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mode", d.Mode)
	populate(objectMap, "operations", d.Operations)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowProperties.
func (d *DataflowProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mode":
			err = unpopulate(val, "Mode", &d.Mode)
			delete(rawMsg, key)
		case "operations":
			err = unpopulate(val, "Operations", &d.Operations)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowResource.
func (d DataflowResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", d.ExtendedLocation)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowResource.
func (d *DataflowResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &d.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowResourceListResult.
func (d DataflowResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowResourceListResult.
func (d *DataflowResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataflowSourceOperationSettings.
func (d DataflowSourceOperationSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assetRef", d.AssetRef)
	populate(objectMap, "dataSources", d.DataSources)
	populate(objectMap, "endpointRef", d.EndpointRef)
	populate(objectMap, "schemaRef", d.SchemaRef)
	populate(objectMap, "serializationFormat", d.SerializationFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataflowSourceOperationSettings.
func (d *DataflowSourceOperationSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetRef":
			err = unpopulate(val, "AssetRef", &d.AssetRef)
			delete(rawMsg, key)
		case "dataSources":
			err = unpopulate(val, "DataSources", &d.DataSources)
			delete(rawMsg, key)
		case "endpointRef":
			err = unpopulate(val, "EndpointRef", &d.EndpointRef)
			delete(rawMsg, key)
		case "schemaRef":
			err = unpopulate(val, "SchemaRef", &d.SchemaRef)
			delete(rawMsg, key)
		case "serializationFormat":
			err = unpopulate(val, "SerializationFormat", &d.SerializationFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticsLogs.
func (d DiagnosticsLogs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "level", d.Level)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiagnosticsLogs.
func (d *DiagnosticsLogs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			err = unpopulate(val, "Level", &d.Level)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskBackedMessageBuffer.
func (d DiskBackedMessageBuffer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ephemeralVolumeClaimSpec", d.EphemeralVolumeClaimSpec)
	populate(objectMap, "maxSize", d.MaxSize)
	populate(objectMap, "persistentVolumeClaimSpec", d.PersistentVolumeClaimSpec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskBackedMessageBuffer.
func (d *DiskBackedMessageBuffer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ephemeralVolumeClaimSpec":
			err = unpopulate(val, "EphemeralVolumeClaimSpec", &d.EphemeralVolumeClaimSpec)
			delete(rawMsg, key)
		case "maxSize":
			err = unpopulate(val, "MaxSize", &d.MaxSize)
			delete(rawMsg, key)
		case "persistentVolumeClaimSpec":
			err = unpopulate(val, "PersistentVolumeClaimSpec", &d.PersistentVolumeClaimSpec)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedLocation.
func (e ExtendedLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtendedLocation.
func (e *ExtendedLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Frontend.
func (f Frontend) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "replicas", f.Replicas)
	populate(objectMap, "workers", f.Workers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Frontend.
func (f *Frontend) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "replicas":
			err = unpopulate(val, "Replicas", &f.Replicas)
			delete(rawMsg, key)
		case "workers":
			err = unpopulate(val, "Workers", &f.Workers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenerateResourceLimits.
func (g GenerateResourceLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpu", g.CPU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenerateResourceLimits.
func (g *GenerateResourceLimits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpu":
			err = unpopulate(val, "CPU", &g.CPU)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstancePatchModel.
func (i InstancePatchModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", i.Identity)
	populate(objectMap, "tags", i.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstancePatchModel.
func (i *InstancePatchModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &i.Identity)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstanceProperties.
func (i InstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "schemaRegistryRef", i.SchemaRegistryRef)
	populate(objectMap, "version", i.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstanceProperties.
func (i *InstanceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		case "schemaRegistryRef":
			err = unpopulate(val, "SchemaRegistryRef", &i.SchemaRegistryRef)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &i.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstanceResource.
func (i InstanceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedLocation", i.ExtendedLocation)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "identity", i.Identity)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstanceResource.
func (i *InstanceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedLocation":
			err = unpopulate(val, "ExtendedLocation", &i.ExtendedLocation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &i.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstanceResourceListResult.
func (i InstanceResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstanceResourceListResult.
func (i *InstanceResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesReference.
func (k KubernetesReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiGroup", k.APIGroup)
	populate(objectMap, "kind", k.Kind)
	populate(objectMap, "name", k.Name)
	populate(objectMap, "namespace", k.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesReference.
func (k *KubernetesReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiGroup":
			err = unpopulate(val, "APIGroup", &k.APIGroup)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &k.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "namespace":
			err = unpopulate(val, "Namespace", &k.Namespace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListenerPort.
func (l ListenerPort) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationRef", l.AuthenticationRef)
	populate(objectMap, "authorizationRef", l.AuthorizationRef)
	populate(objectMap, "nodePort", l.NodePort)
	populate(objectMap, "port", l.Port)
	populate(objectMap, "protocol", l.Protocol)
	populate(objectMap, "tls", l.TLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListenerPort.
func (l *ListenerPort) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationRef":
			err = unpopulate(val, "AuthenticationRef", &l.AuthenticationRef)
			delete(rawMsg, key)
		case "authorizationRef":
			err = unpopulate(val, "AuthorizationRef", &l.AuthorizationRef)
			delete(rawMsg, key)
		case "nodePort":
			err = unpopulate(val, "NodePort", &l.NodePort)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &l.Port)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &l.Protocol)
			delete(rawMsg, key)
		case "tls":
			err = unpopulate(val, "TLS", &l.TLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LocalKubernetesReference.
func (l LocalKubernetesReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiGroup", l.APIGroup)
	populate(objectMap, "kind", l.Kind)
	populate(objectMap, "name", l.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LocalKubernetesReference.
func (l *LocalKubernetesReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiGroup":
			err = unpopulate(val, "APIGroup", &l.APIGroup)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &l.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentity.
func (m ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedServiceIdentity.
func (m *ManagedServiceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &m.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &m.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Metrics.
func (m Metrics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "prometheusPort", m.PrometheusPort)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Metrics.
func (m *Metrics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "prometheusPort":
			err = unpopulate(val, "PrometheusPort", &m.PrometheusPort)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrincipalDefinition.
func (p PrincipalDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attributes", p.Attributes)
	populate(objectMap, "clientIds", p.ClientIDs)
	populate(objectMap, "usernames", p.Usernames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrincipalDefinition.
func (p *PrincipalDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, "Attributes", &p.Attributes)
			delete(rawMsg, key)
		case "clientIds":
			err = unpopulate(val, "ClientIDs", &p.ClientIDs)
			delete(rawMsg, key)
		case "usernames":
			err = unpopulate(val, "Usernames", &p.Usernames)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProfileDiagnostics.
func (p ProfileDiagnostics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logs", p.Logs)
	populate(objectMap, "metrics", p.Metrics)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProfileDiagnostics.
func (p *ProfileDiagnostics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logs":
			err = unpopulate(val, "Logs", &p.Logs)
			delete(rawMsg, key)
		case "metrics":
			err = unpopulate(val, "Metrics", &p.Metrics)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SanForCert.
func (s SanForCert) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dns", s.DNS)
	populate(objectMap, "ip", s.IP)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SanForCert.
func (s *SanForCert) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dns":
			err = unpopulate(val, "DNS", &s.DNS)
			delete(rawMsg, key)
		case "ip":
			err = unpopulate(val, "IP", &s.IP)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaRegistryRef.
func (s SchemaRegistryRef) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceId", s.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaRegistryRef.
func (s *SchemaRegistryRef) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
			err = unpopulate(val, "ResourceID", &s.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfCheck.
func (s SelfCheck) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "intervalSeconds", s.IntervalSeconds)
	populate(objectMap, "mode", s.Mode)
	populate(objectMap, "timeoutSeconds", s.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfCheck.
func (s *SelfCheck) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "intervalSeconds":
			err = unpopulate(val, "IntervalSeconds", &s.IntervalSeconds)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &s.Mode)
			delete(rawMsg, key)
		case "timeoutSeconds":
			err = unpopulate(val, "TimeoutSeconds", &s.TimeoutSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelfTracing.
func (s SelfTracing) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "intervalSeconds", s.IntervalSeconds)
	populate(objectMap, "mode", s.Mode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfTracing.
func (s *SelfTracing) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "intervalSeconds":
			err = unpopulate(val, "IntervalSeconds", &s.IntervalSeconds)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &s.Mode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StateStoreResourceRule.
func (s StateStoreResourceRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keyType", s.KeyType)
	populate(objectMap, "keys", s.Keys)
	populate(objectMap, "method", s.Method)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StateStoreResourceRule.
func (s *StateStoreResourceRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyType":
			err = unpopulate(val, "KeyType", &s.KeyType)
			delete(rawMsg, key)
		case "keys":
			err = unpopulate(val, "Keys", &s.Keys)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, "Method", &s.Method)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubscriberQueueLimit.
func (s SubscriberQueueLimit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "length", s.Length)
	populate(objectMap, "strategy", s.Strategy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriberQueueLimit.
func (s *SubscriberQueueLimit) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "length":
			err = unpopulate(val, "Length", &s.Length)
			delete(rawMsg, key)
		case "strategy":
			err = unpopulate(val, "Strategy", &s.Strategy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTime[datetime.RFC3339](objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTime[datetime.RFC3339](val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTime[datetime.RFC3339](val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TLSCertMethod.
func (t TLSCertMethod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "certManagerCertificateSpec", t.CertManagerCertificateSpec)
	populate(objectMap, "manual", t.Manual)
	populate(objectMap, "mode", t.Mode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TLSCertMethod.
func (t *TLSCertMethod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certManagerCertificateSpec":
			err = unpopulate(val, "CertManagerCertificateSpec", &t.CertManagerCertificateSpec)
			delete(rawMsg, key)
		case "manual":
			err = unpopulate(val, "Manual", &t.Manual)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &t.Mode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TLSProperties.
func (t TLSProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mode", t.Mode)
	populate(objectMap, "trustedCaCertificateConfigMapRef", t.TrustedCaCertificateConfigMapRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TLSProperties.
func (t *TLSProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mode":
			err = unpopulate(val, "Mode", &t.Mode)
			delete(rawMsg, key)
		case "trustedCaCertificateConfigMapRef":
			err = unpopulate(val, "TrustedCaCertificateConfigMapRef", &t.TrustedCaCertificateConfigMapRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Traces.
func (t Traces) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cacheSizeMegabytes", t.CacheSizeMegabytes)
	populate(objectMap, "mode", t.Mode)
	populate(objectMap, "selfTracing", t.SelfTracing)
	populate(objectMap, "spanChannelCapacity", t.SpanChannelCapacity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Traces.
func (t *Traces) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cacheSizeMegabytes":
			err = unpopulate(val, "CacheSizeMegabytes", &t.CacheSizeMegabytes)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &t.Mode)
			delete(rawMsg, key)
		case "selfTracing":
			err = unpopulate(val, "SelfTracing", &t.SelfTracing)
			delete(rawMsg, key)
		case "spanChannelCapacity":
			err = unpopulate(val, "SpanChannelCapacity", &t.SpanChannelCapacity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeClaimResourceRequirements.
func (v VolumeClaimResourceRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "limits", v.Limits)
	populate(objectMap, "requests", v.Requests)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeClaimResourceRequirements.
func (v *VolumeClaimResourceRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "limits":
			err = unpopulate(val, "Limits", &v.Limits)
			delete(rawMsg, key)
		case "requests":
			err = unpopulate(val, "Requests", &v.Requests)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeClaimSpec.
func (v VolumeClaimSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessModes", v.AccessModes)
	populate(objectMap, "dataSource", v.DataSource)
	populate(objectMap, "dataSourceRef", v.DataSourceRef)
	populate(objectMap, "resources", v.Resources)
	populate(objectMap, "selector", v.Selector)
	populate(objectMap, "storageClassName", v.StorageClassName)
	populate(objectMap, "volumeMode", v.VolumeMode)
	populate(objectMap, "volumeName", v.VolumeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeClaimSpec.
func (v *VolumeClaimSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessModes":
			err = unpopulate(val, "AccessModes", &v.AccessModes)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, "DataSource", &v.DataSource)
			delete(rawMsg, key)
		case "dataSourceRef":
			err = unpopulate(val, "DataSourceRef", &v.DataSourceRef)
			delete(rawMsg, key)
		case "resources":
			err = unpopulate(val, "Resources", &v.Resources)
			delete(rawMsg, key)
		case "selector":
			err = unpopulate(val, "Selector", &v.Selector)
			delete(rawMsg, key)
		case "storageClassName":
			err = unpopulate(val, "StorageClassName", &v.StorageClassName)
			delete(rawMsg, key)
		case "volumeMode":
			err = unpopulate(val, "VolumeMode", &v.VolumeMode)
			delete(rawMsg, key)
		case "volumeName":
			err = unpopulate(val, "VolumeName", &v.VolumeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeClaimSpecSelector.
func (v VolumeClaimSpecSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "matchExpressions", v.MatchExpressions)
	populate(objectMap, "matchLabels", v.MatchLabels)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeClaimSpecSelector.
func (v *VolumeClaimSpecSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "matchExpressions":
			err = unpopulate(val, "MatchExpressions", &v.MatchExpressions)
			delete(rawMsg, key)
		case "matchLabels":
			err = unpopulate(val, "MatchLabels", &v.MatchLabels)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeClaimSpecSelectorMatchExpressions.
func (v VolumeClaimSpecSelectorMatchExpressions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", v.Key)
	populate(objectMap, "operator", v.Operator)
	populate(objectMap, "values", v.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeClaimSpecSelectorMatchExpressions.
func (v *VolumeClaimSpecSelectorMatchExpressions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &v.Key)
			delete(rawMsg, key)
		case "operator":
			err = unpopulate(val, "Operator", &v.Operator)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &v.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type X509ManualCertificate.
func (x X509ManualCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretRef", x.SecretRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type X509ManualCertificate.
func (x *X509ManualCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretRef":
			err = unpopulate(val, "SecretRef", &x.SecretRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateTime[T dateTimeConstraints](m map[string]any, k string, t *time.Time) {
	if t == nil {
		return
	} else if azcore.IsNullValue(t) {
		m[k] = nil
	} else if !reflect.ValueOf(t).IsNil() {
		newTime := T(*t)
		m[k] = (*T)(&newTime)
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

func unpopulateTime[T dateTimeConstraints](data json.RawMessage, fn string, t **time.Time) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	var aux T
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	newTime := time.Time(aux)
	*t = &newTime
	return nil
}

type dateTimeConstraints interface {
	datetime.PlainDate | datetime.PlainTime | datetime.RFC1123 | datetime.RFC3339 | datetime.Unix
}
