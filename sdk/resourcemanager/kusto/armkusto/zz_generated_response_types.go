//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armkusto

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AttachedDatabaseConfigurationsCheckNameAvailabilityResponse contains the response from method AttachedDatabaseConfigurations.CheckNameAvailability.
type AttachedDatabaseConfigurationsCheckNameAvailabilityResponse struct {
	AttachedDatabaseConfigurationsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsCheckNameAvailabilityResult contains the result from method AttachedDatabaseConfigurations.CheckNameAvailability.
type AttachedDatabaseConfigurationsCheckNameAvailabilityResult struct {
	CheckNameResult
}

// AttachedDatabaseConfigurationsCreateOrUpdatePollerResponse contains the response from method AttachedDatabaseConfigurations.CreateOrUpdate.
type AttachedDatabaseConfigurationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AttachedDatabaseConfigurationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AttachedDatabaseConfigurationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AttachedDatabaseConfigurationsCreateOrUpdateResponse, error) {
	respType := AttachedDatabaseConfigurationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AttachedDatabaseConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AttachedDatabaseConfigurationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AttachedDatabaseConfigurationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AttachedDatabaseConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AttachedDatabaseConfigurationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AttachedDatabaseConfigurationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AttachedDatabaseConfigurationsCreateOrUpdateResponse contains the response from method AttachedDatabaseConfigurations.CreateOrUpdate.
type AttachedDatabaseConfigurationsCreateOrUpdateResponse struct {
	AttachedDatabaseConfigurationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsCreateOrUpdateResult contains the result from method AttachedDatabaseConfigurations.CreateOrUpdate.
type AttachedDatabaseConfigurationsCreateOrUpdateResult struct {
	AttachedDatabaseConfiguration
}

// AttachedDatabaseConfigurationsDeletePollerResponse contains the response from method AttachedDatabaseConfigurations.Delete.
type AttachedDatabaseConfigurationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AttachedDatabaseConfigurationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AttachedDatabaseConfigurationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AttachedDatabaseConfigurationsDeleteResponse, error) {
	respType := AttachedDatabaseConfigurationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AttachedDatabaseConfigurationsDeletePollerResponse from the provided client and resume token.
func (l *AttachedDatabaseConfigurationsDeletePollerResponse) Resume(ctx context.Context, client *AttachedDatabaseConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AttachedDatabaseConfigurationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AttachedDatabaseConfigurationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AttachedDatabaseConfigurationsDeleteResponse contains the response from method AttachedDatabaseConfigurations.Delete.
type AttachedDatabaseConfigurationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsGetResponse contains the response from method AttachedDatabaseConfigurations.Get.
type AttachedDatabaseConfigurationsGetResponse struct {
	AttachedDatabaseConfigurationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsGetResult contains the result from method AttachedDatabaseConfigurations.Get.
type AttachedDatabaseConfigurationsGetResult struct {
	AttachedDatabaseConfiguration
}

// AttachedDatabaseConfigurationsListByClusterResponse contains the response from method AttachedDatabaseConfigurations.ListByCluster.
type AttachedDatabaseConfigurationsListByClusterResponse struct {
	AttachedDatabaseConfigurationsListByClusterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsListByClusterResult contains the result from method AttachedDatabaseConfigurations.ListByCluster.
type AttachedDatabaseConfigurationsListByClusterResult struct {
	AttachedDatabaseConfigurationListResult
}

// ClusterPrincipalAssignmentsCheckNameAvailabilityResponse contains the response from method ClusterPrincipalAssignments.CheckNameAvailability.
type ClusterPrincipalAssignmentsCheckNameAvailabilityResponse struct {
	ClusterPrincipalAssignmentsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsCheckNameAvailabilityResult contains the result from method ClusterPrincipalAssignments.CheckNameAvailability.
type ClusterPrincipalAssignmentsCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ClusterPrincipalAssignmentsCreateOrUpdatePollerResponse contains the response from method ClusterPrincipalAssignments.CreateOrUpdate.
type ClusterPrincipalAssignmentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClusterPrincipalAssignmentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClusterPrincipalAssignmentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClusterPrincipalAssignmentsCreateOrUpdateResponse, error) {
	respType := ClusterPrincipalAssignmentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ClusterPrincipalAssignment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClusterPrincipalAssignmentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ClusterPrincipalAssignmentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ClusterPrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClusterPrincipalAssignmentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ClusterPrincipalAssignmentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClusterPrincipalAssignmentsCreateOrUpdateResponse contains the response from method ClusterPrincipalAssignments.CreateOrUpdate.
type ClusterPrincipalAssignmentsCreateOrUpdateResponse struct {
	ClusterPrincipalAssignmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsCreateOrUpdateResult contains the result from method ClusterPrincipalAssignments.CreateOrUpdate.
type ClusterPrincipalAssignmentsCreateOrUpdateResult struct {
	ClusterPrincipalAssignment
}

// ClusterPrincipalAssignmentsDeletePollerResponse contains the response from method ClusterPrincipalAssignments.Delete.
type ClusterPrincipalAssignmentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClusterPrincipalAssignmentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClusterPrincipalAssignmentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClusterPrincipalAssignmentsDeleteResponse, error) {
	respType := ClusterPrincipalAssignmentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClusterPrincipalAssignmentsDeletePollerResponse from the provided client and resume token.
func (l *ClusterPrincipalAssignmentsDeletePollerResponse) Resume(ctx context.Context, client *ClusterPrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClusterPrincipalAssignmentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ClusterPrincipalAssignmentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClusterPrincipalAssignmentsDeleteResponse contains the response from method ClusterPrincipalAssignments.Delete.
type ClusterPrincipalAssignmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsGetResponse contains the response from method ClusterPrincipalAssignments.Get.
type ClusterPrincipalAssignmentsGetResponse struct {
	ClusterPrincipalAssignmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsGetResult contains the result from method ClusterPrincipalAssignments.Get.
type ClusterPrincipalAssignmentsGetResult struct {
	ClusterPrincipalAssignment
}

// ClusterPrincipalAssignmentsListResponse contains the response from method ClusterPrincipalAssignments.List.
type ClusterPrincipalAssignmentsListResponse struct {
	ClusterPrincipalAssignmentsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsListResult contains the result from method ClusterPrincipalAssignments.List.
type ClusterPrincipalAssignmentsListResult struct {
	ClusterPrincipalAssignmentListResult
}

// ClustersAddLanguageExtensionsPollerResponse contains the response from method Clusters.AddLanguageExtensions.
type ClustersAddLanguageExtensionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersAddLanguageExtensionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersAddLanguageExtensionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersAddLanguageExtensionsResponse, error) {
	respType := ClustersAddLanguageExtensionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersAddLanguageExtensionsPollerResponse from the provided client and resume token.
func (l *ClustersAddLanguageExtensionsPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.AddLanguageExtensions", token, client.pl, client.addLanguageExtensionsHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersAddLanguageExtensionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersAddLanguageExtensionsResponse contains the response from method Clusters.AddLanguageExtensions.
type ClustersAddLanguageExtensionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersCheckNameAvailabilityResponse contains the response from method Clusters.CheckNameAvailability.
type ClustersCheckNameAvailabilityResponse struct {
	ClustersCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersCheckNameAvailabilityResult contains the result from method Clusters.CheckNameAvailability.
type ClustersCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ClustersCreateOrUpdatePollerResponse contains the response from method Clusters.CreateOrUpdate.
type ClustersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersCreateOrUpdateResponse, error) {
	respType := ClustersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ClustersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersCreateOrUpdateResponse contains the response from method Clusters.CreateOrUpdate.
type ClustersCreateOrUpdateResponse struct {
	ClustersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersCreateOrUpdateResult contains the result from method Clusters.CreateOrUpdate.
type ClustersCreateOrUpdateResult struct {
	Cluster
}

// ClustersDeletePollerResponse contains the response from method Clusters.Delete.
type ClustersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersDeleteResponse, error) {
	respType := ClustersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersDeletePollerResponse from the provided client and resume token.
func (l *ClustersDeletePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersDeleteResponse contains the response from method Clusters.Delete.
type ClustersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersDetachFollowerDatabasesPollerResponse contains the response from method Clusters.DetachFollowerDatabases.
type ClustersDetachFollowerDatabasesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersDetachFollowerDatabasesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersDetachFollowerDatabasesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersDetachFollowerDatabasesResponse, error) {
	respType := ClustersDetachFollowerDatabasesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersDetachFollowerDatabasesPollerResponse from the provided client and resume token.
func (l *ClustersDetachFollowerDatabasesPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.DetachFollowerDatabases", token, client.pl, client.detachFollowerDatabasesHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersDetachFollowerDatabasesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersDetachFollowerDatabasesResponse contains the response from method Clusters.DetachFollowerDatabases.
type ClustersDetachFollowerDatabasesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersDiagnoseVirtualNetworkPollerResponse contains the response from method Clusters.DiagnoseVirtualNetwork.
type ClustersDiagnoseVirtualNetworkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersDiagnoseVirtualNetworkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersDiagnoseVirtualNetworkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersDiagnoseVirtualNetworkResponse, error) {
	respType := ClustersDiagnoseVirtualNetworkResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiagnoseVirtualNetworkResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersDiagnoseVirtualNetworkPollerResponse from the provided client and resume token.
func (l *ClustersDiagnoseVirtualNetworkPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.DiagnoseVirtualNetwork", token, client.pl, client.diagnoseVirtualNetworkHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersDiagnoseVirtualNetworkPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersDiagnoseVirtualNetworkResponse contains the response from method Clusters.DiagnoseVirtualNetwork.
type ClustersDiagnoseVirtualNetworkResponse struct {
	ClustersDiagnoseVirtualNetworkResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersDiagnoseVirtualNetworkResult contains the result from method Clusters.DiagnoseVirtualNetwork.
type ClustersDiagnoseVirtualNetworkResult struct {
	DiagnoseVirtualNetworkResult
}

// ClustersGetResponse contains the response from method Clusters.Get.
type ClustersGetResponse struct {
	ClustersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersGetResult contains the result from method Clusters.Get.
type ClustersGetResult struct {
	Cluster
}

// ClustersListByResourceGroupResponse contains the response from method Clusters.ListByResourceGroup.
type ClustersListByResourceGroupResponse struct {
	ClustersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListByResourceGroupResult contains the result from method Clusters.ListByResourceGroup.
type ClustersListByResourceGroupResult struct {
	ClusterListResult
}

// ClustersListFollowerDatabasesResponse contains the response from method Clusters.ListFollowerDatabases.
type ClustersListFollowerDatabasesResponse struct {
	ClustersListFollowerDatabasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListFollowerDatabasesResult contains the result from method Clusters.ListFollowerDatabases.
type ClustersListFollowerDatabasesResult struct {
	FollowerDatabaseListResult
}

// ClustersListLanguageExtensionsResponse contains the response from method Clusters.ListLanguageExtensions.
type ClustersListLanguageExtensionsResponse struct {
	ClustersListLanguageExtensionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListLanguageExtensionsResult contains the result from method Clusters.ListLanguageExtensions.
type ClustersListLanguageExtensionsResult struct {
	LanguageExtensionsList
}

// ClustersListOutboundNetworkDependenciesEndpointsResponse contains the response from method Clusters.ListOutboundNetworkDependenciesEndpoints.
type ClustersListOutboundNetworkDependenciesEndpointsResponse struct {
	ClustersListOutboundNetworkDependenciesEndpointsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListOutboundNetworkDependenciesEndpointsResult contains the result from method Clusters.ListOutboundNetworkDependenciesEndpoints.
type ClustersListOutboundNetworkDependenciesEndpointsResult struct {
	OutboundNetworkDependenciesEndpointListResult
}

// ClustersListResponse contains the response from method Clusters.List.
type ClustersListResponse struct {
	ClustersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListResult contains the result from method Clusters.List.
type ClustersListResult struct {
	ClusterListResult
}

// ClustersListSKUsByResourceResponse contains the response from method Clusters.ListSKUsByResource.
type ClustersListSKUsByResourceResponse struct {
	ClustersListSKUsByResourceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListSKUsByResourceResult contains the result from method Clusters.ListSKUsByResource.
type ClustersListSKUsByResourceResult struct {
	ListResourceSKUsResult
}

// ClustersListSKUsResponse contains the response from method Clusters.ListSKUs.
type ClustersListSKUsResponse struct {
	ClustersListSKUsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListSKUsResult contains the result from method Clusters.ListSKUs.
type ClustersListSKUsResult struct {
	SKUDescriptionList
}

// ClustersRemoveLanguageExtensionsPollerResponse contains the response from method Clusters.RemoveLanguageExtensions.
type ClustersRemoveLanguageExtensionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersRemoveLanguageExtensionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersRemoveLanguageExtensionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersRemoveLanguageExtensionsResponse, error) {
	respType := ClustersRemoveLanguageExtensionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersRemoveLanguageExtensionsPollerResponse from the provided client and resume token.
func (l *ClustersRemoveLanguageExtensionsPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.RemoveLanguageExtensions", token, client.pl, client.removeLanguageExtensionsHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersRemoveLanguageExtensionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersRemoveLanguageExtensionsResponse contains the response from method Clusters.RemoveLanguageExtensions.
type ClustersRemoveLanguageExtensionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersStartPollerResponse contains the response from method Clusters.Start.
type ClustersStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersStartResponse, error) {
	respType := ClustersStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersStartPollerResponse from the provided client and resume token.
func (l *ClustersStartPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersStartResponse contains the response from method Clusters.Start.
type ClustersStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersStopPollerResponse contains the response from method Clusters.Stop.
type ClustersStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersStopResponse, error) {
	respType := ClustersStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersStopPollerResponse from the provided client and resume token.
func (l *ClustersStopPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersStopResponse contains the response from method Clusters.Stop.
type ClustersStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersUpdatePollerResponse contains the response from method Clusters.Update.
type ClustersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersUpdateResponse, error) {
	respType := ClustersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersUpdatePollerResponse from the provided client and resume token.
func (l *ClustersUpdatePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersUpdateResponse contains the response from method Clusters.Update.
type ClustersUpdateResponse struct {
	ClustersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersUpdateResult contains the result from method Clusters.Update.
type ClustersUpdateResult struct {
	Cluster
}

// DataConnectionsCheckNameAvailabilityResponse contains the response from method DataConnections.CheckNameAvailability.
type DataConnectionsCheckNameAvailabilityResponse struct {
	DataConnectionsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsCheckNameAvailabilityResult contains the result from method DataConnections.CheckNameAvailability.
type DataConnectionsCheckNameAvailabilityResult struct {
	CheckNameResult
}

// DataConnectionsCreateOrUpdatePollerResponse contains the response from method DataConnections.CreateOrUpdate.
type DataConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsCreateOrUpdateResponse, error) {
	respType := DataConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataConnectionClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DataConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DataConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsCreateOrUpdateResponse contains the response from method DataConnections.CreateOrUpdate.
type DataConnectionsCreateOrUpdateResponse struct {
	DataConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsCreateOrUpdateResult contains the result from method DataConnections.CreateOrUpdate.
type DataConnectionsCreateOrUpdateResult struct {
	DataConnectionClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionsCreateOrUpdateResult.
func (d *DataConnectionsCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDataConnectionClassification(data)
	if err != nil {
		return err
	}
	d.DataConnectionClassification = res
	return nil
}

// DataConnectionsDataConnectionValidationPollerResponse contains the response from method DataConnections.DataConnectionValidation.
type DataConnectionsDataConnectionValidationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsDataConnectionValidationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsDataConnectionValidationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsDataConnectionValidationResponse, error) {
	respType := DataConnectionsDataConnectionValidationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataConnectionValidationListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsDataConnectionValidationPollerResponse from the provided client and resume token.
func (l *DataConnectionsDataConnectionValidationPollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.DataConnectionValidation", token, client.pl, client.dataConnectionValidationHandleError)
	if err != nil {
		return err
	}
	poller := &DataConnectionsDataConnectionValidationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsDataConnectionValidationResponse contains the response from method DataConnections.DataConnectionValidation.
type DataConnectionsDataConnectionValidationResponse struct {
	DataConnectionsDataConnectionValidationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsDataConnectionValidationResult contains the result from method DataConnections.DataConnectionValidation.
type DataConnectionsDataConnectionValidationResult struct {
	DataConnectionValidationListResult
}

// DataConnectionsDeletePollerResponse contains the response from method DataConnections.Delete.
type DataConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsDeleteResponse, error) {
	respType := DataConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsDeletePollerResponse from the provided client and resume token.
func (l *DataConnectionsDeletePollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DataConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsDeleteResponse contains the response from method DataConnections.Delete.
type DataConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsGetResponse contains the response from method DataConnections.Get.
type DataConnectionsGetResponse struct {
	DataConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsGetResult contains the result from method DataConnections.Get.
type DataConnectionsGetResult struct {
	DataConnectionClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionsGetResult.
func (d *DataConnectionsGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDataConnectionClassification(data)
	if err != nil {
		return err
	}
	d.DataConnectionClassification = res
	return nil
}

// DataConnectionsListByDatabaseResponse contains the response from method DataConnections.ListByDatabase.
type DataConnectionsListByDatabaseResponse struct {
	DataConnectionsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsListByDatabaseResult contains the result from method DataConnections.ListByDatabase.
type DataConnectionsListByDatabaseResult struct {
	DataConnectionListResult
}

// DataConnectionsUpdatePollerResponse contains the response from method DataConnections.Update.
type DataConnectionsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsUpdateResponse, error) {
	respType := DataConnectionsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataConnectionClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsUpdatePollerResponse from the provided client and resume token.
func (l *DataConnectionsUpdatePollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &DataConnectionsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsUpdateResponse contains the response from method DataConnections.Update.
type DataConnectionsUpdateResponse struct {
	DataConnectionsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsUpdateResult contains the result from method DataConnections.Update.
type DataConnectionsUpdateResult struct {
	DataConnectionClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionsUpdateResult.
func (d *DataConnectionsUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDataConnectionClassification(data)
	if err != nil {
		return err
	}
	d.DataConnectionClassification = res
	return nil
}

// DatabasePrincipalAssignmentsCheckNameAvailabilityResponse contains the response from method DatabasePrincipalAssignments.CheckNameAvailability.
type DatabasePrincipalAssignmentsCheckNameAvailabilityResponse struct {
	DatabasePrincipalAssignmentsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsCheckNameAvailabilityResult contains the result from method DatabasePrincipalAssignments.CheckNameAvailability.
type DatabasePrincipalAssignmentsCheckNameAvailabilityResult struct {
	CheckNameResult
}

// DatabasePrincipalAssignmentsCreateOrUpdatePollerResponse contains the response from method DatabasePrincipalAssignments.CreateOrUpdate.
type DatabasePrincipalAssignmentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasePrincipalAssignmentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasePrincipalAssignmentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasePrincipalAssignmentsCreateOrUpdateResponse, error) {
	respType := DatabasePrincipalAssignmentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabasePrincipalAssignment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasePrincipalAssignmentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabasePrincipalAssignmentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabasePrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasePrincipalAssignmentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasePrincipalAssignmentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasePrincipalAssignmentsCreateOrUpdateResponse contains the response from method DatabasePrincipalAssignments.CreateOrUpdate.
type DatabasePrincipalAssignmentsCreateOrUpdateResponse struct {
	DatabasePrincipalAssignmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsCreateOrUpdateResult contains the result from method DatabasePrincipalAssignments.CreateOrUpdate.
type DatabasePrincipalAssignmentsCreateOrUpdateResult struct {
	DatabasePrincipalAssignment
}

// DatabasePrincipalAssignmentsDeletePollerResponse contains the response from method DatabasePrincipalAssignments.Delete.
type DatabasePrincipalAssignmentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasePrincipalAssignmentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasePrincipalAssignmentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasePrincipalAssignmentsDeleteResponse, error) {
	respType := DatabasePrincipalAssignmentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasePrincipalAssignmentsDeletePollerResponse from the provided client and resume token.
func (l *DatabasePrincipalAssignmentsDeletePollerResponse) Resume(ctx context.Context, client *DatabasePrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasePrincipalAssignmentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasePrincipalAssignmentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasePrincipalAssignmentsDeleteResponse contains the response from method DatabasePrincipalAssignments.Delete.
type DatabasePrincipalAssignmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsGetResponse contains the response from method DatabasePrincipalAssignments.Get.
type DatabasePrincipalAssignmentsGetResponse struct {
	DatabasePrincipalAssignmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsGetResult contains the result from method DatabasePrincipalAssignments.Get.
type DatabasePrincipalAssignmentsGetResult struct {
	DatabasePrincipalAssignment
}

// DatabasePrincipalAssignmentsListResponse contains the response from method DatabasePrincipalAssignments.List.
type DatabasePrincipalAssignmentsListResponse struct {
	DatabasePrincipalAssignmentsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsListResult contains the result from method DatabasePrincipalAssignments.List.
type DatabasePrincipalAssignmentsListResult struct {
	DatabasePrincipalAssignmentListResult
}

// DatabasesAddPrincipalsResponse contains the response from method Databases.AddPrincipals.
type DatabasesAddPrincipalsResponse struct {
	DatabasesAddPrincipalsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesAddPrincipalsResult contains the result from method Databases.AddPrincipals.
type DatabasesAddPrincipalsResult struct {
	DatabasePrincipalListResult
}

// DatabasesCheckNameAvailabilityResponse contains the response from method Databases.CheckNameAvailability.
type DatabasesCheckNameAvailabilityResponse struct {
	DatabasesCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesCheckNameAvailabilityResult contains the result from method Databases.CheckNameAvailability.
type DatabasesCheckNameAvailabilityResult struct {
	CheckNameResult
}

// DatabasesCreateOrUpdatePollerResponse contains the response from method Databases.CreateOrUpdate.
type DatabasesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesCreateOrUpdateResponse, error) {
	respType := DatabasesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesCreateOrUpdateResponse contains the response from method Databases.CreateOrUpdate.
type DatabasesCreateOrUpdateResponse struct {
	DatabasesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesCreateOrUpdateResult contains the result from method Databases.CreateOrUpdate.
type DatabasesCreateOrUpdateResult struct {
	DatabaseClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasesCreateOrUpdateResult.
func (d *DatabasesCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDatabaseClassification(data)
	if err != nil {
		return err
	}
	d.DatabaseClassification = res
	return nil
}

// DatabasesDeletePollerResponse contains the response from method Databases.Delete.
type DatabasesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesDeleteResponse, error) {
	respType := DatabasesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesDeletePollerResponse from the provided client and resume token.
func (l *DatabasesDeletePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesDeleteResponse contains the response from method Databases.Delete.
type DatabasesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesGetResponse contains the response from method Databases.Get.
type DatabasesGetResponse struct {
	DatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesGetResult contains the result from method Databases.Get.
type DatabasesGetResult struct {
	DatabaseClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasesGetResult.
func (d *DatabasesGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDatabaseClassification(data)
	if err != nil {
		return err
	}
	d.DatabaseClassification = res
	return nil
}

// DatabasesListByClusterResponse contains the response from method Databases.ListByCluster.
type DatabasesListByClusterResponse struct {
	DatabasesListByClusterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListByClusterResult contains the result from method Databases.ListByCluster.
type DatabasesListByClusterResult struct {
	DatabaseListResult
}

// DatabasesListPrincipalsResponse contains the response from method Databases.ListPrincipals.
type DatabasesListPrincipalsResponse struct {
	DatabasesListPrincipalsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListPrincipalsResult contains the result from method Databases.ListPrincipals.
type DatabasesListPrincipalsResult struct {
	DatabasePrincipalListResult
}

// DatabasesRemovePrincipalsResponse contains the response from method Databases.RemovePrincipals.
type DatabasesRemovePrincipalsResponse struct {
	DatabasesRemovePrincipalsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesRemovePrincipalsResult contains the result from method Databases.RemovePrincipals.
type DatabasesRemovePrincipalsResult struct {
	DatabasePrincipalListResult
}

// DatabasesUpdatePollerResponse contains the response from method Databases.Update.
type DatabasesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesUpdateResponse, error) {
	respType := DatabasesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseClassification)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesUpdateResponse contains the response from method Databases.Update.
type DatabasesUpdateResponse struct {
	DatabasesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesUpdateResult contains the result from method Databases.Update.
type DatabasesUpdateResult struct {
	DatabaseClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasesUpdateResult.
func (d *DatabasesUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDatabaseClassification(data)
	if err != nil {
		return err
	}
	d.DatabaseClassification = res
	return nil
}

// ManagedPrivateEndpointsCheckNameAvailabilityResponse contains the response from method ManagedPrivateEndpoints.CheckNameAvailability.
type ManagedPrivateEndpointsCheckNameAvailabilityResponse struct {
	ManagedPrivateEndpointsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsCheckNameAvailabilityResult contains the result from method ManagedPrivateEndpoints.CheckNameAvailability.
type ManagedPrivateEndpointsCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ManagedPrivateEndpointsCreateOrUpdatePollerResponse contains the response from method ManagedPrivateEndpoints.CreateOrUpdate.
type ManagedPrivateEndpointsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedPrivateEndpointsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedPrivateEndpointsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedPrivateEndpointsCreateOrUpdateResponse, error) {
	respType := ManagedPrivateEndpointsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedPrivateEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedPrivateEndpointsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedPrivateEndpointsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedPrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedPrivateEndpointsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedPrivateEndpointsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedPrivateEndpointsCreateOrUpdateResponse contains the response from method ManagedPrivateEndpoints.CreateOrUpdate.
type ManagedPrivateEndpointsCreateOrUpdateResponse struct {
	ManagedPrivateEndpointsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsCreateOrUpdateResult contains the result from method ManagedPrivateEndpoints.CreateOrUpdate.
type ManagedPrivateEndpointsCreateOrUpdateResult struct {
	ManagedPrivateEndpoint
}

// ManagedPrivateEndpointsDeletePollerResponse contains the response from method ManagedPrivateEndpoints.Delete.
type ManagedPrivateEndpointsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedPrivateEndpointsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedPrivateEndpointsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedPrivateEndpointsDeleteResponse, error) {
	respType := ManagedPrivateEndpointsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedPrivateEndpointsDeletePollerResponse from the provided client and resume token.
func (l *ManagedPrivateEndpointsDeletePollerResponse) Resume(ctx context.Context, client *ManagedPrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedPrivateEndpointsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedPrivateEndpointsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedPrivateEndpointsDeleteResponse contains the response from method ManagedPrivateEndpoints.Delete.
type ManagedPrivateEndpointsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsGetResponse contains the response from method ManagedPrivateEndpoints.Get.
type ManagedPrivateEndpointsGetResponse struct {
	ManagedPrivateEndpointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsGetResult contains the result from method ManagedPrivateEndpoints.Get.
type ManagedPrivateEndpointsGetResult struct {
	ManagedPrivateEndpoint
}

// ManagedPrivateEndpointsListResponse contains the response from method ManagedPrivateEndpoints.List.
type ManagedPrivateEndpointsListResponse struct {
	ManagedPrivateEndpointsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsListResult contains the result from method ManagedPrivateEndpoints.List.
type ManagedPrivateEndpointsListResult struct {
	ManagedPrivateEndpointListResult
}

// ManagedPrivateEndpointsUpdatePollerResponse contains the response from method ManagedPrivateEndpoints.Update.
type ManagedPrivateEndpointsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedPrivateEndpointsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedPrivateEndpointsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedPrivateEndpointsUpdateResponse, error) {
	respType := ManagedPrivateEndpointsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedPrivateEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedPrivateEndpointsUpdatePollerResponse from the provided client and resume token.
func (l *ManagedPrivateEndpointsUpdatePollerResponse) Resume(ctx context.Context, client *ManagedPrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedPrivateEndpointsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedPrivateEndpointsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedPrivateEndpointsUpdateResponse contains the response from method ManagedPrivateEndpoints.Update.
type ManagedPrivateEndpointsUpdateResponse struct {
	ManagedPrivateEndpointsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsUpdateResult contains the result from method ManagedPrivateEndpoints.Update.
type ManagedPrivateEndpointsUpdateResult struct {
	ManagedPrivateEndpoint
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// OperationsResultsGetResponse contains the response from method OperationsResults.Get.
type OperationsResultsGetResponse struct {
	OperationsResultsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsResultsGetResult contains the result from method OperationsResults.Get.
type OperationsResultsGetResult struct {
	OperationResult
}

// PrivateEndpointConnectionsCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsCreateOrUpdateResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsCreateOrUpdateResult contains the result from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsDeletePollerResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsDeleteResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResponse contains the response from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResponse struct {
	PrivateEndpointConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResult contains the result from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsListResponse contains the response from method PrivateEndpointConnections.List.
type PrivateEndpointConnectionsListResponse struct {
	PrivateEndpointConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsListResult contains the result from method PrivateEndpointConnections.List.
type PrivateEndpointConnectionsListResult struct {
	PrivateEndpointConnectionListResult
}

// PrivateLinkResourcesGetResponse contains the response from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResponse struct {
	PrivateLinkResourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesGetResult contains the result from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResult struct {
	PrivateLinkResource
}

// PrivateLinkResourcesListResponse contains the response from method PrivateLinkResources.List.
type PrivateLinkResourcesListResponse struct {
	PrivateLinkResourcesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesListResult contains the result from method PrivateLinkResources.List.
type PrivateLinkResourcesListResult struct {
	PrivateLinkResourceListResult
}

// ScriptsCheckNameAvailabilityResponse contains the response from method Scripts.CheckNameAvailability.
type ScriptsCheckNameAvailabilityResponse struct {
	ScriptsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsCheckNameAvailabilityResult contains the result from method Scripts.CheckNameAvailability.
type ScriptsCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ScriptsCreateOrUpdatePollerResponse contains the response from method Scripts.CreateOrUpdate.
type ScriptsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptsCreateOrUpdateResponse, error) {
	respType := ScriptsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Script)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ScriptsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ScriptsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ScriptsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptsCreateOrUpdateResponse contains the response from method Scripts.CreateOrUpdate.
type ScriptsCreateOrUpdateResponse struct {
	ScriptsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsCreateOrUpdateResult contains the result from method Scripts.CreateOrUpdate.
type ScriptsCreateOrUpdateResult struct {
	Script
}

// ScriptsDeletePollerResponse contains the response from method Scripts.Delete.
type ScriptsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptsDeleteResponse, error) {
	respType := ScriptsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptsDeletePollerResponse from the provided client and resume token.
func (l *ScriptsDeletePollerResponse) Resume(ctx context.Context, client *ScriptsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ScriptsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptsDeleteResponse contains the response from method Scripts.Delete.
type ScriptsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsGetResponse contains the response from method Scripts.Get.
type ScriptsGetResponse struct {
	ScriptsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsGetResult contains the result from method Scripts.Get.
type ScriptsGetResult struct {
	Script
}

// ScriptsListByDatabaseResponse contains the response from method Scripts.ListByDatabase.
type ScriptsListByDatabaseResponse struct {
	ScriptsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsListByDatabaseResult contains the result from method Scripts.ListByDatabase.
type ScriptsListByDatabaseResult struct {
	ScriptListResult
}

// ScriptsUpdatePollerResponse contains the response from method Scripts.Update.
type ScriptsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptsUpdateResponse, error) {
	respType := ScriptsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Script)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptsUpdatePollerResponse from the provided client and resume token.
func (l *ScriptsUpdatePollerResponse) Resume(ctx context.Context, client *ScriptsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ScriptsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptsUpdateResponse contains the response from method Scripts.Update.
type ScriptsUpdateResponse struct {
	ScriptsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsUpdateResult contains the result from method Scripts.Update.
type ScriptsUpdateResult struct {
	Script
}
