//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armkusto

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AttachedDatabaseConfigurationsClientCheckNameAvailabilityResponse contains the response from method AttachedDatabaseConfigurationsClient.CheckNameAvailability.
type AttachedDatabaseConfigurationsClientCheckNameAvailabilityResponse struct {
	AttachedDatabaseConfigurationsClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsClientCheckNameAvailabilityResult contains the result from method AttachedDatabaseConfigurationsClient.CheckNameAvailability.
type AttachedDatabaseConfigurationsClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// AttachedDatabaseConfigurationsClientCreateOrUpdatePollerResponse contains the response from method AttachedDatabaseConfigurationsClient.CreateOrUpdate.
type AttachedDatabaseConfigurationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AttachedDatabaseConfigurationsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AttachedDatabaseConfigurationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AttachedDatabaseConfigurationsClientCreateOrUpdateResponse, error) {
	respType := AttachedDatabaseConfigurationsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AttachedDatabaseConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AttachedDatabaseConfigurationsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *AttachedDatabaseConfigurationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AttachedDatabaseConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AttachedDatabaseConfigurationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AttachedDatabaseConfigurationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AttachedDatabaseConfigurationsClientCreateOrUpdateResponse contains the response from method AttachedDatabaseConfigurationsClient.CreateOrUpdate.
type AttachedDatabaseConfigurationsClientCreateOrUpdateResponse struct {
	AttachedDatabaseConfigurationsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsClientCreateOrUpdateResult contains the result from method AttachedDatabaseConfigurationsClient.CreateOrUpdate.
type AttachedDatabaseConfigurationsClientCreateOrUpdateResult struct {
	AttachedDatabaseConfiguration
}

// AttachedDatabaseConfigurationsClientDeletePollerResponse contains the response from method AttachedDatabaseConfigurationsClient.Delete.
type AttachedDatabaseConfigurationsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AttachedDatabaseConfigurationsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AttachedDatabaseConfigurationsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AttachedDatabaseConfigurationsClientDeleteResponse, error) {
	respType := AttachedDatabaseConfigurationsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AttachedDatabaseConfigurationsClientDeletePollerResponse from the provided client and resume token.
func (l *AttachedDatabaseConfigurationsClientDeletePollerResponse) Resume(ctx context.Context, client *AttachedDatabaseConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AttachedDatabaseConfigurationsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AttachedDatabaseConfigurationsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AttachedDatabaseConfigurationsClientDeleteResponse contains the response from method AttachedDatabaseConfigurationsClient.Delete.
type AttachedDatabaseConfigurationsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsClientGetResponse contains the response from method AttachedDatabaseConfigurationsClient.Get.
type AttachedDatabaseConfigurationsClientGetResponse struct {
	AttachedDatabaseConfigurationsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsClientGetResult contains the result from method AttachedDatabaseConfigurationsClient.Get.
type AttachedDatabaseConfigurationsClientGetResult struct {
	AttachedDatabaseConfiguration
}

// AttachedDatabaseConfigurationsClientListByClusterResponse contains the response from method AttachedDatabaseConfigurationsClient.ListByCluster.
type AttachedDatabaseConfigurationsClientListByClusterResponse struct {
	AttachedDatabaseConfigurationsClientListByClusterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AttachedDatabaseConfigurationsClientListByClusterResult contains the result from method AttachedDatabaseConfigurationsClient.ListByCluster.
type AttachedDatabaseConfigurationsClientListByClusterResult struct {
	AttachedDatabaseConfigurationListResult
}

// ClusterPrincipalAssignmentsClientCheckNameAvailabilityResponse contains the response from method ClusterPrincipalAssignmentsClient.CheckNameAvailability.
type ClusterPrincipalAssignmentsClientCheckNameAvailabilityResponse struct {
	ClusterPrincipalAssignmentsClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsClientCheckNameAvailabilityResult contains the result from method ClusterPrincipalAssignmentsClient.CheckNameAvailability.
type ClusterPrincipalAssignmentsClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ClusterPrincipalAssignmentsClientCreateOrUpdatePollerResponse contains the response from method ClusterPrincipalAssignmentsClient.CreateOrUpdate.
type ClusterPrincipalAssignmentsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClusterPrincipalAssignmentsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClusterPrincipalAssignmentsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClusterPrincipalAssignmentsClientCreateOrUpdateResponse, error) {
	respType := ClusterPrincipalAssignmentsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ClusterPrincipalAssignment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClusterPrincipalAssignmentsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ClusterPrincipalAssignmentsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ClusterPrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClusterPrincipalAssignmentsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClusterPrincipalAssignmentsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClusterPrincipalAssignmentsClientCreateOrUpdateResponse contains the response from method ClusterPrincipalAssignmentsClient.CreateOrUpdate.
type ClusterPrincipalAssignmentsClientCreateOrUpdateResponse struct {
	ClusterPrincipalAssignmentsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsClientCreateOrUpdateResult contains the result from method ClusterPrincipalAssignmentsClient.CreateOrUpdate.
type ClusterPrincipalAssignmentsClientCreateOrUpdateResult struct {
	ClusterPrincipalAssignment
}

// ClusterPrincipalAssignmentsClientDeletePollerResponse contains the response from method ClusterPrincipalAssignmentsClient.Delete.
type ClusterPrincipalAssignmentsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClusterPrincipalAssignmentsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClusterPrincipalAssignmentsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClusterPrincipalAssignmentsClientDeleteResponse, error) {
	respType := ClusterPrincipalAssignmentsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClusterPrincipalAssignmentsClientDeletePollerResponse from the provided client and resume token.
func (l *ClusterPrincipalAssignmentsClientDeletePollerResponse) Resume(ctx context.Context, client *ClusterPrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClusterPrincipalAssignmentsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClusterPrincipalAssignmentsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClusterPrincipalAssignmentsClientDeleteResponse contains the response from method ClusterPrincipalAssignmentsClient.Delete.
type ClusterPrincipalAssignmentsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsClientGetResponse contains the response from method ClusterPrincipalAssignmentsClient.Get.
type ClusterPrincipalAssignmentsClientGetResponse struct {
	ClusterPrincipalAssignmentsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsClientGetResult contains the result from method ClusterPrincipalAssignmentsClient.Get.
type ClusterPrincipalAssignmentsClientGetResult struct {
	ClusterPrincipalAssignment
}

// ClusterPrincipalAssignmentsClientListResponse contains the response from method ClusterPrincipalAssignmentsClient.List.
type ClusterPrincipalAssignmentsClientListResponse struct {
	ClusterPrincipalAssignmentsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClusterPrincipalAssignmentsClientListResult contains the result from method ClusterPrincipalAssignmentsClient.List.
type ClusterPrincipalAssignmentsClientListResult struct {
	ClusterPrincipalAssignmentListResult
}

// ClustersClientAddLanguageExtensionsPollerResponse contains the response from method ClustersClient.AddLanguageExtensions.
type ClustersClientAddLanguageExtensionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientAddLanguageExtensionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientAddLanguageExtensionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientAddLanguageExtensionsResponse, error) {
	respType := ClustersClientAddLanguageExtensionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientAddLanguageExtensionsPollerResponse from the provided client and resume token.
func (l *ClustersClientAddLanguageExtensionsPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.AddLanguageExtensions", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientAddLanguageExtensionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientAddLanguageExtensionsResponse contains the response from method ClustersClient.AddLanguageExtensions.
type ClustersClientAddLanguageExtensionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientCheckNameAvailabilityResponse contains the response from method ClustersClient.CheckNameAvailability.
type ClustersClientCheckNameAvailabilityResponse struct {
	ClustersClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientCheckNameAvailabilityResult contains the result from method ClustersClient.CheckNameAvailability.
type ClustersClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ClustersClientCreateOrUpdatePollerResponse contains the response from method ClustersClient.CreateOrUpdate.
type ClustersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientCreateOrUpdateResponse, error) {
	respType := ClustersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ClustersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientCreateOrUpdateResponse contains the response from method ClustersClient.CreateOrUpdate.
type ClustersClientCreateOrUpdateResponse struct {
	ClustersClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientCreateOrUpdateResult contains the result from method ClustersClient.CreateOrUpdate.
type ClustersClientCreateOrUpdateResult struct {
	Cluster
}

// ClustersClientDeletePollerResponse contains the response from method ClustersClient.Delete.
type ClustersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientDeleteResponse, error) {
	respType := ClustersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientDeletePollerResponse from the provided client and resume token.
func (l *ClustersClientDeletePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientDeleteResponse contains the response from method ClustersClient.Delete.
type ClustersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientDetachFollowerDatabasesPollerResponse contains the response from method ClustersClient.DetachFollowerDatabases.
type ClustersClientDetachFollowerDatabasesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientDetachFollowerDatabasesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientDetachFollowerDatabasesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientDetachFollowerDatabasesResponse, error) {
	respType := ClustersClientDetachFollowerDatabasesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientDetachFollowerDatabasesPollerResponse from the provided client and resume token.
func (l *ClustersClientDetachFollowerDatabasesPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.DetachFollowerDatabases", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientDetachFollowerDatabasesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientDetachFollowerDatabasesResponse contains the response from method ClustersClient.DetachFollowerDatabases.
type ClustersClientDetachFollowerDatabasesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientDiagnoseVirtualNetworkPollerResponse contains the response from method ClustersClient.DiagnoseVirtualNetwork.
type ClustersClientDiagnoseVirtualNetworkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientDiagnoseVirtualNetworkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientDiagnoseVirtualNetworkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientDiagnoseVirtualNetworkResponse, error) {
	respType := ClustersClientDiagnoseVirtualNetworkResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiagnoseVirtualNetworkResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientDiagnoseVirtualNetworkPollerResponse from the provided client and resume token.
func (l *ClustersClientDiagnoseVirtualNetworkPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.DiagnoseVirtualNetwork", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientDiagnoseVirtualNetworkPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientDiagnoseVirtualNetworkResponse contains the response from method ClustersClient.DiagnoseVirtualNetwork.
type ClustersClientDiagnoseVirtualNetworkResponse struct {
	ClustersClientDiagnoseVirtualNetworkResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientDiagnoseVirtualNetworkResult contains the result from method ClustersClient.DiagnoseVirtualNetwork.
type ClustersClientDiagnoseVirtualNetworkResult struct {
	DiagnoseVirtualNetworkResult
}

// ClustersClientGetResponse contains the response from method ClustersClient.Get.
type ClustersClientGetResponse struct {
	ClustersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientGetResult contains the result from method ClustersClient.Get.
type ClustersClientGetResult struct {
	Cluster
}

// ClustersClientListByResourceGroupResponse contains the response from method ClustersClient.ListByResourceGroup.
type ClustersClientListByResourceGroupResponse struct {
	ClustersClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListByResourceGroupResult contains the result from method ClustersClient.ListByResourceGroup.
type ClustersClientListByResourceGroupResult struct {
	ClusterListResult
}

// ClustersClientListFollowerDatabasesResponse contains the response from method ClustersClient.ListFollowerDatabases.
type ClustersClientListFollowerDatabasesResponse struct {
	ClustersClientListFollowerDatabasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListFollowerDatabasesResult contains the result from method ClustersClient.ListFollowerDatabases.
type ClustersClientListFollowerDatabasesResult struct {
	FollowerDatabaseListResult
}

// ClustersClientListLanguageExtensionsResponse contains the response from method ClustersClient.ListLanguageExtensions.
type ClustersClientListLanguageExtensionsResponse struct {
	ClustersClientListLanguageExtensionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListLanguageExtensionsResult contains the result from method ClustersClient.ListLanguageExtensions.
type ClustersClientListLanguageExtensionsResult struct {
	LanguageExtensionsList
}

// ClustersClientListOutboundNetworkDependenciesEndpointsResponse contains the response from method ClustersClient.ListOutboundNetworkDependenciesEndpoints.
type ClustersClientListOutboundNetworkDependenciesEndpointsResponse struct {
	ClustersClientListOutboundNetworkDependenciesEndpointsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListOutboundNetworkDependenciesEndpointsResult contains the result from method ClustersClient.ListOutboundNetworkDependenciesEndpoints.
type ClustersClientListOutboundNetworkDependenciesEndpointsResult struct {
	OutboundNetworkDependenciesEndpointListResult
}

// ClustersClientListResponse contains the response from method ClustersClient.List.
type ClustersClientListResponse struct {
	ClustersClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListResult contains the result from method ClustersClient.List.
type ClustersClientListResult struct {
	ClusterListResult
}

// ClustersClientListSKUsByResourceResponse contains the response from method ClustersClient.ListSKUsByResource.
type ClustersClientListSKUsByResourceResponse struct {
	ClustersClientListSKUsByResourceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListSKUsByResourceResult contains the result from method ClustersClient.ListSKUsByResource.
type ClustersClientListSKUsByResourceResult struct {
	ListResourceSKUsResult
}

// ClustersClientListSKUsResponse contains the response from method ClustersClient.ListSKUs.
type ClustersClientListSKUsResponse struct {
	ClustersClientListSKUsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientListSKUsResult contains the result from method ClustersClient.ListSKUs.
type ClustersClientListSKUsResult struct {
	SKUDescriptionList
}

// ClustersClientRemoveLanguageExtensionsPollerResponse contains the response from method ClustersClient.RemoveLanguageExtensions.
type ClustersClientRemoveLanguageExtensionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientRemoveLanguageExtensionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientRemoveLanguageExtensionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientRemoveLanguageExtensionsResponse, error) {
	respType := ClustersClientRemoveLanguageExtensionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientRemoveLanguageExtensionsPollerResponse from the provided client and resume token.
func (l *ClustersClientRemoveLanguageExtensionsPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.RemoveLanguageExtensions", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientRemoveLanguageExtensionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientRemoveLanguageExtensionsResponse contains the response from method ClustersClient.RemoveLanguageExtensions.
type ClustersClientRemoveLanguageExtensionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientStartPollerResponse contains the response from method ClustersClient.Start.
type ClustersClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientStartResponse, error) {
	respType := ClustersClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientStartPollerResponse from the provided client and resume token.
func (l *ClustersClientStartPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientStartResponse contains the response from method ClustersClient.Start.
type ClustersClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientStopPollerResponse contains the response from method ClustersClient.Stop.
type ClustersClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientStopResponse, error) {
	respType := ClustersClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientStopPollerResponse from the provided client and resume token.
func (l *ClustersClientStopPollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientStopResponse contains the response from method ClustersClient.Stop.
type ClustersClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientUpdatePollerResponse contains the response from method ClustersClient.Update.
type ClustersClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersClientUpdateResponse, error) {
	respType := ClustersClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersClientUpdatePollerResponse from the provided client and resume token.
func (l *ClustersClientUpdatePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ClustersClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersClientUpdateResponse contains the response from method ClustersClient.Update.
type ClustersClientUpdateResponse struct {
	ClustersClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersClientUpdateResult contains the result from method ClustersClient.Update.
type ClustersClientUpdateResult struct {
	Cluster
}

// DataConnectionsClientCheckNameAvailabilityResponse contains the response from method DataConnectionsClient.CheckNameAvailability.
type DataConnectionsClientCheckNameAvailabilityResponse struct {
	DataConnectionsClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientCheckNameAvailabilityResult contains the result from method DataConnectionsClient.CheckNameAvailability.
type DataConnectionsClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// DataConnectionsClientCreateOrUpdatePollerResponse contains the response from method DataConnectionsClient.CreateOrUpdate.
type DataConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsClientCreateOrUpdateResponse, error) {
	respType := DataConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataConnectionsClientCreateOrUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DataConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DataConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsClientCreateOrUpdateResponse contains the response from method DataConnectionsClient.CreateOrUpdate.
type DataConnectionsClientCreateOrUpdateResponse struct {
	DataConnectionsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientCreateOrUpdateResult contains the result from method DataConnectionsClient.CreateOrUpdate.
type DataConnectionsClientCreateOrUpdateResult struct {
	DataConnectionClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionsClientCreateOrUpdateResult.
func (d *DataConnectionsClientCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDataConnectionClassification(data)
	if err != nil {
		return err
	}
	d.DataConnectionClassification = res
	return nil
}

// DataConnectionsClientDataConnectionValidationPollerResponse contains the response from method DataConnectionsClient.DataConnectionValidation.
type DataConnectionsClientDataConnectionValidationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsClientDataConnectionValidationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsClientDataConnectionValidationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsClientDataConnectionValidationResponse, error) {
	respType := DataConnectionsClientDataConnectionValidationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataConnectionValidationListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsClientDataConnectionValidationPollerResponse from the provided client and resume token.
func (l *DataConnectionsClientDataConnectionValidationPollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.DataConnectionValidation", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DataConnectionsClientDataConnectionValidationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsClientDataConnectionValidationResponse contains the response from method DataConnectionsClient.DataConnectionValidation.
type DataConnectionsClientDataConnectionValidationResponse struct {
	DataConnectionsClientDataConnectionValidationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientDataConnectionValidationResult contains the result from method DataConnectionsClient.DataConnectionValidation.
type DataConnectionsClientDataConnectionValidationResult struct {
	DataConnectionValidationListResult
}

// DataConnectionsClientDeletePollerResponse contains the response from method DataConnectionsClient.Delete.
type DataConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsClientDeleteResponse, error) {
	respType := DataConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *DataConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DataConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsClientDeleteResponse contains the response from method DataConnectionsClient.Delete.
type DataConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientGetResponse contains the response from method DataConnectionsClient.Get.
type DataConnectionsClientGetResponse struct {
	DataConnectionsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientGetResult contains the result from method DataConnectionsClient.Get.
type DataConnectionsClientGetResult struct {
	DataConnectionClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionsClientGetResult.
func (d *DataConnectionsClientGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDataConnectionClassification(data)
	if err != nil {
		return err
	}
	d.DataConnectionClassification = res
	return nil
}

// DataConnectionsClientListByDatabaseResponse contains the response from method DataConnectionsClient.ListByDatabase.
type DataConnectionsClientListByDatabaseResponse struct {
	DataConnectionsClientListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientListByDatabaseResult contains the result from method DataConnectionsClient.ListByDatabase.
type DataConnectionsClientListByDatabaseResult struct {
	DataConnectionListResult
}

// DataConnectionsClientUpdatePollerResponse contains the response from method DataConnectionsClient.Update.
type DataConnectionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataConnectionsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DataConnectionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataConnectionsClientUpdateResponse, error) {
	respType := DataConnectionsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataConnectionsClientUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataConnectionsClientUpdatePollerResponse from the provided client and resume token.
func (l *DataConnectionsClientUpdatePollerResponse) Resume(ctx context.Context, client *DataConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DataConnectionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DataConnectionsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataConnectionsClientUpdateResponse contains the response from method DataConnectionsClient.Update.
type DataConnectionsClientUpdateResponse struct {
	DataConnectionsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataConnectionsClientUpdateResult contains the result from method DataConnectionsClient.Update.
type DataConnectionsClientUpdateResult struct {
	DataConnectionClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionsClientUpdateResult.
func (d *DataConnectionsClientUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDataConnectionClassification(data)
	if err != nil {
		return err
	}
	d.DataConnectionClassification = res
	return nil
}

// DatabasePrincipalAssignmentsClientCheckNameAvailabilityResponse contains the response from method DatabasePrincipalAssignmentsClient.CheckNameAvailability.
type DatabasePrincipalAssignmentsClientCheckNameAvailabilityResponse struct {
	DatabasePrincipalAssignmentsClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsClientCheckNameAvailabilityResult contains the result from method DatabasePrincipalAssignmentsClient.CheckNameAvailability.
type DatabasePrincipalAssignmentsClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// DatabasePrincipalAssignmentsClientCreateOrUpdatePollerResponse contains the response from method DatabasePrincipalAssignmentsClient.CreateOrUpdate.
type DatabasePrincipalAssignmentsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasePrincipalAssignmentsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasePrincipalAssignmentsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasePrincipalAssignmentsClientCreateOrUpdateResponse, error) {
	respType := DatabasePrincipalAssignmentsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabasePrincipalAssignment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasePrincipalAssignmentsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *DatabasePrincipalAssignmentsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabasePrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasePrincipalAssignmentsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasePrincipalAssignmentsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasePrincipalAssignmentsClientCreateOrUpdateResponse contains the response from method DatabasePrincipalAssignmentsClient.CreateOrUpdate.
type DatabasePrincipalAssignmentsClientCreateOrUpdateResponse struct {
	DatabasePrincipalAssignmentsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsClientCreateOrUpdateResult contains the result from method DatabasePrincipalAssignmentsClient.CreateOrUpdate.
type DatabasePrincipalAssignmentsClientCreateOrUpdateResult struct {
	DatabasePrincipalAssignment
}

// DatabasePrincipalAssignmentsClientDeletePollerResponse contains the response from method DatabasePrincipalAssignmentsClient.Delete.
type DatabasePrincipalAssignmentsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasePrincipalAssignmentsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasePrincipalAssignmentsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasePrincipalAssignmentsClientDeleteResponse, error) {
	respType := DatabasePrincipalAssignmentsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasePrincipalAssignmentsClientDeletePollerResponse from the provided client and resume token.
func (l *DatabasePrincipalAssignmentsClientDeletePollerResponse) Resume(ctx context.Context, client *DatabasePrincipalAssignmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasePrincipalAssignmentsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasePrincipalAssignmentsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasePrincipalAssignmentsClientDeleteResponse contains the response from method DatabasePrincipalAssignmentsClient.Delete.
type DatabasePrincipalAssignmentsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsClientGetResponse contains the response from method DatabasePrincipalAssignmentsClient.Get.
type DatabasePrincipalAssignmentsClientGetResponse struct {
	DatabasePrincipalAssignmentsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsClientGetResult contains the result from method DatabasePrincipalAssignmentsClient.Get.
type DatabasePrincipalAssignmentsClientGetResult struct {
	DatabasePrincipalAssignment
}

// DatabasePrincipalAssignmentsClientListResponse contains the response from method DatabasePrincipalAssignmentsClient.List.
type DatabasePrincipalAssignmentsClientListResponse struct {
	DatabasePrincipalAssignmentsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasePrincipalAssignmentsClientListResult contains the result from method DatabasePrincipalAssignmentsClient.List.
type DatabasePrincipalAssignmentsClientListResult struct {
	DatabasePrincipalAssignmentListResult
}

// DatabasesClientAddPrincipalsResponse contains the response from method DatabasesClient.AddPrincipals.
type DatabasesClientAddPrincipalsResponse struct {
	DatabasesClientAddPrincipalsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientAddPrincipalsResult contains the result from method DatabasesClient.AddPrincipals.
type DatabasesClientAddPrincipalsResult struct {
	DatabasePrincipalListResult
}

// DatabasesClientCheckNameAvailabilityResponse contains the response from method DatabasesClient.CheckNameAvailability.
type DatabasesClientCheckNameAvailabilityResponse struct {
	DatabasesClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientCheckNameAvailabilityResult contains the result from method DatabasesClient.CheckNameAvailability.
type DatabasesClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// DatabasesClientCreateOrUpdatePollerResponse contains the response from method DatabasesClient.CreateOrUpdate.
type DatabasesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesClientCreateOrUpdateResponse, error) {
	respType := DatabasesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabasesClientCreateOrUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesClientCreateOrUpdateResponse contains the response from method DatabasesClient.CreateOrUpdate.
type DatabasesClientCreateOrUpdateResponse struct {
	DatabasesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientCreateOrUpdateResult contains the result from method DatabasesClient.CreateOrUpdate.
type DatabasesClientCreateOrUpdateResult struct {
	DatabaseClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasesClientCreateOrUpdateResult.
func (d *DatabasesClientCreateOrUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDatabaseClassification(data)
	if err != nil {
		return err
	}
	d.DatabaseClassification = res
	return nil
}

// DatabasesClientDeletePollerResponse contains the response from method DatabasesClient.Delete.
type DatabasesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesClientDeleteResponse, error) {
	respType := DatabasesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesClientDeletePollerResponse from the provided client and resume token.
func (l *DatabasesClientDeletePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesClientDeleteResponse contains the response from method DatabasesClient.Delete.
type DatabasesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientGetResponse contains the response from method DatabasesClient.Get.
type DatabasesClientGetResponse struct {
	DatabasesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientGetResult contains the result from method DatabasesClient.Get.
type DatabasesClientGetResult struct {
	DatabaseClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasesClientGetResult.
func (d *DatabasesClientGetResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDatabaseClassification(data)
	if err != nil {
		return err
	}
	d.DatabaseClassification = res
	return nil
}

// DatabasesClientListByClusterResponse contains the response from method DatabasesClient.ListByCluster.
type DatabasesClientListByClusterResponse struct {
	DatabasesClientListByClusterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientListByClusterResult contains the result from method DatabasesClient.ListByCluster.
type DatabasesClientListByClusterResult struct {
	DatabaseListResult
}

// DatabasesClientListPrincipalsResponse contains the response from method DatabasesClient.ListPrincipals.
type DatabasesClientListPrincipalsResponse struct {
	DatabasesClientListPrincipalsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientListPrincipalsResult contains the result from method DatabasesClient.ListPrincipals.
type DatabasesClientListPrincipalsResult struct {
	DatabasePrincipalListResult
}

// DatabasesClientRemovePrincipalsResponse contains the response from method DatabasesClient.RemovePrincipals.
type DatabasesClientRemovePrincipalsResponse struct {
	DatabasesClientRemovePrincipalsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientRemovePrincipalsResult contains the result from method DatabasesClient.RemovePrincipals.
type DatabasesClientRemovePrincipalsResult struct {
	DatabasePrincipalListResult
}

// DatabasesClientUpdatePollerResponse contains the response from method DatabasesClient.Update.
type DatabasesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesClientUpdateResponse, error) {
	respType := DatabasesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabasesClientUpdateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesClientUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesClientUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesClientUpdateResponse contains the response from method DatabasesClient.Update.
type DatabasesClientUpdateResponse struct {
	DatabasesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientUpdateResult contains the result from method DatabasesClient.Update.
type DatabasesClientUpdateResult struct {
	DatabaseClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasesClientUpdateResult.
func (d *DatabasesClientUpdateResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalDatabaseClassification(data)
	if err != nil {
		return err
	}
	d.DatabaseClassification = res
	return nil
}

// ManagedPrivateEndpointsClientCheckNameAvailabilityResponse contains the response from method ManagedPrivateEndpointsClient.CheckNameAvailability.
type ManagedPrivateEndpointsClientCheckNameAvailabilityResponse struct {
	ManagedPrivateEndpointsClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsClientCheckNameAvailabilityResult contains the result from method ManagedPrivateEndpointsClient.CheckNameAvailability.
type ManagedPrivateEndpointsClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ManagedPrivateEndpointsClientCreateOrUpdatePollerResponse contains the response from method ManagedPrivateEndpointsClient.CreateOrUpdate.
type ManagedPrivateEndpointsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedPrivateEndpointsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedPrivateEndpointsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedPrivateEndpointsClientCreateOrUpdateResponse, error) {
	respType := ManagedPrivateEndpointsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedPrivateEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedPrivateEndpointsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedPrivateEndpointsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedPrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedPrivateEndpointsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagedPrivateEndpointsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedPrivateEndpointsClientCreateOrUpdateResponse contains the response from method ManagedPrivateEndpointsClient.CreateOrUpdate.
type ManagedPrivateEndpointsClientCreateOrUpdateResponse struct {
	ManagedPrivateEndpointsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsClientCreateOrUpdateResult contains the result from method ManagedPrivateEndpointsClient.CreateOrUpdate.
type ManagedPrivateEndpointsClientCreateOrUpdateResult struct {
	ManagedPrivateEndpoint
}

// ManagedPrivateEndpointsClientDeletePollerResponse contains the response from method ManagedPrivateEndpointsClient.Delete.
type ManagedPrivateEndpointsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedPrivateEndpointsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedPrivateEndpointsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedPrivateEndpointsClientDeleteResponse, error) {
	respType := ManagedPrivateEndpointsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedPrivateEndpointsClientDeletePollerResponse from the provided client and resume token.
func (l *ManagedPrivateEndpointsClientDeletePollerResponse) Resume(ctx context.Context, client *ManagedPrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedPrivateEndpointsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagedPrivateEndpointsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedPrivateEndpointsClientDeleteResponse contains the response from method ManagedPrivateEndpointsClient.Delete.
type ManagedPrivateEndpointsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsClientGetResponse contains the response from method ManagedPrivateEndpointsClient.Get.
type ManagedPrivateEndpointsClientGetResponse struct {
	ManagedPrivateEndpointsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsClientGetResult contains the result from method ManagedPrivateEndpointsClient.Get.
type ManagedPrivateEndpointsClientGetResult struct {
	ManagedPrivateEndpoint
}

// ManagedPrivateEndpointsClientListResponse contains the response from method ManagedPrivateEndpointsClient.List.
type ManagedPrivateEndpointsClientListResponse struct {
	ManagedPrivateEndpointsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsClientListResult contains the result from method ManagedPrivateEndpointsClient.List.
type ManagedPrivateEndpointsClientListResult struct {
	ManagedPrivateEndpointListResult
}

// ManagedPrivateEndpointsClientUpdatePollerResponse contains the response from method ManagedPrivateEndpointsClient.Update.
type ManagedPrivateEndpointsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedPrivateEndpointsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedPrivateEndpointsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedPrivateEndpointsClientUpdateResponse, error) {
	respType := ManagedPrivateEndpointsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedPrivateEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedPrivateEndpointsClientUpdatePollerResponse from the provided client and resume token.
func (l *ManagedPrivateEndpointsClientUpdatePollerResponse) Resume(ctx context.Context, client *ManagedPrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedPrivateEndpointsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagedPrivateEndpointsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedPrivateEndpointsClientUpdateResponse contains the response from method ManagedPrivateEndpointsClient.Update.
type ManagedPrivateEndpointsClientUpdateResponse struct {
	ManagedPrivateEndpointsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedPrivateEndpointsClientUpdateResult contains the result from method ManagedPrivateEndpointsClient.Update.
type ManagedPrivateEndpointsClientUpdateResult struct {
	ManagedPrivateEndpoint
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationListResult
}

// OperationsResultsClientGetResponse contains the response from method OperationsResultsClient.Get.
type OperationsResultsClientGetResponse struct {
	OperationsResultsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsResultsClientGetResult contains the result from method OperationsResultsClient.Get.
type OperationsResultsClientGetResult struct {
	OperationResult
}

// PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientCreateOrUpdateResponse contains the response from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientCreateOrUpdateResult contains the result from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdateResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsClientDeletePollerResponse contains the response from method PrivateEndpointConnectionsClient.Delete.
type PrivateEndpointConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientDeleteResponse contains the response from method PrivateEndpointConnectionsClient.Delete.
type PrivateEndpointConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientGetResponse contains the response from method PrivateEndpointConnectionsClient.Get.
type PrivateEndpointConnectionsClientGetResponse struct {
	PrivateEndpointConnectionsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientGetResult contains the result from method PrivateEndpointConnectionsClient.Get.
type PrivateEndpointConnectionsClientGetResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsClientListResponse contains the response from method PrivateEndpointConnectionsClient.List.
type PrivateEndpointConnectionsClientListResponse struct {
	PrivateEndpointConnectionsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientListResult contains the result from method PrivateEndpointConnectionsClient.List.
type PrivateEndpointConnectionsClientListResult struct {
	PrivateEndpointConnectionListResult
}

// PrivateLinkResourcesClientGetResponse contains the response from method PrivateLinkResourcesClient.Get.
type PrivateLinkResourcesClientGetResponse struct {
	PrivateLinkResourcesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesClientGetResult contains the result from method PrivateLinkResourcesClient.Get.
type PrivateLinkResourcesClientGetResult struct {
	PrivateLinkResource
}

// PrivateLinkResourcesClientListResponse contains the response from method PrivateLinkResourcesClient.List.
type PrivateLinkResourcesClientListResponse struct {
	PrivateLinkResourcesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesClientListResult contains the result from method PrivateLinkResourcesClient.List.
type PrivateLinkResourcesClientListResult struct {
	PrivateLinkResourceListResult
}

// ScriptsClientCheckNameAvailabilityResponse contains the response from method ScriptsClient.CheckNameAvailability.
type ScriptsClientCheckNameAvailabilityResponse struct {
	ScriptsClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsClientCheckNameAvailabilityResult contains the result from method ScriptsClient.CheckNameAvailability.
type ScriptsClientCheckNameAvailabilityResult struct {
	CheckNameResult
}

// ScriptsClientCreateOrUpdatePollerResponse contains the response from method ScriptsClient.CreateOrUpdate.
type ScriptsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptsClientCreateOrUpdateResponse, error) {
	respType := ScriptsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Script)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ScriptsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ScriptsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ScriptsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptsClientCreateOrUpdateResponse contains the response from method ScriptsClient.CreateOrUpdate.
type ScriptsClientCreateOrUpdateResponse struct {
	ScriptsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsClientCreateOrUpdateResult contains the result from method ScriptsClient.CreateOrUpdate.
type ScriptsClientCreateOrUpdateResult struct {
	Script
}

// ScriptsClientDeletePollerResponse contains the response from method ScriptsClient.Delete.
type ScriptsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptsClientDeleteResponse, error) {
	respType := ScriptsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptsClientDeletePollerResponse from the provided client and resume token.
func (l *ScriptsClientDeletePollerResponse) Resume(ctx context.Context, client *ScriptsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ScriptsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptsClientDeleteResponse contains the response from method ScriptsClient.Delete.
type ScriptsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsClientGetResponse contains the response from method ScriptsClient.Get.
type ScriptsClientGetResponse struct {
	ScriptsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsClientGetResult contains the result from method ScriptsClient.Get.
type ScriptsClientGetResult struct {
	Script
}

// ScriptsClientListByDatabaseResponse contains the response from method ScriptsClient.ListByDatabase.
type ScriptsClientListByDatabaseResponse struct {
	ScriptsClientListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsClientListByDatabaseResult contains the result from method ScriptsClient.ListByDatabase.
type ScriptsClientListByDatabaseResult struct {
	ScriptListResult
}

// ScriptsClientUpdatePollerResponse contains the response from method ScriptsClient.Update.
type ScriptsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptsClientUpdateResponse, error) {
	respType := ScriptsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Script)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptsClientUpdatePollerResponse from the provided client and resume token.
func (l *ScriptsClientUpdatePollerResponse) Resume(ctx context.Context, client *ScriptsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ScriptsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptsClientUpdateResponse contains the response from method ScriptsClient.Update.
type ScriptsClientUpdateResponse struct {
	ScriptsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptsClientUpdateResult contains the result from method ScriptsClient.Update.
type ScriptsClientUpdateResult struct {
	Script
}
