//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armlabservices

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ImagesCreateOrUpdateResponse contains the response from method Images.CreateOrUpdate.
type ImagesCreateOrUpdateResponse struct {
	ImagesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ImagesCreateOrUpdateResult contains the result from method Images.CreateOrUpdate.
type ImagesCreateOrUpdateResult struct {
	Image
}

// ImagesGetResponse contains the response from method Images.Get.
type ImagesGetResponse struct {
	ImagesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ImagesGetResult contains the result from method Images.Get.
type ImagesGetResult struct {
	Image
}

// ImagesListByLabPlanResponse contains the response from method Images.ListByLabPlan.
type ImagesListByLabPlanResponse struct {
	ImagesListByLabPlanResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ImagesListByLabPlanResult contains the result from method Images.ListByLabPlan.
type ImagesListByLabPlanResult struct {
	PagedImages
}

// ImagesUpdateResponse contains the response from method Images.Update.
type ImagesUpdateResponse struct {
	ImagesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ImagesUpdateResult contains the result from method Images.Update.
type ImagesUpdateResult struct {
	Image
}

// LabPlansCreateOrUpdatePollerResponse contains the response from method LabPlans.CreateOrUpdate.
type LabPlansCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabPlansCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabPlansCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabPlansCreateOrUpdateResponse, error) {
	respType := LabPlansCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LabPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabPlansCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LabPlansCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LabPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabPlansClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LabPlansCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabPlansCreateOrUpdateResponse contains the response from method LabPlans.CreateOrUpdate.
type LabPlansCreateOrUpdateResponse struct {
	LabPlansCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansCreateOrUpdateResult contains the result from method LabPlans.CreateOrUpdate.
type LabPlansCreateOrUpdateResult struct {
	LabPlan
}

// LabPlansDeletePollerResponse contains the response from method LabPlans.Delete.
type LabPlansDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabPlansDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabPlansDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabPlansDeleteResponse, error) {
	respType := LabPlansDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabPlansDeletePollerResponse from the provided client and resume token.
func (l *LabPlansDeletePollerResponse) Resume(ctx context.Context, client *LabPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabPlansClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LabPlansDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabPlansDeleteResponse contains the response from method LabPlans.Delete.
type LabPlansDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansGetResponse contains the response from method LabPlans.Get.
type LabPlansGetResponse struct {
	LabPlansGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansGetResult contains the result from method LabPlans.Get.
type LabPlansGetResult struct {
	LabPlan
}

// LabPlansListByResourceGroupResponse contains the response from method LabPlans.ListByResourceGroup.
type LabPlansListByResourceGroupResponse struct {
	LabPlansListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansListByResourceGroupResult contains the result from method LabPlans.ListByResourceGroup.
type LabPlansListByResourceGroupResult struct {
	PagedLabPlans
}

// LabPlansListBySubscriptionResponse contains the response from method LabPlans.ListBySubscription.
type LabPlansListBySubscriptionResponse struct {
	LabPlansListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansListBySubscriptionResult contains the result from method LabPlans.ListBySubscription.
type LabPlansListBySubscriptionResult struct {
	PagedLabPlans
}

// LabPlansSaveImagePollerResponse contains the response from method LabPlans.SaveImage.
type LabPlansSaveImagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabPlansSaveImagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabPlansSaveImagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabPlansSaveImageResponse, error) {
	respType := LabPlansSaveImageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabPlansSaveImagePollerResponse from the provided client and resume token.
func (l *LabPlansSaveImagePollerResponse) Resume(ctx context.Context, client *LabPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabPlansClient.SaveImage", token, client.pl, client.saveImageHandleError)
	if err != nil {
		return err
	}
	poller := &LabPlansSaveImagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabPlansSaveImageResponse contains the response from method LabPlans.SaveImage.
type LabPlansSaveImageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansUpdatePollerResponse contains the response from method LabPlans.Update.
type LabPlansUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabPlansUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabPlansUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabPlansUpdateResponse, error) {
	respType := LabPlansUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LabPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabPlansUpdatePollerResponse from the provided client and resume token.
func (l *LabPlansUpdatePollerResponse) Resume(ctx context.Context, client *LabPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabPlansClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &LabPlansUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabPlansUpdateResponse contains the response from method LabPlans.Update.
type LabPlansUpdateResponse struct {
	LabPlansUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabPlansUpdateResult contains the result from method LabPlans.Update.
type LabPlansUpdateResult struct {
	LabPlan
}

// LabsCreateOrUpdatePollerResponse contains the response from method Labs.CreateOrUpdate.
type LabsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsCreateOrUpdateResponse, error) {
	respType := LabsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Lab)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LabsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LabsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsCreateOrUpdateResponse contains the response from method Labs.CreateOrUpdate.
type LabsCreateOrUpdateResponse struct {
	LabsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsCreateOrUpdateResult contains the result from method Labs.CreateOrUpdate.
type LabsCreateOrUpdateResult struct {
	Lab
}

// LabsDeletePollerResponse contains the response from method Labs.Delete.
type LabsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsDeleteResponse, error) {
	respType := LabsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsDeletePollerResponse from the provided client and resume token.
func (l *LabsDeletePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LabsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsDeleteResponse contains the response from method Labs.Delete.
type LabsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsGetResponse contains the response from method Labs.Get.
type LabsGetResponse struct {
	LabsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsGetResult contains the result from method Labs.Get.
type LabsGetResult struct {
	Lab
}

// LabsListByResourceGroupResponse contains the response from method Labs.ListByResourceGroup.
type LabsListByResourceGroupResponse struct {
	LabsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsListByResourceGroupResult contains the result from method Labs.ListByResourceGroup.
type LabsListByResourceGroupResult struct {
	PagedLabs
}

// LabsListBySubscriptionResponse contains the response from method Labs.ListBySubscription.
type LabsListBySubscriptionResponse struct {
	LabsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsListBySubscriptionResult contains the result from method Labs.ListBySubscription.
type LabsListBySubscriptionResult struct {
	PagedLabs
}

// LabsPublishPollerResponse contains the response from method Labs.Publish.
type LabsPublishPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsPublishPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsPublishPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsPublishResponse, error) {
	respType := LabsPublishResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsPublishPollerResponse from the provided client and resume token.
func (l *LabsPublishPollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.Publish", token, client.pl, client.publishHandleError)
	if err != nil {
		return err
	}
	poller := &LabsPublishPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsPublishResponse contains the response from method Labs.Publish.
type LabsPublishResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsSyncGroupPollerResponse contains the response from method Labs.SyncGroup.
type LabsSyncGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsSyncGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsSyncGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsSyncGroupResponse, error) {
	respType := LabsSyncGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsSyncGroupPollerResponse from the provided client and resume token.
func (l *LabsSyncGroupPollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.SyncGroup", token, client.pl, client.syncGroupHandleError)
	if err != nil {
		return err
	}
	poller := &LabsSyncGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsSyncGroupResponse contains the response from method Labs.SyncGroup.
type LabsSyncGroupResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsUpdatePollerResponse contains the response from method Labs.Update.
type LabsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsUpdateResponse, error) {
	respType := LabsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Lab)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LabsUpdatePollerResponse from the provided client and resume token.
func (l *LabsUpdatePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &LabsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LabsUpdateResponse contains the response from method Labs.Update.
type LabsUpdateResponse struct {
	LabsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LabsUpdateResult contains the result from method Labs.Update.
type LabsUpdateResult struct {
	Lab
}

// OperationResultsGetResponse contains the response from method OperationResults.Get.
type OperationResultsGetResponse struct {
	OperationResultsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationResultsGetResult contains the result from method OperationResults.Get.
type OperationResultsGetResult struct {
	OperationResult
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// SKUsListResponse contains the response from method SKUs.List.
type SKUsListResponse struct {
	SKUsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SKUsListResult contains the result from method SKUs.List.
type SKUsListResult struct {
	PagedLabServicesSKUs
}

// SchedulesCreateOrUpdateResponse contains the response from method Schedules.CreateOrUpdate.
type SchedulesCreateOrUpdateResponse struct {
	SchedulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesCreateOrUpdateResult contains the result from method Schedules.CreateOrUpdate.
type SchedulesCreateOrUpdateResult struct {
	Schedule
}

// SchedulesDeletePollerResponse contains the response from method Schedules.Delete.
type SchedulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SchedulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SchedulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SchedulesDeleteResponse, error) {
	respType := SchedulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SchedulesDeletePollerResponse from the provided client and resume token.
func (l *SchedulesDeletePollerResponse) Resume(ctx context.Context, client *SchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SchedulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SchedulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SchedulesDeleteResponse contains the response from method Schedules.Delete.
type SchedulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesGetResponse contains the response from method Schedules.Get.
type SchedulesGetResponse struct {
	SchedulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesGetResult contains the result from method Schedules.Get.
type SchedulesGetResult struct {
	Schedule
}

// SchedulesListByLabResponse contains the response from method Schedules.ListByLab.
type SchedulesListByLabResponse struct {
	SchedulesListByLabResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesListByLabResult contains the result from method Schedules.ListByLab.
type SchedulesListByLabResult struct {
	PagedSchedules
}

// SchedulesUpdateResponse contains the response from method Schedules.Update.
type SchedulesUpdateResponse struct {
	SchedulesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SchedulesUpdateResult contains the result from method Schedules.Update.
type SchedulesUpdateResult struct {
	Schedule
}

// UsagesListByLocationResponse contains the response from method Usages.ListByLocation.
type UsagesListByLocationResponse struct {
	UsagesListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsagesListByLocationResult contains the result from method Usages.ListByLocation.
type UsagesListByLocationResult struct {
	ListUsagesResult
}

// UsersCreateOrUpdatePollerResponse contains the response from method Users.CreateOrUpdate.
type UsersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersCreateOrUpdateResponse, error) {
	respType := UsersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.User)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *UsersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &UsersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersCreateOrUpdateResponse contains the response from method Users.CreateOrUpdate.
type UsersCreateOrUpdateResponse struct {
	UsersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersCreateOrUpdateResult contains the result from method Users.CreateOrUpdate.
type UsersCreateOrUpdateResult struct {
	User
}

// UsersDeletePollerResponse contains the response from method Users.Delete.
type UsersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersDeleteResponse, error) {
	respType := UsersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersDeletePollerResponse from the provided client and resume token.
func (l *UsersDeletePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &UsersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersDeleteResponse contains the response from method Users.Delete.
type UsersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersGetResponse contains the response from method Users.Get.
type UsersGetResponse struct {
	UsersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersGetResult contains the result from method Users.Get.
type UsersGetResult struct {
	User
}

// UsersInvitePollerResponse contains the response from method Users.Invite.
type UsersInvitePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersInvitePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersInvitePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersInviteResponse, error) {
	respType := UsersInviteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersInvitePollerResponse from the provided client and resume token.
func (l *UsersInvitePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Invite", token, client.pl, client.inviteHandleError)
	if err != nil {
		return err
	}
	poller := &UsersInvitePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersInviteResponse contains the response from method Users.Invite.
type UsersInviteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersListByLabResponse contains the response from method Users.ListByLab.
type UsersListByLabResponse struct {
	UsersListByLabResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersListByLabResult contains the result from method Users.ListByLab.
type UsersListByLabResult struct {
	PagedUsers
}

// UsersUpdatePollerResponse contains the response from method Users.Update.
type UsersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersUpdateResponse, error) {
	respType := UsersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.User)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a UsersUpdatePollerResponse from the provided client and resume token.
func (l *UsersUpdatePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &UsersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// UsersUpdateResponse contains the response from method Users.Update.
type UsersUpdateResponse struct {
	UsersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsersUpdateResult contains the result from method Users.Update.
type UsersUpdateResult struct {
	User
}

// VirtualMachinesGetResponse contains the response from method VirtualMachines.Get.
type VirtualMachinesGetResponse struct {
	VirtualMachinesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesGetResult contains the result from method VirtualMachines.Get.
type VirtualMachinesGetResult struct {
	VirtualMachine
}

// VirtualMachinesListByLabResponse contains the response from method VirtualMachines.ListByLab.
type VirtualMachinesListByLabResponse struct {
	VirtualMachinesListByLabResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesListByLabResult contains the result from method VirtualMachines.ListByLab.
type VirtualMachinesListByLabResult struct {
	PagedVirtualMachines
}

// VirtualMachinesRedeployPollerResponse contains the response from method VirtualMachines.Redeploy.
type VirtualMachinesRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesRedeployPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesRedeployResponse, error) {
	respType := VirtualMachinesRedeployResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachinesRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Redeploy", token, client.pl, client.redeployHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesRedeployPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesRedeployResponse contains the response from method VirtualMachines.Redeploy.
type VirtualMachinesRedeployResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesReimagePollerResponse contains the response from method VirtualMachines.Reimage.
type VirtualMachinesReimagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesReimagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesReimagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesReimageResponse, error) {
	respType := VirtualMachinesReimageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesReimagePollerResponse from the provided client and resume token.
func (l *VirtualMachinesReimagePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reimage", token, client.pl, client.reimageHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesReimagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesReimageResponse contains the response from method VirtualMachines.Reimage.
type VirtualMachinesReimageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesResetPasswordPollerResponse contains the response from method VirtualMachines.ResetPassword.
type VirtualMachinesResetPasswordPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesResetPasswordPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesResetPasswordPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesResetPasswordResponse, error) {
	respType := VirtualMachinesResetPasswordResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesResetPasswordPollerResponse from the provided client and resume token.
func (l *VirtualMachinesResetPasswordPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.ResetPassword", token, client.pl, client.resetPasswordHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesResetPasswordPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesResetPasswordResponse contains the response from method VirtualMachines.ResetPassword.
type VirtualMachinesResetPasswordResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesStartPollerResponse contains the response from method VirtualMachines.Start.
type VirtualMachinesStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesStartResponse, error) {
	respType := VirtualMachinesStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesStartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesStartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesStartResponse contains the response from method VirtualMachines.Start.
type VirtualMachinesStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesStopPollerResponse contains the response from method VirtualMachines.Stop.
type VirtualMachinesStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesStopResponse, error) {
	respType := VirtualMachinesStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesStopPollerResponse from the provided client and resume token.
func (l *VirtualMachinesStopPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesStopResponse contains the response from method VirtualMachines.Stop.
type VirtualMachinesStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}
