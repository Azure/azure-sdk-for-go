//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armlogic

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// IntegrationAccountAgreementsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountAgreementsClientListPager struct {
	client    *IntegrationAccountAgreementsClient
	current   IntegrationAccountAgreementsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountAgreementsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountAgreementsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountAgreementsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountAgreementListResult.NextLink == nil || len(*p.current.IntegrationAccountAgreementListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountAgreementsClientListResponse page.
func (p *IntegrationAccountAgreementsClientListPager) PageResponse() IntegrationAccountAgreementsClientListResponse {
	return p.current
}

// IntegrationAccountCertificatesClientListPager provides operations for iterating over paged responses.
type IntegrationAccountCertificatesClientListPager struct {
	client    *IntegrationAccountCertificatesClient
	current   IntegrationAccountCertificatesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountCertificatesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountCertificatesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountCertificatesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountCertificateListResult.NextLink == nil || len(*p.current.IntegrationAccountCertificateListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountCertificatesClientListResponse page.
func (p *IntegrationAccountCertificatesClientListPager) PageResponse() IntegrationAccountCertificatesClientListResponse {
	return p.current
}

// IntegrationAccountMapsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountMapsClientListPager struct {
	client    *IntegrationAccountMapsClient
	current   IntegrationAccountMapsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountMapsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountMapsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountMapsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountMapListResult.NextLink == nil || len(*p.current.IntegrationAccountMapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountMapsClientListResponse page.
func (p *IntegrationAccountMapsClientListPager) PageResponse() IntegrationAccountMapsClientListResponse {
	return p.current
}

// IntegrationAccountPartnersClientListPager provides operations for iterating over paged responses.
type IntegrationAccountPartnersClientListPager struct {
	client    *IntegrationAccountPartnersClient
	current   IntegrationAccountPartnersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountPartnersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountPartnersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountPartnersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountPartnerListResult.NextLink == nil || len(*p.current.IntegrationAccountPartnerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountPartnersClientListResponse page.
func (p *IntegrationAccountPartnersClientListPager) PageResponse() IntegrationAccountPartnersClientListResponse {
	return p.current
}

// IntegrationAccountSchemasClientListPager provides operations for iterating over paged responses.
type IntegrationAccountSchemasClientListPager struct {
	client    *IntegrationAccountSchemasClient
	current   IntegrationAccountSchemasClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountSchemasClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountSchemasClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountSchemasClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountSchemaListResult.NextLink == nil || len(*p.current.IntegrationAccountSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountSchemasClientListResponse page.
func (p *IntegrationAccountSchemasClientListPager) PageResponse() IntegrationAccountSchemasClientListResponse {
	return p.current
}

// IntegrationAccountSessionsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountSessionsClientListPager struct {
	client    *IntegrationAccountSessionsClient
	current   IntegrationAccountSessionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountSessionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountSessionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountSessionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountSessionListResult.NextLink == nil || len(*p.current.IntegrationAccountSessionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountSessionsClientListResponse page.
func (p *IntegrationAccountSessionsClientListPager) PageResponse() IntegrationAccountSessionsClientListResponse {
	return p.current
}

// IntegrationAccountsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IntegrationAccountsClientListByResourceGroupPager struct {
	client    *IntegrationAccountsClient
	current   IntegrationAccountsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountListResult.NextLink == nil || len(*p.current.IntegrationAccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountsClientListByResourceGroupResponse page.
func (p *IntegrationAccountsClientListByResourceGroupPager) PageResponse() IntegrationAccountsClientListByResourceGroupResponse {
	return p.current
}

// IntegrationAccountsClientListBySubscriptionPager provides operations for iterating over paged responses.
type IntegrationAccountsClientListBySubscriptionPager struct {
	client    *IntegrationAccountsClient
	current   IntegrationAccountsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationAccountsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationAccountsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountListResult.NextLink == nil || len(*p.current.IntegrationAccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationAccountsClientListBySubscriptionResponse page.
func (p *IntegrationAccountsClientListBySubscriptionPager) PageResponse() IntegrationAccountsClientListBySubscriptionResponse {
	return p.current
}

// IntegrationServiceEnvironmentManagedAPIOperationsClientListPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentManagedAPIOperationsClientListPager struct {
	client    *IntegrationServiceEnvironmentManagedAPIOperationsClient
	current   IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationServiceEnvironmentManagedAPIOperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationServiceEnvironmentManagedAPIOperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIOperationListResult.NextLink == nil || len(*p.current.APIOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse page.
func (p *IntegrationServiceEnvironmentManagedAPIOperationsClientListPager) PageResponse() IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse {
	return p.current
}

// IntegrationServiceEnvironmentManagedApisClientListPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentManagedApisClientListPager struct {
	client    *IntegrationServiceEnvironmentManagedApisClient
	current   IntegrationServiceEnvironmentManagedApisClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentManagedApisClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationServiceEnvironmentManagedApisClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationServiceEnvironmentManagedApisClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentManagedAPIListResult.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentManagedAPIListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationServiceEnvironmentManagedApisClientListResponse page.
func (p *IntegrationServiceEnvironmentManagedApisClientListPager) PageResponse() IntegrationServiceEnvironmentManagedApisClientListResponse {
	return p.current
}

// IntegrationServiceEnvironmentSKUsClientListPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentSKUsClientListPager struct {
	client    *IntegrationServiceEnvironmentSKUsClient
	current   IntegrationServiceEnvironmentSKUsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentSKUsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationServiceEnvironmentSKUsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationServiceEnvironmentSKUsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentSKUList.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentSKUList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationServiceEnvironmentSKUsClientListResponse page.
func (p *IntegrationServiceEnvironmentSKUsClientListPager) PageResponse() IntegrationServiceEnvironmentSKUsClientListResponse {
	return p.current
}

// IntegrationServiceEnvironmentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentsClientListByResourceGroupPager struct {
	client    *IntegrationServiceEnvironmentsClient
	current   IntegrationServiceEnvironmentsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationServiceEnvironmentsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationServiceEnvironmentsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentListResult.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationServiceEnvironmentsClientListByResourceGroupResponse page.
func (p *IntegrationServiceEnvironmentsClientListByResourceGroupPager) PageResponse() IntegrationServiceEnvironmentsClientListByResourceGroupResponse {
	return p.current
}

// IntegrationServiceEnvironmentsClientListBySubscriptionPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentsClientListBySubscriptionPager struct {
	client    *IntegrationServiceEnvironmentsClient
	current   IntegrationServiceEnvironmentsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationServiceEnvironmentsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationServiceEnvironmentsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentListResult.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationServiceEnvironmentsClientListBySubscriptionResponse page.
func (p *IntegrationServiceEnvironmentsClientListBySubscriptionPager) PageResponse() IntegrationServiceEnvironmentsClientListBySubscriptionResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// WorkflowRunActionRepetitionsRequestHistoriesClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionRepetitionsRequestHistoriesClientListPager struct {
	client    *WorkflowRunActionRepetitionsRequestHistoriesClient
	current   WorkflowRunActionRepetitionsRequestHistoriesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunActionRepetitionsRequestHistoriesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowRunActionRepetitionsRequestHistoriesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowRunActionRepetitionsRequestHistoriesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RequestHistoryListResult.NextLink == nil || len(*p.current.RequestHistoryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowRunActionRepetitionsRequestHistoriesClientListResponse page.
func (p *WorkflowRunActionRepetitionsRequestHistoriesClientListPager) PageResponse() WorkflowRunActionRepetitionsRequestHistoriesClientListResponse {
	return p.current
}

// WorkflowRunActionRequestHistoriesClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionRequestHistoriesClientListPager struct {
	client    *WorkflowRunActionRequestHistoriesClient
	current   WorkflowRunActionRequestHistoriesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunActionRequestHistoriesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowRunActionRequestHistoriesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowRunActionRequestHistoriesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RequestHistoryListResult.NextLink == nil || len(*p.current.RequestHistoryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowRunActionRequestHistoriesClientListResponse page.
func (p *WorkflowRunActionRequestHistoriesClientListPager) PageResponse() WorkflowRunActionRequestHistoriesClientListResponse {
	return p.current
}

// WorkflowRunActionsClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionsClientListPager struct {
	client    *WorkflowRunActionsClient
	current   WorkflowRunActionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunActionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowRunActionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowRunActionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowRunActionListResult.NextLink == nil || len(*p.current.WorkflowRunActionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowRunActionsClientListResponse page.
func (p *WorkflowRunActionsClientListPager) PageResponse() WorkflowRunActionsClientListResponse {
	return p.current
}

// WorkflowRunsClientListPager provides operations for iterating over paged responses.
type WorkflowRunsClientListPager struct {
	client    *WorkflowRunsClient
	current   WorkflowRunsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowRunsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowRunsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowRunListResult.NextLink == nil || len(*p.current.WorkflowRunListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowRunsClientListResponse page.
func (p *WorkflowRunsClientListPager) PageResponse() WorkflowRunsClientListResponse {
	return p.current
}

// WorkflowTriggerHistoriesClientListPager provides operations for iterating over paged responses.
type WorkflowTriggerHistoriesClientListPager struct {
	client    *WorkflowTriggerHistoriesClient
	current   WorkflowTriggerHistoriesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowTriggerHistoriesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowTriggerHistoriesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowTriggerHistoriesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowTriggerHistoryListResult.NextLink == nil || len(*p.current.WorkflowTriggerHistoryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowTriggerHistoriesClientListResponse page.
func (p *WorkflowTriggerHistoriesClientListPager) PageResponse() WorkflowTriggerHistoriesClientListResponse {
	return p.current
}

// WorkflowTriggersClientListPager provides operations for iterating over paged responses.
type WorkflowTriggersClientListPager struct {
	client    *WorkflowTriggersClient
	current   WorkflowTriggersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowTriggersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowTriggersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowTriggersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowTriggerListResult.NextLink == nil || len(*p.current.WorkflowTriggerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowTriggersClientListResponse page.
func (p *WorkflowTriggersClientListPager) PageResponse() WorkflowTriggersClientListResponse {
	return p.current
}

// WorkflowVersionsClientListPager provides operations for iterating over paged responses.
type WorkflowVersionsClientListPager struct {
	client    *WorkflowVersionsClient
	current   WorkflowVersionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowVersionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowVersionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowVersionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowVersionListResult.NextLink == nil || len(*p.current.WorkflowVersionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowVersionsClientListResponse page.
func (p *WorkflowVersionsClientListPager) PageResponse() WorkflowVersionsClientListResponse {
	return p.current
}

// WorkflowsClientListByResourceGroupPager provides operations for iterating over paged responses.
type WorkflowsClientListByResourceGroupPager struct {
	client    *WorkflowsClient
	current   WorkflowsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowListResult.NextLink == nil || len(*p.current.WorkflowListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowsClientListByResourceGroupResponse page.
func (p *WorkflowsClientListByResourceGroupPager) PageResponse() WorkflowsClientListByResourceGroupResponse {
	return p.current
}

// WorkflowsClientListBySubscriptionPager provides operations for iterating over paged responses.
type WorkflowsClientListBySubscriptionPager struct {
	client    *WorkflowsClient
	current   WorkflowsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkflowsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkflowsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowListResult.NextLink == nil || len(*p.current.WorkflowListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkflowsClientListBySubscriptionResponse page.
func (p *WorkflowsClientListBySubscriptionPager) PageResponse() WorkflowsClientListBySubscriptionResponse {
	return p.current
}
