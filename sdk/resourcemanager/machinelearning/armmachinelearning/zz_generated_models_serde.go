//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmachinelearning

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AKS.
func (a AKS) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", a.ComputeLocation)
	objectMap["computeType"] = ComputeTypeAKS
	populateTimeRFC3339(objectMap, "createdOn", a.CreatedOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "disableLocalAuth", a.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", a.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", a.ModifiedOn)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "provisioningErrors", a.ProvisioningErrors)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "resourceId", a.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKS.
func (a *AKS) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &a.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &a.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &a.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &a.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &a.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &a.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &a.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &a.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSSchemaProperties.
func (a AKSSchemaProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentCount", a.AgentCount)
	populate(objectMap, "agentVmSize", a.AgentVMSize)
	populate(objectMap, "aksNetworkingConfiguration", a.AksNetworkingConfiguration)
	populate(objectMap, "clusterFqdn", a.ClusterFqdn)
	populate(objectMap, "clusterPurpose", a.ClusterPurpose)
	populate(objectMap, "loadBalancerSubnet", a.LoadBalancerSubnet)
	populate(objectMap, "loadBalancerType", a.LoadBalancerType)
	populate(objectMap, "sslConfiguration", a.SSLConfiguration)
	populate(objectMap, "systemServices", a.SystemServices)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AccountKeyDatastoreCredentials.
func (a AccountKeyDatastoreCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["credentialsType"] = CredentialsTypeAccountKey
	populate(objectMap, "secrets", a.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountKeyDatastoreCredentials.
func (a *AccountKeyDatastoreCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialsType":
			err = unpopulate(val, "CredentialsType", &a.CredentialsType)
			delete(rawMsg, key)
		case "secrets":
			err = unpopulate(val, "Secrets", &a.Secrets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountKeyDatastoreSecrets.
func (a AccountKeyDatastoreSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "key", a.Key)
	objectMap["secretsType"] = SecretsTypeAccountKey
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountKeyDatastoreSecrets.
func (a *AccountKeyDatastoreSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &a.Key)
			delete(rawMsg, key)
		case "secretsType":
			err = unpopulate(val, "SecretsType", &a.SecretsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AksComputeSecrets.
func (a *AksComputeSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminKubeConfig":
			err = unpopulate(val, "AdminKubeConfig", &a.AdminKubeConfig)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &a.ComputeType)
			delete(rawMsg, key)
		case "imagePullSecretName":
			err = unpopulate(val, "ImagePullSecretName", &a.ImagePullSecretName)
			delete(rawMsg, key)
		case "userKubeConfig":
			err = unpopulate(val, "UserKubeConfig", &a.UserKubeConfig)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmlCompute.
func (a AmlCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", a.ComputeLocation)
	objectMap["computeType"] = ComputeTypeAmlCompute
	populateTimeRFC3339(objectMap, "createdOn", a.CreatedOn)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "disableLocalAuth", a.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", a.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", a.ModifiedOn)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "provisioningErrors", a.ProvisioningErrors)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "resourceId", a.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmlCompute.
func (a *AmlCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &a.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &a.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &a.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &a.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &a.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &a.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &a.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &a.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmlComputeProperties.
func (a AmlComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allocationState", a.AllocationState)
	populateTimeRFC3339(objectMap, "allocationStateTransitionTime", a.AllocationStateTransitionTime)
	populate(objectMap, "currentNodeCount", a.CurrentNodeCount)
	populate(objectMap, "enableNodePublicIp", a.EnableNodePublicIP)
	populate(objectMap, "errors", a.Errors)
	populate(objectMap, "isolatedNetwork", a.IsolatedNetwork)
	populate(objectMap, "nodeStateCounts", a.NodeStateCounts)
	populate(objectMap, "osType", a.OSType)
	populate(objectMap, "propertyBag", &a.PropertyBag)
	populate(objectMap, "remoteLoginPortPublicAccess", a.RemoteLoginPortPublicAccess)
	populate(objectMap, "scaleSettings", a.ScaleSettings)
	populate(objectMap, "subnet", a.Subnet)
	populate(objectMap, "targetNodeCount", a.TargetNodeCount)
	populate(objectMap, "userAccountCredentials", a.UserAccountCredentials)
	populate(objectMap, "vmPriority", a.VMPriority)
	populate(objectMap, "vmSize", a.VMSize)
	populate(objectMap, "virtualMachineImage", a.VirtualMachineImage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmlComputeProperties.
func (a *AmlComputeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocationState":
			err = unpopulate(val, "AllocationState", &a.AllocationState)
			delete(rawMsg, key)
		case "allocationStateTransitionTime":
			err = unpopulateTimeRFC3339(val, "AllocationStateTransitionTime", &a.AllocationStateTransitionTime)
			delete(rawMsg, key)
		case "currentNodeCount":
			err = unpopulate(val, "CurrentNodeCount", &a.CurrentNodeCount)
			delete(rawMsg, key)
		case "enableNodePublicIp":
			err = unpopulate(val, "EnableNodePublicIP", &a.EnableNodePublicIP)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &a.Errors)
			delete(rawMsg, key)
		case "isolatedNetwork":
			err = unpopulate(val, "IsolatedNetwork", &a.IsolatedNetwork)
			delete(rawMsg, key)
		case "nodeStateCounts":
			err = unpopulate(val, "NodeStateCounts", &a.NodeStateCounts)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &a.OSType)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "remoteLoginPortPublicAccess":
			err = unpopulate(val, "RemoteLoginPortPublicAccess", &a.RemoteLoginPortPublicAccess)
			delete(rawMsg, key)
		case "scaleSettings":
			err = unpopulate(val, "ScaleSettings", &a.ScaleSettings)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, "Subnet", &a.Subnet)
			delete(rawMsg, key)
		case "targetNodeCount":
			err = unpopulate(val, "TargetNodeCount", &a.TargetNodeCount)
			delete(rawMsg, key)
		case "userAccountCredentials":
			err = unpopulate(val, "UserAccountCredentials", &a.UserAccountCredentials)
			delete(rawMsg, key)
		case "vmPriority":
			err = unpopulate(val, "VMPriority", &a.VMPriority)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &a.VMSize)
			delete(rawMsg, key)
		case "virtualMachineImage":
			err = unpopulate(val, "VirtualMachineImage", &a.VirtualMachineImage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmlToken.
func (a AmlToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["identityType"] = IdentityConfigurationTypeAMLToken
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmlToken.
func (a *AmlToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identityType":
			err = unpopulate(val, "IdentityType", &a.IdentityType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssetBase.
func (a AssetBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "isAnonymous", a.IsAnonymous)
	populate(objectMap, "isArchived", a.IsArchived)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetContainer.
func (a AssetContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "isArchived", a.IsArchived)
	populate(objectMap, "latestVersion", a.LatestVersion)
	populate(objectMap, "nextVersion", a.NextVersion)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobDatastore.
func (a AzureBlobDatastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "credentials", a.Credentials)
	objectMap["datastoreType"] = DatastoreTypeAzureBlob
	populate(objectMap, "description", a.Description)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "isDefault", a.IsDefault)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "protocol", a.Protocol)
	populate(objectMap, "serviceDataAccessAuthIdentity", a.ServiceDataAccessAuthIdentity)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobDatastore.
func (a *AzureBlobDatastore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "credentials":
			a.Credentials, err = unmarshalDatastoreCredentialsClassification(val)
			delete(rawMsg, key)
		case "datastoreType":
			err = unpopulate(val, "DatastoreType", &a.DatastoreType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "isDefault":
			err = unpopulate(val, "IsDefault", &a.IsDefault)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &a.Protocol)
			delete(rawMsg, key)
		case "serviceDataAccessAuthIdentity":
			err = unpopulate(val, "ServiceDataAccessAuthIdentity", &a.ServiceDataAccessAuthIdentity)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeGen1Datastore.
func (a AzureDataLakeGen1Datastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "credentials", a.Credentials)
	objectMap["datastoreType"] = DatastoreTypeAzureDataLakeGen1
	populate(objectMap, "description", a.Description)
	populate(objectMap, "isDefault", a.IsDefault)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "serviceDataAccessAuthIdentity", a.ServiceDataAccessAuthIdentity)
	populate(objectMap, "storeName", a.StoreName)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeGen1Datastore.
func (a *AzureDataLakeGen1Datastore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentials":
			a.Credentials, err = unmarshalDatastoreCredentialsClassification(val)
			delete(rawMsg, key)
		case "datastoreType":
			err = unpopulate(val, "DatastoreType", &a.DatastoreType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "isDefault":
			err = unpopulate(val, "IsDefault", &a.IsDefault)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "serviceDataAccessAuthIdentity":
			err = unpopulate(val, "ServiceDataAccessAuthIdentity", &a.ServiceDataAccessAuthIdentity)
			delete(rawMsg, key)
		case "storeName":
			err = unpopulate(val, "StoreName", &a.StoreName)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeGen2Datastore.
func (a AzureDataLakeGen2Datastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "credentials", a.Credentials)
	objectMap["datastoreType"] = DatastoreTypeAzureDataLakeGen2
	populate(objectMap, "description", a.Description)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "filesystem", a.Filesystem)
	populate(objectMap, "isDefault", a.IsDefault)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "protocol", a.Protocol)
	populate(objectMap, "serviceDataAccessAuthIdentity", a.ServiceDataAccessAuthIdentity)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeGen2Datastore.
func (a *AzureDataLakeGen2Datastore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "credentials":
			a.Credentials, err = unmarshalDatastoreCredentialsClassification(val)
			delete(rawMsg, key)
		case "datastoreType":
			err = unpopulate(val, "DatastoreType", &a.DatastoreType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "filesystem":
			err = unpopulate(val, "Filesystem", &a.Filesystem)
			delete(rawMsg, key)
		case "isDefault":
			err = unpopulate(val, "IsDefault", &a.IsDefault)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &a.Protocol)
			delete(rawMsg, key)
		case "serviceDataAccessAuthIdentity":
			err = unpopulate(val, "ServiceDataAccessAuthIdentity", &a.ServiceDataAccessAuthIdentity)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileDatastore.
func (a AzureFileDatastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "credentials", a.Credentials)
	objectMap["datastoreType"] = DatastoreTypeAzureFile
	populate(objectMap, "description", a.Description)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "fileShareName", a.FileShareName)
	populate(objectMap, "isDefault", a.IsDefault)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "protocol", a.Protocol)
	populate(objectMap, "serviceDataAccessAuthIdentity", a.ServiceDataAccessAuthIdentity)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileDatastore.
func (a *AzureFileDatastore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "credentials":
			a.Credentials, err = unmarshalDatastoreCredentialsClassification(val)
			delete(rawMsg, key)
		case "datastoreType":
			err = unpopulate(val, "DatastoreType", &a.DatastoreType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "fileShareName":
			err = unpopulate(val, "FileShareName", &a.FileShareName)
			delete(rawMsg, key)
		case "isDefault":
			err = unpopulate(val, "IsDefault", &a.IsDefault)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &a.Protocol)
			delete(rawMsg, key)
		case "serviceDataAccessAuthIdentity":
			err = unpopulate(val, "ServiceDataAccessAuthIdentity", &a.ServiceDataAccessAuthIdentity)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BanditPolicy.
func (b BanditPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "delayEvaluation", b.DelayEvaluation)
	populate(objectMap, "evaluationInterval", b.EvaluationInterval)
	objectMap["policyType"] = EarlyTerminationPolicyTypeBandit
	populate(objectMap, "slackAmount", b.SlackAmount)
	populate(objectMap, "slackFactor", b.SlackFactor)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BanditPolicy.
func (b *BanditPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delayEvaluation":
			err = unpopulate(val, "DelayEvaluation", &b.DelayEvaluation)
			delete(rawMsg, key)
		case "evaluationInterval":
			err = unpopulate(val, "EvaluationInterval", &b.EvaluationInterval)
			delete(rawMsg, key)
		case "policyType":
			err = unpopulate(val, "PolicyType", &b.PolicyType)
			delete(rawMsg, key)
		case "slackAmount":
			err = unpopulate(val, "SlackAmount", &b.SlackAmount)
			delete(rawMsg, key)
		case "slackFactor":
			err = unpopulate(val, "SlackFactor", &b.SlackFactor)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchDeployment.
func (b BatchDeployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", b.ID)
	populate(objectMap, "identity", b.Identity)
	populate(objectMap, "kind", b.Kind)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "sku", b.SKU)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "tags", b.Tags)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BatchDeploymentProperties.
func (b BatchDeploymentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codeConfiguration", b.CodeConfiguration)
	populate(objectMap, "compute", b.Compute)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "environmentId", b.EnvironmentID)
	populate(objectMap, "environmentVariables", b.EnvironmentVariables)
	populate(objectMap, "errorThreshold", b.ErrorThreshold)
	populate(objectMap, "loggingLevel", b.LoggingLevel)
	populate(objectMap, "maxConcurrencyPerInstance", b.MaxConcurrencyPerInstance)
	populate(objectMap, "miniBatchSize", b.MiniBatchSize)
	populate(objectMap, "model", b.Model)
	populate(objectMap, "outputAction", b.OutputAction)
	populate(objectMap, "outputFileName", b.OutputFileName)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "resources", b.Resources)
	populate(objectMap, "retrySettings", b.RetrySettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchDeploymentProperties.
func (b *BatchDeploymentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codeConfiguration":
			err = unpopulate(val, "CodeConfiguration", &b.CodeConfiguration)
			delete(rawMsg, key)
		case "compute":
			err = unpopulate(val, "Compute", &b.Compute)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &b.Description)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, "EnvironmentID", &b.EnvironmentID)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, "EnvironmentVariables", &b.EnvironmentVariables)
			delete(rawMsg, key)
		case "errorThreshold":
			err = unpopulate(val, "ErrorThreshold", &b.ErrorThreshold)
			delete(rawMsg, key)
		case "loggingLevel":
			err = unpopulate(val, "LoggingLevel", &b.LoggingLevel)
			delete(rawMsg, key)
		case "maxConcurrencyPerInstance":
			err = unpopulate(val, "MaxConcurrencyPerInstance", &b.MaxConcurrencyPerInstance)
			delete(rawMsg, key)
		case "miniBatchSize":
			err = unpopulate(val, "MiniBatchSize", &b.MiniBatchSize)
			delete(rawMsg, key)
		case "model":
			b.Model, err = unmarshalAssetReferenceBaseClassification(val)
			delete(rawMsg, key)
		case "outputAction":
			err = unpopulate(val, "OutputAction", &b.OutputAction)
			delete(rawMsg, key)
		case "outputFileName":
			err = unpopulate(val, "OutputFileName", &b.OutputFileName)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		case "resources":
			err = unpopulate(val, "Resources", &b.Resources)
			delete(rawMsg, key)
		case "retrySettings":
			err = unpopulate(val, "RetrySettings", &b.RetrySettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchEndpoint.
func (b BatchEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", b.ID)
	populate(objectMap, "identity", b.Identity)
	populate(objectMap, "kind", b.Kind)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "sku", b.SKU)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "tags", b.Tags)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BatchEndpointProperties.
func (b BatchEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authMode", b.AuthMode)
	populate(objectMap, "defaults", b.Defaults)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "keys", b.Keys)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "scoringUri", b.ScoringURI)
	populate(objectMap, "swaggerUri", b.SwaggerURI)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BayesianSamplingAlgorithm.
func (b BayesianSamplingAlgorithm) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["samplingAlgorithmType"] = SamplingAlgorithmTypeBayesian
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BayesianSamplingAlgorithm.
func (b *BayesianSamplingAlgorithm) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "samplingAlgorithmType":
			err = unpopulate(val, "SamplingAlgorithmType", &b.SamplingAlgorithmType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertificateDatastoreCredentials.
func (c CertificateDatastoreCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authorityUrl", c.AuthorityURL)
	populate(objectMap, "clientId", c.ClientID)
	objectMap["credentialsType"] = CredentialsTypeCertificate
	populate(objectMap, "resourceUrl", c.ResourceURL)
	populate(objectMap, "secrets", c.Secrets)
	populate(objectMap, "tenantId", c.TenantID)
	populate(objectMap, "thumbprint", c.Thumbprint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateDatastoreCredentials.
func (c *CertificateDatastoreCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorityUrl":
			err = unpopulate(val, "AuthorityURL", &c.AuthorityURL)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &c.ClientID)
			delete(rawMsg, key)
		case "credentialsType":
			err = unpopulate(val, "CredentialsType", &c.CredentialsType)
			delete(rawMsg, key)
		case "resourceUrl":
			err = unpopulate(val, "ResourceURL", &c.ResourceURL)
			delete(rawMsg, key)
		case "secrets":
			err = unpopulate(val, "Secrets", &c.Secrets)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &c.TenantID)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, "Thumbprint", &c.Thumbprint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertificateDatastoreSecrets.
func (c CertificateDatastoreSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "certificate", c.Certificate)
	objectMap["secretsType"] = SecretsTypeCertificate
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateDatastoreSecrets.
func (c *CertificateDatastoreSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificate":
			err = unpopulate(val, "Certificate", &c.Certificate)
			delete(rawMsg, key)
		case "secretsType":
			err = unpopulate(val, "SecretsType", &c.SecretsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdateParameters.
func (c ClusterUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CodeContainerProperties.
func (c CodeContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	populate(objectMap, "isArchived", c.IsArchived)
	populate(objectMap, "latestVersion", c.LatestVersion)
	populate(objectMap, "nextVersion", c.NextVersion)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CodeVersionProperties.
func (c CodeVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codeUri", c.CodeURI)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "isAnonymous", c.IsAnonymous)
	populate(objectMap, "isArchived", c.IsArchived)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CommandJob.
func (c CommandJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codeId", c.CodeID)
	populate(objectMap, "command", c.Command)
	populate(objectMap, "computeId", c.ComputeID)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "distribution", c.Distribution)
	populate(objectMap, "environmentId", c.EnvironmentID)
	populate(objectMap, "environmentVariables", c.EnvironmentVariables)
	populate(objectMap, "experimentName", c.ExperimentName)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "inputs", c.Inputs)
	populate(objectMap, "isArchived", c.IsArchived)
	objectMap["jobType"] = JobTypeCommand
	populate(objectMap, "limits", c.Limits)
	populate(objectMap, "outputs", c.Outputs)
	populate(objectMap, "parameters", &c.Parameters)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "resources", c.Resources)
	populate(objectMap, "services", c.Services)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommandJob.
func (c *CommandJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codeId":
			err = unpopulate(val, "CodeID", &c.CodeID)
			delete(rawMsg, key)
		case "command":
			err = unpopulate(val, "Command", &c.Command)
			delete(rawMsg, key)
		case "computeId":
			err = unpopulate(val, "ComputeID", &c.ComputeID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "distribution":
			c.Distribution, err = unmarshalDistributionConfigurationClassification(val)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, "EnvironmentID", &c.EnvironmentID)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, "EnvironmentVariables", &c.EnvironmentVariables)
			delete(rawMsg, key)
		case "experimentName":
			err = unpopulate(val, "ExperimentName", &c.ExperimentName)
			delete(rawMsg, key)
		case "identity":
			c.Identity, err = unmarshalIdentityConfigurationClassification(val)
			delete(rawMsg, key)
		case "inputs":
			c.Inputs, err = unmarshalJobInputClassificationMap(val)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &c.IsArchived)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &c.JobType)
			delete(rawMsg, key)
		case "limits":
			err = unpopulate(val, "Limits", &c.Limits)
			delete(rawMsg, key)
		case "outputs":
			c.Outputs, err = unmarshalJobOutputClassificationMap(val)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "resources":
			err = unpopulate(val, "Resources", &c.Resources)
			delete(rawMsg, key)
		case "services":
			err = unpopulate(val, "Services", &c.Services)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommandJobLimits.
func (c CommandJobLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["jobLimitsType"] = JobLimitsTypeCommand
	populate(objectMap, "timeout", c.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommandJobLimits.
func (c *CommandJobLimits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobLimitsType":
			err = unpopulate(val, "JobLimitsType", &c.JobLimitsType)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &c.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComponentContainerProperties.
func (c ComponentContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	populate(objectMap, "isArchived", c.IsArchived)
	populate(objectMap, "latestVersion", c.LatestVersion)
	populate(objectMap, "nextVersion", c.NextVersion)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ComponentVersionProperties.
func (c ComponentVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "componentSpec", &c.ComponentSpec)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "isAnonymous", c.IsAnonymous)
	populate(objectMap, "isArchived", c.IsArchived)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Compute.
func (c Compute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", c.ComputeLocation)
	objectMap["computeType"] = c.ComputeType
	populateTimeRFC3339(objectMap, "createdOn", c.CreatedOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "disableLocalAuth", c.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", c.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", c.ModifiedOn)
	populate(objectMap, "provisioningErrors", c.ProvisioningErrors)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "resourceId", c.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Compute.
func (c *Compute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &c.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &c.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &c.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &c.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &c.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &c.ModifiedOn)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &c.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &c.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstance.
func (c ComputeInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", c.ComputeLocation)
	objectMap["computeType"] = ComputeTypeComputeInstance
	populateTimeRFC3339(objectMap, "createdOn", c.CreatedOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "disableLocalAuth", c.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", c.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", c.ModifiedOn)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "provisioningErrors", c.ProvisioningErrors)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "resourceId", c.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeInstance.
func (c *ComputeInstance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &c.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &c.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &c.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &c.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &c.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &c.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &c.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &c.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstanceContainer.
func (c ComputeInstanceContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autosave", c.Autosave)
	populate(objectMap, "environment", c.Environment)
	populate(objectMap, "gpu", c.Gpu)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "network", c.Network)
	populate(objectMap, "services", c.Services)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstanceDataMount.
func (c ComputeInstanceDataMount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdBy", c.CreatedBy)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "mountAction", c.MountAction)
	populate(objectMap, "mountName", c.MountName)
	populate(objectMap, "mountPath", c.MountPath)
	populate(objectMap, "mountState", c.MountState)
	populateTimeRFC3339(objectMap, "mountedOn", c.MountedOn)
	populate(objectMap, "source", c.Source)
	populate(objectMap, "sourceType", c.SourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeInstanceDataMount.
func (c *ComputeInstanceDataMount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &c.CreatedBy)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "mountAction":
			err = unpopulate(val, "MountAction", &c.MountAction)
			delete(rawMsg, key)
		case "mountName":
			err = unpopulate(val, "MountName", &c.MountName)
			delete(rawMsg, key)
		case "mountPath":
			err = unpopulate(val, "MountPath", &c.MountPath)
			delete(rawMsg, key)
		case "mountState":
			err = unpopulate(val, "MountState", &c.MountState)
			delete(rawMsg, key)
		case "mountedOn":
			err = unpopulateTimeRFC3339(val, "MountedOn", &c.MountedOn)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		case "sourceType":
			err = unpopulate(val, "SourceType", &c.SourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstanceLastOperation.
func (c ComputeInstanceLastOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operationName", c.OperationName)
	populate(objectMap, "operationStatus", c.OperationStatus)
	populateTimeRFC3339(objectMap, "operationTime", c.OperationTime)
	populate(objectMap, "operationTrigger", c.OperationTrigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeInstanceLastOperation.
func (c *ComputeInstanceLastOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "operationName":
			err = unpopulate(val, "OperationName", &c.OperationName)
			delete(rawMsg, key)
		case "operationStatus":
			err = unpopulate(val, "OperationStatus", &c.OperationStatus)
			delete(rawMsg, key)
		case "operationTime":
			err = unpopulateTimeRFC3339(val, "OperationTime", &c.OperationTime)
			delete(rawMsg, key)
		case "operationTrigger":
			err = unpopulate(val, "OperationTrigger", &c.OperationTrigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstanceProperties.
func (c ComputeInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationSharingPolicy", c.ApplicationSharingPolicy)
	populate(objectMap, "applications", c.Applications)
	populate(objectMap, "computeInstanceAuthorizationType", c.ComputeInstanceAuthorizationType)
	populate(objectMap, "connectivityEndpoints", c.ConnectivityEndpoints)
	populate(objectMap, "containers", c.Containers)
	populate(objectMap, "createdBy", c.CreatedBy)
	populate(objectMap, "dataDisks", c.DataDisks)
	populate(objectMap, "dataMounts", c.DataMounts)
	populate(objectMap, "enableNodePublicIp", c.EnableNodePublicIP)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "lastOperation", c.LastOperation)
	populate(objectMap, "personalComputeInstanceSettings", c.PersonalComputeInstanceSettings)
	populate(objectMap, "sshSettings", c.SSHSettings)
	populate(objectMap, "schedules", c.Schedules)
	populate(objectMap, "setupScripts", c.SetupScripts)
	populate(objectMap, "state", c.State)
	populate(objectMap, "subnet", c.Subnet)
	populate(objectMap, "vmSize", c.VMSize)
	populate(objectMap, "versions", c.Versions)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ComputeResource.
func (c ComputeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeResource.
func (c *ComputeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			c.Properties, err = unmarshalComputeClassification(val)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &c.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeResourceSchema.
func (c ComputeResourceSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeResourceSchema.
func (c *ComputeResourceSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			c.Properties, err = unmarshalComputeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeSchedules.
func (c ComputeSchedules) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeStartStop", c.ComputeStartStop)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CustomModelJobInput.
func (c CustomModelJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	objectMap["jobInputType"] = JobInputTypeCustomModel
	populate(objectMap, "mode", c.Mode)
	populate(objectMap, "uri", c.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModelJobInput.
func (c *CustomModelJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &c.JobInputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &c.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &c.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomModelJobOutput.
func (c CustomModelJobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	objectMap["jobOutputType"] = JobOutputTypeCustomModel
	populate(objectMap, "mode", c.Mode)
	populate(objectMap, "uri", c.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModelJobOutput.
func (c *CustomModelJobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "jobOutputType":
			err = unpopulate(val, "JobOutputType", &c.JobOutputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &c.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &c.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataContainerProperties.
func (d DataContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataType", d.DataType)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "isArchived", d.IsArchived)
	populate(objectMap, "latestVersion", d.LatestVersion)
	populate(objectMap, "nextVersion", d.NextVersion)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataFactory.
func (d DataFactory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", d.ComputeLocation)
	objectMap["computeType"] = ComputeTypeDataFactory
	populateTimeRFC3339(objectMap, "createdOn", d.CreatedOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", d.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", d.ModifiedOn)
	populate(objectMap, "provisioningErrors", d.ProvisioningErrors)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "resourceId", d.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFactory.
func (d *DataFactory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &d.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &d.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &d.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &d.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &d.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &d.ModifiedOn)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &d.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &d.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalytics.
func (d DataLakeAnalytics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", d.ComputeLocation)
	objectMap["computeType"] = ComputeTypeDataLakeAnalytics
	populateTimeRFC3339(objectMap, "createdOn", d.CreatedOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", d.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", d.ModifiedOn)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "provisioningErrors", d.ProvisioningErrors)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "resourceId", d.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalytics.
func (d *DataLakeAnalytics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &d.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &d.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &d.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &d.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &d.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &d.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &d.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &d.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataPathAssetReference.
func (d DataPathAssetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datastoreId", d.DatastoreID)
	populate(objectMap, "path", d.Path)
	objectMap["referenceType"] = ReferenceTypeDataPath
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataPathAssetReference.
func (d *DataPathAssetReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datastoreId":
			err = unpopulate(val, "DatastoreID", &d.DatastoreID)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &d.Path)
			delete(rawMsg, key)
		case "referenceType":
			err = unpopulate(val, "ReferenceType", &d.ReferenceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataVersionBase.
func (d DataVersionBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataVersionBase.
func (d *DataVersionBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDataVersionBasePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataVersionBaseProperties.
func (d DataVersionBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dataType"] = d.DataType
	populate(objectMap, "dataUri", d.DataURI)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "isAnonymous", d.IsAnonymous)
	populate(objectMap, "isArchived", d.IsArchived)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Databricks.
func (d Databricks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", d.ComputeLocation)
	objectMap["computeType"] = ComputeTypeDatabricks
	populateTimeRFC3339(objectMap, "createdOn", d.CreatedOn)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "disableLocalAuth", d.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", d.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", d.ModifiedOn)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "provisioningErrors", d.ProvisioningErrors)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "resourceId", d.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Databricks.
func (d *Databricks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &d.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &d.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &d.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &d.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &d.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &d.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &d.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &d.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksComputeSecrets.
func (d *DatabricksComputeSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			err = unpopulate(val, "ComputeType", &d.ComputeType)
			delete(rawMsg, key)
		case "databricksAccessToken":
			err = unpopulate(val, "DatabricksAccessToken", &d.DatabricksAccessToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Datastore.
func (d Datastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Datastore.
func (d *Datastore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDatastorePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatastoreProperties.
func (d DatastoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "credentials", d.Credentials)
	objectMap["datastoreType"] = d.DatastoreType
	populate(objectMap, "description", d.Description)
	populate(objectMap, "isDefault", d.IsDefault)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatastoreProperties.
func (d *DatastoreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentials":
			d.Credentials, err = unmarshalDatastoreCredentialsClassification(val)
			delete(rawMsg, key)
		case "datastoreType":
			err = unpopulate(val, "DatastoreType", &d.DatastoreType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "isDefault":
			err = unpopulate(val, "IsDefault", &d.IsDefault)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DefaultScaleSettings.
func (d DefaultScaleSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["scaleType"] = ScaleTypeDefault
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DefaultScaleSettings.
func (d *DefaultScaleSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scaleType":
			err = unpopulate(val, "ScaleType", &d.ScaleType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiagnoseRequestProperties.
func (d DiagnoseRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationInsights", d.ApplicationInsights)
	populate(objectMap, "containerRegistry", d.ContainerRegistry)
	populate(objectMap, "dnsResolution", d.DNSResolution)
	populate(objectMap, "keyVault", d.KeyVault)
	populate(objectMap, "nsg", d.Nsg)
	populate(objectMap, "others", d.Others)
	populate(objectMap, "resourceLock", d.ResourceLock)
	populate(objectMap, "storageAccount", d.StorageAccount)
	populate(objectMap, "udr", d.Udr)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EndpointDeploymentPropertiesBase.
func (e EndpointDeploymentPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codeConfiguration", e.CodeConfiguration)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "environmentId", e.EnvironmentID)
	populate(objectMap, "environmentVariables", e.EnvironmentVariables)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EndpointPropertiesBase.
func (e EndpointPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authMode", e.AuthMode)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "keys", e.Keys)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "scoringUri", e.ScoringURI)
	populate(objectMap, "swaggerUri", e.SwaggerURI)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentContainerProperties.
func (e EnvironmentContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", e.Description)
	populate(objectMap, "isArchived", e.IsArchived)
	populate(objectMap, "latestVersion", e.LatestVersion)
	populate(objectMap, "nextVersion", e.NextVersion)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVersionProperties.
func (e EnvironmentVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "build", e.Build)
	populate(objectMap, "condaFile", e.CondaFile)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "environmentType", e.EnvironmentType)
	populate(objectMap, "image", e.Image)
	populate(objectMap, "inferenceConfig", e.InferenceConfig)
	populate(objectMap, "isAnonymous", e.IsAnonymous)
	populate(objectMap, "isArchived", e.IsArchived)
	populate(objectMap, "osType", e.OSType)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type FlavorData.
func (f FlavorData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", f.Data)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type GridSamplingAlgorithm.
func (g GridSamplingAlgorithm) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["samplingAlgorithmType"] = SamplingAlgorithmTypeGrid
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GridSamplingAlgorithm.
func (g *GridSamplingAlgorithm) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "samplingAlgorithmType":
			err = unpopulate(val, "SamplingAlgorithmType", &g.SamplingAlgorithmType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HDInsight.
func (h HDInsight) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", h.ComputeLocation)
	objectMap["computeType"] = ComputeTypeHDInsight
	populateTimeRFC3339(objectMap, "createdOn", h.CreatedOn)
	populate(objectMap, "description", h.Description)
	populate(objectMap, "disableLocalAuth", h.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", h.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", h.ModifiedOn)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "provisioningErrors", h.ProvisioningErrors)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "resourceId", h.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsight.
func (h *HDInsight) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &h.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &h.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &h.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &h.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &h.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &h.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &h.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &h.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IDAssetReference.
func (i IDAssetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetId", i.AssetID)
	objectMap["referenceType"] = ReferenceTypeID
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IDAssetReference.
func (i *IDAssetReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetId":
			err = unpopulate(val, "AssetID", &i.AssetID)
			delete(rawMsg, key)
		case "referenceType":
			err = unpopulate(val, "ReferenceType", &i.ReferenceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstanceTypeSchema.
func (i InstanceTypeSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nodeSelector", i.NodeSelector)
	populate(objectMap, "resources", i.Resources)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InstanceTypeSchemaResources.
func (i InstanceTypeSchemaResources) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "limits", i.Limits)
	populate(objectMap, "requests", i.Requests)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JobBase.
func (j JobBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobBase.
func (j *JobBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &j.Name)
			delete(rawMsg, key)
		case "properties":
			j.Properties, err = unmarshalJobBasePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &j.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobBaseProperties.
func (j JobBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeId", j.ComputeID)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "experimentName", j.ExperimentName)
	populate(objectMap, "identity", j.Identity)
	populate(objectMap, "isArchived", j.IsArchived)
	objectMap["jobType"] = j.JobType
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "services", j.Services)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "tags", j.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobBaseProperties.
func (j *JobBaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeId":
			err = unpopulate(val, "ComputeID", &j.ComputeID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &j.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "experimentName":
			err = unpopulate(val, "ExperimentName", &j.ExperimentName)
			delete(rawMsg, key)
		case "identity":
			j.Identity, err = unmarshalIdentityConfigurationClassification(val)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &j.IsArchived)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &j.JobType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &j.Properties)
			delete(rawMsg, key)
		case "services":
			err = unpopulate(val, "Services", &j.Services)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &j.Status)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &j.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobService.
func (j JobService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "endpoint", j.Endpoint)
	populate(objectMap, "errorMessage", j.ErrorMessage)
	populate(objectMap, "jobServiceType", j.JobServiceType)
	populate(objectMap, "port", j.Port)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Kubernetes.
func (k Kubernetes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", k.ComputeLocation)
	objectMap["computeType"] = ComputeTypeKubernetes
	populateTimeRFC3339(objectMap, "createdOn", k.CreatedOn)
	populate(objectMap, "description", k.Description)
	populate(objectMap, "disableLocalAuth", k.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", k.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", k.ModifiedOn)
	populate(objectMap, "properties", k.Properties)
	populate(objectMap, "provisioningErrors", k.ProvisioningErrors)
	populate(objectMap, "provisioningState", k.ProvisioningState)
	populate(objectMap, "resourceId", k.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Kubernetes.
func (k *Kubernetes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &k.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &k.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &k.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &k.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &k.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &k.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &k.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &k.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &k.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &k.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &k.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesOnlineDeployment.
func (k KubernetesOnlineDeployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appInsightsEnabled", k.AppInsightsEnabled)
	populate(objectMap, "codeConfiguration", k.CodeConfiguration)
	populate(objectMap, "containerResourceRequirements", k.ContainerResourceRequirements)
	populate(objectMap, "description", k.Description)
	objectMap["endpointComputeType"] = EndpointComputeTypeKubernetes
	populate(objectMap, "environmentId", k.EnvironmentID)
	populate(objectMap, "environmentVariables", k.EnvironmentVariables)
	populate(objectMap, "instanceType", k.InstanceType)
	populate(objectMap, "livenessProbe", k.LivenessProbe)
	populate(objectMap, "model", k.Model)
	populate(objectMap, "modelMountPath", k.ModelMountPath)
	populate(objectMap, "properties", k.Properties)
	populate(objectMap, "provisioningState", k.ProvisioningState)
	populate(objectMap, "readinessProbe", k.ReadinessProbe)
	populate(objectMap, "requestSettings", k.RequestSettings)
	populate(objectMap, "scaleSettings", k.ScaleSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesOnlineDeployment.
func (k *KubernetesOnlineDeployment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appInsightsEnabled":
			err = unpopulate(val, "AppInsightsEnabled", &k.AppInsightsEnabled)
			delete(rawMsg, key)
		case "codeConfiguration":
			err = unpopulate(val, "CodeConfiguration", &k.CodeConfiguration)
			delete(rawMsg, key)
		case "containerResourceRequirements":
			err = unpopulate(val, "ContainerResourceRequirements", &k.ContainerResourceRequirements)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &k.Description)
			delete(rawMsg, key)
		case "endpointComputeType":
			err = unpopulate(val, "EndpointComputeType", &k.EndpointComputeType)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, "EnvironmentID", &k.EnvironmentID)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, "EnvironmentVariables", &k.EnvironmentVariables)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &k.InstanceType)
			delete(rawMsg, key)
		case "livenessProbe":
			err = unpopulate(val, "LivenessProbe", &k.LivenessProbe)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &k.Model)
			delete(rawMsg, key)
		case "modelMountPath":
			err = unpopulate(val, "ModelMountPath", &k.ModelMountPath)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &k.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &k.ProvisioningState)
			delete(rawMsg, key)
		case "readinessProbe":
			err = unpopulate(val, "ReadinessProbe", &k.ReadinessProbe)
			delete(rawMsg, key)
		case "requestSettings":
			err = unpopulate(val, "RequestSettings", &k.RequestSettings)
			delete(rawMsg, key)
		case "scaleSettings":
			k.ScaleSettings, err = unmarshalOnlineScaleSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesProperties.
func (k KubernetesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultInstanceType", k.DefaultInstanceType)
	populate(objectMap, "extensionInstanceReleaseTrain", k.ExtensionInstanceReleaseTrain)
	populate(objectMap, "extensionPrincipalId", k.ExtensionPrincipalID)
	populate(objectMap, "instanceTypes", k.InstanceTypes)
	populate(objectMap, "namespace", k.Namespace)
	populate(objectMap, "relayConnectionString", k.RelayConnectionString)
	populate(objectMap, "serviceBusConnectionString", k.ServiceBusConnectionString)
	populate(objectMap, "vcName", k.VcName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiteralJobInput.
func (l LiteralJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", l.Description)
	objectMap["jobInputType"] = JobInputTypeLiteral
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiteralJobInput.
func (l *LiteralJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &l.JobInputType)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLFlowModelJobInput.
func (m MLFlowModelJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	objectMap["jobInputType"] = JobInputTypeMlflowModel
	populate(objectMap, "mode", m.Mode)
	populate(objectMap, "uri", m.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLFlowModelJobInput.
func (m *MLFlowModelJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &m.JobInputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &m.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &m.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLFlowModelJobOutput.
func (m MLFlowModelJobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	objectMap["jobOutputType"] = JobOutputTypeMlflowModel
	populate(objectMap, "mode", m.Mode)
	populate(objectMap, "uri", m.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLFlowModelJobOutput.
func (m *MLFlowModelJobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "jobOutputType":
			err = unpopulate(val, "JobOutputType", &m.JobOutputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &m.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &m.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLTableData.
func (m MLTableData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dataType"] = DataTypeMltable
	populate(objectMap, "dataUri", m.DataURI)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "isAnonymous", m.IsAnonymous)
	populate(objectMap, "isArchived", m.IsArchived)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "referencedUris", m.ReferencedUris)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLTableData.
func (m *MLTableData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &m.DataType)
			delete(rawMsg, key)
		case "dataUri":
			err = unpopulate(val, "DataURI", &m.DataURI)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "isAnonymous":
			err = unpopulate(val, "IsAnonymous", &m.IsAnonymous)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &m.IsArchived)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "referencedUris":
			err = unpopulate(val, "ReferencedUris", &m.ReferencedUris)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLTableJobInput.
func (m MLTableJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	objectMap["jobInputType"] = JobInputTypeMltable
	populate(objectMap, "mode", m.Mode)
	populate(objectMap, "uri", m.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLTableJobInput.
func (m *MLTableJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &m.JobInputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &m.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &m.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLTableJobOutput.
func (m MLTableJobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	objectMap["jobOutputType"] = JobOutputTypeMltable
	populate(objectMap, "mode", m.Mode)
	populate(objectMap, "uri", m.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLTableJobOutput.
func (m *MLTableJobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "jobOutputType":
			err = unpopulate(val, "JobOutputType", &m.JobOutputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &m.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &m.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentity.
func (m ManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", m.ClientID)
	objectMap["identityType"] = IdentityConfigurationTypeManaged
	populate(objectMap, "objectId", m.ObjectID)
	populate(objectMap, "resourceId", m.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentity.
func (m *ManagedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &m.ClientID)
			delete(rawMsg, key)
		case "identityType":
			err = unpopulate(val, "IdentityType", &m.IdentityType)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, "ObjectID", &m.ObjectID)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &m.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (m ManagedIdentityAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authType"] = ConnectionAuthTypeManagedIdentity
	populate(objectMap, "category", m.Category)
	populate(objectMap, "credentials", m.Credentials)
	populate(objectMap, "target", m.Target)
	populate(objectMap, "value", m.Value)
	populate(objectMap, "valueFormat", m.ValueFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (m *ManagedIdentityAuthTypeWorkspaceConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authType":
			err = unpopulate(val, "AuthType", &m.AuthType)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &m.Category)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &m.Credentials)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &m.Target)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		case "valueFormat":
			err = unpopulate(val, "ValueFormat", &m.ValueFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedOnlineDeployment.
func (m ManagedOnlineDeployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appInsightsEnabled", m.AppInsightsEnabled)
	populate(objectMap, "codeConfiguration", m.CodeConfiguration)
	populate(objectMap, "description", m.Description)
	objectMap["endpointComputeType"] = EndpointComputeTypeManaged
	populate(objectMap, "environmentId", m.EnvironmentID)
	populate(objectMap, "environmentVariables", m.EnvironmentVariables)
	populate(objectMap, "instanceType", m.InstanceType)
	populate(objectMap, "livenessProbe", m.LivenessProbe)
	populate(objectMap, "model", m.Model)
	populate(objectMap, "modelMountPath", m.ModelMountPath)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "readinessProbe", m.ReadinessProbe)
	populate(objectMap, "requestSettings", m.RequestSettings)
	populate(objectMap, "scaleSettings", m.ScaleSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedOnlineDeployment.
func (m *ManagedOnlineDeployment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appInsightsEnabled":
			err = unpopulate(val, "AppInsightsEnabled", &m.AppInsightsEnabled)
			delete(rawMsg, key)
		case "codeConfiguration":
			err = unpopulate(val, "CodeConfiguration", &m.CodeConfiguration)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "endpointComputeType":
			err = unpopulate(val, "EndpointComputeType", &m.EndpointComputeType)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, "EnvironmentID", &m.EnvironmentID)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, "EnvironmentVariables", &m.EnvironmentVariables)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &m.InstanceType)
			delete(rawMsg, key)
		case "livenessProbe":
			err = unpopulate(val, "LivenessProbe", &m.LivenessProbe)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &m.Model)
			delete(rawMsg, key)
		case "modelMountPath":
			err = unpopulate(val, "ModelMountPath", &m.ModelMountPath)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &m.ProvisioningState)
			delete(rawMsg, key)
		case "readinessProbe":
			err = unpopulate(val, "ReadinessProbe", &m.ReadinessProbe)
			delete(rawMsg, key)
		case "requestSettings":
			err = unpopulate(val, "RequestSettings", &m.RequestSettings)
			delete(rawMsg, key)
		case "scaleSettings":
			m.ScaleSettings, err = unmarshalOnlineScaleSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentity.
func (m ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MedianStoppingPolicy.
func (m MedianStoppingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "delayEvaluation", m.DelayEvaluation)
	populate(objectMap, "evaluationInterval", m.EvaluationInterval)
	objectMap["policyType"] = EarlyTerminationPolicyTypeMedianStopping
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MedianStoppingPolicy.
func (m *MedianStoppingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delayEvaluation":
			err = unpopulate(val, "DelayEvaluation", &m.DelayEvaluation)
			delete(rawMsg, key)
		case "evaluationInterval":
			err = unpopulate(val, "EvaluationInterval", &m.EvaluationInterval)
			delete(rawMsg, key)
		case "policyType":
			err = unpopulate(val, "PolicyType", &m.PolicyType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModelContainerProperties.
func (m ModelContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "isArchived", m.IsArchived)
	populate(objectMap, "latestVersion", m.LatestVersion)
	populate(objectMap, "nextVersion", m.NextVersion)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ModelVersionProperties.
func (m ModelVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "flavors", m.Flavors)
	populate(objectMap, "isAnonymous", m.IsAnonymous)
	populate(objectMap, "isArchived", m.IsArchived)
	populate(objectMap, "jobName", m.JobName)
	populate(objectMap, "modelType", m.ModelType)
	populate(objectMap, "modelUri", m.ModelURI)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Mpi.
func (m Mpi) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["distributionType"] = DistributionTypeMpi
	populate(objectMap, "processCountPerInstance", m.ProcessCountPerInstance)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Mpi.
func (m *Mpi) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionType":
			err = unpopulate(val, "DistributionType", &m.DistributionType)
			delete(rawMsg, key)
		case "processCountPerInstance":
			err = unpopulate(val, "ProcessCountPerInstance", &m.ProcessCountPerInstance)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NoneAuthTypeWorkspaceConnectionProperties.
func (n NoneAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authType"] = ConnectionAuthTypeNone
	populate(objectMap, "category", n.Category)
	populate(objectMap, "target", n.Target)
	populate(objectMap, "value", n.Value)
	populate(objectMap, "valueFormat", n.ValueFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NoneAuthTypeWorkspaceConnectionProperties.
func (n *NoneAuthTypeWorkspaceConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authType":
			err = unpopulate(val, "AuthType", &n.AuthType)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &n.Category)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &n.Target)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		case "valueFormat":
			err = unpopulate(val, "ValueFormat", &n.ValueFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NoneDatastoreCredentials.
func (n NoneDatastoreCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["credentialsType"] = CredentialsTypeNone
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NoneDatastoreCredentials.
func (n *NoneDatastoreCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialsType":
			err = unpopulate(val, "CredentialsType", &n.CredentialsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnlineDeployment.
func (o OnlineDeployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", o.ID)
	populate(objectMap, "identity", o.Identity)
	populate(objectMap, "kind", o.Kind)
	populate(objectMap, "location", o.Location)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "sku", o.SKU)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "tags", o.Tags)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnlineDeployment.
func (o *OnlineDeployment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &o.Identity)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &o.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &o.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			o.Properties, err = unmarshalOnlineDeploymentPropertiesClassification(val)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &o.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &o.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnlineDeploymentProperties.
func (o OnlineDeploymentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appInsightsEnabled", o.AppInsightsEnabled)
	populate(objectMap, "codeConfiguration", o.CodeConfiguration)
	populate(objectMap, "description", o.Description)
	objectMap["endpointComputeType"] = o.EndpointComputeType
	populate(objectMap, "environmentId", o.EnvironmentID)
	populate(objectMap, "environmentVariables", o.EnvironmentVariables)
	populate(objectMap, "instanceType", o.InstanceType)
	populate(objectMap, "livenessProbe", o.LivenessProbe)
	populate(objectMap, "model", o.Model)
	populate(objectMap, "modelMountPath", o.ModelMountPath)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "readinessProbe", o.ReadinessProbe)
	populate(objectMap, "requestSettings", o.RequestSettings)
	populate(objectMap, "scaleSettings", o.ScaleSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnlineDeploymentProperties.
func (o *OnlineDeploymentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appInsightsEnabled":
			err = unpopulate(val, "AppInsightsEnabled", &o.AppInsightsEnabled)
			delete(rawMsg, key)
		case "codeConfiguration":
			err = unpopulate(val, "CodeConfiguration", &o.CodeConfiguration)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "endpointComputeType":
			err = unpopulate(val, "EndpointComputeType", &o.EndpointComputeType)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, "EnvironmentID", &o.EnvironmentID)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, "EnvironmentVariables", &o.EnvironmentVariables)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &o.InstanceType)
			delete(rawMsg, key)
		case "livenessProbe":
			err = unpopulate(val, "LivenessProbe", &o.LivenessProbe)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &o.Model)
			delete(rawMsg, key)
		case "modelMountPath":
			err = unpopulate(val, "ModelMountPath", &o.ModelMountPath)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &o.ProvisioningState)
			delete(rawMsg, key)
		case "readinessProbe":
			err = unpopulate(val, "ReadinessProbe", &o.ReadinessProbe)
			delete(rawMsg, key)
		case "requestSettings":
			err = unpopulate(val, "RequestSettings", &o.RequestSettings)
			delete(rawMsg, key)
		case "scaleSettings":
			o.ScaleSettings, err = unmarshalOnlineScaleSettingsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnlineEndpoint.
func (o OnlineEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", o.ID)
	populate(objectMap, "identity", o.Identity)
	populate(objectMap, "kind", o.Kind)
	populate(objectMap, "location", o.Location)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "sku", o.SKU)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "tags", o.Tags)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OnlineEndpointProperties.
func (o OnlineEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authMode", o.AuthMode)
	populate(objectMap, "compute", o.Compute)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "keys", o.Keys)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "scoringUri", o.ScoringURI)
	populate(objectMap, "swaggerUri", o.SwaggerURI)
	populate(objectMap, "traffic", o.Traffic)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OutputPathAssetReference.
func (o OutputPathAssetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "jobId", o.JobID)
	populate(objectMap, "path", o.Path)
	objectMap["referenceType"] = ReferenceTypeOutputPath
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputPathAssetReference.
func (o *OutputPathAssetReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobId":
			err = unpopulate(val, "JobID", &o.JobID)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &o.Path)
			delete(rawMsg, key)
		case "referenceType":
			err = unpopulate(val, "ReferenceType", &o.ReferenceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PATAuthTypeWorkspaceConnectionProperties.
func (p PATAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authType"] = ConnectionAuthTypePAT
	populate(objectMap, "category", p.Category)
	populate(objectMap, "credentials", p.Credentials)
	populate(objectMap, "target", p.Target)
	populate(objectMap, "value", p.Value)
	populate(objectMap, "valueFormat", p.ValueFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PATAuthTypeWorkspaceConnectionProperties.
func (p *PATAuthTypeWorkspaceConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authType":
			err = unpopulate(val, "AuthType", &p.AuthType)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &p.Category)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &p.Credentials)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &p.Target)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		case "valueFormat":
			err = unpopulate(val, "ValueFormat", &p.ValueFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties.
func (p PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PartialManagedServiceIdentity.
func (p PartialManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "type", p.Type)
	populate(objectMap, "userAssignedIdentities", p.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PartialMinimalTrackedResource.
func (p PartialMinimalTrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PartialMinimalTrackedResourceWithIdentity.
func (p PartialMinimalTrackedResourceWithIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PartialMinimalTrackedResourceWithSKU.
func (p PartialMinimalTrackedResourceWithSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PipelineJob.
func (p PipelineJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeId", p.ComputeID)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "experimentName", p.ExperimentName)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "inputs", p.Inputs)
	populate(objectMap, "isArchived", p.IsArchived)
	objectMap["jobType"] = JobTypePipeline
	populate(objectMap, "jobs", p.Jobs)
	populate(objectMap, "outputs", p.Outputs)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "services", p.Services)
	populate(objectMap, "settings", &p.Settings)
	populate(objectMap, "status", p.Status)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineJob.
func (p *PipelineJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeId":
			err = unpopulate(val, "ComputeID", &p.ComputeID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "experimentName":
			err = unpopulate(val, "ExperimentName", &p.ExperimentName)
			delete(rawMsg, key)
		case "identity":
			p.Identity, err = unmarshalIdentityConfigurationClassification(val)
			delete(rawMsg, key)
		case "inputs":
			p.Inputs, err = unmarshalJobInputClassificationMap(val)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &p.IsArchived)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &p.JobType)
			delete(rawMsg, key)
		case "jobs":
			err = unpopulate(val, "Jobs", &p.Jobs)
			delete(rawMsg, key)
		case "outputs":
			p.Outputs, err = unmarshalJobOutputClassificationMap(val)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "services":
			err = unpopulate(val, "Services", &p.Services)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &p.Settings)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PyTorch.
func (p PyTorch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["distributionType"] = DistributionTypePyTorch
	populate(objectMap, "processCountPerInstance", p.ProcessCountPerInstance)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PyTorch.
func (p *PyTorch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionType":
			err = unpopulate(val, "DistributionType", &p.DistributionType)
			delete(rawMsg, key)
		case "processCountPerInstance":
			err = unpopulate(val, "ProcessCountPerInstance", &p.ProcessCountPerInstance)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuotaUpdateParameters.
func (q QuotaUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", q.Location)
	populate(objectMap, "value", q.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RandomSamplingAlgorithm.
func (r RandomSamplingAlgorithm) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rule", r.Rule)
	objectMap["samplingAlgorithmType"] = SamplingAlgorithmTypeRandom
	populate(objectMap, "seed", r.Seed)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RandomSamplingAlgorithm.
func (r *RandomSamplingAlgorithm) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rule":
			err = unpopulate(val, "Rule", &r.Rule)
			delete(rawMsg, key)
		case "samplingAlgorithmType":
			err = unpopulate(val, "SamplingAlgorithmType", &r.SamplingAlgorithmType)
			delete(rawMsg, key)
		case "seed":
			err = unpopulate(val, "Seed", &r.Seed)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceBase.
func (r ResourceBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", r.Description)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ResourceConfiguration.
func (r ResourceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "instanceCount", r.InstanceCount)
	populate(objectMap, "instanceType", r.InstanceType)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SASAuthTypeWorkspaceConnectionProperties.
func (s SASAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authType"] = ConnectionAuthTypeSAS
	populate(objectMap, "category", s.Category)
	populate(objectMap, "credentials", s.Credentials)
	populate(objectMap, "target", s.Target)
	populate(objectMap, "value", s.Value)
	populate(objectMap, "valueFormat", s.ValueFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SASAuthTypeWorkspaceConnectionProperties.
func (s *SASAuthTypeWorkspaceConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authType":
			err = unpopulate(val, "AuthType", &s.AuthType)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &s.Category)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &s.Credentials)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &s.Target)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		case "valueFormat":
			err = unpopulate(val, "ValueFormat", &s.ValueFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SasDatastoreCredentials.
func (s SasDatastoreCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["credentialsType"] = CredentialsTypeSas
	populate(objectMap, "secrets", s.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SasDatastoreCredentials.
func (s *SasDatastoreCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialsType":
			err = unpopulate(val, "CredentialsType", &s.CredentialsType)
			delete(rawMsg, key)
		case "secrets":
			err = unpopulate(val, "Secrets", &s.Secrets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SasDatastoreSecrets.
func (s SasDatastoreSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "sasToken", s.SasToken)
	objectMap["secretsType"] = SecretsTypeSas
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SasDatastoreSecrets.
func (s *SasDatastoreSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sasToken":
			err = unpopulate(val, "SasToken", &s.SasToken)
			delete(rawMsg, key)
		case "secretsType":
			err = unpopulate(val, "SecretsType", &s.SecretsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalDatastoreCredentials.
func (s ServicePrincipalDatastoreCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authorityUrl", s.AuthorityURL)
	populate(objectMap, "clientId", s.ClientID)
	objectMap["credentialsType"] = CredentialsTypeServicePrincipal
	populate(objectMap, "resourceUrl", s.ResourceURL)
	populate(objectMap, "secrets", s.Secrets)
	populate(objectMap, "tenantId", s.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalDatastoreCredentials.
func (s *ServicePrincipalDatastoreCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorityUrl":
			err = unpopulate(val, "AuthorityURL", &s.AuthorityURL)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &s.ClientID)
			delete(rawMsg, key)
		case "credentialsType":
			err = unpopulate(val, "CredentialsType", &s.CredentialsType)
			delete(rawMsg, key)
		case "resourceUrl":
			err = unpopulate(val, "ResourceURL", &s.ResourceURL)
			delete(rawMsg, key)
		case "secrets":
			err = unpopulate(val, "Secrets", &s.Secrets)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &s.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalDatastoreSecrets.
func (s ServicePrincipalDatastoreSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientSecret", s.ClientSecret)
	objectMap["secretsType"] = SecretsTypeServicePrincipal
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalDatastoreSecrets.
func (s *ServicePrincipalDatastoreSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientSecret":
			err = unpopulate(val, "ClientSecret", &s.ClientSecret)
			delete(rawMsg, key)
		case "secretsType":
			err = unpopulate(val, "SecretsType", &s.SecretsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SweepJob.
func (s SweepJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeId", s.ComputeID)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "earlyTermination", s.EarlyTermination)
	populate(objectMap, "experimentName", s.ExperimentName)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "inputs", s.Inputs)
	populate(objectMap, "isArchived", s.IsArchived)
	objectMap["jobType"] = JobTypeSweep
	populate(objectMap, "limits", s.Limits)
	populate(objectMap, "objective", s.Objective)
	populate(objectMap, "outputs", s.Outputs)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "samplingAlgorithm", s.SamplingAlgorithm)
	populate(objectMap, "searchSpace", &s.SearchSpace)
	populate(objectMap, "services", s.Services)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "trial", s.Trial)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SweepJob.
func (s *SweepJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeId":
			err = unpopulate(val, "ComputeID", &s.ComputeID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &s.DisplayName)
			delete(rawMsg, key)
		case "earlyTermination":
			s.EarlyTermination, err = unmarshalEarlyTerminationPolicyClassification(val)
			delete(rawMsg, key)
		case "experimentName":
			err = unpopulate(val, "ExperimentName", &s.ExperimentName)
			delete(rawMsg, key)
		case "identity":
			s.Identity, err = unmarshalIdentityConfigurationClassification(val)
			delete(rawMsg, key)
		case "inputs":
			s.Inputs, err = unmarshalJobInputClassificationMap(val)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &s.IsArchived)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &s.JobType)
			delete(rawMsg, key)
		case "limits":
			err = unpopulate(val, "Limits", &s.Limits)
			delete(rawMsg, key)
		case "objective":
			err = unpopulate(val, "Objective", &s.Objective)
			delete(rawMsg, key)
		case "outputs":
			s.Outputs, err = unmarshalJobOutputClassificationMap(val)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "samplingAlgorithm":
			s.SamplingAlgorithm, err = unmarshalSamplingAlgorithmClassification(val)
			delete(rawMsg, key)
		case "searchSpace":
			err = unpopulate(val, "SearchSpace", &s.SearchSpace)
			delete(rawMsg, key)
		case "services":
			err = unpopulate(val, "Services", &s.Services)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &s.Tags)
			delete(rawMsg, key)
		case "trial":
			err = unpopulate(val, "Trial", &s.Trial)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SweepJobLimits.
func (s SweepJobLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["jobLimitsType"] = JobLimitsTypeSweep
	populate(objectMap, "maxConcurrentTrials", s.MaxConcurrentTrials)
	populate(objectMap, "maxTotalTrials", s.MaxTotalTrials)
	populate(objectMap, "timeout", s.Timeout)
	populate(objectMap, "trialTimeout", s.TrialTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SweepJobLimits.
func (s *SweepJobLimits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobLimitsType":
			err = unpopulate(val, "JobLimitsType", &s.JobLimitsType)
			delete(rawMsg, key)
		case "maxConcurrentTrials":
			err = unpopulate(val, "MaxConcurrentTrials", &s.MaxConcurrentTrials)
			delete(rawMsg, key)
		case "maxTotalTrials":
			err = unpopulate(val, "MaxTotalTrials", &s.MaxTotalTrials)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &s.Timeout)
			delete(rawMsg, key)
		case "trialTimeout":
			err = unpopulate(val, "TrialTimeout", &s.TrialTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSpark.
func (s SynapseSpark) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", s.ComputeLocation)
	objectMap["computeType"] = ComputeTypeSynapseSpark
	populateTimeRFC3339(objectMap, "createdOn", s.CreatedOn)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "disableLocalAuth", s.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", s.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", s.ModifiedOn)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "provisioningErrors", s.ProvisioningErrors)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resourceId", s.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSpark.
func (s *SynapseSpark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &s.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &s.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &s.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &s.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &s.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &s.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &s.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &s.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetUtilizationScaleSettings.
func (t TargetUtilizationScaleSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "maxInstances", t.MaxInstances)
	populate(objectMap, "minInstances", t.MinInstances)
	populate(objectMap, "pollingInterval", t.PollingInterval)
	objectMap["scaleType"] = ScaleTypeTargetUtilization
	populate(objectMap, "targetUtilizationPercentage", t.TargetUtilizationPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetUtilizationScaleSettings.
func (t *TargetUtilizationScaleSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxInstances":
			err = unpopulate(val, "MaxInstances", &t.MaxInstances)
			delete(rawMsg, key)
		case "minInstances":
			err = unpopulate(val, "MinInstances", &t.MinInstances)
			delete(rawMsg, key)
		case "pollingInterval":
			err = unpopulate(val, "PollingInterval", &t.PollingInterval)
			delete(rawMsg, key)
		case "scaleType":
			err = unpopulate(val, "ScaleType", &t.ScaleType)
			delete(rawMsg, key)
		case "targetUtilizationPercentage":
			err = unpopulate(val, "TargetUtilizationPercentage", &t.TargetUtilizationPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TensorFlow.
func (t TensorFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["distributionType"] = DistributionTypeTensorFlow
	populate(objectMap, "parameterServerCount", t.ParameterServerCount)
	populate(objectMap, "workerCount", t.WorkerCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TensorFlow.
func (t *TensorFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionType":
			err = unpopulate(val, "DistributionType", &t.DistributionType)
			delete(rawMsg, key)
		case "parameterServerCount":
			err = unpopulate(val, "ParameterServerCount", &t.ParameterServerCount)
			delete(rawMsg, key)
		case "workerCount":
			err = unpopulate(val, "WorkerCount", &t.WorkerCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TrialComponent.
func (t TrialComponent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codeId", t.CodeID)
	populate(objectMap, "command", t.Command)
	populate(objectMap, "distribution", t.Distribution)
	populate(objectMap, "environmentId", t.EnvironmentID)
	populate(objectMap, "environmentVariables", t.EnvironmentVariables)
	populate(objectMap, "resources", t.Resources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrialComponent.
func (t *TrialComponent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codeId":
			err = unpopulate(val, "CodeID", &t.CodeID)
			delete(rawMsg, key)
		case "command":
			err = unpopulate(val, "Command", &t.Command)
			delete(rawMsg, key)
		case "distribution":
			t.Distribution, err = unmarshalDistributionConfigurationClassification(val)
			delete(rawMsg, key)
		case "environmentId":
			err = unpopulate(val, "EnvironmentID", &t.EnvironmentID)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, "EnvironmentVariables", &t.EnvironmentVariables)
			delete(rawMsg, key)
		case "resources":
			err = unpopulate(val, "Resources", &t.Resources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TritonModelJobInput.
func (t TritonModelJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	objectMap["jobInputType"] = JobInputTypeTritonModel
	populate(objectMap, "mode", t.Mode)
	populate(objectMap, "uri", t.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TritonModelJobInput.
func (t *TritonModelJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &t.JobInputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &t.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &t.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TritonModelJobOutput.
func (t TritonModelJobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	objectMap["jobOutputType"] = JobOutputTypeTritonModel
	populate(objectMap, "mode", t.Mode)
	populate(objectMap, "uri", t.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TritonModelJobOutput.
func (t *TritonModelJobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "jobOutputType":
			err = unpopulate(val, "JobOutputType", &t.JobOutputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &t.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &t.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TruncationSelectionPolicy.
func (t TruncationSelectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "delayEvaluation", t.DelayEvaluation)
	populate(objectMap, "evaluationInterval", t.EvaluationInterval)
	objectMap["policyType"] = EarlyTerminationPolicyTypeTruncationSelection
	populate(objectMap, "truncationPercentage", t.TruncationPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TruncationSelectionPolicy.
func (t *TruncationSelectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delayEvaluation":
			err = unpopulate(val, "DelayEvaluation", &t.DelayEvaluation)
			delete(rawMsg, key)
		case "evaluationInterval":
			err = unpopulate(val, "EvaluationInterval", &t.EvaluationInterval)
			delete(rawMsg, key)
		case "policyType":
			err = unpopulate(val, "PolicyType", &t.PolicyType)
			delete(rawMsg, key)
		case "truncationPercentage":
			err = unpopulate(val, "TruncationPercentage", &t.TruncationPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URIFileDataVersion.
func (u URIFileDataVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dataType"] = DataTypeURIFile
	populate(objectMap, "dataUri", u.DataURI)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "isAnonymous", u.IsAnonymous)
	populate(objectMap, "isArchived", u.IsArchived)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URIFileDataVersion.
func (u *URIFileDataVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &u.DataType)
			delete(rawMsg, key)
		case "dataUri":
			err = unpopulate(val, "DataURI", &u.DataURI)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "isAnonymous":
			err = unpopulate(val, "IsAnonymous", &u.IsAnonymous)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &u.IsArchived)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &u.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URIFileJobInput.
func (u URIFileJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", u.Description)
	objectMap["jobInputType"] = JobInputTypeURIFile
	populate(objectMap, "mode", u.Mode)
	populate(objectMap, "uri", u.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URIFileJobInput.
func (u *URIFileJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &u.JobInputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &u.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &u.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URIFileJobOutput.
func (u URIFileJobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", u.Description)
	objectMap["jobOutputType"] = JobOutputTypeURIFile
	populate(objectMap, "mode", u.Mode)
	populate(objectMap, "uri", u.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URIFileJobOutput.
func (u *URIFileJobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "jobOutputType":
			err = unpopulate(val, "JobOutputType", &u.JobOutputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &u.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &u.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URIFolderDataVersion.
func (u URIFolderDataVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dataType"] = DataTypeURIFolder
	populate(objectMap, "dataUri", u.DataURI)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "isAnonymous", u.IsAnonymous)
	populate(objectMap, "isArchived", u.IsArchived)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URIFolderDataVersion.
func (u *URIFolderDataVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &u.DataType)
			delete(rawMsg, key)
		case "dataUri":
			err = unpopulate(val, "DataURI", &u.DataURI)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "isAnonymous":
			err = unpopulate(val, "IsAnonymous", &u.IsAnonymous)
			delete(rawMsg, key)
		case "isArchived":
			err = unpopulate(val, "IsArchived", &u.IsArchived)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &u.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URIFolderJobInput.
func (u URIFolderJobInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", u.Description)
	objectMap["jobInputType"] = JobInputTypeURIFolder
	populate(objectMap, "mode", u.Mode)
	populate(objectMap, "uri", u.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URIFolderJobInput.
func (u *URIFolderJobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "jobInputType":
			err = unpopulate(val, "JobInputType", &u.JobInputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &u.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &u.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URIFolderJobOutput.
func (u URIFolderJobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", u.Description)
	objectMap["jobOutputType"] = JobOutputTypeURIFolder
	populate(objectMap, "mode", u.Mode)
	populate(objectMap, "uri", u.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URIFolderJobOutput.
func (u *URIFolderJobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "jobOutputType":
			err = unpopulate(val, "JobOutputType", &u.JobOutputType)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &u.Mode)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &u.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserIdentity.
func (u UserIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["identityType"] = IdentityConfigurationTypeUserIdentity
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserIdentity.
func (u *UserIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identityType":
			err = unpopulate(val, "IdentityType", &u.IdentityType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (u UsernamePasswordAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["authType"] = ConnectionAuthTypeUsernamePassword
	populate(objectMap, "category", u.Category)
	populate(objectMap, "credentials", u.Credentials)
	populate(objectMap, "target", u.Target)
	populate(objectMap, "value", u.Value)
	populate(objectMap, "valueFormat", u.ValueFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (u *UsernamePasswordAuthTypeWorkspaceConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authType":
			err = unpopulate(val, "AuthType", &u.AuthType)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &u.Category)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &u.Credentials)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &u.Target)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		case "valueFormat":
			err = unpopulate(val, "ValueFormat", &u.ValueFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachine.
func (v VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "computeLocation", v.ComputeLocation)
	objectMap["computeType"] = ComputeTypeVirtualMachine
	populateTimeRFC3339(objectMap, "createdOn", v.CreatedOn)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "disableLocalAuth", v.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", v.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", v.ModifiedOn)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "provisioningErrors", v.ProvisioningErrors)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "resourceId", v.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachine.
func (v *VirtualMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, "ComputeLocation", &v.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &v.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &v.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &v.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, "DisableLocalAuth", &v.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, "IsAttachedCompute", &v.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, "ModifiedOn", &v.ModifiedOn)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, "ProvisioningErrors", &v.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &v.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineSecrets.
func (v *VirtualMachineSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administratorAccount":
			err = unpopulate(val, "AdministratorAccount", &v.AdministratorAccount)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, "ComputeType", &v.ComputeType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "location", w.Location)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "sku", w.SKU)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "tags", w.Tags)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceConnectionPropertiesV2BasicResource.
func (w WorkspaceConnectionPropertiesV2BasicResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceConnectionPropertiesV2BasicResource.
func (w *WorkspaceConnectionPropertiesV2BasicResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			w.Properties, err = unmarshalWorkspaceConnectionPropertiesV2Classification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceProperties.
func (w WorkspaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowPublicAccessWhenBehindVnet", w.AllowPublicAccessWhenBehindVnet)
	populate(objectMap, "applicationInsights", w.ApplicationInsights)
	populate(objectMap, "containerRegistry", w.ContainerRegistry)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "discoveryUrl", w.DiscoveryURL)
	populate(objectMap, "encryption", w.Encryption)
	populate(objectMap, "friendlyName", w.FriendlyName)
	populate(objectMap, "hbiWorkspace", w.HbiWorkspace)
	populate(objectMap, "imageBuildCompute", w.ImageBuildCompute)
	populate(objectMap, "keyVault", w.KeyVault)
	populate(objectMap, "mlFlowTrackingUri", w.MlFlowTrackingURI)
	populate(objectMap, "notebookInfo", w.NotebookInfo)
	populate(objectMap, "primaryUserAssignedIdentity", w.PrimaryUserAssignedIdentity)
	populate(objectMap, "privateEndpointConnections", w.PrivateEndpointConnections)
	populate(objectMap, "privateLinkCount", w.PrivateLinkCount)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", w.PublicNetworkAccess)
	populate(objectMap, "serviceManagedResourcesSettings", w.ServiceManagedResourcesSettings)
	populate(objectMap, "serviceProvisionedResourceGroup", w.ServiceProvisionedResourceGroup)
	populate(objectMap, "sharedPrivateLinkResources", w.SharedPrivateLinkResources)
	populate(objectMap, "storageAccount", w.StorageAccount)
	populate(objectMap, "storageHnsEnabled", w.StorageHnsEnabled)
	populate(objectMap, "tenantId", w.TenantID)
	populate(objectMap, "v1LegacyMode", w.V1LegacyMode)
	populate(objectMap, "workspaceId", w.WorkspaceID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceUpdateParameters.
func (w WorkspaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "sku", w.SKU)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
