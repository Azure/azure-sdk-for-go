//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmachinelearningservices

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AKS - A Machine Learning compute based on AKS.
type AKS struct {
	Compute
	// AKS properties
	Properties *AKSProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AKS.
func (a AKS) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Compute.marshalInternal(objectMap, ComputeTypeAKS)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKS.
func (a *AKS) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AKSProperties - AKS properties
type AKSProperties struct {
	// Number of agents
	AgentCount *int32 `json:"agentCount,omitempty"`

	// Agent virtual machine size
	AgentVMSize *string `json:"agentVmSize,omitempty"`

	// AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration `json:"aksNetworkingConfiguration,omitempty"`

	// Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// Intended usage of the cluster
	ClusterPurpose *ClusterPurpose `json:"clusterPurpose,omitempty"`

	// Load Balancer Subnet
	LoadBalancerSubnet *string `json:"loadBalancerSubnet,omitempty"`

	// Load Balancer Type
	LoadBalancerType *LoadBalancerType `json:"loadBalancerType,omitempty"`

	// SSL configuration
	SSLConfiguration *SSLConfiguration `json:"sslConfiguration,omitempty"`

	// READ-ONLY; System services
	SystemServices []*SystemService `json:"systemServices,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AKSProperties.
func (a AKSProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentCount", a.AgentCount)
	populate(objectMap, "agentVmSize", a.AgentVMSize)
	populate(objectMap, "aksNetworkingConfiguration", a.AksNetworkingConfiguration)
	populate(objectMap, "clusterFqdn", a.ClusterFqdn)
	populate(objectMap, "clusterPurpose", a.ClusterPurpose)
	populate(objectMap, "loadBalancerSubnet", a.LoadBalancerSubnet)
	populate(objectMap, "loadBalancerType", a.LoadBalancerType)
	populate(objectMap, "sslConfiguration", a.SSLConfiguration)
	populate(objectMap, "systemServices", a.SystemServices)
	return json.Marshal(objectMap)
}

// AksComputeSecrets - Secrets related to a Machine Learning compute based on AKS.
type AksComputeSecrets struct {
	AksComputeSecretsProperties
	ComputeSecrets
}

// MarshalJSON implements the json.Marshaller interface for type AksComputeSecrets.
func (a AksComputeSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ComputeSecrets.marshalInternal(objectMap, ComputeTypeAKS)
	a.AksComputeSecretsProperties.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// AksComputeSecretsProperties - Properties of AksComputeSecrets
type AksComputeSecretsProperties struct {
	// Content of kubeconfig file that can be used to connect to the Kubernetes cluster.
	AdminKubeConfig *string `json:"adminKubeConfig,omitempty"`

	// Image registry pull secret.
	ImagePullSecretName *string `json:"imagePullSecretName,omitempty"`

	// Content of kubeconfig file that can be used to connect to the Kubernetes cluster.
	UserKubeConfig *string `json:"userKubeConfig,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AksComputeSecretsProperties.
func (a AksComputeSecretsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AksComputeSecretsProperties.
func (a *AksComputeSecretsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AksComputeSecretsProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "adminKubeConfig", a.AdminKubeConfig)
	populate(objectMap, "imagePullSecretName", a.ImagePullSecretName)
	populate(objectMap, "userKubeConfig", a.UserKubeConfig)
}

func (a *AksComputeSecretsProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminKubeConfig":
			err = unpopulate(val, &a.AdminKubeConfig)
			delete(rawMsg, key)
		case "imagePullSecretName":
			err = unpopulate(val, &a.ImagePullSecretName)
			delete(rawMsg, key)
		case "userKubeConfig":
			err = unpopulate(val, &a.UserKubeConfig)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AksNetworkingConfiguration - Advance configuration for AKS networking
type AksNetworkingConfiguration struct {
	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
	DNSServiceIP *string `json:"dnsServiceIP,omitempty"`

	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// Virtual network subnet resource ID the compute nodes belong to
	SubnetID *string `json:"subnetId,omitempty"`
}

// AmlCompute - Properties(top level) of AmlCompute
type AmlCompute struct {
	Compute
	// Properties of AmlCompute
	Properties *AmlComputeProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmlCompute.
func (a AmlCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Compute.marshalInternal(objectMap, ComputeTypeAmlCompute)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmlCompute.
func (a *AmlCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AmlComputeNodeInformation - Compute node information related to a AmlCompute.
type AmlComputeNodeInformation struct {
	// READ-ONLY; ID of the compute node.
	NodeID *string `json:"nodeId,omitempty" azure:"ro"`

	// READ-ONLY; State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
	NodeState *NodeState `json:"nodeState,omitempty" azure:"ro"`

	// READ-ONLY; SSH port number of the node.
	Port *int32 `json:"port,omitempty" azure:"ro"`

	// READ-ONLY; Private IP address of the compute node.
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" azure:"ro"`

	// READ-ONLY; Public IP address of the compute node.
	PublicIPAddress *string `json:"publicIpAddress,omitempty" azure:"ro"`

	// READ-ONLY; ID of the Experiment running on the node, if any else null.
	RunID *string `json:"runId,omitempty" azure:"ro"`
}

// AmlComputeNodesInformation - Result of AmlCompute Nodes
type AmlComputeNodesInformation struct {
	// READ-ONLY; The continuation token.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The collection of returned AmlCompute nodes details.
	Nodes []*AmlComputeNodeInformation `json:"nodes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AmlComputeNodesInformation.
func (a AmlComputeNodesInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "nodes", a.Nodes)
	return json.Marshal(objectMap)
}

// AmlComputeProperties - AML Compute properties
type AmlComputeProperties struct {
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public
	// IPs provisioned. false - Indicates that the
	// compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty"`

	// Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`

	// Compute OS Type
	OSType *OsType `json:"osType,omitempty"`

	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates
	// that the public ssh port is open on all
	// nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public
	// nodes. It can be default only during cluster
	// creation time, after creation it will be either enabled or disabled.
	RemoteLoginPortPublicAccess *RemoteLoginPortPublicAccess `json:"remoteLoginPortPublicAccess,omitempty"`

	// Scale settings for AML Compute
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`

	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceID `json:"subnet,omitempty"`

	// Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials `json:"userAccountCredentials,omitempty"`

	// Virtual Machine priority
	VMPriority *VMPriority `json:"vmPriority,omitempty"`

	// Virtual Machine Size
	VMSize *string `json:"vmSize,omitempty"`

	// Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage `json:"virtualMachineImage,omitempty"`

	// READ-ONLY; Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number
	// of compute nodes in the compute in progress. A compute
	// enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates
	// that the compute is resizing; that is,
	// compute nodes are being added to or removed from the compute.
	AllocationState *AllocationState `json:"allocationState,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the compute entered its current allocation state.
	AllocationStateTransitionTime *time.Time `json:"allocationStateTransitionTime,omitempty" azure:"ro"`

	// READ-ONLY; The number of compute nodes currently assigned to the compute.
	CurrentNodeCount *int32 `json:"currentNodeCount,omitempty" azure:"ro"`

	// READ-ONLY; Collection of errors encountered by various compute nodes during node setup.
	Errors []*ErrorResponse `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Counts of various node states on the compute.
	NodeStateCounts *NodeStateCounts `json:"nodeStateCounts,omitempty" azure:"ro"`

	// READ-ONLY; The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the
	// ongoing resize operation. If the allocationState is steady,
	// this property denotes the target node count for the previous resize operation.
	TargetNodeCount *int32 `json:"targetNodeCount,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AmlComputeProperties.
func (a AmlComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allocationState", a.AllocationState)
	populateTimeRFC3339(objectMap, "allocationStateTransitionTime", a.AllocationStateTransitionTime)
	populate(objectMap, "currentNodeCount", a.CurrentNodeCount)
	populate(objectMap, "enableNodePublicIp", a.EnableNodePublicIP)
	populate(objectMap, "errors", a.Errors)
	populate(objectMap, "isolatedNetwork", a.IsolatedNetwork)
	populate(objectMap, "nodeStateCounts", a.NodeStateCounts)
	populate(objectMap, "osType", a.OSType)
	populate(objectMap, "remoteLoginPortPublicAccess", a.RemoteLoginPortPublicAccess)
	populate(objectMap, "scaleSettings", a.ScaleSettings)
	populate(objectMap, "subnet", a.Subnet)
	populate(objectMap, "targetNodeCount", a.TargetNodeCount)
	populate(objectMap, "userAccountCredentials", a.UserAccountCredentials)
	populate(objectMap, "vmPriority", a.VMPriority)
	populate(objectMap, "vmSize", a.VMSize)
	populate(objectMap, "virtualMachineImage", a.VirtualMachineImage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmlComputeProperties.
func (a *AmlComputeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocationState":
			err = unpopulate(val, &a.AllocationState)
			delete(rawMsg, key)
		case "allocationStateTransitionTime":
			err = unpopulateTimeRFC3339(val, &a.AllocationStateTransitionTime)
			delete(rawMsg, key)
		case "currentNodeCount":
			err = unpopulate(val, &a.CurrentNodeCount)
			delete(rawMsg, key)
		case "enableNodePublicIp":
			err = unpopulate(val, &a.EnableNodePublicIP)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &a.Errors)
			delete(rawMsg, key)
		case "isolatedNetwork":
			err = unpopulate(val, &a.IsolatedNetwork)
			delete(rawMsg, key)
		case "nodeStateCounts":
			err = unpopulate(val, &a.NodeStateCounts)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &a.OSType)
			delete(rawMsg, key)
		case "remoteLoginPortPublicAccess":
			err = unpopulate(val, &a.RemoteLoginPortPublicAccess)
			delete(rawMsg, key)
		case "scaleSettings":
			err = unpopulate(val, &a.ScaleSettings)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, &a.Subnet)
			delete(rawMsg, key)
		case "targetNodeCount":
			err = unpopulate(val, &a.TargetNodeCount)
			delete(rawMsg, key)
		case "userAccountCredentials":
			err = unpopulate(val, &a.UserAccountCredentials)
			delete(rawMsg, key)
		case "vmPriority":
			err = unpopulate(val, &a.VMPriority)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, &a.VMSize)
			delete(rawMsg, key)
		case "virtualMachineImage":
			err = unpopulate(val, &a.VirtualMachineImage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AmlUserFeature - Features enabled for a workspace
type AmlUserFeature struct {
	// Describes the feature for user experience
	Description *string `json:"description,omitempty"`

	// Specifies the feature name
	DisplayName *string `json:"displayName,omitempty"`

	// Specifies the feature ID
	ID *string `json:"id,omitempty"`
}

// AssignedUser - A user that can be assigned to a compute instance.
type AssignedUser struct {
	// REQUIRED; User’s AAD Object Id.
	ObjectID *string `json:"objectId,omitempty"`

	// REQUIRED; User’s AAD Tenant Id.
	TenantID *string `json:"tenantId,omitempty"`
}

// AutoPauseProperties - Auto pause properties
type AutoPauseProperties struct {
	DelayInMinutes *int32 `json:"delayInMinutes,omitempty"`
	Enabled        *bool  `json:"enabled,omitempty"`
}

// AutoScaleProperties - Auto scale properties
type AutoScaleProperties struct {
	Enabled      *bool  `json:"enabled,omitempty"`
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
}

// ClusterUpdateParameters - AmlCompute update parameters.
type ClusterUpdateParameters struct {
	// The properties of the amlCompute.
	Properties *ClusterUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdateParameters.
func (c ClusterUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// ClusterUpdateProperties - The properties of a amlCompute that need to be updated.
type ClusterUpdateProperties struct {
	// Properties of ClusterUpdate
	Properties *ScaleSettingsInformation `json:"properties,omitempty"`
}

type Components1D3SwueSchemasComputeresourceAllof1 struct {
	// Compute properties
	Properties ComputeClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Components1D3SwueSchemasComputeresourceAllof1.
func (c Components1D3SwueSchemasComputeresourceAllof1) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Components1D3SwueSchemasComputeresourceAllof1.
func (c *Components1D3SwueSchemasComputeresourceAllof1) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c Components1D3SwueSchemasComputeresourceAllof1) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "properties", c.Properties)
}

func (c *Components1D3SwueSchemasComputeresourceAllof1) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			c.Properties, err = unmarshalComputeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ComputeClassification provides polymorphic access to related types.
// Call the interface's GetCompute() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AKS, *AmlCompute, *Compute, *ComputeInstance, *DataFactory, *DataLakeAnalytics, *Databricks, *HDInsight, *Kubernetes,
// - *SynapseSpark, *VirtualMachine
type ComputeClassification interface {
	// GetCompute returns the Compute content of the underlying type.
	GetCompute() *Compute
}

// Compute - Machine Learning compute object.
type Compute struct {
	// REQUIRED; The type of compute
	ComputeType *ComputeType `json:"computeType,omitempty"`

	// Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`

	// READ-ONLY; The time at which the compute was created.
	CreatedOn *time.Time `json:"createdOn,omitempty" azure:"ro"`

	// READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *time.Time `json:"modifiedOn,omitempty" azure:"ro"`

	// READ-ONLY; Errors during provisioning
	ProvisioningErrors []*ErrorResponse `json:"provisioningErrors,omitempty" azure:"ro"`

	// READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// GetCompute implements the ComputeClassification interface for type Compute.
func (c *Compute) GetCompute() *Compute { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type Compute.
func (c *Compute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c Compute) marshalInternal(objectMap map[string]interface{}, discValue ComputeType) {
	populate(objectMap, "computeLocation", c.ComputeLocation)
	c.ComputeType = &discValue
	objectMap["computeType"] = c.ComputeType
	populateTimeRFC3339(objectMap, "createdOn", c.CreatedOn)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "disableLocalAuth", c.DisableLocalAuth)
	populate(objectMap, "isAttachedCompute", c.IsAttachedCompute)
	populateTimeRFC3339(objectMap, "modifiedOn", c.ModifiedOn)
	populate(objectMap, "provisioningErrors", c.ProvisioningErrors)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "resourceId", c.ResourceID)
}

func (c *Compute) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeLocation":
			err = unpopulate(val, &c.ComputeLocation)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, &c.ComputeType)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &c.CreatedOn)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, &c.DisableLocalAuth)
			delete(rawMsg, key)
		case "isAttachedCompute":
			err = unpopulate(val, &c.IsAttachedCompute)
			delete(rawMsg, key)
		case "modifiedOn":
			err = unpopulateTimeRFC3339(val, &c.ModifiedOn)
			delete(rawMsg, key)
		case "provisioningErrors":
			err = unpopulate(val, &c.ProvisioningErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &c.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ComputeBeginCreateOrUpdateOptions contains the optional parameters for the Compute.BeginCreateOrUpdate method.
type ComputeBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ComputeBeginDeleteOptions contains the optional parameters for the Compute.BeginDelete method.
type ComputeBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ComputeBeginRestartOptions contains the optional parameters for the Compute.BeginRestart method.
type ComputeBeginRestartOptions struct {
	// placeholder for future optional parameters
}

// ComputeBeginStartOptions contains the optional parameters for the Compute.BeginStart method.
type ComputeBeginStartOptions struct {
	// placeholder for future optional parameters
}

// ComputeBeginStopOptions contains the optional parameters for the Compute.BeginStop method.
type ComputeBeginStopOptions struct {
	// placeholder for future optional parameters
}

// ComputeBeginUpdateOptions contains the optional parameters for the Compute.BeginUpdate method.
type ComputeBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ComputeGetOptions contains the optional parameters for the Compute.Get method.
type ComputeGetOptions struct {
	// placeholder for future optional parameters
}

// ComputeInstance - Properties(top level) of ComputeInstance
type ComputeInstance struct {
	Compute
	// Properties of ComputeInstance
	Properties *ComputeInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstance.
func (c ComputeInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Compute.marshalInternal(objectMap, ComputeTypeComputeInstance)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeInstance.
func (c *ComputeInstance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ComputeInstanceApplication - Defines an Aml Instance application and its connectivity endpoint URI.
type ComputeInstanceApplication struct {
	// Name of the ComputeInstance application.
	DisplayName *string `json:"displayName,omitempty"`

	// Application' endpoint URI.
	EndpointURI *string `json:"endpointUri,omitempty"`
}

// ComputeInstanceConnectivityEndpoints - Defines all connectivity endpoints and properties for an ComputeInstance.
type ComputeInstanceConnectivityEndpoints struct {
	// READ-ONLY; Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is deployed).
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" azure:"ro"`

	// READ-ONLY; Public IP Address of this ComputeInstance.
	PublicIPAddress *string `json:"publicIpAddress,omitempty" azure:"ro"`
}

// ComputeInstanceCreatedBy - Describes information on user who created this ComputeInstance.
type ComputeInstanceCreatedBy struct {
	// READ-ONLY; Uniquely identifies the user within his/her organization.
	UserID *string `json:"userId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the user.
	UserName *string `json:"userName,omitempty" azure:"ro"`

	// READ-ONLY; Uniquely identifies user' Azure Active Directory organization.
	UserOrgID *string `json:"userOrgId,omitempty" azure:"ro"`
}

// ComputeInstanceLastOperation - The last operation on ComputeInstance.
type ComputeInstanceLastOperation struct {
	// Name of the last operation.
	OperationName *OperationName `json:"operationName,omitempty"`

	// Operation status.
	OperationStatus *OperationStatus `json:"operationStatus,omitempty"`

	// Time of the last operation.
	OperationTime *time.Time `json:"operationTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstanceLastOperation.
func (c ComputeInstanceLastOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operationName", c.OperationName)
	populate(objectMap, "operationStatus", c.OperationStatus)
	populateTimeRFC3339(objectMap, "operationTime", c.OperationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeInstanceLastOperation.
func (c *ComputeInstanceLastOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "operationName":
			err = unpopulate(val, &c.OperationName)
			delete(rawMsg, key)
		case "operationStatus":
			err = unpopulate(val, &c.OperationStatus)
			delete(rawMsg, key)
		case "operationTime":
			err = unpopulateTimeRFC3339(val, &c.OperationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ComputeInstanceProperties - Compute Instance properties
type ComputeInstanceProperties struct {
	// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this
	// compute instance. When Shared, any workspace
	// user can access applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *ApplicationSharingPolicy `json:"applicationSharingPolicy,omitempty"`

	// The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *ComputeInstanceAuthorizationType `json:"computeInstanceAuthorizationType,omitempty"`

	// Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `json:"personalComputeInstanceSettings,omitempty"`

	// Specifies policy and settings for SSH access.
	SSHSettings *ComputeInstanceSSHSettings `json:"sshSettings,omitempty"`

	// Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `json:"setupScripts,omitempty"`

	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceID `json:"subnet,omitempty"`

	// Virtual Machine Size
	VMSize *string `json:"vmSize,omitempty"`

	// READ-ONLY; Describes available applications and their endpoints on this ComputeInstance.
	Applications []*ComputeInstanceApplication `json:"applications,omitempty" azure:"ro"`

	// READ-ONLY; Describes all connectivity endpoints available for this ComputeInstance.
	ConnectivityEndpoints *ComputeInstanceConnectivityEndpoints `json:"connectivityEndpoints,omitempty" azure:"ro"`

	// READ-ONLY; Describes information on user who created this ComputeInstance.
	CreatedBy *ComputeInstanceCreatedBy `json:"createdBy,omitempty" azure:"ro"`

	// READ-ONLY; Collection of errors encountered on this ComputeInstance.
	Errors []*ErrorResponse `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The last operation on ComputeInstance.
	LastOperation *ComputeInstanceLastOperation `json:"lastOperation,omitempty" azure:"ro"`

	// READ-ONLY; The current state of this ComputeInstance.
	State *ComputeInstanceState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ComputeInstanceProperties.
func (c ComputeInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationSharingPolicy", c.ApplicationSharingPolicy)
	populate(objectMap, "applications", c.Applications)
	populate(objectMap, "computeInstanceAuthorizationType", c.ComputeInstanceAuthorizationType)
	populate(objectMap, "connectivityEndpoints", c.ConnectivityEndpoints)
	populate(objectMap, "createdBy", c.CreatedBy)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "lastOperation", c.LastOperation)
	populate(objectMap, "personalComputeInstanceSettings", c.PersonalComputeInstanceSettings)
	populate(objectMap, "sshSettings", c.SSHSettings)
	populate(objectMap, "setupScripts", c.SetupScripts)
	populate(objectMap, "state", c.State)
	populate(objectMap, "subnet", c.Subnet)
	populate(objectMap, "vmSize", c.VMSize)
	return json.Marshal(objectMap)
}

// ComputeInstanceSSHSettings - Specifies policy and settings for SSH access.
type ComputeInstanceSSHSettings struct {
	// Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`

	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that
	// the public ssh port is open and accessible
	// according to the VNet/subnet policy if applicable.
	SSHPublicAccess *SSHPublicAccess `json:"sshPublicAccess,omitempty"`

	// READ-ONLY; Describes the admin user name.
	AdminUserName *string `json:"adminUserName,omitempty" azure:"ro"`

	// READ-ONLY; Describes the port for connecting through SSH.
	SSHPort *int32 `json:"sshPort,omitempty" azure:"ro"`
}

// ComputeListKeysOptions contains the optional parameters for the Compute.ListKeys method.
type ComputeListKeysOptions struct {
	// placeholder for future optional parameters
}

// ComputeListNodesOptions contains the optional parameters for the Compute.ListNodes method.
type ComputeListNodesOptions struct {
	// placeholder for future optional parameters
}

// ComputeListOptions contains the optional parameters for the Compute.List method.
type ComputeListOptions struct {
	// Continuation token for pagination.
	Skip *string
}

// ComputeResource - Machine Learning compute object wrapped into ARM resource envelope.
type ComputeResource struct {
	Components1D3SwueSchemasComputeresourceAllof1
	Resource
	// The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// The sku of the workspace.
	SKU *SKU `json:"sku,omitempty"`

	// Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; System data
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ComputeResource.
func (c ComputeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Resource.marshalInternal(objectMap)
	c.Components1D3SwueSchemasComputeresourceAllof1.marshalInternal(objectMap)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeResource.
func (c *ComputeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &c.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &c.Location)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &c.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	if err := c.Components1D3SwueSchemasComputeresourceAllof1.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ComputeSecretsClassification provides polymorphic access to related types.
// Call the interface's GetComputeSecrets() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AksComputeSecrets, *ComputeSecrets, *DatabricksComputeSecrets, *VirtualMachineSecrets
type ComputeSecretsClassification interface {
	// GetComputeSecrets returns the ComputeSecrets content of the underlying type.
	GetComputeSecrets() *ComputeSecrets
}

// ComputeSecrets - Secrets related to a Machine Learning compute. Might differ for every type of compute.
type ComputeSecrets struct {
	// REQUIRED; The type of compute
	ComputeType *ComputeType `json:"computeType,omitempty"`
}

// GetComputeSecrets implements the ComputeSecretsClassification interface for type ComputeSecrets.
func (c *ComputeSecrets) GetComputeSecrets() *ComputeSecrets { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeSecrets.
func (c *ComputeSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ComputeSecrets) marshalInternal(objectMap map[string]interface{}, discValue ComputeType) {
	c.ComputeType = &discValue
	objectMap["computeType"] = c.ComputeType
}

func (c *ComputeSecrets) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			err = unpopulate(val, &c.ComputeType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContainerResourceRequirements - The resource requirements for the container (cpu and memory).
type ContainerResourceRequirements struct {
	// The minimum amount of CPU cores to be used by the container. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	CPU *float64 `json:"cpu,omitempty"`

	// The maximum amount of CPU cores allowed to be used by the container. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	CPULimit *float64 `json:"cpuLimit,omitempty"`

	// The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
	Fpga *int32 `json:"fpga,omitempty"`

	// The number of GPU cores in the container.
	Gpu *int32 `json:"gpu,omitempty"`

	// The minimum amount of memory (in GB) to be used by the container. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`

	// The maximum amount of memory (in GB) allowed to be used by the container. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	MemoryInGBLimit *float64 `json:"memoryInGBLimit,omitempty"`
}

type CosmosDbSettings struct {
	// The throughput of the collections in cosmosdb database
	CollectionsThroughput *int32 `json:"collectionsThroughput,omitempty"`
}

// DataFactory - A DataFactory compute.
type DataFactory struct {
	Compute
}

// MarshalJSON implements the json.Marshaller interface for type DataFactory.
func (d DataFactory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Compute.marshalInternal(objectMap, ComputeTypeDataFactory)
	return json.Marshal(objectMap)
}

// DataLakeAnalytics - A DataLakeAnalytics compute.
type DataLakeAnalytics struct {
	Compute
	Properties *DataLakeAnalyticsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalytics.
func (d DataLakeAnalytics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Compute.marshalInternal(objectMap, ComputeTypeDataLakeAnalytics)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalytics.
func (d *DataLakeAnalytics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DataLakeAnalyticsProperties struct {
	// DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

// Databricks - A DataFactory compute.
type Databricks struct {
	Compute
	// Properties of Databricks
	Properties *DatabricksProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Databricks.
func (d Databricks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.Compute.marshalInternal(objectMap, ComputeTypeDatabricks)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Databricks.
func (d *Databricks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatabricksComputeSecrets - Secrets related to a Machine Learning compute based on Databricks.
type DatabricksComputeSecrets struct {
	ComputeSecrets
	DatabricksComputeSecretsProperties
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksComputeSecrets.
func (d DatabricksComputeSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ComputeSecrets.marshalInternal(objectMap, ComputeTypeDatabricks)
	d.DatabricksComputeSecretsProperties.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// DatabricksComputeSecretsProperties - Properties of Databricks Compute Secrets
type DatabricksComputeSecretsProperties struct {
	// access token for databricks account.
	DatabricksAccessToken *string `json:"databricksAccessToken,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksComputeSecretsProperties.
func (d DatabricksComputeSecretsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksComputeSecretsProperties.
func (d *DatabricksComputeSecretsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DatabricksComputeSecretsProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "databricksAccessToken", d.DatabricksAccessToken)
}

func (d *DatabricksComputeSecretsProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databricksAccessToken":
			err = unpopulate(val, &d.DatabricksAccessToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabricksProperties - Properties of Databricks
type DatabricksProperties struct {
	// Databricks access token
	DatabricksAccessToken *string `json:"databricksAccessToken,omitempty"`

	// Workspace Url
	WorkspaceURL *string `json:"workspaceUrl,omitempty"`
}

type DiagnoseRequestProperties struct {
	// Setting for diagnosing dependent application insights
	ApplicationInsights map[string]map[string]interface{} `json:"applicationInsights,omitempty"`

	// Setting for diagnosing dependent container registry
	ContainerRegistry map[string]map[string]interface{} `json:"containerRegistry,omitempty"`

	// Setting for diagnosing dns resolution
	DNSResolution map[string]map[string]interface{} `json:"dnsResolution,omitempty"`

	// Setting for diagnosing dependent key vault
	KeyVault map[string]map[string]interface{} `json:"keyVault,omitempty"`

	// Setting for diagnosing network security group
	Nsg map[string]map[string]interface{} `json:"nsg,omitempty"`

	// Setting for diagnosing unclassified category of problems
	Others map[string]map[string]interface{} `json:"others,omitempty"`

	// Setting for diagnosing resource lock
	ResourceLock map[string]map[string]interface{} `json:"resourceLock,omitempty"`

	// Setting for diagnosing dependent storage account
	StorageAccount map[string]map[string]interface{} `json:"storageAccount,omitempty"`

	// Setting for diagnosing user defined routing
	Udr map[string]map[string]interface{} `json:"udr,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiagnoseRequestProperties.
func (d DiagnoseRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationInsights", d.ApplicationInsights)
	populate(objectMap, "containerRegistry", d.ContainerRegistry)
	populate(objectMap, "dnsResolution", d.DNSResolution)
	populate(objectMap, "keyVault", d.KeyVault)
	populate(objectMap, "nsg", d.Nsg)
	populate(objectMap, "others", d.Others)
	populate(objectMap, "resourceLock", d.ResourceLock)
	populate(objectMap, "storageAccount", d.StorageAccount)
	populate(objectMap, "udr", d.Udr)
	return json.Marshal(objectMap)
}

type DiagnoseResponseResult struct {
	Value *DiagnoseResponseResultValue `json:"value,omitempty"`
}

type DiagnoseResponseResultValue struct {
	ApplicationInsightsResults []*DiagnoseResult `json:"applicationInsightsResults,omitempty"`
	ContainerRegistryResults   []*DiagnoseResult `json:"containerRegistryResults,omitempty"`
	DNSResolutionResults       []*DiagnoseResult `json:"dnsResolutionResults,omitempty"`
	KeyVaultResults            []*DiagnoseResult `json:"keyVaultResults,omitempty"`
	NetworkSecurityRuleResults []*DiagnoseResult `json:"networkSecurityRuleResults,omitempty"`
	OtherResults               []*DiagnoseResult `json:"otherResults,omitempty"`
	ResourceLockResults        []*DiagnoseResult `json:"resourceLockResults,omitempty"`
	StorageAccountResults      []*DiagnoseResult `json:"storageAccountResults,omitempty"`
	UserDefinedRouteResults    []*DiagnoseResult `json:"userDefinedRouteResults,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiagnoseResponseResultValue.
func (d DiagnoseResponseResultValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationInsightsResults", d.ApplicationInsightsResults)
	populate(objectMap, "containerRegistryResults", d.ContainerRegistryResults)
	populate(objectMap, "dnsResolutionResults", d.DNSResolutionResults)
	populate(objectMap, "keyVaultResults", d.KeyVaultResults)
	populate(objectMap, "networkSecurityRuleResults", d.NetworkSecurityRuleResults)
	populate(objectMap, "otherResults", d.OtherResults)
	populate(objectMap, "resourceLockResults", d.ResourceLockResults)
	populate(objectMap, "storageAccountResults", d.StorageAccountResults)
	populate(objectMap, "userDefinedRouteResults", d.UserDefinedRouteResults)
	return json.Marshal(objectMap)
}

// DiagnoseResult - Result of Diagnose
type DiagnoseResult struct {
	// READ-ONLY; Code for workspace setup error
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Level of workspace setup error
	Level *DiagnoseResultLevel `json:"level,omitempty" azure:"ro"`

	// READ-ONLY; Message of workspace setup error
	Message *string `json:"message,omitempty" azure:"ro"`
}

// DiagnoseWorkspaceParameters - Parameters to diagnose a workspace
type DiagnoseWorkspaceParameters struct {
	// Value of Parameters
	Value *DiagnoseRequestProperties `json:"value,omitempty"`
}

type EncryptionProperty struct {
	// REQUIRED; Customer Key vault properties.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// REQUIRED; Indicates whether or not the encryption is enabled for the workspace.
	Status *EncryptionStatus `json:"status,omitempty"`

	// The identity that will be used to access the key vault for encryption at rest.
	Identity *IdentityForCmk `json:"identity,omitempty"`
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// EstimatedVMPrice - The estimated price info for using a VM of a particular OS type, tier, etc.
type EstimatedVMPrice struct {
	// REQUIRED; Operating system type used by the VM.
	OSType *VMPriceOSType `json:"osType,omitempty"`

	// REQUIRED; The price charged for using the VM.
	RetailPrice *float64 `json:"retailPrice,omitempty"`

	// REQUIRED; The type of the VM.
	VMTier *VMTier `json:"vmTier,omitempty"`
}

// EstimatedVMPrices - The estimated price info for using a VM.
type EstimatedVMPrices struct {
	// REQUIRED; Three lettered code specifying the currency of the VM price. Example: USD
	BillingCurrency *BillingCurrency `json:"billingCurrency,omitempty"`

	// REQUIRED; The unit of time measurement for the specified VM price. Example: OneHour
	UnitOfMeasure *UnitOfMeasure `json:"unitOfMeasure,omitempty"`

	// REQUIRED; The list of estimated prices for using a VM of a particular OS type, tier, etc.
	Values []*EstimatedVMPrice `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedVMPrices.
func (e EstimatedVMPrices) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "billingCurrency", e.BillingCurrency)
	populate(objectMap, "unitOfMeasure", e.UnitOfMeasure)
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

type ExternalFQDNResponse struct {
	Value []*FQDNEndpoints `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExternalFQDNResponse.
func (e ExternalFQDNResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

type FQDNEndpoint struct {
	DomainName      *string               `json:"domainName,omitempty"`
	EndpointDetails []*FQDNEndpointDetail `json:"endpointDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FQDNEndpoint.
func (f FQDNEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "domainName", f.DomainName)
	populate(objectMap, "endpointDetails", f.EndpointDetails)
	return json.Marshal(objectMap)
}

type FQDNEndpointDetail struct {
	Port *int32 `json:"port,omitempty"`
}

type FQDNEndpoints struct {
	Properties *FQDNEndpointsProperties `json:"properties,omitempty"`
}

type FQDNEndpointsProperties struct {
	Category  *string         `json:"category,omitempty"`
	Endpoints []*FQDNEndpoint `json:"endpoints,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FQDNEndpointsProperties.
func (f FQDNEndpointsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", f.Category)
	populate(objectMap, "endpoints", f.Endpoints)
	return json.Marshal(objectMap)
}

// HDInsight - A HDInsight compute.
type HDInsight struct {
	Compute
	// HDInsight compute properties
	Properties *HDInsightProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HDInsight.
func (h HDInsight) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.Compute.marshalInternal(objectMap, ComputeTypeHDInsight)
	populate(objectMap, "properties", h.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HDInsight.
func (h *HDInsight) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &h.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HDInsightProperties - HDInsight compute properties
type HDInsightProperties struct {
	// Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`

	// Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`

	// Port open for ssh connections on the master node of the cluster.
	SSHPort *int32 `json:"sshPort,omitempty"`
}

// Identity for the resource.
type Identity struct {
	// The identity type.
	Type *ResourceIdentityType `json:"type,omitempty"`

	// The user assigned identities associated with the resource.
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// IdentityForCmk - Identity that will be used to access key vault for encryption at rest
type IdentityForCmk struct {
	// The ArmId of the user assigned identity that will be used to access the customer managed key vault
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// InstanceTypeSchema - Instance type schema.
type InstanceTypeSchema struct {
	// Node Selector
	NodeSelector map[string]*string `json:"nodeSelector,omitempty"`

	// Resource requests/limits for this instance type
	Resources *InstanceTypeSchemaResources `json:"resources,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InstanceTypeSchema.
func (i InstanceTypeSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nodeSelector", i.NodeSelector)
	populate(objectMap, "resources", i.Resources)
	return json.Marshal(objectMap)
}

// InstanceTypeSchemaResources - Resource requests/limits for this instance type
type InstanceTypeSchemaResources struct {
	// Resource limits for this instance type
	Limits map[string]*string `json:"limits,omitempty"`

	// Resource requests for this instance type
	Requests map[string]*string `json:"requests,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InstanceTypeSchemaResources.
func (i InstanceTypeSchemaResources) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "limits", i.Limits)
	populate(objectMap, "requests", i.Requests)
	return json.Marshal(objectMap)
}

type KeyVaultProperties struct {
	// REQUIRED; Key vault uri to access the encryption key.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// REQUIRED; The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmID *string `json:"keyVaultArmId,omitempty"`

	// For future use - The client id of the identity which will be used to access key vault.
	IdentityClientID *string `json:"identityClientId,omitempty"`
}

// Kubernetes - A Machine Learning compute based on Kubernetes Compute.
type Kubernetes struct {
	Compute
	KubernetesSchema
}

// MarshalJSON implements the json.Marshaller interface for type Kubernetes.
func (k Kubernetes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	k.Compute.marshalInternal(objectMap, ComputeTypeKubernetes)
	k.KubernetesSchema.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// KubernetesProperties - Kubernetes properties
type KubernetesProperties struct {
	// Default instance type
	DefaultInstanceType *string `json:"defaultInstanceType,omitempty"`

	// Extension instance release train.
	ExtensionInstanceReleaseTrain *string `json:"extensionInstanceReleaseTrain,omitempty"`

	// Extension principal-id.
	ExtensionPrincipalID *string `json:"extensionPrincipalId,omitempty"`

	// Instance Type Schema
	InstanceTypes map[string]*InstanceTypeSchema `json:"instanceTypes,omitempty"`

	// Compute namespace
	Namespace *string `json:"namespace,omitempty"`

	// Relay connection string.
	RelayConnectionString *string `json:"relayConnectionString,omitempty"`

	// ServiceBus connection string.
	ServiceBusConnectionString *string `json:"serviceBusConnectionString,omitempty"`

	// VC name.
	VcName *string `json:"vcName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesProperties.
func (k KubernetesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultInstanceType", k.DefaultInstanceType)
	populate(objectMap, "extensionInstanceReleaseTrain", k.ExtensionInstanceReleaseTrain)
	populate(objectMap, "extensionPrincipalId", k.ExtensionPrincipalID)
	populate(objectMap, "instanceTypes", k.InstanceTypes)
	populate(objectMap, "namespace", k.Namespace)
	populate(objectMap, "relayConnectionString", k.RelayConnectionString)
	populate(objectMap, "serviceBusConnectionString", k.ServiceBusConnectionString)
	populate(objectMap, "vcName", k.VcName)
	return json.Marshal(objectMap)
}

// KubernetesSchema - Kubernetes Compute Schema
type KubernetesSchema struct {
	// Properties of Kubernetes
	Properties *KubernetesProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesSchema.
func (k KubernetesSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	k.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesSchema.
func (k *KubernetesSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return k.unmarshalInternal(rawMsg)
}

func (k KubernetesSchema) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "properties", k.Properties)
}

func (k *KubernetesSchema) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &k.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ListAmlUserFeatureResult - The List Aml user feature operation response.
type ListAmlUserFeatureResult struct {
	// READ-ONLY; The URI to fetch the next page of AML user features information. Call ListNext() with this to fetch the next page of AML user features information.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of AML user facing features.
	Value []*AmlUserFeature `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ListAmlUserFeatureResult.
func (l ListAmlUserFeatureResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

type ListNotebookKeysResult struct {
	// READ-ONLY
	PrimaryAccessKey *string `json:"primaryAccessKey,omitempty" azure:"ro"`

	// READ-ONLY
	SecondaryAccessKey *string `json:"secondaryAccessKey,omitempty" azure:"ro"`
}

type ListStorageAccountKeysResult struct {
	// READ-ONLY
	UserStorageKey *string `json:"userStorageKey,omitempty" azure:"ro"`
}

// ListUsagesResult - The List Usages operation response.
type ListUsagesResult struct {
	// READ-ONLY; The URI to fetch the next page of AML resource usage information. Call ListNext() with this to fetch the next page of AML resource usage information.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of AML resource usages.
	Value []*Usage `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ListUsagesResult.
func (l ListUsagesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

type ListWorkspaceKeysResult struct {
	// READ-ONLY
	AppInsightsInstrumentationKey *string `json:"appInsightsInstrumentationKey,omitempty" azure:"ro"`

	// READ-ONLY
	ContainerRegistryCredentials *RegistryListCredentialsResult `json:"containerRegistryCredentials,omitempty" azure:"ro"`

	// READ-ONLY
	NotebookAccessKeys *ListNotebookKeysResult `json:"notebookAccessKeys,omitempty" azure:"ro"`

	// READ-ONLY
	UserStorageKey *string `json:"userStorageKey,omitempty" azure:"ro"`

	// READ-ONLY
	UserStorageResourceID *string `json:"userStorageResourceId,omitempty" azure:"ro"`
}

// ListWorkspaceQuotas - The List WorkspaceQuotasByVMFamily operation response.
type ListWorkspaceQuotas struct {
	// READ-ONLY; The URI to fetch the next page of workspace quota information by VM Family. Call ListNext() with this to fetch the next page of Workspace
	// Quota information.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of Workspace Quotas by VM Family
	Value []*ResourceQuota `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ListWorkspaceQuotas.
func (l ListWorkspaceQuotas) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// NodeStateCounts - Counts of various compute node states on the amlCompute.
type NodeStateCounts struct {
	// READ-ONLY; Number of compute nodes in idle state.
	IdleNodeCount *int32 `json:"idleNodeCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of compute nodes which are leaving the amlCompute.
	LeavingNodeCount *int32 `json:"leavingNodeCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of compute nodes which are in preempted state.
	PreemptedNodeCount *int32 `json:"preemptedNodeCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of compute nodes which are being prepared.
	PreparingNodeCount *int32 `json:"preparingNodeCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of compute nodes which are running jobs.
	RunningNodeCount *int32 `json:"runningNodeCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of compute nodes which are in unusable state.
	UnusableNodeCount *int32 `json:"unusableNodeCount,omitempty" azure:"ro"`
}

type NotebookAccessTokenResult struct {
	// READ-ONLY
	AccessToken *string `json:"accessToken,omitempty" azure:"ro"`

	// READ-ONLY
	ExpiresIn *int32 `json:"expiresIn,omitempty" azure:"ro"`

	// READ-ONLY
	HostName *string `json:"hostName,omitempty" azure:"ro"`

	// READ-ONLY
	NotebookResourceID *string `json:"notebookResourceId,omitempty" azure:"ro"`

	// READ-ONLY
	PublicDNS *string `json:"publicDns,omitempty" azure:"ro"`

	// READ-ONLY
	RefreshToken *string `json:"refreshToken,omitempty" azure:"ro"`

	// READ-ONLY
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY
	TokenType *string `json:"tokenType,omitempty" azure:"ro"`
}

type NotebookPreparationError struct {
	ErrorMessage *string `json:"errorMessage,omitempty"`
	StatusCode   *int32  `json:"statusCode,omitempty"`
}

type NotebookResourceInfo struct {
	Fqdn *string `json:"fqdn,omitempty"`

	// The error that occurs when preparing notebook.
	NotebookPreparationError *NotebookPreparationError `json:"notebookPreparationError,omitempty"`

	// the data plane resourceId that used to initialize notebook component
	ResourceID *string `json:"resourceId,omitempty"`
}

// Operation - Azure Machine Learning workspace REST API operation
type Operation struct {
	// Display name of operation
	Display *OperationDisplay `json:"display,omitempty"`

	// Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
}

// OperationDisplay - Display name of operation
type OperationDisplay struct {
	// The description for the operation.
	Description *string `json:"description,omitempty"`

	// The operation that users can perform.
	Operation *string `json:"operation,omitempty"`

	// The resource provider name: Microsoft.MachineLearningExperimentation
	Provider *string `json:"provider,omitempty"`

	// The resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationListResult - An array of operations supported by the resource provider.
type OperationListResult struct {
	// List of AML workspace operations supported by the AML workspace resource provider.
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PaginatedComputeResourcesList - Paginated list of Machine Learning compute objects wrapped in ARM resource envelope.
type PaginatedComputeResourcesList struct {
	// A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of Machine Learning compute objects wrapped in ARM resource envelope.
	Value []*ComputeResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedComputeResourcesList.
func (p PaginatedComputeResourcesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PaginatedWorkspaceConnectionsList - Paginated list of Workspace connection objects.
type PaginatedWorkspaceConnectionsList struct {
	// A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of Workspace connection objects.
	Value []*WorkspaceConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedWorkspaceConnectionsList.
func (p PaginatedWorkspaceConnectionsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

type Password struct {
	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	Value *string `json:"value,omitempty" azure:"ro"`
}

// PersonalComputeInstanceSettings - Settings for a personal compute instance.
type PersonalComputeInstanceSettings struct {
	// A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser `json:"assignedUser,omitempty"`
}

// PrivateEndpoint - The Private Endpoint resource.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The ARM identifier for Subnet resource that private endpoint links to
	SubnetArmID *string `json:"subnetArmId,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - The Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	Resource
	// The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// The sku of the workspace.
	SKU *SKU `json:"sku,omitempty"`

	// Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; System data
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnection.
func (p *PrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &p.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &p.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &p.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &p.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PrivateEndpointConnectionListResult - List of private endpoint connection associated with the specified workspace
type PrivateEndpointConnectionListResult struct {
	// Array of private endpoint connections
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// REQUIRED; A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// READ-ONLY; The provisioning state of the private endpoint connection resource.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionsCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnections.CreateOrUpdate method.
type PrivateEndpointConnectionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsDeleteOptions contains the optional parameters for the PrivateEndpointConnections.Delete method.
type PrivateEndpointConnectionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListOptions contains the optional parameters for the PrivateEndpointConnections.List method.
type PrivateEndpointConnectionsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	Resource
	// The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// Resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// The sku of the workspace.
	SKU *SKU `json:"sku,omitempty"`

	// Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; System data
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &p.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &p.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &p.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &p.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PrivateLinkResourceListResult - A list of private link resources
type PrivateLinkResourceListResult struct {
	// Array of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// The private link resource Private link DNS zone name.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`

	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesListOptions contains the optional parameters for the PrivateLinkResources.List method.
type PrivateLinkResourcesListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// QuotaBaseProperties - The properties for Quota update or retrieval.
type QuotaBaseProperties struct {
	// Specifies the resource ID.
	ID *string `json:"id,omitempty"`

	// The maximum permitted quota of the resource.
	Limit *int64 `json:"limit,omitempty"`

	// Specifies the resource type.
	Type *string `json:"type,omitempty"`

	// An enum describing the unit of quota measurement.
	Unit *QuotaUnit `json:"unit,omitempty"`
}

// QuotaUpdateParameters - Quota update parameters.
type QuotaUpdateParameters struct {
	// Region of workspace quota to be updated.
	Location *string `json:"location,omitempty"`

	// The list for update quota.
	Value []*QuotaBaseProperties `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuotaUpdateParameters.
func (q QuotaUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", q.Location)
	populate(objectMap, "value", q.Value)
	return json.Marshal(objectMap)
}

// QuotasListOptions contains the optional parameters for the Quotas.List method.
type QuotasListOptions struct {
	// placeholder for future optional parameters
}

// QuotasUpdateOptions contains the optional parameters for the Quotas.Update method.
type QuotasUpdateOptions struct {
	// placeholder for future optional parameters
}

type RegistryListCredentialsResult struct {
	Passwords []*Password `json:"passwords,omitempty"`

	// READ-ONLY
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY
	Username *string `json:"username,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RegistryListCredentialsResult.
func (r RegistryListCredentialsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", r.Location)
	populate(objectMap, "passwords", r.Passwords)
	populate(objectMap, "username", r.Username)
	return json.Marshal(objectMap)
}

// Resource - Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

func (r *Resource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceID - Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceID struct {
	// REQUIRED; The ID of the resource
	ID *string `json:"id,omitempty"`
}

// ResourceName - The Resource Name.
type ResourceName struct {
	// READ-ONLY; The localized name of the resource.
	LocalizedValue *string `json:"localizedValue,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// ResourceQuota - The quota assigned to a resource.
type ResourceQuota struct {
	// READ-ONLY; Region of the AML workspace in the id.
	AmlWorkspaceLocation *string `json:"amlWorkspaceLocation,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The maximum permitted quota of the resource.
	Limit *int64 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource.
	Name *ResourceName `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the resource type.
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; An enum describing the unit of quota measurement.
	Unit *QuotaUnit `json:"unit,omitempty" azure:"ro"`
}

type ResourceSKULocationInfo struct {
	// READ-ONLY; Location of the SKU
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; Details of capabilities available to a SKU in specific zones.
	ZoneDetails []*ResourceSKUZoneDetails `json:"zoneDetails,omitempty" azure:"ro"`

	// READ-ONLY; List of availability zones where the SKU is supported.
	Zones []*string `json:"zones,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKULocationInfo.
func (r ResourceSKULocationInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", r.Location)
	populate(objectMap, "zoneDetails", r.ZoneDetails)
	populate(objectMap, "zones", r.Zones)
	return json.Marshal(objectMap)
}

// ResourceSKUZoneDetails - Describes The zonal capabilities of a SKU.
type ResourceSKUZoneDetails struct {
	// READ-ONLY; A list of capabilities that are available for the SKU in the specified list of zones.
	Capabilities []*SKUCapability `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; The set of zones that the SKU is available in with the specified capabilities.
	Name []*string `json:"name,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKUZoneDetails.
func (r ResourceSKUZoneDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capabilities", r.Capabilities)
	populate(objectMap, "name", r.Name)
	return json.Marshal(objectMap)
}

// Restriction - The restriction because of which SKU cannot be used.
type Restriction struct {
	// The reason for the restriction.
	ReasonCode *ReasonCode `json:"reasonCode,omitempty"`

	// READ-ONLY; The type of restrictions. As of now only possible value for this is location.
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
	Values []*string `json:"values,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Restriction.
func (r Restriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "reasonCode", r.ReasonCode)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// SKU - Sku of the resource
type SKU struct {
	// Name of the sku
	Name *string `json:"name,omitempty"`

	// Tier of the sku like Basic or Enterprise
	Tier *string `json:"tier,omitempty"`
}

// SKUCapability - Features/user capabilities associated with the sku
type SKUCapability struct {
	// Capability/Feature ID
	Name *string `json:"name,omitempty"`

	// Details about the feature/capability
	Value *string `json:"value,omitempty"`
}

// SKUListResult - List of skus with features
type SKUListResult struct {
	// The URI to fetch the next page of Workspace Skus. Call ListNext() with this URI to fetch the next page of Workspace Skus
	NextLink *string         `json:"nextLink,omitempty"`
	Value    []*WorkspaceSKU `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUListResult.
func (s SKUListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SSLConfiguration - The ssl configuration for scoring
type SSLConfiguration struct {
	// Cert data
	Cert *string `json:"cert,omitempty"`

	// CNAME of the cert
	Cname *string `json:"cname,omitempty"`

	// Key data
	Key *string `json:"key,omitempty"`

	// Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`

	// Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`

	// Enable or disable ssl for scoring
	Status *SSLConfigurationStatus `json:"status,omitempty"`
}

// ScaleSettings - scale settings for AML Compute
type ScaleSettings struct {
	// REQUIRED; Max number of nodes to use
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`

	// Min number of nodes to use
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`

	// Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

// ScaleSettingsInformation - Desired scale settings for the amlCompute.
type ScaleSettingsInformation struct {
	// scale settings for AML Compute
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`
}

// ScriptReference - Script reference
type ScriptReference struct {
	// Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`

	// The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`

	// The storage source of the script: inline, workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`

	// Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

// ScriptsToExecute - Customized setup scripts
type ScriptsToExecute struct {
	// Script that's run only once during provision of the compute.
	CreationScript *ScriptReference `json:"creationScript,omitempty"`

	// Script that's run every time the machine starts.
	StartupScript *ScriptReference `json:"startupScript,omitempty"`
}

type ServiceManagedResourcesSettings struct {
	// The settings for the service managed cosmosdb account.
	CosmosDb *CosmosDbSettings `json:"cosmosDb,omitempty"`
}

// ServicePrincipalCredentials - Service principal credentials.
type ServicePrincipalCredentials struct {
	// REQUIRED; Client Id
	ClientID *string `json:"clientId,omitempty"`

	// REQUIRED; Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// SetupScripts - Details of customized scripts to execute for setting up the cluster.
type SetupScripts struct {
	// Customized setup scripts
	Scripts *ScriptsToExecute `json:"scripts,omitempty"`
}

type SharedPrivateLinkResource struct {
	// Unique name of the private link.
	Name *string `json:"name,omitempty"`

	// Resource properties.
	Properties *SharedPrivateLinkResourceProperty `json:"properties,omitempty"`
}

// SharedPrivateLinkResourceProperty - Properties of a shared private link resource.
type SharedPrivateLinkResourceProperty struct {
	// The private link resource group id.
	GroupID *string `json:"groupId,omitempty"`

	// The resource id that private link links to.
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`

	// Request message.
	RequestMessage *string `json:"requestMessage,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// SynapseSpark - A SynapseSpark compute.
type SynapseSpark struct {
	Compute
	Properties *SynapseSparkProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSpark.
func (s SynapseSpark) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Compute.marshalInternal(objectMap, ComputeTypeSynapseSpark)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSpark.
func (s *SynapseSpark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type SynapseSparkProperties struct {
	// Auto pause properties.
	AutoPauseProperties *AutoPauseProperties `json:"autoPauseProperties,omitempty"`

	// Auto scale properties.
	AutoScaleProperties *AutoScaleProperties `json:"autoScaleProperties,omitempty"`

	// The number of compute nodes currently assigned to the compute.
	NodeCount *int32 `json:"nodeCount,omitempty"`

	// Node size.
	NodeSize *string `json:"nodeSize,omitempty"`

	// Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`

	// Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// Azure subscription identifier.
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SystemService - A system service running on a compute.
type SystemService struct {
	// READ-ONLY; Public IP address
	PublicIPAddress *string `json:"publicIpAddress,omitempty" azure:"ro"`

	// READ-ONLY; The type of this system service.
	SystemServiceType *string `json:"systemServiceType,omitempty" azure:"ro"`

	// READ-ONLY; The version for this type.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// UpdateWorkspaceQuotas - The properties for update Quota response.
type UpdateWorkspaceQuotas struct {
	// The maximum permitted quota of the resource.
	Limit *int64 `json:"limit,omitempty"`

	// Status of update workspace quota.
	Status *Status `json:"status,omitempty"`

	// READ-ONLY; Specifies the resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the resource type.
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; An enum describing the unit of quota measurement.
	Unit *QuotaUnit `json:"unit,omitempty" azure:"ro"`
}

// UpdateWorkspaceQuotasResult - The result of update workspace quota.
type UpdateWorkspaceQuotasResult struct {
	// READ-ONLY; The URI to fetch the next page of workspace quota update result. Call ListNext() with this to fetch the next page of Workspace Quota update
	// result.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; The list of workspace quota update result.
	Value []*UpdateWorkspaceQuotas `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateWorkspaceQuotasResult.
func (u UpdateWorkspaceQuotasResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// Usage - Describes AML Resource Usage.
type Usage struct {
	// READ-ONLY; Region of the AML workspace in the id.
	AmlWorkspaceLocation *string `json:"amlWorkspaceLocation,omitempty" azure:"ro"`

	// READ-ONLY; The current usage of the resource.
	CurrentValue *int64 `json:"currentValue,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The maximum permitted usage of the resource.
	Limit *int64 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; The name of the type of usage.
	Name *UsageName `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the resource type.
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; An enum describing the unit of usage measurement.
	Unit *UsageUnit `json:"unit,omitempty" azure:"ro"`
}

// UsageName - The Usage Names.
type UsageName struct {
	// READ-ONLY; The localized name of the resource.
	LocalizedValue *string `json:"localizedValue,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// UsagesListOptions contains the optional parameters for the Usages.List method.
type UsagesListOptions struct {
	// placeholder for future optional parameters
}

// UserAccountCredentials - Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials struct {
	// REQUIRED; Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`

	// Password of the administrator user account.
	AdminUserPassword *string `json:"adminUserPassword,omitempty"`

	// SSH public key of the administrator user account.
	AdminUserSSHPublicKey *string `json:"adminUserSshPublicKey,omitempty"`
}

// UserAssignedIdentity - User Assigned Identity
type UserAssignedIdentity struct {
	// READ-ONLY; The clientId(aka appId) of the user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal ID of the user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of the user assigned identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// VirtualMachine - A Machine Learning compute based on Azure Virtual Machines.
type VirtualMachine struct {
	Compute
	Properties *VirtualMachineProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachine.
func (v VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.Compute.marshalInternal(objectMap, ComputeTypeVirtualMachine)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachine.
func (v *VirtualMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &v.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.Compute.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VirtualMachineImage - Virtual Machine image for Windows AML Compute
type VirtualMachineImage struct {
	// REQUIRED; Virtual Machine image path
	ID *string `json:"id,omitempty"`
}

type VirtualMachineProperties struct {
	// Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`

	// Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`

	// Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`

	// Port open for ssh connections.
	SSHPort *int32 `json:"sshPort,omitempty"`

	// Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
}

// VirtualMachineSSHCredentials - Admin credentials for virtual machine
type VirtualMachineSSHCredentials struct {
	// Password of admin account
	Password *string `json:"password,omitempty"`

	// Private key data
	PrivateKeyData *string `json:"privateKeyData,omitempty"`

	// Public key data
	PublicKeyData *string `json:"publicKeyData,omitempty"`

	// Username of admin account
	Username *string `json:"username,omitempty"`
}

// VirtualMachineSecrets - Secrets related to a Machine Learning compute based on AKS.
type VirtualMachineSecrets struct {
	ComputeSecrets
	// Admin credentials for virtual machine.
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineSecrets.
func (v VirtualMachineSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ComputeSecrets.marshalInternal(objectMap, ComputeTypeVirtualMachine)
	populate(objectMap, "administratorAccount", v.AdministratorAccount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineSecrets.
func (v *VirtualMachineSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administratorAccount":
			err = unpopulate(val, &v.AdministratorAccount)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ComputeSecrets.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VirtualMachineSize - Describes the properties of a VM size.
type VirtualMachineSize struct {
	// The estimated price information for using a VM.
	EstimatedVMPrices *EstimatedVMPrices `json:"estimatedVMPrices,omitempty"`

	// Specifies the compute types supported by the virtual machine size.
	SupportedComputeTypes []*string `json:"supportedComputeTypes,omitempty"`

	// READ-ONLY; The family name of the virtual machine size.
	Family *string `json:"family,omitempty" azure:"ro"`

	// READ-ONLY; The number of gPUs supported by the virtual machine size.
	Gpus *int32 `json:"gpus,omitempty" azure:"ro"`

	// READ-ONLY; Specifies if the virtual machine size supports low priority VMs.
	LowPriorityCapable *bool `json:"lowPriorityCapable,omitempty" azure:"ro"`

	// READ-ONLY; The resource volume size, in MB, allowed by the virtual machine size.
	MaxResourceVolumeMB *int32 `json:"maxResourceVolumeMB,omitempty" azure:"ro"`

	// READ-ONLY; The amount of memory, in GB, supported by the virtual machine size.
	MemoryGB *float64 `json:"memoryGB,omitempty" azure:"ro"`

	// READ-ONLY; The name of the virtual machine size.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The OS VHD disk size, in MB, allowed by the virtual machine size.
	OSVhdSizeMB *int32 `json:"osVhdSizeMB,omitempty" azure:"ro"`

	// READ-ONLY; Specifies if the virtual machine size supports premium IO.
	PremiumIO *bool `json:"premiumIO,omitempty" azure:"ro"`

	// READ-ONLY; The number of vCPUs supported by the virtual machine size.
	VCPUs *int32 `json:"vCPUs,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineSize.
func (v VirtualMachineSize) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "estimatedVMPrices", v.EstimatedVMPrices)
	populate(objectMap, "family", v.Family)
	populate(objectMap, "gpus", v.Gpus)
	populate(objectMap, "lowPriorityCapable", v.LowPriorityCapable)
	populate(objectMap, "maxResourceVolumeMB", v.MaxResourceVolumeMB)
	populate(objectMap, "memoryGB", v.MemoryGB)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "osVhdSizeMB", v.OSVhdSizeMB)
	populate(objectMap, "premiumIO", v.PremiumIO)
	populate(objectMap, "supportedComputeTypes", v.SupportedComputeTypes)
	populate(objectMap, "vCPUs", v.VCPUs)
	return json.Marshal(objectMap)
}

// VirtualMachineSizeListResult - The List Virtual Machine size operation response.
type VirtualMachineSizeListResult struct {
	// The list of virtual machine sizes supported by AmlCompute.
	Value []*VirtualMachineSize `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineSizeListResult.
func (v VirtualMachineSizeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualMachineSizesListOptions contains the optional parameters for the VirtualMachineSizes.List method.
type VirtualMachineSizesListOptions struct {
	// placeholder for future optional parameters
}

// Workspace - An object that represents a machine learning workspace.
type Workspace struct {
	Resource
	// The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// The properties of the machine learning workspace.
	Properties *WorkspaceProperties `json:"properties,omitempty"`

	// The sku of the workspace.
	SKU *SKU `json:"sku,omitempty"`

	// Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; System data
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "location", w.Location)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "sku", w.SKU)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Workspace.
func (w *Workspace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &w.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &w.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &w.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &w.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &w.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := w.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// WorkspaceConnection - Workspace connection.
type WorkspaceConnection struct {
	// Properties of workspace connection.
	Properties *WorkspaceConnectionProps `json:"properties,omitempty"`

	// READ-ONLY; ResourceId of the workspace connection.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Friendly name of the workspace connection.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type of workspace connection.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// WorkspaceConnectionProps - Workspace Connection specific properties.
type WorkspaceConnectionProps struct {
	// Authorization type of the workspace connection.
	AuthType *string `json:"authType,omitempty"`

	// Category of the workspace connection.
	Category *string `json:"category,omitempty"`

	// Target of the workspace connection.
	Target *string `json:"target,omitempty"`

	// Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// format for the workspace connection value
	ValueFormat *ValueFormat `json:"valueFormat,omitempty"`
}

// WorkspaceConnectionsCreateOptions contains the optional parameters for the WorkspaceConnections.Create method.
type WorkspaceConnectionsCreateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceConnectionsDeleteOptions contains the optional parameters for the WorkspaceConnections.Delete method.
type WorkspaceConnectionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceConnectionsGetOptions contains the optional parameters for the WorkspaceConnections.Get method.
type WorkspaceConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceConnectionsListOptions contains the optional parameters for the WorkspaceConnections.List method.
type WorkspaceConnectionsListOptions struct {
	// Category of the workspace connection.
	Category *string
	// Target of the workspace connection.
	Target *string
}

// WorkspaceFeaturesListOptions contains the optional parameters for the WorkspaceFeatures.List method.
type WorkspaceFeaturesListOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceListResult - The result of a request to list machine learning workspaces.
type WorkspaceListResult struct {
	// The URI that can be used to request the next list of machine learning workspaces.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of machine learning workspaces. Since this list may be incomplete, the nextLink field should be used to request the next list of machine learning
	// workspaces.
	Value []*Workspace `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceListResult.
func (w WorkspaceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WorkspaceProperties - The properties of a machine learning workspace.
type WorkspaceProperties struct {
	// The flag to indicate whether to allow public access when behind VNet.
	AllowPublicAccessWhenBehindVnet *bool `json:"allowPublicAccessWhenBehindVnet,omitempty"`

	// ARM id of the application insights associated with this workspace. This cannot be changed once the workspace has been created
	ApplicationInsights *string `json:"applicationInsights,omitempty"`

	// ARM id of the container registry associated with this workspace. This cannot be changed once the workspace has been created
	ContainerRegistry *string `json:"containerRegistry,omitempty"`

	// The description of this workspace.
	Description *string `json:"description,omitempty"`

	// Url for the discovery service to identify regional endpoints for machine learning experimentation services
	DiscoveryURL *string `json:"discoveryUrl,omitempty"`

	// The encryption settings of Azure ML workspace.
	Encryption *EncryptionProperty `json:"encryption,omitempty"`

	// The friendly name for this workspace. This name in mutable
	FriendlyName *string `json:"friendlyName,omitempty"`

	// The flag to signal HBI data in the workspace and reduce diagnostic data collected by the service
	HbiWorkspace *bool `json:"hbiWorkspace,omitempty"`

	// The compute name for image build
	ImageBuildCompute *string `json:"imageBuildCompute,omitempty"`

	// ARM id of the key vault associated with this workspace. This cannot be changed once the workspace has been created
	KeyVault *string `json:"keyVault,omitempty"`

	// The user assigned identity resource id that represents the workspace identity.
	PrimaryUserAssignedIdentity *string `json:"primaryUserAssignedIdentity,omitempty"`

	// Whether requests from Public Network are allowed.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The service managed resource settings.
	ServiceManagedResourcesSettings *ServiceManagedResourcesSettings `json:"serviceManagedResourcesSettings,omitempty"`

	// The list of shared private link resources in this workspace.
	SharedPrivateLinkResources []*SharedPrivateLinkResource `json:"sharedPrivateLinkResources,omitempty"`

	// ARM id of the storage account associated with this workspace. This cannot be changed once the workspace has been created
	StorageAccount *string `json:"storageAccount,omitempty"`

	// READ-ONLY; The URI associated with this workspace that machine learning flow must point at to set up tracking.
	MlFlowTrackingURI *string `json:"mlFlowTrackingUri,omitempty" azure:"ro"`

	// READ-ONLY; The notebook info of Azure ML workspace.
	NotebookInfo *NotebookResourceInfo `json:"notebookInfo,omitempty" azure:"ro"`

	// READ-ONLY; The list of private endpoint connections in the workspace.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; Count of private connections in the workspace
	PrivateLinkCount *int32 `json:"privateLinkCount,omitempty" azure:"ro"`

	// READ-ONLY; The current deployment state of workspace resource. The provisioningState is to indicate states for resource provisioning.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The name of the managed resource group created by workspace RP in customer subscription if the workspace is CMK workspace
	ServiceProvisionedResourceGroup *string `json:"serviceProvisionedResourceGroup,omitempty" azure:"ro"`

	// READ-ONLY; If the storage associated with the workspace has hierarchical namespace(HNS) enabled.
	StorageHnsEnabled *bool `json:"storageHnsEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The tenant id associated with this workspace.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// READ-ONLY; The immutable id associated with this workspace.
	WorkspaceID *string `json:"workspaceId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceProperties.
func (w WorkspaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowPublicAccessWhenBehindVnet", w.AllowPublicAccessWhenBehindVnet)
	populate(objectMap, "applicationInsights", w.ApplicationInsights)
	populate(objectMap, "containerRegistry", w.ContainerRegistry)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "discoveryUrl", w.DiscoveryURL)
	populate(objectMap, "encryption", w.Encryption)
	populate(objectMap, "friendlyName", w.FriendlyName)
	populate(objectMap, "hbiWorkspace", w.HbiWorkspace)
	populate(objectMap, "imageBuildCompute", w.ImageBuildCompute)
	populate(objectMap, "keyVault", w.KeyVault)
	populate(objectMap, "mlFlowTrackingUri", w.MlFlowTrackingURI)
	populate(objectMap, "notebookInfo", w.NotebookInfo)
	populate(objectMap, "primaryUserAssignedIdentity", w.PrimaryUserAssignedIdentity)
	populate(objectMap, "privateEndpointConnections", w.PrivateEndpointConnections)
	populate(objectMap, "privateLinkCount", w.PrivateLinkCount)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", w.PublicNetworkAccess)
	populate(objectMap, "serviceManagedResourcesSettings", w.ServiceManagedResourcesSettings)
	populate(objectMap, "serviceProvisionedResourceGroup", w.ServiceProvisionedResourceGroup)
	populate(objectMap, "sharedPrivateLinkResources", w.SharedPrivateLinkResources)
	populate(objectMap, "storageAccount", w.StorageAccount)
	populate(objectMap, "storageHnsEnabled", w.StorageHnsEnabled)
	populate(objectMap, "tenantId", w.TenantID)
	populate(objectMap, "workspaceId", w.WorkspaceID)
	return json.Marshal(objectMap)
}

// WorkspacePropertiesUpdateParameters - The parameters for updating the properties of a machine learning workspace.
type WorkspacePropertiesUpdateParameters struct {
	// The description of this workspace.
	Description *string `json:"description,omitempty"`

	// The friendly name for this workspace.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// The compute name for image build
	ImageBuildCompute *string `json:"imageBuildCompute,omitempty"`

	// The user assigned identity resource id that represents the workspace identity.
	PrimaryUserAssignedIdentity *string `json:"primaryUserAssignedIdentity,omitempty"`

	// Whether requests from Public Network are allowed.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The service managed resource settings.
	ServiceManagedResourcesSettings *ServiceManagedResourcesSettings `json:"serviceManagedResourcesSettings,omitempty"`
}

// WorkspaceSKU - Describes Workspace Sku details and features
type WorkspaceSKU struct {
	// The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
	Restrictions []*Restriction `json:"restrictions,omitempty"`

	// READ-ONLY; List of features/user capabilities associated with the sku
	Capabilities []*SKUCapability `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; A list of locations and availability zones in those locations where the SKU is available.
	LocationInfo []*ResourceSKULocationInfo `json:"locationInfo,omitempty" azure:"ro"`

	// READ-ONLY; The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g. West US, East US, Southeast
	// Asia, etc.).
	Locations []*string `json:"locations,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; Sku Tier like Basic or Enterprise
	Tier *string `json:"tier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceSKU.
func (w WorkspaceSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capabilities", w.Capabilities)
	populate(objectMap, "locationInfo", w.LocationInfo)
	populate(objectMap, "locations", w.Locations)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "resourceType", w.ResourceType)
	populate(objectMap, "restrictions", w.Restrictions)
	populate(objectMap, "tier", w.Tier)
	return json.Marshal(objectMap)
}

// WorkspaceSKUsListOptions contains the optional parameters for the WorkspaceSKUs.List method.
type WorkspaceSKUsListOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceUpdateParameters - The parameters for updating a machine learning workspace.
type WorkspaceUpdateParameters struct {
	// The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// The properties that the machine learning workspace will be updated with.
	Properties *WorkspacePropertiesUpdateParameters `json:"properties,omitempty"`

	// The sku of the workspace.
	SKU *SKU `json:"sku,omitempty"`

	// The resource tags for the machine learning workspace.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceUpdateParameters.
func (w WorkspaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "sku", w.SKU)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// WorkspacesBeginCreateOrUpdateOptions contains the optional parameters for the Workspaces.BeginCreateOrUpdate method.
type WorkspacesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesBeginDeleteOptions contains the optional parameters for the Workspaces.BeginDelete method.
type WorkspacesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesBeginDiagnoseOptions contains the optional parameters for the Workspaces.BeginDiagnose method.
type WorkspacesBeginDiagnoseOptions struct {
	// The parameter of diagnosing workspace health
	Parameters *DiagnoseWorkspaceParameters
}

// WorkspacesBeginPrepareNotebookOptions contains the optional parameters for the Workspaces.BeginPrepareNotebook method.
type WorkspacesBeginPrepareNotebookOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesBeginResyncKeysOptions contains the optional parameters for the Workspaces.BeginResyncKeys method.
type WorkspacesBeginResyncKeysOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesGetOptions contains the optional parameters for the Workspaces.Get method.
type WorkspacesGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListByResourceGroupOptions contains the optional parameters for the Workspaces.ListByResourceGroup method.
type WorkspacesListByResourceGroupOptions struct {
	// Continuation token for pagination.
	Skip *string
}

// WorkspacesListBySubscriptionOptions contains the optional parameters for the Workspaces.ListBySubscription method.
type WorkspacesListBySubscriptionOptions struct {
	// Continuation token for pagination.
	Skip *string
}

// WorkspacesListKeysOptions contains the optional parameters for the Workspaces.ListKeys method.
type WorkspacesListKeysOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListNotebookAccessTokenOptions contains the optional parameters for the Workspaces.ListNotebookAccessToken method.
type WorkspacesListNotebookAccessTokenOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListNotebookKeysOptions contains the optional parameters for the Workspaces.ListNotebookKeys method.
type WorkspacesListNotebookKeysOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListOutboundNetworkDependenciesEndpointsOptions contains the optional parameters for the Workspaces.ListOutboundNetworkDependenciesEndpoints
// method.
type WorkspacesListOutboundNetworkDependenciesEndpointsOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListStorageAccountKeysOptions contains the optional parameters for the Workspaces.ListStorageAccountKeys method.
type WorkspacesListStorageAccountKeysOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesUpdateOptions contains the optional parameters for the Workspaces.Update method.
type WorkspacesUpdateOptions struct {
	// placeholder for future optional parameters
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
