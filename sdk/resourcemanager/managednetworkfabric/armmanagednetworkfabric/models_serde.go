//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package armmanagednetworkfabric

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ARPProperties.
func (a ARPProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "address", a.Address)
	populate(objectMap, "age", a.Age)
	populate(objectMap, "interface", a.Interface)
	populate(objectMap, "macAddress", a.MacAddress)
	populate(objectMap, "state", a.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ARPProperties.
func (a *ARPProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "address":
			err = unpopulate(val, "Address", &a.Address)
			delete(rawMsg, key)
		case "age":
			err = unpopulate(val, "Age", &a.Age)
			delete(rawMsg, key)
		case "interface":
			err = unpopulate(val, "Interface", &a.Interface)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &a.MacAddress)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlList.
func (a AccessControlList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlList.
func (a *AccessControlList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlListConditionProperties.
func (a AccessControlListConditionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", a.Action)
	populate(objectMap, "annotation", a.Annotation)
	populate(objectMap, "destinationAddress", a.DestinationAddress)
	populate(objectMap, "destinationPort", a.DestinationPort)
	populate(objectMap, "protocol", a.Protocol)
	populate(objectMap, "sequenceNumber", a.SequenceNumber)
	populate(objectMap, "sourceAddress", a.SourceAddress)
	populate(objectMap, "sourcePort", a.SourcePort)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlListConditionProperties.
func (a *AccessControlListConditionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &a.Action)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &a.Annotation)
			delete(rawMsg, key)
		case "destinationAddress":
			err = unpopulate(val, "DestinationAddress", &a.DestinationAddress)
			delete(rawMsg, key)
		case "destinationPort":
			err = unpopulate(val, "DestinationPort", &a.DestinationPort)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &a.Protocol)
			delete(rawMsg, key)
		case "sequenceNumber":
			err = unpopulate(val, "SequenceNumber", &a.SequenceNumber)
			delete(rawMsg, key)
		case "sourceAddress":
			err = unpopulate(val, "SourceAddress", &a.SourceAddress)
			delete(rawMsg, key)
		case "sourcePort":
			err = unpopulate(val, "SourcePort", &a.SourcePort)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlListPatch.
func (a AccessControlListPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlListPatch.
func (a *AccessControlListPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlListPatchProperties.
func (a AccessControlListPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addressFamily", a.AddressFamily)
	populate(objectMap, "annotation", a.Annotation)
	populate(objectMap, "conditions", a.Conditions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlListPatchProperties.
func (a *AccessControlListPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addressFamily":
			err = unpopulate(val, "AddressFamily", &a.AddressFamily)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &a.Annotation)
			delete(rawMsg, key)
		case "conditions":
			err = unpopulate(val, "Conditions", &a.Conditions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlListProperties.
func (a AccessControlListProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addressFamily", a.AddressFamily)
	populate(objectMap, "annotation", a.Annotation)
	populate(objectMap, "conditions", a.Conditions)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlListProperties.
func (a *AccessControlListProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addressFamily":
			err = unpopulate(val, "AddressFamily", &a.AddressFamily)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &a.Annotation)
			delete(rawMsg, key)
		case "conditions":
			err = unpopulate(val, "Conditions", &a.Conditions)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlListsListResult.
func (a AccessControlListsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlListsListResult.
func (a *AccessControlListsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActionIPCommunityProperties.
func (a ActionIPCommunityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "add", a.Add)
	populate(objectMap, "delete", a.Delete)
	populate(objectMap, "set", a.Set)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionIPCommunityProperties.
func (a *ActionIPCommunityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "add":
			err = unpopulate(val, "Add", &a.Add)
			delete(rawMsg, key)
		case "delete":
			err = unpopulate(val, "Delete", &a.Delete)
			delete(rawMsg, key)
		case "set":
			err = unpopulate(val, "Set", &a.Set)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActionIPExtendedCommunityProperties.
func (a ActionIPExtendedCommunityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "add", a.Add)
	populate(objectMap, "delete", a.Delete)
	populate(objectMap, "set", a.Set)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionIPExtendedCommunityProperties.
func (a *ActionIPExtendedCommunityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "add":
			err = unpopulate(val, "Add", &a.Add)
			delete(rawMsg, key)
		case "delete":
			err = unpopulate(val, "Delete", &a.Delete)
			delete(rawMsg, key)
		case "set":
			err = unpopulate(val, "Set", &a.Set)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AggregateRoute.
func (a AggregateRoute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "prefix", a.Prefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AggregateRoute.
func (a *AggregateRoute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "prefix":
			err = unpopulate(val, "Prefix", &a.Prefix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AggregateRouteConfiguration.
func (a AggregateRouteConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4Routes", a.IPv4Routes)
	populate(objectMap, "ipv6Routes", a.IPv6Routes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AggregateRouteConfiguration.
func (a *AggregateRouteConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4Routes":
			err = unpopulate(val, "IPv4Routes", &a.IPv4Routes)
			delete(rawMsg, key)
		case "ipv6Routes":
			err = unpopulate(val, "IPv6Routes", &a.IPv6Routes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BfdConfiguration.
func (b BfdConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", b.AdministrativeState)
	populate(objectMap, "interval", b.Interval)
	populate(objectMap, "multiplier", b.Multiplier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BfdConfiguration.
func (b *BfdConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &b.AdministrativeState)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, "Interval", &b.Interval)
			delete(rawMsg, key)
		case "multiplier":
			err = unpopulate(val, "Multiplier", &b.Multiplier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BgpConfiguration.
func (b BgpConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowAS", b.AllowAS)
	populate(objectMap, "allowASOverride", b.AllowASOverride)
	populate(objectMap, "annotation", b.Annotation)
	populate(objectMap, "bfdConfiguration", b.BfdConfiguration)
	populate(objectMap, "defaultRouteOriginate", b.DefaultRouteOriginate)
	populate(objectMap, "fabricASN", b.FabricASN)
	populate(objectMap, "ipv4ListenRangePrefixes", b.IPv4ListenRangePrefixes)
	populate(objectMap, "ipv4NeighborAddress", b.IPv4NeighborAddress)
	populate(objectMap, "ipv6ListenRangePrefixes", b.IPv6ListenRangePrefixes)
	populate(objectMap, "ipv6NeighborAddress", b.IPv6NeighborAddress)
	populate(objectMap, "peerASN", b.PeerASN)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BgpConfiguration.
func (b *BgpConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowAS":
			err = unpopulate(val, "AllowAS", &b.AllowAS)
			delete(rawMsg, key)
		case "allowASOverride":
			err = unpopulate(val, "AllowASOverride", &b.AllowASOverride)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &b.Annotation)
			delete(rawMsg, key)
		case "bfdConfiguration":
			err = unpopulate(val, "BfdConfiguration", &b.BfdConfiguration)
			delete(rawMsg, key)
		case "defaultRouteOriginate":
			err = unpopulate(val, "DefaultRouteOriginate", &b.DefaultRouteOriginate)
			delete(rawMsg, key)
		case "fabricASN":
			err = unpopulate(val, "FabricASN", &b.FabricASN)
			delete(rawMsg, key)
		case "ipv4ListenRangePrefixes":
			err = unpopulate(val, "IPv4ListenRangePrefixes", &b.IPv4ListenRangePrefixes)
			delete(rawMsg, key)
		case "ipv4NeighborAddress":
			err = unpopulate(val, "IPv4NeighborAddress", &b.IPv4NeighborAddress)
			delete(rawMsg, key)
		case "ipv6ListenRangePrefixes":
			err = unpopulate(val, "IPv6ListenRangePrefixes", &b.IPv6ListenRangePrefixes)
			delete(rawMsg, key)
		case "ipv6NeighborAddress":
			err = unpopulate(val, "IPv6NeighborAddress", &b.IPv6NeighborAddress)
			delete(rawMsg, key)
		case "peerASN":
			err = unpopulate(val, "PeerASN", &b.PeerASN)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectedSubnet.
func (c ConnectedSubnet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", c.Annotation)
	populate(objectMap, "prefix", c.Prefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectedSubnet.
func (c *ConnectedSubnet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &c.Annotation)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &c.Prefix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeviceInterfaceProperties.
func (d DeviceInterfaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identifier", d.Identifier)
	populate(objectMap, "interfaceType", d.InterfaceType)
	populate(objectMap, "supportedConnectorTypes", d.SupportedConnectorTypes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeviceInterfaceProperties.
func (d *DeviceInterfaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identifier":
			err = unpopulate(val, "Identifier", &d.Identifier)
			delete(rawMsg, key)
		case "interfaceType":
			err = unpopulate(val, "InterfaceType", &d.InterfaceType)
			delete(rawMsg, key)
		case "supportedConnectorTypes":
			err = unpopulate(val, "SupportedConnectorTypes", &d.SupportedConnectorTypes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeviceLimits.
func (d DeviceLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxBidirectionalForwardingDetectionPeers", d.MaxBidirectionalForwardingDetectionPeers)
	populate(objectMap, "maxBorderGatewayProtocolPeers", d.MaxBorderGatewayProtocolPeers)
	populate(objectMap, "maxSubInterfaces", d.MaxSubInterfaces)
	populate(objectMap, "maxTunnelInterfaces", d.MaxTunnelInterfaces)
	populate(objectMap, "maxVirtualRouterFunctions", d.MaxVirtualRouterFunctions)
	populate(objectMap, "physicalInterfaceCount", d.PhysicalInterfaceCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeviceLimits.
func (d *DeviceLimits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxBidirectionalForwardingDetectionPeers":
			err = unpopulate(val, "MaxBidirectionalForwardingDetectionPeers", &d.MaxBidirectionalForwardingDetectionPeers)
			delete(rawMsg, key)
		case "maxBorderGatewayProtocolPeers":
			err = unpopulate(val, "MaxBorderGatewayProtocolPeers", &d.MaxBorderGatewayProtocolPeers)
			delete(rawMsg, key)
		case "maxSubInterfaces":
			err = unpopulate(val, "MaxSubInterfaces", &d.MaxSubInterfaces)
			delete(rawMsg, key)
		case "maxTunnelInterfaces":
			err = unpopulate(val, "MaxTunnelInterfaces", &d.MaxTunnelInterfaces)
			delete(rawMsg, key)
		case "maxVirtualRouterFunctions":
			err = unpopulate(val, "MaxVirtualRouterFunctions", &d.MaxVirtualRouterFunctions)
			delete(rawMsg, key)
		case "physicalInterfaceCount":
			err = unpopulate(val, "PhysicalInterfaceCount", &d.PhysicalInterfaceCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnableDisableOnResources.
func (e EnableDisableOnResources) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceIds", e.ResourceIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnableDisableOnResources.
func (e *EnableDisableOnResources) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceIds":
			err = unpopulate(val, "ResourceIDs", &e.ResourceIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpressRouteConnectionInformation.
func (e ExpressRouteConnectionInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expressRouteAuthorizationKey", e.ExpressRouteAuthorizationKey)
	populate(objectMap, "expressRouteCircuitId", e.ExpressRouteCircuitID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpressRouteConnectionInformation.
func (e *ExpressRouteConnectionInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expressRouteAuthorizationKey":
			err = unpopulate(val, "ExpressRouteAuthorizationKey", &e.ExpressRouteAuthorizationKey)
			delete(rawMsg, key)
		case "expressRouteCircuitId":
			err = unpopulate(val, "ExpressRouteCircuitID", &e.ExpressRouteCircuitID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalNetwork.
func (e ExternalNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalNetwork.
func (e *ExternalNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalNetworkPatch.
func (e ExternalNetworkPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalNetworkPatch.
func (e *ExternalNetworkPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalNetworkPatchProperties.
func (e ExternalNetworkPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", e.Annotation)
	populate(objectMap, "exportRoutePolicyId", e.ExportRoutePolicyID)
	populate(objectMap, "importRoutePolicyId", e.ImportRoutePolicyID)
	populate(objectMap, "optionAProperties", e.OptionAProperties)
	populate(objectMap, "optionBProperties", e.OptionBProperties)
	populate(objectMap, "peeringOption", e.PeeringOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalNetworkPatchProperties.
func (e *ExternalNetworkPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &e.Annotation)
			delete(rawMsg, key)
		case "exportRoutePolicyId":
			err = unpopulate(val, "ExportRoutePolicyID", &e.ExportRoutePolicyID)
			delete(rawMsg, key)
		case "importRoutePolicyId":
			err = unpopulate(val, "ImportRoutePolicyID", &e.ImportRoutePolicyID)
			delete(rawMsg, key)
		case "optionAProperties":
			err = unpopulate(val, "OptionAProperties", &e.OptionAProperties)
			delete(rawMsg, key)
		case "optionBProperties":
			err = unpopulate(val, "OptionBProperties", &e.OptionBProperties)
			delete(rawMsg, key)
		case "peeringOption":
			err = unpopulate(val, "PeeringOption", &e.PeeringOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalNetworkProperties.
func (e ExternalNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", e.AdministrativeState)
	populate(objectMap, "annotation", e.Annotation)
	populate(objectMap, "disabledOnResources", e.DisabledOnResources)
	populate(objectMap, "exportRoutePolicyId", e.ExportRoutePolicyID)
	populate(objectMap, "importRoutePolicyId", e.ImportRoutePolicyID)
	populate(objectMap, "networkToNetworkInterconnectId", e.NetworkToNetworkInterconnectID)
	populate(objectMap, "optionAProperties", e.OptionAProperties)
	populate(objectMap, "optionBProperties", e.OptionBProperties)
	populate(objectMap, "peeringOption", e.PeeringOption)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalNetworkProperties.
func (e *ExternalNetworkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &e.AdministrativeState)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &e.Annotation)
			delete(rawMsg, key)
		case "disabledOnResources":
			err = unpopulate(val, "DisabledOnResources", &e.DisabledOnResources)
			delete(rawMsg, key)
		case "exportRoutePolicyId":
			err = unpopulate(val, "ExportRoutePolicyID", &e.ExportRoutePolicyID)
			delete(rawMsg, key)
		case "importRoutePolicyId":
			err = unpopulate(val, "ImportRoutePolicyID", &e.ImportRoutePolicyID)
			delete(rawMsg, key)
		case "networkToNetworkInterconnectId":
			err = unpopulate(val, "NetworkToNetworkInterconnectID", &e.NetworkToNetworkInterconnectID)
			delete(rawMsg, key)
		case "optionAProperties":
			err = unpopulate(val, "OptionAProperties", &e.OptionAProperties)
			delete(rawMsg, key)
		case "optionBProperties":
			err = unpopulate(val, "OptionBProperties", &e.OptionBProperties)
			delete(rawMsg, key)
		case "peeringOption":
			err = unpopulate(val, "PeeringOption", &e.PeeringOption)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalNetworkPropertiesOptionAProperties.
func (e ExternalNetworkPropertiesOptionAProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bfdConfiguration", e.BfdConfiguration)
	populate(objectMap, "fabricASN", e.FabricASN)
	populate(objectMap, "mtu", e.Mtu)
	populate(objectMap, "peerASN", e.PeerASN)
	populate(objectMap, "primaryIpv4Prefix", e.PrimaryIPv4Prefix)
	populate(objectMap, "primaryIpv6Prefix", e.PrimaryIPv6Prefix)
	populate(objectMap, "secondaryIpv4Prefix", e.SecondaryIPv4Prefix)
	populate(objectMap, "secondaryIpv6Prefix", e.SecondaryIPv6Prefix)
	populate(objectMap, "vlanId", e.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalNetworkPropertiesOptionAProperties.
func (e *ExternalNetworkPropertiesOptionAProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bfdConfiguration":
			err = unpopulate(val, "BfdConfiguration", &e.BfdConfiguration)
			delete(rawMsg, key)
		case "fabricASN":
			err = unpopulate(val, "FabricASN", &e.FabricASN)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &e.Mtu)
			delete(rawMsg, key)
		case "peerASN":
			err = unpopulate(val, "PeerASN", &e.PeerASN)
			delete(rawMsg, key)
		case "primaryIpv4Prefix":
			err = unpopulate(val, "PrimaryIPv4Prefix", &e.PrimaryIPv4Prefix)
			delete(rawMsg, key)
		case "primaryIpv6Prefix":
			err = unpopulate(val, "PrimaryIPv6Prefix", &e.PrimaryIPv6Prefix)
			delete(rawMsg, key)
		case "secondaryIpv4Prefix":
			err = unpopulate(val, "SecondaryIPv4Prefix", &e.SecondaryIPv4Prefix)
			delete(rawMsg, key)
		case "secondaryIpv6Prefix":
			err = unpopulate(val, "SecondaryIPv6Prefix", &e.SecondaryIPv6Prefix)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &e.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalNetworksList.
func (e ExternalNetworksList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalNetworksList.
func (e *ExternalNetworksList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricBfdConfiguration.
func (f FabricBfdConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interval", f.Interval)
	populate(objectMap, "multiplier", f.Multiplier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricBfdConfiguration.
func (f *FabricBfdConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interval":
			err = unpopulate(val, "Interval", &f.Interval)
			delete(rawMsg, key)
		case "multiplier":
			err = unpopulate(val, "Multiplier", &f.Multiplier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetDeviceStatusProperties.
func (g GetDeviceStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "operationalStatus", g.OperationalStatus)
	populate(objectMap, "powerCycleState", g.PowerCycleState)
	populate(objectMap, "serialNumber", g.SerialNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetDeviceStatusProperties.
func (g *GetDeviceStatusProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "operationalStatus":
			err = unpopulate(val, "OperationalStatus", &g.OperationalStatus)
			delete(rawMsg, key)
		case "powerCycleState":
			err = unpopulate(val, "PowerCycleState", &g.PowerCycleState)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &g.SerialNumber)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetDynamicInterfaceMapsPropertiesItem.
func (g GetDynamicInterfaceMapsPropertiesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", g.AdministrativeState)
	populate(objectMap, "connectedTo", g.ConnectedTo)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "operationalStatus", g.OperationalStatus)
	populate(objectMap, "phyStatus", g.PhyStatus)
	populate(objectMap, "transceiverStatus", g.TransceiverStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetDynamicInterfaceMapsPropertiesItem.
func (g *GetDynamicInterfaceMapsPropertiesItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &g.AdministrativeState)
			delete(rawMsg, key)
		case "connectedTo":
			err = unpopulate(val, "ConnectedTo", &g.ConnectedTo)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "operationalStatus":
			err = unpopulate(val, "OperationalStatus", &g.OperationalStatus)
			delete(rawMsg, key)
		case "phyStatus":
			err = unpopulate(val, "PhyStatus", &g.PhyStatus)
			delete(rawMsg, key)
		case "transceiverStatus":
			err = unpopulate(val, "TransceiverStatus", &g.TransceiverStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetStaticInterfaceMapsPropertiesItem.
func (g GetStaticInterfaceMapsPropertiesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "channelGroupId", g.ChannelGroupID)
	populate(objectMap, "connectedTo", g.ConnectedTo)
	populate(objectMap, "connectorType", g.ConnectorType)
	populate(objectMap, "description", g.Description)
	populate(objectMap, "identifier", g.Identifier)
	populate(objectMap, "interfaceType", g.InterfaceType)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "speed", g.Speed)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetStaticInterfaceMapsPropertiesItem.
func (g *GetStaticInterfaceMapsPropertiesItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelGroupId":
			err = unpopulate(val, "ChannelGroupID", &g.ChannelGroupID)
			delete(rawMsg, key)
		case "connectedTo":
			err = unpopulate(val, "ConnectedTo", &g.ConnectedTo)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &g.ConnectorType)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &g.Description)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, "Identifier", &g.Identifier)
			delete(rawMsg, key)
		case "interfaceType":
			err = unpopulate(val, "InterfaceType", &g.InterfaceType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "speed":
			err = unpopulate(val, "Speed", &g.Speed)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPCommunitiesListResult.
func (i IPCommunitiesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPCommunitiesListResult.
func (i *IPCommunitiesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPCommunity.
func (i IPCommunity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPCommunity.
func (i *IPCommunity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPCommunityIDList.
func (i IPCommunityIDList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipCommunityIds", i.IPCommunityIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPCommunityIDList.
func (i *IPCommunityIDList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipCommunityIds":
			err = unpopulate(val, "IPCommunityIDs", &i.IPCommunityIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPCommunityPatch.
func (i IPCommunityPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", i.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPCommunityPatch.
func (i *IPCommunityPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPCommunityProperties.
func (i IPCommunityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", i.Action)
	populate(objectMap, "annotation", i.Annotation)
	populate(objectMap, "communityMembers", i.CommunityMembers)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "wellKnownCommunities", i.WellKnownCommunities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPCommunityProperties.
func (i *IPCommunityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &i.Action)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &i.Annotation)
			delete(rawMsg, key)
		case "communityMembers":
			err = unpopulate(val, "CommunityMembers", &i.CommunityMembers)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		case "wellKnownCommunities":
			err = unpopulate(val, "WellKnownCommunities", &i.WellKnownCommunities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPExtendedCommunity.
func (i IPExtendedCommunity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPExtendedCommunity.
func (i *IPExtendedCommunity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPExtendedCommunityIDList.
func (i IPExtendedCommunityIDList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipExtendedCommunityIds", i.IPExtendedCommunityIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPExtendedCommunityIDList.
func (i *IPExtendedCommunityIDList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipExtendedCommunityIds":
			err = unpopulate(val, "IPExtendedCommunityIDs", &i.IPExtendedCommunityIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPExtendedCommunityListResult.
func (i IPExtendedCommunityListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPExtendedCommunityListResult.
func (i *IPExtendedCommunityListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPExtendedCommunityPatch.
func (i IPExtendedCommunityPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", i.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPExtendedCommunityPatch.
func (i *IPExtendedCommunityPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPExtendedCommunityProperties.
func (i IPExtendedCommunityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", i.Action)
	populate(objectMap, "annotation", i.Annotation)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "routeTargets", i.RouteTargets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPExtendedCommunityProperties.
func (i *IPExtendedCommunityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &i.Action)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &i.Annotation)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		case "routeTargets":
			err = unpopulate(val, "RouteTargets", &i.RouteTargets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPPrefix.
func (i IPPrefix) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPPrefix.
func (i *IPPrefix) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &i.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPPrefixPatch.
func (i IPPrefixPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", i.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPPrefixPatch.
func (i *IPPrefixPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPPrefixProperties.
func (i IPPrefixProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", i.Annotation)
	populate(objectMap, "ipPrefixRules", i.IPPrefixRules)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPPrefixProperties.
func (i *IPPrefixProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &i.Annotation)
			delete(rawMsg, key)
		case "ipPrefixRules":
			err = unpopulate(val, "IPPrefixRules", &i.IPPrefixRules)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPPrefixPropertiesIPPrefixRulesItem.
func (i IPPrefixPropertiesIPPrefixRulesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", i.Action)
	populate(objectMap, "condition", i.Condition)
	populate(objectMap, "networkPrefix", i.NetworkPrefix)
	populate(objectMap, "sequenceNumber", i.SequenceNumber)
	populate(objectMap, "subnetMaskLength", i.SubnetMaskLength)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPPrefixPropertiesIPPrefixRulesItem.
func (i *IPPrefixPropertiesIPPrefixRulesItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &i.Action)
			delete(rawMsg, key)
		case "condition":
			err = unpopulate(val, "Condition", &i.Condition)
			delete(rawMsg, key)
		case "networkPrefix":
			err = unpopulate(val, "NetworkPrefix", &i.NetworkPrefix)
			delete(rawMsg, key)
		case "sequenceNumber":
			err = unpopulate(val, "SequenceNumber", &i.SequenceNumber)
			delete(rawMsg, key)
		case "subnetMaskLength":
			err = unpopulate(val, "SubnetMaskLength", &i.SubnetMaskLength)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPPrefixesListResult.
func (i IPPrefixesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPPrefixesListResult.
func (i *IPPrefixesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InfrastructureServices.
func (i InfrastructureServices) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4AddressSpaces", i.IPv4AddressSpaces)
	populate(objectMap, "ipv6AddressSpaces", i.IPv6AddressSpaces)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InfrastructureServices.
func (i *InfrastructureServices) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4AddressSpaces":
			err = unpopulate(val, "IPv4AddressSpaces", &i.IPv4AddressSpaces)
			delete(rawMsg, key)
		case "ipv6AddressSpaces":
			err = unpopulate(val, "IPv6AddressSpaces", &i.IPv6AddressSpaces)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InterfaceStatus.
func (i InterfaceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", i.AdministrativeState)
	populate(objectMap, "connectedTo", i.ConnectedTo)
	populate(objectMap, "operationalStatus", i.OperationalStatus)
	populate(objectMap, "phyStatus", i.PhyStatus)
	populate(objectMap, "transceiverStatus", i.TransceiverStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InterfaceStatus.
func (i *InterfaceStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &i.AdministrativeState)
			delete(rawMsg, key)
		case "connectedTo":
			err = unpopulate(val, "ConnectedTo", &i.ConnectedTo)
			delete(rawMsg, key)
		case "operationalStatus":
			err = unpopulate(val, "OperationalStatus", &i.OperationalStatus)
			delete(rawMsg, key)
		case "phyStatus":
			err = unpopulate(val, "PhyStatus", &i.PhyStatus)
			delete(rawMsg, key)
		case "transceiverStatus":
			err = unpopulate(val, "TransceiverStatus", &i.TransceiverStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InternalNetwork.
func (i InternalNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InternalNetwork.
func (i *InternalNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InternalNetworkPatch.
func (i InternalNetworkPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InternalNetworkPatch.
func (i *InternalNetworkPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InternalNetworkPatchProperties.
func (i InternalNetworkPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", i.Annotation)
	populate(objectMap, "bgpConfiguration", i.BgpConfiguration)
	populate(objectMap, "connectedIPv4Subnets", i.ConnectedIPv4Subnets)
	populate(objectMap, "connectedIPv6Subnets", i.ConnectedIPv6Subnets)
	populate(objectMap, "exportRoutePolicyId", i.ExportRoutePolicyID)
	populate(objectMap, "importRoutePolicyId", i.ImportRoutePolicyID)
	populate(objectMap, "mtu", i.Mtu)
	populate(objectMap, "staticRouteConfiguration", i.StaticRouteConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InternalNetworkPatchProperties.
func (i *InternalNetworkPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &i.Annotation)
			delete(rawMsg, key)
		case "bgpConfiguration":
			err = unpopulate(val, "BgpConfiguration", &i.BgpConfiguration)
			delete(rawMsg, key)
		case "connectedIPv4Subnets":
			err = unpopulate(val, "ConnectedIPv4Subnets", &i.ConnectedIPv4Subnets)
			delete(rawMsg, key)
		case "connectedIPv6Subnets":
			err = unpopulate(val, "ConnectedIPv6Subnets", &i.ConnectedIPv6Subnets)
			delete(rawMsg, key)
		case "exportRoutePolicyId":
			err = unpopulate(val, "ExportRoutePolicyID", &i.ExportRoutePolicyID)
			delete(rawMsg, key)
		case "importRoutePolicyId":
			err = unpopulate(val, "ImportRoutePolicyID", &i.ImportRoutePolicyID)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &i.Mtu)
			delete(rawMsg, key)
		case "staticRouteConfiguration":
			err = unpopulate(val, "StaticRouteConfiguration", &i.StaticRouteConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InternalNetworkProperties.
func (i InternalNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", i.AdministrativeState)
	populate(objectMap, "annotation", i.Annotation)
	populate(objectMap, "bfdDisabledOnResources", i.BfdDisabledOnResources)
	populate(objectMap, "bfdForStaticRoutesDisabledOnResources", i.BfdForStaticRoutesDisabledOnResources)
	populate(objectMap, "bgpConfiguration", i.BgpConfiguration)
	populate(objectMap, "bgpDisabledOnResources", i.BgpDisabledOnResources)
	populate(objectMap, "connectedIPv4Subnets", i.ConnectedIPv4Subnets)
	populate(objectMap, "connectedIPv6Subnets", i.ConnectedIPv6Subnets)
	populate(objectMap, "disabledOnResources", i.DisabledOnResources)
	populate(objectMap, "exportRoutePolicyId", i.ExportRoutePolicyID)
	populate(objectMap, "importRoutePolicyId", i.ImportRoutePolicyID)
	populate(objectMap, "mtu", i.Mtu)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "staticRouteConfiguration", i.StaticRouteConfiguration)
	populate(objectMap, "vlanId", i.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InternalNetworkProperties.
func (i *InternalNetworkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &i.AdministrativeState)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &i.Annotation)
			delete(rawMsg, key)
		case "bfdDisabledOnResources":
			err = unpopulate(val, "BfdDisabledOnResources", &i.BfdDisabledOnResources)
			delete(rawMsg, key)
		case "bfdForStaticRoutesDisabledOnResources":
			err = unpopulate(val, "BfdForStaticRoutesDisabledOnResources", &i.BfdForStaticRoutesDisabledOnResources)
			delete(rawMsg, key)
		case "bgpConfiguration":
			err = unpopulate(val, "BgpConfiguration", &i.BgpConfiguration)
			delete(rawMsg, key)
		case "bgpDisabledOnResources":
			err = unpopulate(val, "BgpDisabledOnResources", &i.BgpDisabledOnResources)
			delete(rawMsg, key)
		case "connectedIPv4Subnets":
			err = unpopulate(val, "ConnectedIPv4Subnets", &i.ConnectedIPv4Subnets)
			delete(rawMsg, key)
		case "connectedIPv6Subnets":
			err = unpopulate(val, "ConnectedIPv6Subnets", &i.ConnectedIPv6Subnets)
			delete(rawMsg, key)
		case "disabledOnResources":
			err = unpopulate(val, "DisabledOnResources", &i.DisabledOnResources)
			delete(rawMsg, key)
		case "exportRoutePolicyId":
			err = unpopulate(val, "ExportRoutePolicyID", &i.ExportRoutePolicyID)
			delete(rawMsg, key)
		case "importRoutePolicyId":
			err = unpopulate(val, "ImportRoutePolicyID", &i.ImportRoutePolicyID)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &i.Mtu)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		case "staticRouteConfiguration":
			err = unpopulate(val, "StaticRouteConfiguration", &i.StaticRouteConfiguration)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &i.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InternalNetworksList.
func (i InternalNetworksList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InternalNetworksList.
func (i *InternalNetworksList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L2IsolationDomain.
func (l L2IsolationDomain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L2IsolationDomain.
func (l *L2IsolationDomain) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &l.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &l.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &l.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &l.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &l.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L2IsolationDomainPatch.
func (l L2IsolationDomainPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L2IsolationDomainPatch.
func (l *L2IsolationDomainPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &l.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &l.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L2IsolationDomainPatchProperties.
func (l L2IsolationDomainPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", l.Annotation)
	populate(objectMap, "mtu", l.Mtu)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L2IsolationDomainPatchProperties.
func (l *L2IsolationDomainPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &l.Annotation)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &l.Mtu)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L2IsolationDomainProperties.
func (l L2IsolationDomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", l.AdministrativeState)
	populate(objectMap, "annotation", l.Annotation)
	populate(objectMap, "disabledOnResources", l.DisabledOnResources)
	populate(objectMap, "mtu", l.Mtu)
	populate(objectMap, "networkFabricId", l.NetworkFabricID)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "vlanId", l.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L2IsolationDomainProperties.
func (l *L2IsolationDomainProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &l.AdministrativeState)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &l.Annotation)
			delete(rawMsg, key)
		case "disabledOnResources":
			err = unpopulate(val, "DisabledOnResources", &l.DisabledOnResources)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &l.Mtu)
			delete(rawMsg, key)
		case "networkFabricId":
			err = unpopulate(val, "NetworkFabricID", &l.NetworkFabricID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &l.ProvisioningState)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &l.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L2IsolationDomainsListResult.
func (l L2IsolationDomainsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L2IsolationDomainsListResult.
func (l *L2IsolationDomainsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &l.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L3IsolationDomain.
func (l L3IsolationDomain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L3IsolationDomain.
func (l *L3IsolationDomain) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &l.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &l.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &l.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &l.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &l.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L3IsolationDomainPatch.
func (l L3IsolationDomainPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L3IsolationDomainPatch.
func (l *L3IsolationDomainPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &l.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &l.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L3IsolationDomainPatchProperties.
func (l L3IsolationDomainPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aggregateRouteConfiguration", l.AggregateRouteConfiguration)
	populate(objectMap, "connectedSubnetRoutePolicy", l.ConnectedSubnetRoutePolicy)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "redistributeConnectedSubnets", l.RedistributeConnectedSubnets)
	populate(objectMap, "redistributeStaticRoutes", l.RedistributeStaticRoutes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L3IsolationDomainPatchProperties.
func (l *L3IsolationDomainPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregateRouteConfiguration":
			err = unpopulate(val, "AggregateRouteConfiguration", &l.AggregateRouteConfiguration)
			delete(rawMsg, key)
		case "connectedSubnetRoutePolicy":
			err = unpopulate(val, "ConnectedSubnetRoutePolicy", &l.ConnectedSubnetRoutePolicy)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "redistributeConnectedSubnets":
			err = unpopulate(val, "RedistributeConnectedSubnets", &l.RedistributeConnectedSubnets)
			delete(rawMsg, key)
		case "redistributeStaticRoutes":
			err = unpopulate(val, "RedistributeStaticRoutes", &l.RedistributeStaticRoutes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy.
func (l L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", l.AdministrativeState)
	populate(objectMap, "exportRoutePolicyId", l.ExportRoutePolicyID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy.
func (l *L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &l.AdministrativeState)
			delete(rawMsg, key)
		case "exportRoutePolicyId":
			err = unpopulate(val, "ExportRoutePolicyID", &l.ExportRoutePolicyID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L3IsolationDomainProperties.
func (l L3IsolationDomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", l.AdministrativeState)
	populate(objectMap, "aggregateRouteConfiguration", l.AggregateRouteConfiguration)
	populate(objectMap, "annotation", l.Annotation)
	populate(objectMap, "connectedSubnetRoutePolicy", l.ConnectedSubnetRoutePolicy)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "disabledOnResources", l.DisabledOnResources)
	populate(objectMap, "networkFabricId", l.NetworkFabricID)
	populate(objectMap, "optionBDisabledOnResources", l.OptionBDisabledOnResources)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "redistributeConnectedSubnets", l.RedistributeConnectedSubnets)
	populate(objectMap, "redistributeStaticRoutes", l.RedistributeStaticRoutes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L3IsolationDomainProperties.
func (l *L3IsolationDomainProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &l.AdministrativeState)
			delete(rawMsg, key)
		case "aggregateRouteConfiguration":
			err = unpopulate(val, "AggregateRouteConfiguration", &l.AggregateRouteConfiguration)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &l.Annotation)
			delete(rawMsg, key)
		case "connectedSubnetRoutePolicy":
			err = unpopulate(val, "ConnectedSubnetRoutePolicy", &l.ConnectedSubnetRoutePolicy)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "disabledOnResources":
			err = unpopulate(val, "DisabledOnResources", &l.DisabledOnResources)
			delete(rawMsg, key)
		case "networkFabricId":
			err = unpopulate(val, "NetworkFabricID", &l.NetworkFabricID)
			delete(rawMsg, key)
		case "optionBDisabledOnResources":
			err = unpopulate(val, "OptionBDisabledOnResources", &l.OptionBDisabledOnResources)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &l.ProvisioningState)
			delete(rawMsg, key)
		case "redistributeConnectedSubnets":
			err = unpopulate(val, "RedistributeConnectedSubnets", &l.RedistributeConnectedSubnets)
			delete(rawMsg, key)
		case "redistributeStaticRoutes":
			err = unpopulate(val, "RedistributeStaticRoutes", &l.RedistributeStaticRoutes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type L3IsolationDomainsListResult.
func (l L3IsolationDomainsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type L3IsolationDomainsListResult.
func (l *L3IsolationDomainsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &l.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Layer2Configuration.
func (l Layer2Configuration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interfaces", l.Interfaces)
	populate(objectMap, "mtu", l.Mtu)
	populate(objectMap, "portCount", l.PortCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Layer2Configuration.
func (l *Layer2Configuration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interfaces":
			err = unpopulate(val, "Interfaces", &l.Interfaces)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &l.Mtu)
			delete(rawMsg, key)
		case "portCount":
			err = unpopulate(val, "PortCount", &l.PortCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Layer3Configuration.
func (l Layer3Configuration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exportRoutePolicyId", l.ExportRoutePolicyID)
	populate(objectMap, "fabricASN", l.FabricASN)
	populate(objectMap, "importRoutePolicyId", l.ImportRoutePolicyID)
	populate(objectMap, "peerASN", l.PeerASN)
	populate(objectMap, "primaryIpv4Prefix", l.PrimaryIPv4Prefix)
	populate(objectMap, "primaryIpv6Prefix", l.PrimaryIPv6Prefix)
	populate(objectMap, "secondaryIpv4Prefix", l.SecondaryIPv4Prefix)
	populate(objectMap, "secondaryIpv6Prefix", l.SecondaryIPv6Prefix)
	populate(objectMap, "vlanId", l.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Layer3Configuration.
func (l *Layer3Configuration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exportRoutePolicyId":
			err = unpopulate(val, "ExportRoutePolicyID", &l.ExportRoutePolicyID)
			delete(rawMsg, key)
		case "fabricASN":
			err = unpopulate(val, "FabricASN", &l.FabricASN)
			delete(rawMsg, key)
		case "importRoutePolicyId":
			err = unpopulate(val, "ImportRoutePolicyID", &l.ImportRoutePolicyID)
			delete(rawMsg, key)
		case "peerASN":
			err = unpopulate(val, "PeerASN", &l.PeerASN)
			delete(rawMsg, key)
		case "primaryIpv4Prefix":
			err = unpopulate(val, "PrimaryIPv4Prefix", &l.PrimaryIPv4Prefix)
			delete(rawMsg, key)
		case "primaryIpv6Prefix":
			err = unpopulate(val, "PrimaryIPv6Prefix", &l.PrimaryIPv6Prefix)
			delete(rawMsg, key)
		case "secondaryIpv4Prefix":
			err = unpopulate(val, "SecondaryIPv4Prefix", &l.SecondaryIPv4Prefix)
			delete(rawMsg, key)
		case "secondaryIpv6Prefix":
			err = unpopulate(val, "SecondaryIPv6Prefix", &l.SecondaryIPv6Prefix)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &l.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Layer3OptionAProperties.
func (l Layer3OptionAProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bfdConfiguration", l.BfdConfiguration)
	populate(objectMap, "fabricASN", l.FabricASN)
	populate(objectMap, "mtu", l.Mtu)
	populate(objectMap, "peerASN", l.PeerASN)
	populate(objectMap, "primaryIpv4Prefix", l.PrimaryIPv4Prefix)
	populate(objectMap, "primaryIpv6Prefix", l.PrimaryIPv6Prefix)
	populate(objectMap, "secondaryIpv4Prefix", l.SecondaryIPv4Prefix)
	populate(objectMap, "secondaryIpv6Prefix", l.SecondaryIPv6Prefix)
	populate(objectMap, "vlanId", l.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Layer3OptionAProperties.
func (l *Layer3OptionAProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bfdConfiguration":
			err = unpopulate(val, "BfdConfiguration", &l.BfdConfiguration)
			delete(rawMsg, key)
		case "fabricASN":
			err = unpopulate(val, "FabricASN", &l.FabricASN)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &l.Mtu)
			delete(rawMsg, key)
		case "peerASN":
			err = unpopulate(val, "PeerASN", &l.PeerASN)
			delete(rawMsg, key)
		case "primaryIpv4Prefix":
			err = unpopulate(val, "PrimaryIPv4Prefix", &l.PrimaryIPv4Prefix)
			delete(rawMsg, key)
		case "primaryIpv6Prefix":
			err = unpopulate(val, "PrimaryIPv6Prefix", &l.PrimaryIPv6Prefix)
			delete(rawMsg, key)
		case "secondaryIpv4Prefix":
			err = unpopulate(val, "SecondaryIPv4Prefix", &l.SecondaryIPv4Prefix)
			delete(rawMsg, key)
		case "secondaryIpv6Prefix":
			err = unpopulate(val, "SecondaryIPv6Prefix", &l.SecondaryIPv6Prefix)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &l.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedResourceGroupConfiguration.
func (m ManagedResourceGroupConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedResourceGroupConfiguration.
func (m *ManagedResourceGroupConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementNetworkConfiguration.
func (m ManagementNetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "infrastructureVpnConfiguration", m.InfrastructureVPNConfiguration)
	populate(objectMap, "workloadVpnConfiguration", m.WorkloadVPNConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementNetworkConfiguration.
func (m *ManagementNetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "infrastructureVpnConfiguration":
			err = unpopulate(val, "InfrastructureVPNConfiguration", &m.InfrastructureVPNConfiguration)
			delete(rawMsg, key)
		case "workloadVpnConfiguration":
			err = unpopulate(val, "WorkloadVPNConfiguration", &m.WorkloadVPNConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NeighborAddress.
func (n NeighborAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "address", n.Address)
	populate(objectMap, "operationalState", n.OperationalState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NeighborAddress.
func (n *NeighborAddress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "address":
			err = unpopulate(val, "Address", &n.Address)
			delete(rawMsg, key)
		case "operationalState":
			err = unpopulate(val, "OperationalState", &n.OperationalState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDevice.
func (n NetworkDevice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "location", n.Location)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDevice.
func (n *NetworkDevice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &n.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDevicePatchParameters.
func (n NetworkDevicePatchParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "tags", n.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDevicePatchParameters.
func (n *NetworkDevicePatchParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDevicePatchParametersProperties.
func (n NetworkDevicePatchParametersProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "hostName", n.HostName)
	populate(objectMap, "serialNumber", n.SerialNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDevicePatchParametersProperties.
func (n *NetworkDevicePatchParametersProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &n.HostName)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &n.SerialNumber)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDeviceProperties.
func (n NetworkDeviceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "hostName", n.HostName)
	populate(objectMap, "networkDeviceRole", n.NetworkDeviceRole)
	populate(objectMap, "networkDeviceSku", n.NetworkDeviceSKU)
	populate(objectMap, "networkRackId", n.NetworkRackID)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "serialNumber", n.SerialNumber)
	populate(objectMap, "version", n.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDeviceProperties.
func (n *NetworkDeviceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &n.HostName)
			delete(rawMsg, key)
		case "networkDeviceRole":
			err = unpopulate(val, "NetworkDeviceRole", &n.NetworkDeviceRole)
			delete(rawMsg, key)
		case "networkDeviceSku":
			err = unpopulate(val, "NetworkDeviceSKU", &n.NetworkDeviceSKU)
			delete(rawMsg, key)
		case "networkRackId":
			err = unpopulate(val, "NetworkRackID", &n.NetworkRackID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &n.SerialNumber)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &n.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDeviceRoleProperties.
func (n NetworkDeviceRoleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "networkDeviceSkuName", n.NetworkDeviceSKUName)
	populate(objectMap, "rackSlot", n.RackSlot)
	populate(objectMap, "roleType", n.RoleType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDeviceRoleProperties.
func (n *NetworkDeviceRoleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "networkDeviceSkuName":
			err = unpopulate(val, "NetworkDeviceSKUName", &n.NetworkDeviceSKUName)
			delete(rawMsg, key)
		case "rackSlot":
			err = unpopulate(val, "RackSlot", &n.RackSlot)
			delete(rawMsg, key)
		case "roleType":
			err = unpopulate(val, "RoleType", &n.RoleType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDeviceSKU.
func (n NetworkDeviceSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDeviceSKU.
func (n *NetworkDeviceSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDeviceSKUProperties.
func (n NetworkDeviceSKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interfaces", n.Interfaces)
	populate(objectMap, "limits", n.Limits)
	populate(objectMap, "manufacturer", n.Manufacturer)
	populate(objectMap, "model", n.Model)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "supportedRoleTypes", n.SupportedRoleTypes)
	populate(objectMap, "supportedVersions", n.SupportedVersions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDeviceSKUProperties.
func (n *NetworkDeviceSKUProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interfaces":
			err = unpopulate(val, "Interfaces", &n.Interfaces)
			delete(rawMsg, key)
		case "limits":
			err = unpopulate(val, "Limits", &n.Limits)
			delete(rawMsg, key)
		case "manufacturer":
			err = unpopulate(val, "Manufacturer", &n.Manufacturer)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &n.Model)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "supportedRoleTypes":
			err = unpopulate(val, "SupportedRoleTypes", &n.SupportedRoleTypes)
			delete(rawMsg, key)
		case "supportedVersions":
			err = unpopulate(val, "SupportedVersions", &n.SupportedVersions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDeviceSKUsListResult.
func (n NetworkDeviceSKUsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDeviceSKUsListResult.
func (n *NetworkDeviceSKUsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkDevicesListResult.
func (n NetworkDevicesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkDevicesListResult.
func (n *NetworkDevicesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabric.
func (n NetworkFabric) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "location", n.Location)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabric.
func (n *NetworkFabric) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &n.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricController.
func (n NetworkFabricController) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "location", n.Location)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricController.
func (n *NetworkFabricController) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &n.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricControllerPatch.
func (n NetworkFabricControllerPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "tags", n.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricControllerPatch.
func (n *NetworkFabricControllerPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricControllerPatchableProperties.
func (n NetworkFabricControllerPatchableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "infrastructureExpressRouteConnections", n.InfrastructureExpressRouteConnections)
	populate(objectMap, "workloadExpressRouteConnections", n.WorkloadExpressRouteConnections)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricControllerPatchableProperties.
func (n *NetworkFabricControllerPatchableProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "infrastructureExpressRouteConnections":
			err = unpopulate(val, "InfrastructureExpressRouteConnections", &n.InfrastructureExpressRouteConnections)
			delete(rawMsg, key)
		case "workloadExpressRouteConnections":
			err = unpopulate(val, "WorkloadExpressRouteConnections", &n.WorkloadExpressRouteConnections)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricControllerProperties.
func (n NetworkFabricControllerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "ipv4AddressSpace", n.IPv4AddressSpace)
	populate(objectMap, "ipv6AddressSpace", n.IPv6AddressSpace)
	populate(objectMap, "infrastructureExpressRouteConnections", n.InfrastructureExpressRouteConnections)
	populate(objectMap, "infrastructureServices", n.InfrastructureServices)
	populate(objectMap, "managedResourceGroupConfiguration", n.ManagedResourceGroupConfiguration)
	populate(objectMap, "networkFabricIds", n.NetworkFabricIDs)
	populate(objectMap, "operationalState", n.OperationalState)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "workloadExpressRouteConnections", n.WorkloadExpressRouteConnections)
	populate(objectMap, "workloadManagementNetwork", n.WorkloadManagementNetwork)
	populate(objectMap, "workloadServices", n.WorkloadServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricControllerProperties.
func (n *NetworkFabricControllerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "ipv4AddressSpace":
			err = unpopulate(val, "IPv4AddressSpace", &n.IPv4AddressSpace)
			delete(rawMsg, key)
		case "ipv6AddressSpace":
			err = unpopulate(val, "IPv6AddressSpace", &n.IPv6AddressSpace)
			delete(rawMsg, key)
		case "infrastructureExpressRouteConnections":
			err = unpopulate(val, "InfrastructureExpressRouteConnections", &n.InfrastructureExpressRouteConnections)
			delete(rawMsg, key)
		case "infrastructureServices":
			err = unpopulate(val, "InfrastructureServices", &n.InfrastructureServices)
			delete(rawMsg, key)
		case "managedResourceGroupConfiguration":
			err = unpopulate(val, "ManagedResourceGroupConfiguration", &n.ManagedResourceGroupConfiguration)
			delete(rawMsg, key)
		case "networkFabricIds":
			err = unpopulate(val, "NetworkFabricIDs", &n.NetworkFabricIDs)
			delete(rawMsg, key)
		case "operationalState":
			err = unpopulate(val, "OperationalState", &n.OperationalState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "workloadExpressRouteConnections":
			err = unpopulate(val, "WorkloadExpressRouteConnections", &n.WorkloadExpressRouteConnections)
			delete(rawMsg, key)
		case "workloadManagementNetwork":
			err = unpopulate(val, "WorkloadManagementNetwork", &n.WorkloadManagementNetwork)
			delete(rawMsg, key)
		case "workloadServices":
			err = unpopulate(val, "WorkloadServices", &n.WorkloadServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricControllersListResult.
func (n NetworkFabricControllersListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricControllersListResult.
func (n *NetworkFabricControllersListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricPatchParameters.
func (n NetworkFabricPatchParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "tags", n.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricPatchParameters.
func (n *NetworkFabricPatchParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricPatchParametersProperties.
func (n NetworkFabricPatchParametersProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "l2IsolationDomains", n.L2IsolationDomains)
	populate(objectMap, "l3IsolationDomains", n.L3IsolationDomains)
	populate(objectMap, "racks", n.Racks)
	populate(objectMap, "terminalServerConfiguration", n.TerminalServerConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricPatchParametersProperties.
func (n *NetworkFabricPatchParametersProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "l2IsolationDomains":
			err = unpopulate(val, "L2IsolationDomains", &n.L2IsolationDomains)
			delete(rawMsg, key)
		case "l3IsolationDomains":
			err = unpopulate(val, "L3IsolationDomains", &n.L3IsolationDomains)
			delete(rawMsg, key)
		case "racks":
			err = unpopulate(val, "Racks", &n.Racks)
			delete(rawMsg, key)
		case "terminalServerConfiguration":
			err = unpopulate(val, "TerminalServerConfiguration", &n.TerminalServerConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricProperties.
func (n NetworkFabricProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "fabricASN", n.FabricASN)
	populate(objectMap, "ipv4Prefix", n.IPv4Prefix)
	populate(objectMap, "ipv6Prefix", n.IPv6Prefix)
	populate(objectMap, "l2IsolationDomains", n.L2IsolationDomains)
	populate(objectMap, "l3IsolationDomains", n.L3IsolationDomains)
	populate(objectMap, "managementNetworkConfiguration", n.ManagementNetworkConfiguration)
	populate(objectMap, "networkFabricControllerId", n.NetworkFabricControllerID)
	populate(objectMap, "networkFabricSku", n.NetworkFabricSKU)
	populate(objectMap, "operationalState", n.OperationalState)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "rackCount", n.RackCount)
	populate(objectMap, "racks", n.Racks)
	populate(objectMap, "routerId", n.RouterID)
	populate(objectMap, "serverCountPerRack", n.ServerCountPerRack)
	populate(objectMap, "terminalServerConfiguration", n.TerminalServerConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricProperties.
func (n *NetworkFabricProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "fabricASN":
			err = unpopulate(val, "FabricASN", &n.FabricASN)
			delete(rawMsg, key)
		case "ipv4Prefix":
			err = unpopulate(val, "IPv4Prefix", &n.IPv4Prefix)
			delete(rawMsg, key)
		case "ipv6Prefix":
			err = unpopulate(val, "IPv6Prefix", &n.IPv6Prefix)
			delete(rawMsg, key)
		case "l2IsolationDomains":
			err = unpopulate(val, "L2IsolationDomains", &n.L2IsolationDomains)
			delete(rawMsg, key)
		case "l3IsolationDomains":
			err = unpopulate(val, "L3IsolationDomains", &n.L3IsolationDomains)
			delete(rawMsg, key)
		case "managementNetworkConfiguration":
			err = unpopulate(val, "ManagementNetworkConfiguration", &n.ManagementNetworkConfiguration)
			delete(rawMsg, key)
		case "networkFabricControllerId":
			err = unpopulate(val, "NetworkFabricControllerID", &n.NetworkFabricControllerID)
			delete(rawMsg, key)
		case "networkFabricSku":
			err = unpopulate(val, "NetworkFabricSKU", &n.NetworkFabricSKU)
			delete(rawMsg, key)
		case "operationalState":
			err = unpopulate(val, "OperationalState", &n.OperationalState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "rackCount":
			err = unpopulate(val, "RackCount", &n.RackCount)
			delete(rawMsg, key)
		case "racks":
			err = unpopulate(val, "Racks", &n.Racks)
			delete(rawMsg, key)
		case "routerId":
			err = unpopulate(val, "RouterID", &n.RouterID)
			delete(rawMsg, key)
		case "serverCountPerRack":
			err = unpopulate(val, "ServerCountPerRack", &n.ServerCountPerRack)
			delete(rawMsg, key)
		case "terminalServerConfiguration":
			err = unpopulate(val, "TerminalServerConfiguration", &n.TerminalServerConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricSKU.
func (n NetworkFabricSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricSKU.
func (n *NetworkFabricSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricSKUProperties.
func (n NetworkFabricSKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detailsUri", n.DetailsURI)
	populate(objectMap, "maxComputeRacks", n.MaxComputeRacks)
	populate(objectMap, "maxSupportedVer", n.MaxSupportedVer)
	populate(objectMap, "minSupportedVer", n.MinSupportedVer)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricSKUProperties.
func (n *NetworkFabricSKUProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detailsUri":
			err = unpopulate(val, "DetailsURI", &n.DetailsURI)
			delete(rawMsg, key)
		case "maxComputeRacks":
			err = unpopulate(val, "MaxComputeRacks", &n.MaxComputeRacks)
			delete(rawMsg, key)
		case "maxSupportedVer":
			err = unpopulate(val, "MaxSupportedVer", &n.MaxSupportedVer)
			delete(rawMsg, key)
		case "minSupportedVer":
			err = unpopulate(val, "MinSupportedVer", &n.MinSupportedVer)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricSKUsListResult.
func (n NetworkFabricSKUsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricSKUsListResult.
func (n *NetworkFabricSKUsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkFabricsListResult.
func (n NetworkFabricsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkFabricsListResult.
func (n *NetworkFabricsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterface.
func (n NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterface.
func (n *NetworkInterface) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterfacePatch.
func (n NetworkInterfacePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", n.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterfacePatch.
func (n *NetworkInterfacePatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterfacePatchProperties.
func (n NetworkInterfacePatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterfacePatchProperties.
func (n *NetworkInterfacePatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterfaceProperties.
func (n NetworkInterfaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", n.AdministrativeState)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "connectedTo", n.ConnectedTo)
	populate(objectMap, "ipv4Address", n.IPv4Address)
	populate(objectMap, "ipv6Address", n.IPv6Address)
	populate(objectMap, "interfaceType", n.InterfaceType)
	populate(objectMap, "physicalIdentifier", n.PhysicalIdentifier)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterfaceProperties.
func (n *NetworkInterfaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &n.AdministrativeState)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "connectedTo":
			err = unpopulate(val, "ConnectedTo", &n.ConnectedTo)
			delete(rawMsg, key)
		case "ipv4Address":
			err = unpopulate(val, "IPv4Address", &n.IPv4Address)
			delete(rawMsg, key)
		case "ipv6Address":
			err = unpopulate(val, "IPv6Address", &n.IPv6Address)
			delete(rawMsg, key)
		case "interfaceType":
			err = unpopulate(val, "InterfaceType", &n.InterfaceType)
			delete(rawMsg, key)
		case "physicalIdentifier":
			err = unpopulate(val, "PhysicalIdentifier", &n.PhysicalIdentifier)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterfacesList.
func (n NetworkInterfacesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterfacesList.
func (n *NetworkInterfacesList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRack.
func (n NetworkRack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "location", n.Location)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRack.
func (n *NetworkRack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &n.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRackPatch.
func (n NetworkRackPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "properties", n.Properties)
	populate(objectMap, "tags", n.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRackPatch.
func (n *NetworkRackPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRackProperties.
func (n NetworkRackProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", n.Annotation)
	populate(objectMap, "networkDevices", n.NetworkDevices)
	populate(objectMap, "networkFabricId", n.NetworkFabricID)
	populate(objectMap, "networkRackSku", n.NetworkRackSKU)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRackProperties.
func (n *NetworkRackProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &n.Annotation)
			delete(rawMsg, key)
		case "networkDevices":
			err = unpopulate(val, "NetworkDevices", &n.NetworkDevices)
			delete(rawMsg, key)
		case "networkFabricId":
			err = unpopulate(val, "NetworkFabricID", &n.NetworkFabricID)
			delete(rawMsg, key)
		case "networkRackSku":
			err = unpopulate(val, "NetworkRackSKU", &n.NetworkRackSKU)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRackSKU.
func (n NetworkRackSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRackSKU.
func (n *NetworkRackSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRackSKUProperties.
func (n NetworkRackSKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maximumServerCount", n.MaximumServerCount)
	populate(objectMap, "maximumStorageCount", n.MaximumStorageCount)
	populate(objectMap, "maximumUplinks", n.MaximumUplinks)
	populate(objectMap, "networkDevices", n.NetworkDevices)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "roleName", n.RoleName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRackSKUProperties.
func (n *NetworkRackSKUProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maximumServerCount":
			err = unpopulate(val, "MaximumServerCount", &n.MaximumServerCount)
			delete(rawMsg, key)
		case "maximumStorageCount":
			err = unpopulate(val, "MaximumStorageCount", &n.MaximumStorageCount)
			delete(rawMsg, key)
		case "maximumUplinks":
			err = unpopulate(val, "MaximumUplinks", &n.MaximumUplinks)
			delete(rawMsg, key)
		case "networkDevices":
			err = unpopulate(val, "NetworkDevices", &n.NetworkDevices)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "roleName":
			err = unpopulate(val, "RoleName", &n.RoleName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRackSKUsListResult.
func (n NetworkRackSKUsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRackSKUsListResult.
func (n *NetworkRackSKUsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRacksListResult.
func (n NetworkRacksListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkRacksListResult.
func (n *NetworkRacksListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkToNetworkInterconnect.
func (n NetworkToNetworkInterconnect) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkToNetworkInterconnect.
func (n *NetworkToNetworkInterconnect) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkToNetworkInterconnectProperties.
func (n NetworkToNetworkInterconnectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", n.AdministrativeState)
	populate(objectMap, "isManagementType", n.IsManagementType)
	populate(objectMap, "layer2Configuration", n.Layer2Configuration)
	populate(objectMap, "layer3Configuration", n.Layer3Configuration)
	populate(objectMap, "nniType", n.NniType)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "useOptionB", n.UseOptionB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkToNetworkInterconnectProperties.
func (n *NetworkToNetworkInterconnectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &n.AdministrativeState)
			delete(rawMsg, key)
		case "isManagementType":
			err = unpopulate(val, "IsManagementType", &n.IsManagementType)
			delete(rawMsg, key)
		case "layer2Configuration":
			err = unpopulate(val, "Layer2Configuration", &n.Layer2Configuration)
			delete(rawMsg, key)
		case "layer3Configuration":
			err = unpopulate(val, "Layer3Configuration", &n.Layer3Configuration)
			delete(rawMsg, key)
		case "nniType":
			err = unpopulate(val, "NniType", &n.NniType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "useOptionB":
			err = unpopulate(val, "UseOptionB", &n.UseOptionB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkToNetworkInterconnectsList.
func (n NetworkToNetworkInterconnectsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkToNetworkInterconnectsList.
func (n *NetworkToNetworkInterconnectsList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OptionAProperties.
func (o OptionAProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bfdConfiguration", o.BfdConfiguration)
	populate(objectMap, "mtu", o.Mtu)
	populate(objectMap, "peerASN", o.PeerASN)
	populate(objectMap, "primaryIpv4Prefix", o.PrimaryIPv4Prefix)
	populate(objectMap, "primaryIpv6Prefix", o.PrimaryIPv6Prefix)
	populate(objectMap, "secondaryIpv4Prefix", o.SecondaryIPv4Prefix)
	populate(objectMap, "secondaryIpv6Prefix", o.SecondaryIPv6Prefix)
	populate(objectMap, "vlanId", o.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OptionAProperties.
func (o *OptionAProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bfdConfiguration":
			err = unpopulate(val, "BfdConfiguration", &o.BfdConfiguration)
			delete(rawMsg, key)
		case "mtu":
			err = unpopulate(val, "Mtu", &o.Mtu)
			delete(rawMsg, key)
		case "peerASN":
			err = unpopulate(val, "PeerASN", &o.PeerASN)
			delete(rawMsg, key)
		case "primaryIpv4Prefix":
			err = unpopulate(val, "PrimaryIPv4Prefix", &o.PrimaryIPv4Prefix)
			delete(rawMsg, key)
		case "primaryIpv6Prefix":
			err = unpopulate(val, "PrimaryIPv6Prefix", &o.PrimaryIPv6Prefix)
			delete(rawMsg, key)
		case "secondaryIpv4Prefix":
			err = unpopulate(val, "SecondaryIPv4Prefix", &o.SecondaryIPv4Prefix)
			delete(rawMsg, key)
		case "secondaryIpv6Prefix":
			err = unpopulate(val, "SecondaryIPv6Prefix", &o.SecondaryIPv6Prefix)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &o.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OptionBProperties.
func (o OptionBProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exportRouteTargets", o.ExportRouteTargets)
	populate(objectMap, "importRouteTargets", o.ImportRouteTargets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OptionBProperties.
func (o *OptionBProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exportRouteTargets":
			err = unpopulate(val, "ExportRouteTargets", &o.ExportRouteTargets)
			delete(rawMsg, key)
		case "importRouteTargets":
			err = unpopulate(val, "ImportRouteTargets", &o.ImportRouteTargets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OptionBPropertiesAutoGenerated.
func (o OptionBPropertiesAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exportRouteTargets", o.ExportRouteTargets)
	populate(objectMap, "importRouteTargets", o.ImportRouteTargets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OptionBPropertiesAutoGenerated.
func (o *OptionBPropertiesAutoGenerated) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exportRouteTargets":
			err = unpopulate(val, "ExportRouteTargets", &o.ExportRouteTargets)
			delete(rawMsg, key)
		case "importRouteTargets":
			err = unpopulate(val, "ImportRouteTargets", &o.ImportRouteTargets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RoutePoliciesListResult.
func (r RoutePoliciesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutePoliciesListResult.
func (r *RoutePoliciesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RoutePolicy.
func (r RoutePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutePolicy.
func (r *RoutePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &r.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RoutePolicyPatch.
func (r RoutePolicyPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutePolicyPatch.
func (r *RoutePolicyPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RoutePolicyProperties.
func (r RoutePolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotation", r.Annotation)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "statements", r.Statements)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutePolicyProperties.
func (r *RoutePolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotation":
			err = unpopulate(val, "Annotation", &r.Annotation)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &r.ProvisioningState)
			delete(rawMsg, key)
		case "statements":
			err = unpopulate(val, "Statements", &r.Statements)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RoutePolicyStatementProperties.
func (r RoutePolicyStatementProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", r.Action)
	populate(objectMap, "annotation", r.Annotation)
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "sequenceNumber", r.SequenceNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoutePolicyStatementProperties.
func (r *RoutePolicyStatementProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &r.Action)
			delete(rawMsg, key)
		case "annotation":
			err = unpopulate(val, "Annotation", &r.Annotation)
			delete(rawMsg, key)
		case "condition":
			err = unpopulate(val, "Condition", &r.Condition)
			delete(rawMsg, key)
		case "sequenceNumber":
			err = unpopulate(val, "SequenceNumber", &r.SequenceNumber)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StatementActionProperties.
func (s StatementActionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", s.ActionType)
	populate(objectMap, "ipCommunityProperties", s.IPCommunityProperties)
	populate(objectMap, "ipExtendedCommunityProperties", s.IPExtendedCommunityProperties)
	populate(objectMap, "localPreference", s.LocalPreference)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatementActionProperties.
func (s *StatementActionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &s.ActionType)
			delete(rawMsg, key)
		case "ipCommunityProperties":
			err = unpopulate(val, "IPCommunityProperties", &s.IPCommunityProperties)
			delete(rawMsg, key)
		case "ipExtendedCommunityProperties":
			err = unpopulate(val, "IPExtendedCommunityProperties", &s.IPExtendedCommunityProperties)
			delete(rawMsg, key)
		case "localPreference":
			err = unpopulate(val, "LocalPreference", &s.LocalPreference)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StatementConditionProperties.
func (s StatementConditionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipCommunityIds", s.IPCommunityIDs)
	populate(objectMap, "ipExtendedCommunityIds", s.IPExtendedCommunityIDs)
	populate(objectMap, "ipPrefixId", s.IPPrefixID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatementConditionProperties.
func (s *StatementConditionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipCommunityIds":
			err = unpopulate(val, "IPCommunityIDs", &s.IPCommunityIDs)
			delete(rawMsg, key)
		case "ipExtendedCommunityIds":
			err = unpopulate(val, "IPExtendedCommunityIDs", &s.IPExtendedCommunityIDs)
			delete(rawMsg, key)
		case "ipPrefixId":
			err = unpopulate(val, "IPPrefixID", &s.IPPrefixID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StaticRouteConfiguration.
func (s StaticRouteConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bfdConfiguration", s.BfdConfiguration)
	populate(objectMap, "ipv4Routes", s.IPv4Routes)
	populate(objectMap, "ipv6Routes", s.IPv6Routes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticRouteConfiguration.
func (s *StaticRouteConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bfdConfiguration":
			err = unpopulate(val, "BfdConfiguration", &s.BfdConfiguration)
			delete(rawMsg, key)
		case "ipv4Routes":
			err = unpopulate(val, "IPv4Routes", &s.IPv4Routes)
			delete(rawMsg, key)
		case "ipv6Routes":
			err = unpopulate(val, "IPv6Routes", &s.IPv6Routes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StaticRouteProperties.
func (s StaticRouteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextHop", s.NextHop)
	populate(objectMap, "prefix", s.Prefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticRouteProperties.
func (s *StaticRouteProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextHop":
			err = unpopulate(val, "NextHop", &s.NextHop)
			delete(rawMsg, key)
		case "prefix":
			err = unpopulate(val, "Prefix", &s.Prefix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SupportPackageProperties.
func (s SupportPackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "supportPackageURL", s.SupportPackageURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SupportPackageProperties.
func (s *SupportPackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "supportPackageURL":
			err = unpopulate(val, "SupportPackageURL", &s.SupportPackageURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SupportedConnectorProperties.
func (s SupportedConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectorType", s.ConnectorType)
	populate(objectMap, "maxSpeedInMbps", s.MaxSpeedInMbps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SupportedConnectorProperties.
func (s *SupportedConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &s.ConnectorType)
			delete(rawMsg, key)
		case "maxSpeedInMbps":
			err = unpopulate(val, "MaxSpeedInMbps", &s.MaxSpeedInMbps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SupportedVersionProperties.
func (s SupportedVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isCurrent", s.IsCurrent)
	populate(objectMap, "isTest", s.IsTest)
	populate(objectMap, "vendorFirmwareVersion", s.VendorFirmwareVersion)
	populate(objectMap, "vendorOsVersion", s.VendorOsVersion)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SupportedVersionProperties.
func (s *SupportedVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isCurrent":
			err = unpopulate(val, "IsCurrent", &s.IsCurrent)
			delete(rawMsg, key)
		case "isTest":
			err = unpopulate(val, "IsTest", &s.IsTest)
			delete(rawMsg, key)
		case "vendorFirmwareVersion":
			err = unpopulate(val, "VendorFirmwareVersion", &s.VendorFirmwareVersion)
			delete(rawMsg, key)
		case "vendorOsVersion":
			err = unpopulate(val, "VendorOsVersion", &s.VendorOsVersion)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TerminalServerConfiguration.
func (t TerminalServerConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "networkDeviceId", t.NetworkDeviceID)
	populate(objectMap, "password", t.Password)
	populate(objectMap, "primaryIpv4Prefix", t.PrimaryIPv4Prefix)
	populate(objectMap, "primaryIpv6Prefix", t.PrimaryIPv6Prefix)
	populate(objectMap, "secondaryIpv4Prefix", t.SecondaryIPv4Prefix)
	populate(objectMap, "secondaryIpv6Prefix", t.SecondaryIPv6Prefix)
	populate(objectMap, "serialNumber", t.SerialNumber)
	populate(objectMap, "username", t.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TerminalServerConfiguration.
func (t *TerminalServerConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "networkDeviceId":
			err = unpopulate(val, "NetworkDeviceID", &t.NetworkDeviceID)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &t.Password)
			delete(rawMsg, key)
		case "primaryIpv4Prefix":
			err = unpopulate(val, "PrimaryIPv4Prefix", &t.PrimaryIPv4Prefix)
			delete(rawMsg, key)
		case "primaryIpv6Prefix":
			err = unpopulate(val, "PrimaryIPv6Prefix", &t.PrimaryIPv6Prefix)
			delete(rawMsg, key)
		case "secondaryIpv4Prefix":
			err = unpopulate(val, "SecondaryIPv4Prefix", &t.SecondaryIPv4Prefix)
			delete(rawMsg, key)
		case "secondaryIpv6Prefix":
			err = unpopulate(val, "SecondaryIPv6Prefix", &t.SecondaryIPv6Prefix)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &t.SerialNumber)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &t.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TerminalServerPatchableProperties.
func (t TerminalServerPatchableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "password", t.Password)
	populate(objectMap, "serialNumber", t.SerialNumber)
	populate(objectMap, "username", t.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TerminalServerPatchableProperties.
func (t *TerminalServerPatchableProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			err = unpopulate(val, "Password", &t.Password)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &t.SerialNumber)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &t.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateAdministrativeState.
func (u UpdateAdministrativeState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceIds", u.ResourceIDs)
	populate(objectMap, "state", u.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateAdministrativeState.
func (u *UpdateAdministrativeState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceIds":
			err = unpopulate(val, "ResourceIDs", &u.ResourceIDs)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &u.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdatePowerCycleProperties.
func (u UpdatePowerCycleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "powerEnd", u.PowerEnd)
	populate(objectMap, "state", u.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdatePowerCycleProperties.
func (u *UpdatePowerCycleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "powerEnd":
			err = unpopulate(val, "PowerEnd", &u.PowerEnd)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &u.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateVersionProperties.
func (u UpdateVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "skuVersion", u.SKUVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateVersionProperties.
func (u *UpdateVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "skuVersion":
			err = unpopulate(val, "SKUVersion", &u.SKUVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VPNConfigurationProperties.
func (v VPNConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "administrativeState", v.AdministrativeState)
	populate(objectMap, "networkToNetworkInterconnectId", v.NetworkToNetworkInterconnectID)
	populate(objectMap, "optionAProperties", v.OptionAProperties)
	populate(objectMap, "optionBProperties", v.OptionBProperties)
	populate(objectMap, "peeringOption", v.PeeringOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VPNConfigurationProperties.
func (v *VPNConfigurationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "administrativeState":
			err = unpopulate(val, "AdministrativeState", &v.AdministrativeState)
			delete(rawMsg, key)
		case "networkToNetworkInterconnectId":
			err = unpopulate(val, "NetworkToNetworkInterconnectID", &v.NetworkToNetworkInterconnectID)
			delete(rawMsg, key)
		case "optionAProperties":
			err = unpopulate(val, "OptionAProperties", &v.OptionAProperties)
			delete(rawMsg, key)
		case "optionBProperties":
			err = unpopulate(val, "OptionBProperties", &v.OptionBProperties)
			delete(rawMsg, key)
		case "peeringOption":
			err = unpopulate(val, "PeeringOption", &v.PeeringOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadServices.
func (w WorkloadServices) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4AddressSpaces", w.IPv4AddressSpaces)
	populate(objectMap, "ipv6AddressSpaces", w.IPv6AddressSpaces)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadServices.
func (w *WorkloadServices) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4AddressSpaces":
			err = unpopulate(val, "IPv4AddressSpaces", &w.IPv4AddressSpaces)
			delete(rawMsg, key)
		case "ipv6AddressSpaces":
			err = unpopulate(val, "IPv6AddressSpaces", &w.IPv6AddressSpaces)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
