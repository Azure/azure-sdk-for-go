//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmarketplace

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// PrivateStoreClient contains the methods for the PrivateStore group.
// Don't use this type directly, use NewPrivateStoreClient() instead.
type PrivateStoreClient struct {
	ep string
	pl runtime.Pipeline
}

// NewPrivateStoreClient creates a new instance of PrivateStoreClient with the specified values.
func NewPrivateStoreClient(credential azcore.TokenCredential, options *arm.ClientOptions) *PrivateStoreClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &PrivateStoreClient{ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// AcknowledgeOfferNotification - Acknowledge notification for offer
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) AcknowledgeOfferNotification(ctx context.Context, privateStoreID string, offerID string, options *PrivateStoreAcknowledgeOfferNotificationOptions) (PrivateStoreAcknowledgeOfferNotificationResponse, error) {
	req, err := client.acknowledgeOfferNotificationCreateRequest(ctx, privateStoreID, offerID, options)
	if err != nil {
		return PrivateStoreAcknowledgeOfferNotificationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreAcknowledgeOfferNotificationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreAcknowledgeOfferNotificationResponse{}, client.acknowledgeOfferNotificationHandleError(resp)
	}
	return PrivateStoreAcknowledgeOfferNotificationResponse{RawResponse: resp}, nil
}

// acknowledgeOfferNotificationCreateRequest creates the AcknowledgeOfferNotification request.
func (client *PrivateStoreClient) acknowledgeOfferNotificationCreateRequest(ctx context.Context, privateStoreID string, offerID string, options *PrivateStoreAcknowledgeOfferNotificationOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/offers/{offerId}/acknowledgeNotification"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if offerID == "" {
		return nil, errors.New("parameter offerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{offerId}", url.PathEscape(offerID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// acknowledgeOfferNotificationHandleError handles the AcknowledgeOfferNotification error response.
func (client *PrivateStoreClient) acknowledgeOfferNotificationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// AdminRequestApprovalsList - Get list of admin request approvals
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) AdminRequestApprovalsList(ctx context.Context, privateStoreID string, options *PrivateStoreAdminRequestApprovalsListOptions) (PrivateStoreAdminRequestApprovalsListResponse, error) {
	req, err := client.adminRequestApprovalsListCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreAdminRequestApprovalsListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreAdminRequestApprovalsListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreAdminRequestApprovalsListResponse{}, client.adminRequestApprovalsListHandleError(resp)
	}
	return client.adminRequestApprovalsListHandleResponse(resp)
}

// adminRequestApprovalsListCreateRequest creates the AdminRequestApprovalsList request.
func (client *PrivateStoreClient) adminRequestApprovalsListCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreAdminRequestApprovalsListOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/adminRequestApprovals"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// adminRequestApprovalsListHandleResponse handles the AdminRequestApprovalsList response.
func (client *PrivateStoreClient) adminRequestApprovalsListHandleResponse(resp *http.Response) (PrivateStoreAdminRequestApprovalsListResponse, error) {
	result := PrivateStoreAdminRequestApprovalsListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AdminRequestApprovalsList); err != nil {
		return PrivateStoreAdminRequestApprovalsListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// adminRequestApprovalsListHandleError handles the AdminRequestApprovalsList error response.
func (client *PrivateStoreClient) adminRequestApprovalsListHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BillingAccounts - Tenant billing accounts names
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) BillingAccounts(ctx context.Context, privateStoreID string, options *PrivateStoreBillingAccountsOptions) (PrivateStoreBillingAccountsResponse, error) {
	req, err := client.billingAccountsCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreBillingAccountsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreBillingAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreBillingAccountsResponse{}, client.billingAccountsHandleError(resp)
	}
	return client.billingAccountsHandleResponse(resp)
}

// billingAccountsCreateRequest creates the BillingAccounts request.
func (client *PrivateStoreClient) billingAccountsCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreBillingAccountsOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/billingAccounts"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// billingAccountsHandleResponse handles the BillingAccounts response.
func (client *PrivateStoreClient) billingAccountsHandleResponse(resp *http.Response) (PrivateStoreBillingAccountsResponse, error) {
	result := PrivateStoreBillingAccountsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingAccountsResponse); err != nil {
		return PrivateStoreBillingAccountsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// billingAccountsHandleError handles the BillingAccounts error response.
func (client *PrivateStoreClient) billingAccountsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BulkCollectionsAction - Perform an action on bulk collections
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) BulkCollectionsAction(ctx context.Context, privateStoreID string, options *PrivateStoreBulkCollectionsActionOptions) (PrivateStoreBulkCollectionsActionResponse, error) {
	req, err := client.bulkCollectionsActionCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreBulkCollectionsActionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreBulkCollectionsActionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreBulkCollectionsActionResponse{}, client.bulkCollectionsActionHandleError(resp)
	}
	return client.bulkCollectionsActionHandleResponse(resp)
}

// bulkCollectionsActionCreateRequest creates the BulkCollectionsAction request.
func (client *PrivateStoreClient) bulkCollectionsActionCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreBulkCollectionsActionOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/bulkCollectionsAction"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// bulkCollectionsActionHandleResponse handles the BulkCollectionsAction response.
func (client *PrivateStoreClient) bulkCollectionsActionHandleResponse(resp *http.Response) (PrivateStoreBulkCollectionsActionResponse, error) {
	result := PrivateStoreBulkCollectionsActionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BulkCollectionsResponse); err != nil {
		return PrivateStoreBulkCollectionsActionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// bulkCollectionsActionHandleError handles the BulkCollectionsAction error response.
func (client *PrivateStoreClient) bulkCollectionsActionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CollectionsToSubscriptionsMapping - For a given subscriptions list, the API will return a map of collections and the related subscriptions from the supplied
// list.
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) CollectionsToSubscriptionsMapping(ctx context.Context, privateStoreID string, options *PrivateStoreCollectionsToSubscriptionsMappingOptions) (PrivateStoreCollectionsToSubscriptionsMappingResponse, error) {
	req, err := client.collectionsToSubscriptionsMappingCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreCollectionsToSubscriptionsMappingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreCollectionsToSubscriptionsMappingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreCollectionsToSubscriptionsMappingResponse{}, client.collectionsToSubscriptionsMappingHandleError(resp)
	}
	return client.collectionsToSubscriptionsMappingHandleResponse(resp)
}

// collectionsToSubscriptionsMappingCreateRequest creates the CollectionsToSubscriptionsMapping request.
func (client *PrivateStoreClient) collectionsToSubscriptionsMappingCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreCollectionsToSubscriptionsMappingOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/collectionsToSubscriptionsMapping"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// collectionsToSubscriptionsMappingHandleResponse handles the CollectionsToSubscriptionsMapping response.
func (client *PrivateStoreClient) collectionsToSubscriptionsMappingHandleResponse(resp *http.Response) (PrivateStoreCollectionsToSubscriptionsMappingResponse, error) {
	result := PrivateStoreCollectionsToSubscriptionsMappingResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CollectionsToSubscriptionsMappingResponse); err != nil {
		return PrivateStoreCollectionsToSubscriptionsMappingResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// collectionsToSubscriptionsMappingHandleError handles the CollectionsToSubscriptionsMapping error response.
func (client *PrivateStoreClient) collectionsToSubscriptionsMappingHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateApprovalRequest - Create approval request
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) CreateApprovalRequest(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreCreateApprovalRequestOptions) (PrivateStoreCreateApprovalRequestResponse, error) {
	req, err := client.createApprovalRequestCreateRequest(ctx, privateStoreID, requestApprovalID, options)
	if err != nil {
		return PrivateStoreCreateApprovalRequestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreCreateApprovalRequestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreCreateApprovalRequestResponse{}, client.createApprovalRequestHandleError(resp)
	}
	return client.createApprovalRequestHandleResponse(resp)
}

// createApprovalRequestCreateRequest creates the CreateApprovalRequest request.
func (client *PrivateStoreClient) createApprovalRequestCreateRequest(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreCreateApprovalRequestOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/requestApprovals/{requestApprovalId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if requestApprovalID == "" {
		return nil, errors.New("parameter requestApprovalID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{requestApprovalId}", url.PathEscape(requestApprovalID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// createApprovalRequestHandleResponse handles the CreateApprovalRequest response.
func (client *PrivateStoreClient) createApprovalRequestHandleResponse(resp *http.Response) (PrivateStoreCreateApprovalRequestResponse, error) {
	result := PrivateStoreCreateApprovalRequestResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestApprovalResource); err != nil {
		return PrivateStoreCreateApprovalRequestResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createApprovalRequestHandleError handles the CreateApprovalRequest error response.
func (client *PrivateStoreClient) createApprovalRequestHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdate - Changes private store properties
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) CreateOrUpdate(ctx context.Context, privateStoreID string, options *PrivateStoreCreateOrUpdateOptions) (PrivateStoreCreateOrUpdateResponse, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreCreateOrUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreCreateOrUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreCreateOrUpdateResponse{}, client.createOrUpdateHandleError(resp)
	}
	return PrivateStoreCreateOrUpdateResponse{RawResponse: resp}, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *PrivateStoreClient) createOrUpdateCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *PrivateStoreClient) createOrUpdateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - Deletes the private store. All that is not saved will be lost.
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) Delete(ctx context.Context, privateStoreID string, options *PrivateStoreDeleteOptions) (PrivateStoreDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return PrivateStoreDeleteResponse{}, client.deleteHandleError(resp)
	}
	return PrivateStoreDeleteResponse{RawResponse: resp}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *PrivateStoreClient) deleteCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreDeleteOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *PrivateStoreClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Get - Get information about the private store
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) Get(ctx context.Context, privateStoreID string, options *PrivateStoreGetOptions) (PrivateStoreGetResponse, error) {
	req, err := client.getCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreGetResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *PrivateStoreClient) getCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreGetOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *PrivateStoreClient) getHandleResponse(resp *http.Response) (PrivateStoreGetResponse, error) {
	result := PrivateStoreGetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateStore); err != nil {
		return PrivateStoreGetResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHandleError handles the Get error response.
func (client *PrivateStoreClient) getHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAdminRequestApproval - Get open approval requests
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) GetAdminRequestApproval(ctx context.Context, privateStoreID string, adminRequestApprovalID string, publisherID string, options *PrivateStoreGetAdminRequestApprovalOptions) (PrivateStoreGetAdminRequestApprovalResponse, error) {
	req, err := client.getAdminRequestApprovalCreateRequest(ctx, privateStoreID, adminRequestApprovalID, publisherID, options)
	if err != nil {
		return PrivateStoreGetAdminRequestApprovalResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreGetAdminRequestApprovalResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreGetAdminRequestApprovalResponse{}, client.getAdminRequestApprovalHandleError(resp)
	}
	return client.getAdminRequestApprovalHandleResponse(resp)
}

// getAdminRequestApprovalCreateRequest creates the GetAdminRequestApproval request.
func (client *PrivateStoreClient) getAdminRequestApprovalCreateRequest(ctx context.Context, privateStoreID string, adminRequestApprovalID string, publisherID string, options *PrivateStoreGetAdminRequestApprovalOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/adminRequestApprovals/{adminRequestApprovalId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if adminRequestApprovalID == "" {
		return nil, errors.New("parameter adminRequestApprovalID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{adminRequestApprovalId}", url.PathEscape(adminRequestApprovalID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	reqQP.Set("publisherId", publisherID)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAdminRequestApprovalHandleResponse handles the GetAdminRequestApproval response.
func (client *PrivateStoreClient) getAdminRequestApprovalHandleResponse(resp *http.Response) (PrivateStoreGetAdminRequestApprovalResponse, error) {
	result := PrivateStoreGetAdminRequestApprovalResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AdminRequestApprovalsResource); err != nil {
		return PrivateStoreGetAdminRequestApprovalResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAdminRequestApprovalHandleError handles the GetAdminRequestApproval error response.
func (client *PrivateStoreClient) getAdminRequestApprovalHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetApprovalRequestsList - Get all open approval requests of current user
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) GetApprovalRequestsList(ctx context.Context, privateStoreID string, options *PrivateStoreGetApprovalRequestsListOptions) (PrivateStoreGetApprovalRequestsListResponse, error) {
	req, err := client.getApprovalRequestsListCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreGetApprovalRequestsListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreGetApprovalRequestsListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreGetApprovalRequestsListResponse{}, client.getApprovalRequestsListHandleError(resp)
	}
	return client.getApprovalRequestsListHandleResponse(resp)
}

// getApprovalRequestsListCreateRequest creates the GetApprovalRequestsList request.
func (client *PrivateStoreClient) getApprovalRequestsListCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreGetApprovalRequestsListOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/requestApprovals"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getApprovalRequestsListHandleResponse handles the GetApprovalRequestsList response.
func (client *PrivateStoreClient) getApprovalRequestsListHandleResponse(resp *http.Response) (PrivateStoreGetApprovalRequestsListResponse, error) {
	result := PrivateStoreGetApprovalRequestsListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestApprovalsList); err != nil {
		return PrivateStoreGetApprovalRequestsListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getApprovalRequestsListHandleError handles the GetApprovalRequestsList error response.
func (client *PrivateStoreClient) getApprovalRequestsListHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetRequestApproval - Get open request approval details
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) GetRequestApproval(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreGetRequestApprovalOptions) (PrivateStoreGetRequestApprovalResponse, error) {
	req, err := client.getRequestApprovalCreateRequest(ctx, privateStoreID, requestApprovalID, options)
	if err != nil {
		return PrivateStoreGetRequestApprovalResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreGetRequestApprovalResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreGetRequestApprovalResponse{}, client.getRequestApprovalHandleError(resp)
	}
	return client.getRequestApprovalHandleResponse(resp)
}

// getRequestApprovalCreateRequest creates the GetRequestApproval request.
func (client *PrivateStoreClient) getRequestApprovalCreateRequest(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreGetRequestApprovalOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/requestApprovals/{requestApprovalId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if requestApprovalID == "" {
		return nil, errors.New("parameter requestApprovalID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{requestApprovalId}", url.PathEscape(requestApprovalID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getRequestApprovalHandleResponse handles the GetRequestApproval response.
func (client *PrivateStoreClient) getRequestApprovalHandleResponse(resp *http.Response) (PrivateStoreGetRequestApprovalResponse, error) {
	result := PrivateStoreGetRequestApprovalResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestApprovalResource); err != nil {
		return PrivateStoreGetRequestApprovalResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getRequestApprovalHandleError handles the GetRequestApproval error response.
func (client *PrivateStoreClient) getRequestApprovalHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// List - Gets the list of available private stores.
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) List(options *PrivateStoreListOptions) *PrivateStoreListPager {
	return &PrivateStoreListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PrivateStoreListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PrivateStoreList.NextLink)
		},
	}
}

// listCreateRequest creates the List request.
func (client *PrivateStoreClient) listCreateRequest(ctx context.Context, options *PrivateStoreListOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	if options != nil && options.UseCache != nil {
		reqQP.Set("use-cache", *options.UseCache)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *PrivateStoreClient) listHandleResponse(resp *http.Response) (PrivateStoreListResponse, error) {
	result := PrivateStoreListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateStoreList); err != nil {
		return PrivateStoreListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHandleError handles the List error response.
func (client *PrivateStoreClient) listHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// QueryApprovedPlans - Get map of plans and related approved subscriptions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) QueryApprovedPlans(ctx context.Context, privateStoreID string, options *PrivateStoreQueryApprovedPlansOptions) (PrivateStoreQueryApprovedPlansResponse, error) {
	req, err := client.queryApprovedPlansCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreQueryApprovedPlansResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreQueryApprovedPlansResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreQueryApprovedPlansResponse{}, client.queryApprovedPlansHandleError(resp)
	}
	return client.queryApprovedPlansHandleResponse(resp)
}

// queryApprovedPlansCreateRequest creates the QueryApprovedPlans request.
func (client *PrivateStoreClient) queryApprovedPlansCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreQueryApprovedPlansOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/queryApprovedPlans"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// queryApprovedPlansHandleResponse handles the QueryApprovedPlans response.
func (client *PrivateStoreClient) queryApprovedPlansHandleResponse(resp *http.Response) (PrivateStoreQueryApprovedPlansResponse, error) {
	result := PrivateStoreQueryApprovedPlansResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.QueryApprovedPlansResponse); err != nil {
		return PrivateStoreQueryApprovedPlansResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// queryApprovedPlansHandleError handles the QueryApprovedPlans error response.
func (client *PrivateStoreClient) queryApprovedPlansHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// QueryNotificationsState - Get private store notifications state
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) QueryNotificationsState(ctx context.Context, privateStoreID string, options *PrivateStoreQueryNotificationsStateOptions) (PrivateStoreQueryNotificationsStateResponse, error) {
	req, err := client.queryNotificationsStateCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreQueryNotificationsStateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreQueryNotificationsStateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreQueryNotificationsStateResponse{}, client.queryNotificationsStateHandleError(resp)
	}
	return client.queryNotificationsStateHandleResponse(resp)
}

// queryNotificationsStateCreateRequest creates the QueryNotificationsState request.
func (client *PrivateStoreClient) queryNotificationsStateCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreQueryNotificationsStateOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/queryNotificationsState"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// queryNotificationsStateHandleResponse handles the QueryNotificationsState response.
func (client *PrivateStoreClient) queryNotificationsStateHandleResponse(resp *http.Response) (PrivateStoreQueryNotificationsStateResponse, error) {
	result := PrivateStoreQueryNotificationsStateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateStoreNotificationsState); err != nil {
		return PrivateStoreQueryNotificationsStateResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// queryNotificationsStateHandleError handles the QueryNotificationsState error response.
func (client *PrivateStoreClient) queryNotificationsStateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// QueryOffers - List of offers, regardless the collections
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) QueryOffers(ctx context.Context, privateStoreID string, options *PrivateStoreQueryOffersOptions) (PrivateStoreQueryOffersResponse, error) {
	req, err := client.queryOffersCreateRequest(ctx, privateStoreID, options)
	if err != nil {
		return PrivateStoreQueryOffersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreQueryOffersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreQueryOffersResponse{}, client.queryOffersHandleError(resp)
	}
	return client.queryOffersHandleResponse(resp)
}

// queryOffersCreateRequest creates the QueryOffers request.
func (client *PrivateStoreClient) queryOffersCreateRequest(ctx context.Context, privateStoreID string, options *PrivateStoreQueryOffersOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/queryOffers"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// queryOffersHandleResponse handles the QueryOffers response.
func (client *PrivateStoreClient) queryOffersHandleResponse(resp *http.Response) (PrivateStoreQueryOffersResponse, error) {
	result := PrivateStoreQueryOffersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.QueryOffers); err != nil {
		return PrivateStoreQueryOffersResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// queryOffersHandleError handles the QueryOffers error response.
func (client *PrivateStoreClient) queryOffersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// QueryRequestApproval - Get request statuses foreach plan, this api is used as a complex GET action.
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) QueryRequestApproval(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreQueryRequestApprovalOptions) (PrivateStoreQueryRequestApprovalResponse, error) {
	req, err := client.queryRequestApprovalCreateRequest(ctx, privateStoreID, requestApprovalID, options)
	if err != nil {
		return PrivateStoreQueryRequestApprovalResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreQueryRequestApprovalResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreQueryRequestApprovalResponse{}, client.queryRequestApprovalHandleError(resp)
	}
	return client.queryRequestApprovalHandleResponse(resp)
}

// queryRequestApprovalCreateRequest creates the QueryRequestApproval request.
func (client *PrivateStoreClient) queryRequestApprovalCreateRequest(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreQueryRequestApprovalOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/requestApprovals/{requestApprovalId}/query"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if requestApprovalID == "" {
		return nil, errors.New("parameter requestApprovalID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{requestApprovalId}", url.PathEscape(requestApprovalID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// queryRequestApprovalHandleResponse handles the QueryRequestApproval response.
func (client *PrivateStoreClient) queryRequestApprovalHandleResponse(resp *http.Response) (PrivateStoreQueryRequestApprovalResponse, error) {
	result := PrivateStoreQueryRequestApprovalResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.QueryRequestApproval); err != nil {
		return PrivateStoreQueryRequestApprovalResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// queryRequestApprovalHandleError handles the QueryRequestApproval error response.
func (client *PrivateStoreClient) queryRequestApprovalHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAdminRequestApproval - Update the admin action, weather the request is approved or rejected and the approved plans
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) UpdateAdminRequestApproval(ctx context.Context, privateStoreID string, adminRequestApprovalID string, options *PrivateStoreUpdateAdminRequestApprovalOptions) (PrivateStoreUpdateAdminRequestApprovalResponse, error) {
	req, err := client.updateAdminRequestApprovalCreateRequest(ctx, privateStoreID, adminRequestApprovalID, options)
	if err != nil {
		return PrivateStoreUpdateAdminRequestApprovalResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreUpdateAdminRequestApprovalResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreUpdateAdminRequestApprovalResponse{}, client.updateAdminRequestApprovalHandleError(resp)
	}
	return client.updateAdminRequestApprovalHandleResponse(resp)
}

// updateAdminRequestApprovalCreateRequest creates the UpdateAdminRequestApproval request.
func (client *PrivateStoreClient) updateAdminRequestApprovalCreateRequest(ctx context.Context, privateStoreID string, adminRequestApprovalID string, options *PrivateStoreUpdateAdminRequestApprovalOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/adminRequestApprovals/{adminRequestApprovalId}"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if adminRequestApprovalID == "" {
		return nil, errors.New("parameter adminRequestApprovalID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{adminRequestApprovalId}", url.PathEscape(adminRequestApprovalID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// updateAdminRequestApprovalHandleResponse handles the UpdateAdminRequestApproval response.
func (client *PrivateStoreClient) updateAdminRequestApprovalHandleResponse(resp *http.Response) (PrivateStoreUpdateAdminRequestApprovalResponse, error) {
	result := PrivateStoreUpdateAdminRequestApprovalResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AdminRequestApprovalsResource); err != nil {
		return PrivateStoreUpdateAdminRequestApprovalResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAdminRequestApprovalHandleError handles the UpdateAdminRequestApproval error response.
func (client *PrivateStoreClient) updateAdminRequestApprovalHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// WithdrawPlan - Withdraw a user request approval on specific plan
// If the operation fails it returns the *ErrorResponse error type.
func (client *PrivateStoreClient) WithdrawPlan(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreWithdrawPlanOptions) (PrivateStoreWithdrawPlanResponse, error) {
	req, err := client.withdrawPlanCreateRequest(ctx, privateStoreID, requestApprovalID, options)
	if err != nil {
		return PrivateStoreWithdrawPlanResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrivateStoreWithdrawPlanResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrivateStoreWithdrawPlanResponse{}, client.withdrawPlanHandleError(resp)
	}
	return PrivateStoreWithdrawPlanResponse{RawResponse: resp}, nil
}

// withdrawPlanCreateRequest creates the WithdrawPlan request.
func (client *PrivateStoreClient) withdrawPlanCreateRequest(ctx context.Context, privateStoreID string, requestApprovalID string, options *PrivateStoreWithdrawPlanOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Marketplace/privateStores/{privateStoreId}/requestApprovals/{requestApprovalId}/withdrawPlan"
	if privateStoreID == "" {
		return nil, errors.New("parameter privateStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateStoreId}", url.PathEscape(privateStoreID))
	if requestApprovalID == "" {
		return nil, errors.New("parameter requestApprovalID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{requestApprovalId}", url.PathEscape(requestApprovalID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Payload != nil {
		return req, runtime.MarshalAsJSON(req, *options.Payload)
	}
	return req, nil
}

// withdrawPlanHandleError handles the WithdrawPlan error response.
func (client *PrivateStoreClient) withdrawPlanHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
