//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmediaservices

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
	"time"
)

// AacAudio - Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudio struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// The number of channels in the audio.
	Channels *int32 `json:"channels,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// The encoding profile to be used when encoding audio with AAC.
	Profile *AacAudioProfile `json:"profile,omitempty"`

	// The sampling rate to use for encoding in hertz.
	SamplingRate *int32 `json:"samplingRate,omitempty"`
}

// GetAudio implements the AudioClassification interface for type AacAudio.
func (a *AacAudio) GetAudio() *Audio {
	return &Audio{
		Channels:     a.Channels,
		SamplingRate: a.SamplingRate,
		Bitrate:      a.Bitrate,
		ODataType:    a.ODataType,
		Label:        a.Label,
	}
}

// GetCodec implements the CodecClassification interface for type AacAudio.
func (a *AacAudio) GetCodec() *Codec {
	return &Codec{
		ODataType: a.ODataType,
		Label:     a.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AacAudio.
func (a AacAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "label", a.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.AacAudio"
	populate(objectMap, "profile", a.Profile)
	populate(objectMap, "samplingRate", a.SamplingRate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AacAudio.
func (a *AacAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, &a.Channels)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &a.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, &a.Profile)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AbsoluteClipTime - Specifies the clip time as an absolute time position in the media file. The absolute time can point
// to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTime struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S
	// for 30 seconds.
	Time *string `json:"time,omitempty"`
}

// GetClipTime implements the ClipTimeClassification interface for type AbsoluteClipTime.
func (a *AbsoluteClipTime) GetClipTime() *ClipTime {
	return &ClipTime{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AbsoluteClipTime.
func (a AbsoluteClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.AbsoluteClipTime"
	populate(objectMap, "time", a.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AbsoluteClipTime.
func (a *AbsoluteClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "time":
			err = unpopulate(val, &a.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type AccessControl struct {
	// The behavior for IP access control in Key Delivery.
	DefaultAction *DefaultAction `json:"defaultAction,omitempty"`

	// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be
	// empty.
	IPAllowList []*string `json:"ipAllowList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessControl.
func (a AccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", a.DefaultAction)
	populate(objectMap, "ipAllowList", a.IPAllowList)
	return json.Marshal(objectMap)
}

type AccountEncryption struct {
	// REQUIRED; The type of key used to encrypt the Account Key.
	Type *AccountEncryptionKeyType `json:"type,omitempty"`

	// The Key Vault identity.
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// READ-ONLY; The current status of the Key Vault mapping.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// AccountFilter - An Account Filter.
type AccountFilter struct {
	// The Media Filter properties.
	Properties *MediaFilterProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilter.
func (a AccountFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AccountFilterCollection - A collection of AccountFilter items.
type AccountFilterCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of AccountFilter items.
	Value []*AccountFilter `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilterCollection.
func (a AccountFilterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccountFiltersClientCreateOrUpdateOptions contains the optional parameters for the AccountFiltersClient.CreateOrUpdate
// method.
type AccountFiltersClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersClientDeleteOptions contains the optional parameters for the AccountFiltersClient.Delete method.
type AccountFiltersClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersClientGetOptions contains the optional parameters for the AccountFiltersClient.Get method.
type AccountFiltersClientGetOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersClientListOptions contains the optional parameters for the AccountFiltersClient.List method.
type AccountFiltersClientListOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersClientUpdateOptions contains the optional parameters for the AccountFiltersClient.Update method.
type AccountFiltersClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// AkamaiAccessControl - Akamai access control
type AkamaiAccessControl struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList []*AkamaiSignatureHeaderAuthenticationKey `json:"akamaiSignatureHeaderAuthenticationKeyList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiAccessControl.
func (a AkamaiAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "akamaiSignatureHeaderAuthenticationKeyList", a.AkamaiSignatureHeaderAuthenticationKeyList)
	return json.Marshal(objectMap)
}

// AkamaiSignatureHeaderAuthenticationKey - Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKey struct {
	// authentication key
	Base64Key *string `json:"base64Key,omitempty"`

	// The expiration time of the authentication key.
	Expiration *time.Time `json:"expiration,omitempty"`

	// identifier of the key
	Identifier *string `json:"identifier,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a AkamaiSignatureHeaderAuthenticationKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "base64Key", a.Base64Key)
	populateTimeRFC3339(objectMap, "expiration", a.Expiration)
	populate(objectMap, "identifier", a.Identifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a *AkamaiSignatureHeaderAuthenticationKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "base64Key":
			err = unpopulate(val, &a.Base64Key)
			delete(rawMsg, key)
		case "expiration":
			err = unpopulateTimeRFC3339(val, &a.Expiration)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, &a.Identifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Asset - An Asset.
type Asset struct {
	// The resource properties.
	Properties *AssetProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Asset.
func (a Asset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AssetCollection - A collection of Asset items.
type AssetCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of Asset items.
	Value []*Asset `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetCollection.
func (a AssetCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AssetContainerSas - The Asset Storage container SAS URLs.
type AssetContainerSas struct {
	// The list of Asset container SAS URLs.
	AssetContainerSasUrls []*string `json:"assetContainerSasUrls,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetContainerSas.
func (a AssetContainerSas) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetContainerSasUrls", a.AssetContainerSasUrls)
	return json.Marshal(objectMap)
}

// AssetFileEncryptionMetadata - The Asset File Storage encryption metadata.
type AssetFileEncryptionMetadata struct {
	// REQUIRED; The Asset File Id.
	AssetFileID *string `json:"assetFileId,omitempty"`

	// The Asset File name.
	AssetFileName *string `json:"assetFileName,omitempty"`

	// The Asset File initialization vector.
	InitializationVector *string `json:"initializationVector,omitempty"`
}

// AssetFilter - An Asset Filter.
type AssetFilter struct {
	// The Media Filter properties.
	Properties *MediaFilterProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilter.
func (a AssetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AssetFilterCollection - A collection of AssetFilter items.
type AssetFilterCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of AssetFilter items.
	Value []*AssetFilter `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilterCollection.
func (a AssetFilterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AssetFiltersClientCreateOrUpdateOptions contains the optional parameters for the AssetFiltersClient.CreateOrUpdate method.
type AssetFiltersClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersClientDeleteOptions contains the optional parameters for the AssetFiltersClient.Delete method.
type AssetFiltersClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersClientGetOptions contains the optional parameters for the AssetFiltersClient.Get method.
type AssetFiltersClientGetOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersClientListOptions contains the optional parameters for the AssetFiltersClient.List method.
type AssetFiltersClientListOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersClientUpdateOptions contains the optional parameters for the AssetFiltersClient.Update method.
type AssetFiltersClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// AssetProperties - The Asset properties.
type AssetProperties struct {
	// The alternate ID of the Asset.
	AlternateID *string `json:"alternateId,omitempty"`

	// The name of the asset blob container.
	Container *string `json:"container,omitempty"`

	// The Asset description.
	Description *string `json:"description,omitempty"`

	// The name of the storage account.
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// READ-ONLY; The Asset ID.
	AssetID *string `json:"assetId,omitempty" azure:"ro"`

	// READ-ONLY; The creation date of the Asset.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The last modified date of the Asset.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The Asset encryption format. One of None or MediaStorageEncryption.
	StorageEncryptionFormat *AssetStorageEncryptionFormat `json:"storageEncryptionFormat,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetProperties.
func (a AssetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateId", a.AlternateID)
	populate(objectMap, "assetId", a.AssetID)
	populate(objectMap, "container", a.Container)
	populateTimeRFC3339(objectMap, "created", a.Created)
	populate(objectMap, "description", a.Description)
	populateTimeRFC3339(objectMap, "lastModified", a.LastModified)
	populate(objectMap, "storageAccountName", a.StorageAccountName)
	populate(objectMap, "storageEncryptionFormat", a.StorageEncryptionFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetProperties.
func (a *AssetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateId":
			err = unpopulate(val, &a.AlternateID)
			delete(rawMsg, key)
		case "assetId":
			err = unpopulate(val, &a.AssetID)
			delete(rawMsg, key)
		case "container":
			err = unpopulate(val, &a.Container)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &a.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &a.LastModified)
			delete(rawMsg, key)
		case "storageAccountName":
			err = unpopulate(val, &a.StorageAccountName)
			delete(rawMsg, key)
		case "storageEncryptionFormat":
			err = unpopulate(val, &a.StorageEncryptionFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AssetStreamingLocator - Properties of the Streaming Locator.
type AssetStreamingLocator struct {
	// READ-ONLY; Asset Name.
	AssetName *string `json:"assetName,omitempty" azure:"ro"`

	// READ-ONLY; The creation time of the Streaming Locator.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty" azure:"ro"`

	// READ-ONLY; The end time of the Streaming Locator.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; Streaming Locator name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the Streaming Locator.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; StreamingLocatorId of the Streaming Locator.
	StreamingLocatorID *string `json:"streamingLocatorId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the Streaming Policy used by this Streaming Locator.
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetStreamingLocator.
func (a AssetStreamingLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", a.AssetName)
	populateTimeRFC3339(objectMap, "created", a.Created)
	populate(objectMap, "defaultContentKeyPolicyName", a.DefaultContentKeyPolicyName)
	populateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "name", a.Name)
	populateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "streamingLocatorId", a.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", a.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetStreamingLocator.
func (a *AssetStreamingLocator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &a.AssetName)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &a.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &a.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &a.EndTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &a.StartTime)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, &a.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, &a.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AssetsClientCreateOrUpdateOptions contains the optional parameters for the AssetsClient.CreateOrUpdate method.
type AssetsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AssetsClientDeleteOptions contains the optional parameters for the AssetsClient.Delete method.
type AssetsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// AssetsClientGetEncryptionKeyOptions contains the optional parameters for the AssetsClient.GetEncryptionKey method.
type AssetsClientGetEncryptionKeyOptions struct {
	// placeholder for future optional parameters
}

// AssetsClientGetOptions contains the optional parameters for the AssetsClient.Get method.
type AssetsClientGetOptions struct {
	// placeholder for future optional parameters
}

// AssetsClientListContainerSasOptions contains the optional parameters for the AssetsClient.ListContainerSas method.
type AssetsClientListContainerSasOptions struct {
	// placeholder for future optional parameters
}

// AssetsClientListOptions contains the optional parameters for the AssetsClient.List method.
type AssetsClientListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the
	// number of available items up to but not greater than the specified value n.
	Top *int32
}

// AssetsClientListStreamingLocatorsOptions contains the optional parameters for the AssetsClient.ListStreamingLocators method.
type AssetsClientListStreamingLocatorsOptions struct {
	// placeholder for future optional parameters
}

// AssetsClientUpdateOptions contains the optional parameters for the AssetsClient.Update method.
type AssetsClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// AudioClassification provides polymorphic access to related types.
// Call the interface's GetAudio() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AacAudio, *Audio
type AudioClassification interface {
	CodecClassification
	// GetAudio returns the Audio content of the underlying type.
	GetAudio() *Audio
}

// Audio - Defines the common properties for all audio codecs.
type Audio struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// The number of channels in the audio.
	Channels *int32 `json:"channels,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// The sampling rate to use for encoding in hertz.
	SamplingRate *int32 `json:"samplingRate,omitempty"`
}

// GetAudio implements the AudioClassification interface for type Audio.
func (a *Audio) GetAudio() *Audio { return a }

// GetCodec implements the CodecClassification interface for type Audio.
func (a *Audio) GetCodec() *Codec {
	return &Codec{
		ODataType: a.ODataType,
		Label:     a.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Audio.
func (a Audio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "label", a.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Audio"
	populate(objectMap, "samplingRate", a.SamplingRate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Audio.
func (a *Audio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, &a.Channels)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &a.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AudioAnalyzerPresetClassification provides polymorphic access to related types.
// Call the interface's GetAudioAnalyzerPreset() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioAnalyzerPreset, *VideoAnalyzerPreset
type AudioAnalyzerPresetClassification interface {
	PresetClassification
	// GetAudioAnalyzerPreset returns the AudioAnalyzerPreset content of the underlying type.
	GetAudioAnalyzerPreset() *AudioAnalyzerPreset
}

// AudioAnalyzerPreset - The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech
// transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPreset struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you
	// know the language of your content, it is recommended that you specify it. The
	// language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included
	// in basic mode. If the language isn't specified or set to null, automatic language
	// detection will choose the first language detected and process with the selected language for the duration of the file.
	// It does not currently support dynamically switching between languages after the
	// first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If
	// automatic detection fails to find the language, transcription would fallback to
	// 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `json:"audioLanguage,omitempty"`

	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions,omitempty"`

	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be
	// chosen.
	Mode *AudioAnalysisMode `json:"mode,omitempty"`
}

// GetAudioAnalyzerPreset implements the AudioAnalyzerPresetClassification interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) GetAudioAnalyzerPreset() *AudioAnalyzerPreset { return a }

// GetPreset implements the PresetClassification interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioAnalyzerPreset.
func (a AudioAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioLanguage", a.AudioLanguage)
	populate(objectMap, "experimentalOptions", a.ExperimentalOptions)
	populate(objectMap, "mode", a.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioAnalyzerPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, &a.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &a.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &a.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AudioOverlay - Describes the properties of an audio overlay.
type AudioOverlay struct {
	// REQUIRED; The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can
	// specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV,
	// MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video
	// file formats.
	InputLabel *string `json:"inputLabel,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`

	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format.
	// For example, PT30S to end the overlay at 30 seconds into the input video. If not
	// specified or the value is greater than the input video duration, the overlay will be applied until the end of the input
	// video if the overlay media duration is greater than the input video duration,
	// else the overlay will last as long as the overlay media duration.
	End *string `json:"end,omitempty"`

	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If
	// not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`

	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not
	// specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`

	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format.
	// For example, PT05S to start the overlay at 5 seconds into the input video.
	// If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
}

// GetOverlay implements the OverlayClassification interface for type AudioOverlay.
func (a *AudioOverlay) GetOverlay() *Overlay {
	return &Overlay{
		ODataType:       a.ODataType,
		InputLabel:      a.InputLabel,
		Start:           a.Start,
		End:             a.End,
		FadeInDuration:  a.FadeInDuration,
		FadeOutDuration: a.FadeOutDuration,
		AudioGainLevel:  a.AudioGainLevel,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioOverlay.
func (a AudioOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioGainLevel", a.AudioGainLevel)
	populate(objectMap, "end", a.End)
	populate(objectMap, "fadeInDuration", a.FadeInDuration)
	populate(objectMap, "fadeOutDuration", a.FadeOutDuration)
	populate(objectMap, "inputLabel", a.InputLabel)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioOverlay"
	populate(objectMap, "start", a.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioOverlay.
func (a *AudioOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, &a.AudioGainLevel)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, &a.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, &a.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, &a.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, &a.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &a.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AudioTrackDescriptorClassification provides polymorphic access to related types.
// Call the interface's GetAudioTrackDescriptor() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioTrackDescriptor, *SelectAudioTrackByAttribute, *SelectAudioTrackByID
type AudioTrackDescriptorClassification interface {
	TrackDescriptorClassification
	// GetAudioTrackDescriptor returns the AudioTrackDescriptor content of the underlying type.
	GetAudioTrackDescriptor() *AudioTrackDescriptor
}

// AudioTrackDescriptor - A TrackSelection to select audio tracks.
type AudioTrackDescriptor struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Optional designation for single channel audio tracks. Can be used to combine the tracks into stereo or multi-channel audio
	// tracks.
	ChannelMapping *ChannelMapping `json:"channelMapping,omitempty"`
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) GetAudioTrackDescriptor() *AudioTrackDescriptor { return a }

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioTrackDescriptor.
func (a AudioTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelMapping", a.ChannelMapping)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioTrackDescriptor"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, &a.ChannelMapping)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BuiltInStandardEncoderPreset - Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPreset struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The built-in preset to be used for encoding videos.
	PresetName *EncoderNamedPreset `json:"presetName,omitempty"`

	// PresetConfigurations are only supported for the ContentAwareEncoding and H265ContentAwareEncoding built-in presets. These
	// settings will not affect other built-in or custom defined presets.
	Configurations *PresetConfigurations `json:"configurations,omitempty"`
}

// GetPreset implements the PresetClassification interface for type BuiltInStandardEncoderPreset.
func (b *BuiltInStandardEncoderPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: b.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BuiltInStandardEncoderPreset.
func (b BuiltInStandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configurations", b.Configurations)
	objectMap["@odata.type"] = "#Microsoft.Media.BuiltInStandardEncoderPreset"
	populate(objectMap, "presetName", b.PresetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BuiltInStandardEncoderPreset.
func (b *BuiltInStandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurations":
			err = unpopulate(val, &b.Configurations)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &b.ODataType)
			delete(rawMsg, key)
		case "presetName":
			err = unpopulate(val, &b.PresetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CbcsDrmConfiguration - Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfiguration struct {
	// FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfiguration `json:"fairPlay,omitempty"`

	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `json:"playReady,omitempty"`

	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `json:"widevine,omitempty"`
}

// CencDrmConfiguration - Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfiguration struct {
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `json:"playReady,omitempty"`

	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `json:"widevine,omitempty"`
}

// CheckNameAvailabilityInput - The input to the check name availability request.
type CheckNameAvailabilityInput struct {
	// The account name.
	Name *string `json:"name,omitempty"`

	// The account type. For a Media Services account, this should be 'MediaServices'.
	Type *string `json:"type,omitempty"`
}

// ClientCreateOrUpdateOptions contains the optional parameters for the Client.CreateOrUpdate method.
type ClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteOptions contains the optional parameters for the Client.Delete method.
type ClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ClientGetOptions contains the optional parameters for the Client.Get method.
type ClientGetOptions struct {
	// placeholder for future optional parameters
}

// ClientListBySubscriptionOptions contains the optional parameters for the Client.ListBySubscription method.
type ClientListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// ClientListEdgePoliciesOptions contains the optional parameters for the Client.ListEdgePolicies method.
type ClientListEdgePoliciesOptions struct {
	// placeholder for future optional parameters
}

// ClientListOptions contains the optional parameters for the Client.List method.
type ClientListOptions struct {
	// placeholder for future optional parameters
}

// ClientSyncStorageKeysOptions contains the optional parameters for the Client.SyncStorageKeys method.
type ClientSyncStorageKeysOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateOptions contains the optional parameters for the Client.Update method.
type ClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// ClipTimeClassification provides polymorphic access to related types.
// Call the interface's GetClipTime() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AbsoluteClipTime, *ClipTime, *UTCClipTime
type ClipTimeClassification interface {
	// GetClipTime returns the ClipTime content of the underlying type.
	GetClipTime() *ClipTime
}

// ClipTime - Base class for specifying a clip time. Use sub classes of this class to specify the time position in the media.
type ClipTime struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetClipTime implements the ClipTimeClassification interface for type ClipTime.
func (c *ClipTime) GetClipTime() *ClipTime { return c }

// CodecClassification provides polymorphic access to related types.
// Call the interface's GetCodec() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AacAudio, *Audio, *Codec, *CopyAudio, *CopyVideo, *H264Video, *H265Video, *Image, *JpgImage, *PNGImage, *Video
type CodecClassification interface {
	// GetCodec returns the Codec content of the underlying type.
	GetCodec() *Codec
}

// Codec - Describes the basic properties of all codecs.
type Codec struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
}

// GetCodec implements the CodecClassification interface for type Codec.
func (c *Codec) GetCodec() *Codec { return c }

// CommonEncryptionCbcs - Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcs struct {
	// Representing which tracks should not be encrypted
	ClearTracks []*TrackSelection `json:"clearTracks,omitempty"`

	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`

	// Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfiguration `json:"drm,omitempty"`

	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCbcs.
func (c CommonEncryptionCbcs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// CommonEncryptionCenc - Class for envelope encryption scheme
type CommonEncryptionCenc struct {
	// Representing which tracks should not be encrypted
	ClearTracks []*TrackSelection `json:"clearTracks,omitempty"`

	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`

	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfiguration `json:"drm,omitempty"`

	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCenc.
func (c CommonEncryptionCenc) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// ContentKeyPoliciesClientCreateOrUpdateOptions contains the optional parameters for the ContentKeyPoliciesClient.CreateOrUpdate
// method.
type ContentKeyPoliciesClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesClientDeleteOptions contains the optional parameters for the ContentKeyPoliciesClient.Delete method.
type ContentKeyPoliciesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesClientGetOptions contains the optional parameters for the ContentKeyPoliciesClient.Get method.
type ContentKeyPoliciesClientGetOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesClientGetPolicyPropertiesWithSecretsOptions contains the optional parameters for the ContentKeyPoliciesClient.GetPolicyPropertiesWithSecrets
// method.
type ContentKeyPoliciesClientGetPolicyPropertiesWithSecretsOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesClientListOptions contains the optional parameters for the ContentKeyPoliciesClient.List method.
type ContentKeyPoliciesClientListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the
	// number of available items up to but not greater than the specified value n.
	Top *int32
}

// ContentKeyPoliciesClientUpdateOptions contains the optional parameters for the ContentKeyPoliciesClient.Update method.
type ContentKeyPoliciesClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPolicy - A Content Key Policy resource.
type ContentKeyPolicy struct {
	// The properties of the Content Key Policy.
	Properties *ContentKeyPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicy.
func (c ContentKeyPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// ContentKeyPolicyClearKeyConfiguration - Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfiguration struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyClearKeyConfiguration.
func (c *ContentKeyPolicyClearKeyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c ContentKeyPolicyClearKeyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c *ContentKeyPolicyClearKeyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyCollection - A collection of ContentKeyPolicy items.
type ContentKeyPolicyCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of ContentKeyPolicy items.
	Value []*ContentKeyPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyCollection.
func (c ContentKeyPolicyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", c.ODataNextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ContentKeyPolicyConfigurationClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyConfiguration() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyClearKeyConfiguration, *ContentKeyPolicyConfiguration, *ContentKeyPolicyFairPlayConfiguration, *ContentKeyPolicyPlayReadyConfiguration,
// - *ContentKeyPolicyUnknownConfiguration, *ContentKeyPolicyWidevineConfiguration
type ContentKeyPolicyConfigurationClassification interface {
	// GetContentKeyPolicyConfiguration returns the ContentKeyPolicyConfiguration content of the underlying type.
	GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration
}

// ContentKeyPolicyConfiguration - Base class for Content Key Policy configuration. A derived class must be used to create
// a configuration.
type ContentKeyPolicyConfiguration struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyConfiguration.
func (c *ContentKeyPolicyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return c
}

// ContentKeyPolicyFairPlayConfiguration - Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfiguration struct {
	// REQUIRED; The key that must be used as FairPlay Application Secret key.
	Ask []byte `json:"ask,omitempty"`

	// REQUIRED; The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx *string `json:"fairPlayPfx,omitempty"`

	// REQUIRED; The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword *string `json:"fairPlayPfxPassword,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The rental and lease key type.
	RentalAndLeaseKeyType *ContentKeyPolicyFairPlayRentalAndLeaseKeyType `json:"rentalAndLeaseKeyType,omitempty"`

	// REQUIRED; The rental duration. Must be greater than or equal to 0.
	RentalDuration *int64 `json:"rentalDuration,omitempty"`

	// Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfiguration `json:"offlineRentalConfiguration,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyFairPlayConfiguration.
func (c *ContentKeyPolicyFairPlayConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c ContentKeyPolicyFairPlayConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "ask", c.Ask, runtime.Base64StdFormat)
	populate(objectMap, "fairPlayPfx", c.FairPlayPfx)
	populate(objectMap, "fairPlayPfxPassword", c.FairPlayPfxPassword)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration"
	populate(objectMap, "offlineRentalConfiguration", c.OfflineRentalConfiguration)
	populate(objectMap, "rentalAndLeaseKeyType", c.RentalAndLeaseKeyType)
	populate(objectMap, "rentalDuration", c.RentalDuration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c *ContentKeyPolicyFairPlayConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ask":
			err = runtime.DecodeByteArray(string(val), &c.Ask, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "fairPlayPfx":
			err = unpopulate(val, &c.FairPlayPfx)
			delete(rawMsg, key)
		case "fairPlayPfxPassword":
			err = unpopulate(val, &c.FairPlayPfxPassword)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "offlineRentalConfiguration":
			err = unpopulate(val, &c.OfflineRentalConfiguration)
			delete(rawMsg, key)
		case "rentalAndLeaseKeyType":
			err = unpopulate(val, &c.RentalAndLeaseKeyType)
			delete(rawMsg, key)
		case "rentalDuration":
			err = unpopulate(val, &c.RentalDuration)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type ContentKeyPolicyFairPlayOfflineRentalConfiguration struct {
	// REQUIRED; Playback duration
	PlaybackDurationSeconds *int64 `json:"playbackDurationSeconds,omitempty"`

	// REQUIRED; Storage duration
	StorageDurationSeconds *int64 `json:"storageDurationSeconds,omitempty"`
}

// ContentKeyPolicyOpenRestriction - Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestriction struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyOpenRestriction.
func (c *ContentKeyPolicyOpenRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return &ContentKeyPolicyRestriction{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOpenRestriction.
func (c ContentKeyPolicyOpenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyOpenRestriction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOpenRestriction.
func (c *ContentKeyPolicyOpenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyOption - Represents a policy option.
type ContentKeyPolicyOption struct {
	// REQUIRED; The key delivery configuration.
	Configuration ContentKeyPolicyConfigurationClassification `json:"configuration,omitempty"`

	// REQUIRED; The requirements that must be met to deliver keys with this configuration
	Restriction ContentKeyPolicyRestrictionClassification `json:"restriction,omitempty"`

	// The Policy Option description.
	Name *string `json:"name,omitempty"`

	// READ-ONLY; The legacy Policy Option ID.
	PolicyOptionID *string `json:"policyOptionId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOption.
func (c ContentKeyPolicyOption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configuration", c.Configuration)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "policyOptionId", c.PolicyOptionID)
	populate(objectMap, "restriction", c.Restriction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOption.
func (c *ContentKeyPolicyOption) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			c.Configuration, err = unmarshalContentKeyPolicyConfigurationClassification(val)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "policyOptionId":
			err = unpopulate(val, &c.PolicyOptionID)
			delete(rawMsg, key)
		case "restriction":
			c.Restriction, err = unmarshalContentKeyPolicyRestrictionClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyConfiguration - Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfiguration struct {
	// REQUIRED; The PlayReady licenses.
	Licenses []*ContentKeyPolicyPlayReadyLicense `json:"licenses,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The custom response data.
	ResponseCustomData *string `json:"responseCustomData,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c *ContentKeyPolicyPlayReadyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c ContentKeyPolicyPlayReadyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "licenses", c.Licenses)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration"
	populate(objectMap, "responseCustomData", c.ResponseCustomData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c *ContentKeyPolicyPlayReadyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenses":
			err = unpopulate(val, &c.Licenses)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "responseCustomData":
			err = unpopulate(val, &c.ResponseCustomData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader - Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification
// interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return &ContentKeyPolicyPlayReadyContentKeyLocation{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier - Specifies that the content key ID is specified in the
// PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier struct {
	// REQUIRED; The content key ID.
	KeyID *string `json:"keyId,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification
// interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return &ContentKeyPolicyPlayReadyContentKeyLocation{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyId", c.KeyID)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyId":
			err = unpopulate(val, &c.KeyID)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyContentKeyLocationClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyPlayReadyContentKeyLocation() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier,
// - *ContentKeyPolicyPlayReadyContentKeyLocation
type ContentKeyPolicyPlayReadyContentKeyLocationClassification interface {
	// GetContentKeyPolicyPlayReadyContentKeyLocation returns the ContentKeyPolicyPlayReadyContentKeyLocation content of the underlying type.
	GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation
}

// ContentKeyPolicyPlayReadyContentKeyLocation - Base class for content key ID location. A derived class must be used to represent
// the location.
type ContentKeyPolicyPlayReadyContentKeyLocation struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification
// interface for type ContentKeyPolicyPlayReadyContentKeyLocation.
func (c *ContentKeyPolicyPlayReadyContentKeyLocation) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return c
}

// ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction - Configures the Explicit Analog Television Output Restriction
// control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction struct {
	// REQUIRED; Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort *bool `json:"bestEffort,omitempty"`

	// REQUIRED; Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData *int32 `json:"configurationData,omitempty"`
}

// ContentKeyPolicyPlayReadyLicense - The PlayReady license
type ContentKeyPolicyPlayReadyLicense struct {
	// REQUIRED; A flag indicating whether test devices can use the license.
	AllowTestDevices *bool `json:"allowTestDevices,omitempty"`

	// REQUIRED; The content key location.
	ContentKeyLocation ContentKeyPolicyPlayReadyContentKeyLocationClassification `json:"contentKeyLocation,omitempty"`

	// REQUIRED; The PlayReady content type.
	ContentType *ContentKeyPolicyPlayReadyContentType `json:"contentType,omitempty"`

	// REQUIRED; The license type.
	LicenseType *ContentKeyPolicyPlayReadyLicenseType `json:"licenseType,omitempty"`

	// The begin date of license
	BeginDate *time.Time `json:"beginDate,omitempty"`

	// The expiration date of license.
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	// The grace period of license.
	GracePeriod *string `json:"gracePeriod,omitempty"`

	// The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRight `json:"playRight,omitempty"`

	// The relative begin date of license.
	RelativeBeginDate *string `json:"relativeBeginDate,omitempty"`

	// The relative expiration date of license.
	RelativeExpirationDate *string `json:"relativeExpirationDate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c ContentKeyPolicyPlayReadyLicense) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowTestDevices", c.AllowTestDevices)
	populateTimeRFC3339(objectMap, "beginDate", c.BeginDate)
	populate(objectMap, "contentKeyLocation", c.ContentKeyLocation)
	populate(objectMap, "contentType", c.ContentType)
	populateTimeRFC3339(objectMap, "expirationDate", c.ExpirationDate)
	populate(objectMap, "gracePeriod", c.GracePeriod)
	populate(objectMap, "licenseType", c.LicenseType)
	populate(objectMap, "playRight", c.PlayRight)
	populate(objectMap, "relativeBeginDate", c.RelativeBeginDate)
	populate(objectMap, "relativeExpirationDate", c.RelativeExpirationDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c *ContentKeyPolicyPlayReadyLicense) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTestDevices":
			err = unpopulate(val, &c.AllowTestDevices)
			delete(rawMsg, key)
		case "beginDate":
			err = unpopulateTimeRFC3339(val, &c.BeginDate)
			delete(rawMsg, key)
		case "contentKeyLocation":
			c.ContentKeyLocation, err = unmarshalContentKeyPolicyPlayReadyContentKeyLocationClassification(val)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &c.ContentType)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &c.ExpirationDate)
			delete(rawMsg, key)
		case "gracePeriod":
			err = unpopulate(val, &c.GracePeriod)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, &c.LicenseType)
			delete(rawMsg, key)
		case "playRight":
			err = unpopulate(val, &c.PlayRight)
			delete(rawMsg, key)
		case "relativeBeginDate":
			err = unpopulate(val, &c.RelativeBeginDate)
			delete(rawMsg, key)
		case "relativeExpirationDate":
			err = unpopulate(val, &c.RelativeExpirationDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyPlayRight - Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRight struct {
	// REQUIRED; Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput *ContentKeyPolicyPlayReadyUnknownOutputPassingOption `json:"allowPassingVideoContentToUnknownOutput,omitempty"`

	// REQUIRED; Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction *bool `json:"digitalVideoOnlyContentRestriction,omitempty"`

	// REQUIRED; Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction *bool `json:"imageConstraintForAnalogComponentVideoRestriction,omitempty"`

	// REQUIRED; Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction *bool `json:"imageConstraintForAnalogComputerMonitorRestriction,omitempty"`

	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int32 `json:"agcAndColorStripeRestriction,omitempty"`

	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int32 `json:"analogVideoOpl,omitempty"`

	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int32 `json:"compressedDigitalAudioOpl,omitempty"`

	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int32 `json:"compressedDigitalVideoOpl,omitempty"`

	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3
	// inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction `json:"explicitAnalogTelevisionOutputRestriction,omitempty"`

	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `json:"firstPlayExpiration,omitempty"`

	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int32 `json:"scmsRestriction,omitempty"`

	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int32 `json:"uncompressedDigitalAudioOpl,omitempty"`

	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int32 `json:"uncompressedDigitalVideoOpl,omitempty"`
}

// ContentKeyPolicyProperties - The properties of the Content Key Policy.
type ContentKeyPolicyProperties struct {
	// REQUIRED; The Key Policy options.
	Options []*ContentKeyPolicyOption `json:"options,omitempty"`

	// A description for the Policy.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; The creation date of the Policy
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The last modified date of the Policy
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The legacy Policy ID.
	PolicyID *string `json:"policyId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyProperties.
func (c ContentKeyPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", c.Created)
	populate(objectMap, "description", c.Description)
	populateTimeRFC3339(objectMap, "lastModified", c.LastModified)
	populate(objectMap, "options", c.Options)
	populate(objectMap, "policyId", c.PolicyID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyProperties.
func (c *ContentKeyPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &c.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &c.LastModified)
			delete(rawMsg, key)
		case "options":
			err = unpopulate(val, &c.Options)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, &c.PolicyID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyRestrictionClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyRestriction() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyOpenRestriction, *ContentKeyPolicyRestriction, *ContentKeyPolicyTokenRestriction, *ContentKeyPolicyUnknownRestriction
type ContentKeyPolicyRestrictionClassification interface {
	// GetContentKeyPolicyRestriction returns the ContentKeyPolicyRestriction content of the underlying type.
	GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction
}

// ContentKeyPolicyRestriction - Base class for Content Key Policy restrictions. A derived class must be used to create a
// restriction.
type ContentKeyPolicyRestriction struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyRestriction.
func (c *ContentKeyPolicyRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return c
}

// ContentKeyPolicyRestrictionTokenKeyClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyRestrictionTokenKey() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyRestrictionTokenKey, *ContentKeyPolicyRsaTokenKey, *ContentKeyPolicySymmetricTokenKey, *ContentKeyPolicyX509CertificateTokenKey
type ContentKeyPolicyRestrictionTokenKeyClassification interface {
	// GetContentKeyPolicyRestrictionTokenKey returns the ContentKeyPolicyRestrictionTokenKey content of the underlying type.
	GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey
}

// ContentKeyPolicyRestrictionTokenKey - Base class for Content Key Policy key for token validation. A derived class must
// be used to create a token key.
type ContentKeyPolicyRestrictionTokenKey struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicyRestrictionTokenKey.
func (c *ContentKeyPolicyRestrictionTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return c
}

// ContentKeyPolicyRsaTokenKey - Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKey struct {
	// REQUIRED; The RSA Parameter exponent
	Exponent []byte `json:"exponent,omitempty"`

	// REQUIRED; The RSA Parameter modulus
	Modulus []byte `json:"modulus,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicyRsaTokenKey.
func (c *ContentKeyPolicyRsaTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return &ContentKeyPolicyRestrictionTokenKey{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c ContentKeyPolicyRsaTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "exponent", c.Exponent, runtime.Base64StdFormat)
	populateByteArray(objectMap, "modulus", c.Modulus, runtime.Base64StdFormat)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyRsaTokenKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c *ContentKeyPolicyRsaTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exponent":
			err = runtime.DecodeByteArray(string(val), &c.Exponent, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "modulus":
			err = runtime.DecodeByteArray(string(val), &c.Modulus, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicySymmetricTokenKey - Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKey struct {
	// REQUIRED; The key value of the key
	KeyValue []byte `json:"keyValue,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicySymmetricTokenKey.
func (c *ContentKeyPolicySymmetricTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return &ContentKeyPolicyRestrictionTokenKey{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c ContentKeyPolicySymmetricTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "keyValue", c.KeyValue, runtime.Base64StdFormat)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c *ContentKeyPolicySymmetricTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyValue":
			err = runtime.DecodeByteArray(string(val), &c.KeyValue, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyTokenClaim - Represents a token claim.
type ContentKeyPolicyTokenClaim struct {
	// Token claim type.
	ClaimType *string `json:"claimType,omitempty"`

	// Token claim value.
	ClaimValue *string `json:"claimValue,omitempty"`
}

// ContentKeyPolicyTokenRestriction - Represents a token restriction. Provided token must match these requirements for successful
// license or key delivery.
type ContentKeyPolicyTokenRestriction struct {
	// REQUIRED; The audience for the token.
	Audience *string `json:"audience,omitempty"`

	// REQUIRED; The token issuer.
	Issuer *string `json:"issuer,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The primary verification key.
	PrimaryVerificationKey ContentKeyPolicyRestrictionTokenKeyClassification `json:"primaryVerificationKey,omitempty"`

	// REQUIRED; The type of token.
	RestrictionTokenType *ContentKeyPolicyRestrictionTokenType `json:"restrictionTokenType,omitempty"`

	// A list of alternative verification keys.
	AlternateVerificationKeys []ContentKeyPolicyRestrictionTokenKeyClassification `json:"alternateVerificationKeys,omitempty"`

	// The OpenID connect discovery document.
	OpenIDConnectDiscoveryDocument *string `json:"openIdConnectDiscoveryDocument,omitempty"`

	// A list of required token claims.
	RequiredClaims []*ContentKeyPolicyTokenClaim `json:"requiredClaims,omitempty"`
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyTokenRestriction.
func (c *ContentKeyPolicyTokenRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return &ContentKeyPolicyRestriction{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyTokenRestriction.
func (c ContentKeyPolicyTokenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateVerificationKeys", c.AlternateVerificationKeys)
	populate(objectMap, "audience", c.Audience)
	populate(objectMap, "issuer", c.Issuer)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyTokenRestriction"
	populate(objectMap, "openIdConnectDiscoveryDocument", c.OpenIDConnectDiscoveryDocument)
	populate(objectMap, "primaryVerificationKey", c.PrimaryVerificationKey)
	populate(objectMap, "requiredClaims", c.RequiredClaims)
	populate(objectMap, "restrictionTokenType", c.RestrictionTokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyTokenRestriction.
func (c *ContentKeyPolicyTokenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateVerificationKeys":
			c.AlternateVerificationKeys, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassificationArray(val)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, &c.Audience)
			delete(rawMsg, key)
		case "issuer":
			err = unpopulate(val, &c.Issuer)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "openIdConnectDiscoveryDocument":
			err = unpopulate(val, &c.OpenIDConnectDiscoveryDocument)
			delete(rawMsg, key)
		case "primaryVerificationKey":
			c.PrimaryVerificationKey, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassification(val)
			delete(rawMsg, key)
		case "requiredClaims":
			err = unpopulate(val, &c.RequiredClaims)
			delete(rawMsg, key)
		case "restrictionTokenType":
			err = unpopulate(val, &c.RestrictionTokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyUnknownConfiguration - Represents a ContentKeyPolicyConfiguration that is unavailable in the current API
// version.
type ContentKeyPolicyUnknownConfiguration struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyUnknownConfiguration.
func (c *ContentKeyPolicyUnknownConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c ContentKeyPolicyUnknownConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c *ContentKeyPolicyUnknownConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyUnknownRestriction - Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestriction struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyUnknownRestriction.
func (c *ContentKeyPolicyUnknownRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return &ContentKeyPolicyRestriction{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c ContentKeyPolicyUnknownRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyUnknownRestriction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c *ContentKeyPolicyUnknownRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyWidevineConfiguration - Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfiguration struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The Widevine template.
	WidevineTemplate *string `json:"widevineTemplate,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyWidevineConfiguration.
func (c *ContentKeyPolicyWidevineConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c ContentKeyPolicyWidevineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration"
	populate(objectMap, "widevineTemplate", c.WidevineTemplate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c *ContentKeyPolicyWidevineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "widevineTemplate":
			err = unpopulate(val, &c.WidevineTemplate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyX509CertificateTokenKey - Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKey struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody []byte `json:"rawBody,omitempty"`
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicyX509CertificateTokenKey.
func (c *ContentKeyPolicyX509CertificateTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return &ContentKeyPolicyRestrictionTokenKey{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c ContentKeyPolicyX509CertificateTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey"
	populateByteArray(objectMap, "rawBody", c.RawBody, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c *ContentKeyPolicyX509CertificateTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "rawBody":
			err = runtime.DecodeByteArray(string(val), &c.RawBody, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyAudio - A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudio struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
}

// GetCodec implements the CodecClassification interface for type CopyAudio.
func (c *CopyAudio) GetCodec() *Codec {
	return &Codec{
		ODataType: c.ODataType,
		Label:     c.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CopyAudio.
func (c CopyAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", c.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.CopyAudio"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyAudio.
func (c *CopyAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyVideo - A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideo struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
}

// GetCodec implements the CodecClassification interface for type CopyVideo.
func (c *CopyVideo) GetCodec() *Codec {
	return &Codec{
		ODataType: c.ODataType,
		Label:     c.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CopyVideo.
func (c CopyVideo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", c.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.CopyVideo"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyVideo.
func (c *CopyVideo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CrossSiteAccessPolicies - The client access policy.
type CrossSiteAccessPolicies struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty"`

	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty"`
}

// DefaultKey - Class to specify properties of default content key for each encryption scheme
type DefaultKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `json:"label,omitempty"`

	// Policy used by Default Key
	PolicyName *string `json:"policyName,omitempty"`
}

// Deinterlace - Describes the de-interlacing settings.
type Deinterlace struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode *DeinterlaceMode `json:"mode,omitempty"`

	// The field parity for de-interlacing, defaults to Auto.
	Parity *DeinterlaceParity `json:"parity,omitempty"`
}

type EdgePolicies struct {
	UsageDataCollectionPolicy *EdgeUsageDataCollectionPolicy `json:"usageDataCollectionPolicy,omitempty"`
}

type EdgeUsageDataCollectionPolicy struct {
	// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataCollectionFrequency *string `json:"dataCollectionFrequency,omitempty"`

	// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataReportingFrequency *string `json:"dataReportingFrequency,omitempty"`

	// Details of Event Hub where the usage will be reported.
	EventHubDetails *EdgeUsageDataEventHub `json:"eventHubDetails,omitempty"`

	// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
	MaxAllowedUnreportedUsageDuration *string `json:"maxAllowedUnreportedUsageDuration,omitempty"`
}

type EdgeUsageDataEventHub struct {
	// Name of the Event Hub where usage will be reported.
	Name *string `json:"name,omitempty"`

	// Namespace of the Event Hub where usage will be reported.
	Namespace *string `json:"namespace,omitempty"`

	// SAS token needed to interact with Event Hub.
	Token *string `json:"token,omitempty"`
}

// EnabledProtocols - Class to specify which protocols are enabled
type EnabledProtocols struct {
	// REQUIRED; Enable DASH protocol or not
	Dash *bool `json:"dash,omitempty"`

	// REQUIRED; Enable Download protocol or not
	Download *bool `json:"download,omitempty"`

	// REQUIRED; Enable HLS protocol or not
	Hls *bool `json:"hls,omitempty"`

	// REQUIRED; Enable SmoothStreaming protocol or not
	SmoothStreaming *bool `json:"smoothStreaming,omitempty"`
}

// EntityNameAvailabilityCheckOutput - The response from the check name availability request.
type EntityNameAvailabilityCheckOutput struct {
	// REQUIRED; Specifies if the name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// Specifies the detailed reason if the name is not available.
	Message *string `json:"message,omitempty"`

	// Specifies the reason if the name is not available.
	Reason *string `json:"reason,omitempty"`
}

// EnvelopeEncryption - Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryption struct {
	// Representing which tracks should not be encrypted
	ClearTracks []*TrackSelection `json:"clearTracks,omitempty"`

	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`

	// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
	// for issuing keys. The template supports replaceable tokens that the service
	// will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId},
	// which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
	// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionURLTemplate *string `json:"customKeyAcquisitionUrlTemplate,omitempty"`

	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EnvelopeEncryption.
func (e EnvelopeEncryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", e.ClearTracks)
	populate(objectMap, "contentKeys", e.ContentKeys)
	populate(objectMap, "customKeyAcquisitionUrlTemplate", e.CustomKeyAcquisitionURLTemplate)
	populate(objectMap, "enabledProtocols", e.EnabledProtocols)
	return json.Marshal(objectMap)
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations.
// (This also follows the OData error response format.).
type ErrorResponse struct {
	// The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// FaceDetectorPreset - Describes all the settings to be used when analyzing a video in order to detect (and optionally redact)
// all the faces present.
type FaceDetectorPreset struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Blur type
	BlurType *BlurType `json:"blurType,omitempty"`

	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions,omitempty"`

	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates
	// a metadata JSON file marking appearances of faces throughout the
	// video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs)
	// detected faces. 3) Redact - This enables a 2-pass process, allowing for
	// selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the
	// source video, and a user-selected subset of IDs that require redaction.
	Mode *FaceRedactorMode `json:"mode,omitempty"`

	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will
	// keep the input video at its original resolution when analyzed. Using
	// "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It
	// will only resize if the video is of higher resolution. For example, a 1920x1080
	// input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to
	// process high resolution video. It may also reduce the cost of using this
	// component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces
	// that end up being too small in the resized video may not be detected.
	Resolution *AnalysisResolution `json:"resolution,omitempty"`
}

// GetPreset implements the PresetClassification interface for type FaceDetectorPreset.
func (f *FaceDetectorPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: f.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FaceDetectorPreset.
func (f FaceDetectorPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blurType", f.BlurType)
	populate(objectMap, "experimentalOptions", f.ExperimentalOptions)
	populate(objectMap, "mode", f.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.FaceDetectorPreset"
	populate(objectMap, "resolution", f.Resolution)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaceDetectorPreset.
func (f *FaceDetectorPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blurType":
			err = unpopulate(val, &f.BlurType)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &f.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &f.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		case "resolution":
			err = unpopulate(val, &f.Resolution)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FilterTrackPropertyCondition - The class to specify one track property condition.
type FilterTrackPropertyCondition struct {
	// REQUIRED; The track property condition operation.
	Operation *FilterTrackPropertyCompareOperation `json:"operation,omitempty"`

	// REQUIRED; The track property type.
	Property *FilterTrackPropertyType `json:"property,omitempty"`

	// REQUIRED; The track property value.
	Value *string `json:"value,omitempty"`
}

// FilterTrackSelection - Representing a list of FilterTrackPropertyConditions to select a track. The filters are combined
// using a logical AND operation.
type FilterTrackSelection struct {
	// REQUIRED; The track selections.
	TrackSelections []*FilterTrackPropertyCondition `json:"trackSelections,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FilterTrackSelection.
func (f FilterTrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", f.TrackSelections)
	return json.Marshal(objectMap)
}

// Filters - Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input
// media before encoding.
type Filters struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop *Rectangle `json:"crop,omitempty"`

	// The de-interlacing settings.
	Deinterlace *Deinterlace `json:"deinterlace,omitempty"`

	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays []OverlayClassification `json:"overlays,omitempty"`

	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation *Rotation `json:"rotation,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Filters.
func (f Filters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "crop", f.Crop)
	populate(objectMap, "deinterlace", f.Deinterlace)
	populate(objectMap, "overlays", f.Overlays)
	populate(objectMap, "rotation", f.Rotation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Filters.
func (f *Filters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crop":
			err = unpopulate(val, &f.Crop)
			delete(rawMsg, key)
		case "deinterlace":
			err = unpopulate(val, &f.Deinterlace)
			delete(rawMsg, key)
		case "overlays":
			f.Overlays, err = unmarshalOverlayClassificationArray(val)
			delete(rawMsg, key)
		case "rotation":
			err = unpopulate(val, &f.Rotation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FirstQuality - Filter First Quality
type FirstQuality struct {
	// REQUIRED; The first quality bitrate.
	Bitrate *int32 `json:"bitrate,omitempty"`
}

// FormatClassification provides polymorphic access to related types.
// Call the interface's GetFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Format, *ImageFormat, *JpgFormat, *Mp4Format, *MultiBitrateFormat, *PNGFormat, *TransportStreamFormat
type FormatClassification interface {
	// GetFormat returns the Format content of the underlying type.
	GetFormat() *Format
}

// Format - Base class for output.
type Format struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetFormat implements the FormatClassification interface for type Format.
func (f *Format) GetFormat() *Format { return f }

// FromAllInputFile - An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks
// property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to
// allow selection of a single track across a set of input files.
type FromAllInputFile struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []TrackDescriptorClassification `json:"includedTracks,omitempty"`
}

// GetInputDefinition implements the InputDefinitionClassification interface for type FromAllInputFile.
func (f *FromAllInputFile) GetInputDefinition() *InputDefinition {
	return &InputDefinition{
		ODataType:      f.ODataType,
		IncludedTracks: f.IncludedTracks,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FromAllInputFile.
func (f FromAllInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", f.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.FromAllInputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FromAllInputFile.
func (f *FromAllInputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			f.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FromEachInputFile - An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks
// property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select
// tracks from each file given.
type FromEachInputFile struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []TrackDescriptorClassification `json:"includedTracks,omitempty"`
}

// GetInputDefinition implements the InputDefinitionClassification interface for type FromEachInputFile.
func (f *FromEachInputFile) GetInputDefinition() *InputDefinition {
	return &InputDefinition{
		ODataType:      f.ODataType,
		IncludedTracks: f.IncludedTracks,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FromEachInputFile.
func (f FromEachInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", f.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.FromEachInputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FromEachInputFile.
func (f *FromEachInputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			f.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// H264Layer - Describes the settings to be used when encoding the input video into a desired output bitrate layer with the
// H.264 video codec.
type H264Layer struct {
	// REQUIRED; The average bitrate in bits per second at which to encode the input video when generating this layer. This is
	// a required field.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on
	// whenever the video profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`

	// The number of B-frames to be used when encoding this layer. If not specified, the encoder chooses an appropriate number
	// based on the video profile and level.
	BFrames *int32 `json:"bFrames,omitempty"`

	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds.
	// The default is 5 seconds (for example, PT5S).
	BufferWindow *string `json:"bufferWindow,omitempty"`

	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the
	// profile and level.
	EntropyMode *EntropyMode `json:"entropyMode,omitempty"`

	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N
	// are integers (For example, 30000/1001), or in the form of a number (For example,
	// 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified,
	// the encoder will use the same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified,
	// the default is Auto, which lets the encoder choose the Level that is
	// appropriate for this layer.
	Level *string `json:"level,omitempty"`

	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults
	// to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`

	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile *H264VideoProfile `json:"profile,omitempty"`

	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate
	// number based on the encoder complexity setting.
	ReferenceFrames *int32 `json:"referenceFrames,omitempty"`

	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will
	// use a single slice for each frame.
	Slices *int32 `json:"slices,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetLayer implements the LayerClassification interface for type H264Layer.
func (h *H264Layer) GetLayer() *Layer {
	return &Layer{
		ODataType: h.ODataType,
		Width:     h.Width,
		Height:    h.Height,
		Label:     h.Label,
	}
}

// GetVideoLayer implements the VideoLayerClassification interface for type H264Layer.
func (h *H264Layer) GetVideoLayer() *VideoLayer {
	return &VideoLayer{
		Bitrate:        h.Bitrate,
		MaxBitrate:     h.MaxBitrate,
		BFrames:        h.BFrames,
		FrameRate:      h.FrameRate,
		Slices:         h.Slices,
		AdaptiveBFrame: h.AdaptiveBFrame,
		ODataType:      h.ODataType,
		Width:          h.Width,
		Height:         h.Height,
		Label:          h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H264Layer.
func (h H264Layer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adaptiveBFrame", h.AdaptiveBFrame)
	populate(objectMap, "bFrames", h.BFrames)
	populate(objectMap, "bitrate", h.Bitrate)
	populate(objectMap, "bufferWindow", h.BufferWindow)
	populate(objectMap, "entropyMode", h.EntropyMode)
	populate(objectMap, "frameRate", h.FrameRate)
	populate(objectMap, "height", h.Height)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "level", h.Level)
	populate(objectMap, "maxBitrate", h.MaxBitrate)
	objectMap["@odata.type"] = "#Microsoft.Media.H264Layer"
	populate(objectMap, "profile", h.Profile)
	populate(objectMap, "referenceFrames", h.ReferenceFrames)
	populate(objectMap, "slices", h.Slices)
	populate(objectMap, "width", h.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H264Layer.
func (h *H264Layer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptiveBFrame":
			err = unpopulate(val, &h.AdaptiveBFrame)
			delete(rawMsg, key)
		case "bFrames":
			err = unpopulate(val, &h.BFrames)
			delete(rawMsg, key)
		case "bitrate":
			err = unpopulate(val, &h.Bitrate)
			delete(rawMsg, key)
		case "bufferWindow":
			err = unpopulate(val, &h.BufferWindow)
			delete(rawMsg, key)
		case "entropyMode":
			err = unpopulate(val, &h.EntropyMode)
			delete(rawMsg, key)
		case "frameRate":
			err = unpopulate(val, &h.FrameRate)
			delete(rawMsg, key)
		case "height":
			err = unpopulate(val, &h.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &h.Level)
			delete(rawMsg, key)
		case "maxBitrate":
			err = unpopulate(val, &h.MaxBitrate)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, &h.Profile)
			delete(rawMsg, key)
		case "referenceFrames":
			err = unpopulate(val, &h.ReferenceFrames)
			delete(rawMsg, key)
		case "slices":
			err = unpopulate(val, &h.Slices)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &h.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// H264Video - Describes all the properties for encoding a video with the H.264 codec.
type H264Video struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity *H264Complexity `json:"complexity,omitempty"`

	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601
	// format. The default is 2 seconds(PT2S). Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// The collection of output H.264 layers to be produced by the encoder.
	Layers []*H264Layer `json:"layers,omitempty"`

	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag
	// should be set to true only when the encoder is being configured to produce a
	// single output video.
	SceneChangeDetection *bool `json:"sceneChangeDetection,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetCodec implements the CodecClassification interface for type H264Video.
func (h *H264Video) GetCodec() *Codec {
	return &Codec{
		ODataType: h.ODataType,
		Label:     h.Label,
	}
}

// GetVideo implements the VideoClassification interface for type H264Video.
func (h *H264Video) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: h.KeyFrameInterval,
		StretchMode:      h.StretchMode,
		SyncMode:         h.SyncMode,
		ODataType:        h.ODataType,
		Label:            h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H264Video.
func (h H264Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "keyFrameInterval", h.KeyFrameInterval)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "layers", h.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.H264Video"
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	populate(objectMap, "stretchMode", h.StretchMode)
	populate(objectMap, "syncMode", h.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H264Video.
func (h *H264Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, &h.Complexity)
			delete(rawMsg, key)
		case "keyFrameInterval":
			err = unpopulate(val, &h.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &h.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, &h.SceneChangeDetection)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &h.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &h.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// H265Layer - Describes the settings to be used when encoding the input video into a desired output bitrate layer with the
// H.265 video codec.
type H265Layer struct {
	// REQUIRED; The average bitrate in bits per second at which to encode the input video when generating this layer. For example:
	// a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a
	// required field.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will
	// turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`

	// The number of B-frames to be used when encoding this layer. If not specified, the encoder chooses an appropriate number
	// based on the video profile and level.
	BFrames *int32 `json:"bFrames,omitempty"`

	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds.
	// The default is 5 seconds (for example, PT5S).
	BufferWindow *string `json:"bufferWindow,omitempty"`

	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N
	// are integers (For example, 30000/1001), or in the form of a number (For example,
	// 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified,
	// the encoder will use the same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified,
	// the default is Auto, which lets the encoder choose the Level that is
	// appropriate for this layer.
	Level *string `json:"level,omitempty"`

	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults
	// to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`

	// We currently support Main. Default is Auto.
	Profile *H265VideoProfile `json:"profile,omitempty"`

	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate
	// number based on the encoder complexity setting.
	ReferenceFrames *int32 `json:"referenceFrames,omitempty"`

	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will
	// use a single slice for each frame.
	Slices *int32 `json:"slices,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetH265VideoLayer implements the H265VideoLayerClassification interface for type H265Layer.
func (h *H265Layer) GetH265VideoLayer() *H265VideoLayer {
	return &H265VideoLayer{
		Bitrate:        h.Bitrate,
		MaxBitrate:     h.MaxBitrate,
		BFrames:        h.BFrames,
		FrameRate:      h.FrameRate,
		Slices:         h.Slices,
		AdaptiveBFrame: h.AdaptiveBFrame,
		ODataType:      h.ODataType,
		Width:          h.Width,
		Height:         h.Height,
		Label:          h.Label,
	}
}

// GetLayer implements the LayerClassification interface for type H265Layer.
func (h *H265Layer) GetLayer() *Layer {
	return &Layer{
		ODataType: h.ODataType,
		Width:     h.Width,
		Height:    h.Height,
		Label:     h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H265Layer.
func (h H265Layer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adaptiveBFrame", h.AdaptiveBFrame)
	populate(objectMap, "bFrames", h.BFrames)
	populate(objectMap, "bitrate", h.Bitrate)
	populate(objectMap, "bufferWindow", h.BufferWindow)
	populate(objectMap, "frameRate", h.FrameRate)
	populate(objectMap, "height", h.Height)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "level", h.Level)
	populate(objectMap, "maxBitrate", h.MaxBitrate)
	objectMap["@odata.type"] = "#Microsoft.Media.H265Layer"
	populate(objectMap, "profile", h.Profile)
	populate(objectMap, "referenceFrames", h.ReferenceFrames)
	populate(objectMap, "slices", h.Slices)
	populate(objectMap, "width", h.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265Layer.
func (h *H265Layer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptiveBFrame":
			err = unpopulate(val, &h.AdaptiveBFrame)
			delete(rawMsg, key)
		case "bFrames":
			err = unpopulate(val, &h.BFrames)
			delete(rawMsg, key)
		case "bitrate":
			err = unpopulate(val, &h.Bitrate)
			delete(rawMsg, key)
		case "bufferWindow":
			err = unpopulate(val, &h.BufferWindow)
			delete(rawMsg, key)
		case "frameRate":
			err = unpopulate(val, &h.FrameRate)
			delete(rawMsg, key)
		case "height":
			err = unpopulate(val, &h.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &h.Level)
			delete(rawMsg, key)
		case "maxBitrate":
			err = unpopulate(val, &h.MaxBitrate)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, &h.Profile)
			delete(rawMsg, key)
		case "referenceFrames":
			err = unpopulate(val, &h.ReferenceFrames)
			delete(rawMsg, key)
		case "slices":
			err = unpopulate(val, &h.Slices)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &h.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// H265Video - Describes all the properties for encoding a video with the H.265 codec.
type H265Video struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Tells the encoder how to choose its encoding settings. Quality will provide for a higher compression ratio but at a higher
	// cost and longer compute time. Speed will produce a relatively larger file but
	// is faster and more economical. The default value is Balanced.
	Complexity *H265Complexity `json:"complexity,omitempty"`

	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601
	// format. The default is 2 seconds(PT2S). Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// The collection of output H.265 layers to be produced by the encoder.
	Layers []*H265Layer `json:"layers,omitempty"`

	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false.
	// This flag should be set to true only when the encoder is being configured to
	// produce a single output video.
	SceneChangeDetection *bool `json:"sceneChangeDetection,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetCodec implements the CodecClassification interface for type H265Video.
func (h *H265Video) GetCodec() *Codec {
	return &Codec{
		ODataType: h.ODataType,
		Label:     h.Label,
	}
}

// GetVideo implements the VideoClassification interface for type H265Video.
func (h *H265Video) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: h.KeyFrameInterval,
		StretchMode:      h.StretchMode,
		SyncMode:         h.SyncMode,
		ODataType:        h.ODataType,
		Label:            h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H265Video.
func (h H265Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "keyFrameInterval", h.KeyFrameInterval)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "layers", h.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.H265Video"
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	populate(objectMap, "stretchMode", h.StretchMode)
	populate(objectMap, "syncMode", h.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265Video.
func (h *H265Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, &h.Complexity)
			delete(rawMsg, key)
		case "keyFrameInterval":
			err = unpopulate(val, &h.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &h.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, &h.SceneChangeDetection)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &h.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &h.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// H265VideoLayerClassification provides polymorphic access to related types.
// Call the interface's GetH265VideoLayer() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H265Layer, *H265VideoLayer
type H265VideoLayerClassification interface {
	LayerClassification
	// GetH265VideoLayer returns the H265VideoLayer content of the underlying type.
	GetH265VideoLayer() *H265VideoLayer
}

// H265VideoLayer - Describes the settings to be used when encoding the input video into a desired output bitrate layer.
type H265VideoLayer struct {
	// REQUIRED; The average bitrate in bits per second at which to encode the input video when generating this layer. For example:
	// a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a
	// required field.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will
	// turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`

	// The number of B-frames to be used when encoding this layer. If not specified, the encoder chooses an appropriate number
	// based on the video profile and level.
	BFrames *int32 `json:"bFrames,omitempty"`

	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N
	// are integers (For example, 30000/1001), or in the form of a number (For example,
	// 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified,
	// the encoder will use the same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults
	// to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`

	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will
	// use a single slice for each frame.
	Slices *int32 `json:"slices,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetH265VideoLayer implements the H265VideoLayerClassification interface for type H265VideoLayer.
func (h *H265VideoLayer) GetH265VideoLayer() *H265VideoLayer { return h }

// GetLayer implements the LayerClassification interface for type H265VideoLayer.
func (h *H265VideoLayer) GetLayer() *Layer {
	return &Layer{
		ODataType: h.ODataType,
		Width:     h.Width,
		Height:    h.Height,
		Label:     h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H265VideoLayer.
func (h H265VideoLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adaptiveBFrame", h.AdaptiveBFrame)
	populate(objectMap, "bFrames", h.BFrames)
	populate(objectMap, "bitrate", h.Bitrate)
	populate(objectMap, "frameRate", h.FrameRate)
	populate(objectMap, "height", h.Height)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "maxBitrate", h.MaxBitrate)
	objectMap["@odata.type"] = "#Microsoft.Media.H265VideoLayer"
	populate(objectMap, "slices", h.Slices)
	populate(objectMap, "width", h.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265VideoLayer.
func (h *H265VideoLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptiveBFrame":
			err = unpopulate(val, &h.AdaptiveBFrame)
			delete(rawMsg, key)
		case "bFrames":
			err = unpopulate(val, &h.BFrames)
			delete(rawMsg, key)
		case "bitrate":
			err = unpopulate(val, &h.Bitrate)
			delete(rawMsg, key)
		case "frameRate":
			err = unpopulate(val, &h.FrameRate)
			delete(rawMsg, key)
		case "height":
			err = unpopulate(val, &h.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "maxBitrate":
			err = unpopulate(val, &h.MaxBitrate)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "slices":
			err = unpopulate(val, &h.Slices)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &h.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Hls - HTTP Live Streaming (HLS) packing setting for the live output.
type Hls struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not
	// affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment *int32 `json:"fragmentsPerTsSegment,omitempty"`
}

// IPAccessControl - The IP access control.
type IPAccessControl struct {
	// The IP allow list.
	Allow []*IPRange `json:"allow,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPAccessControl.
func (i IPAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allow", i.Allow)
	return json.Marshal(objectMap)
}

// IPRange - The IP address range in the CIDR scheme.
type IPRange struct {
	// The IP address.
	Address *string `json:"address,omitempty"`

	// The friendly name for the IP address range.
	Name *string `json:"name,omitempty"`

	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int32 `json:"subnetPrefixLength,omitempty"`
}

// ImageClassification provides polymorphic access to related types.
// Call the interface's GetImage() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Image, *JpgImage, *PNGImage
type ImageClassification interface {
	VideoClassification
	// GetImage returns the Image content of the underlying type.
	GetImage() *Image
}

// Image - Describes the basic properties for generating thumbnails from the input video
type Image struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format
	// (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at
	// the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports
	// a macro {Best}, which tells the encoder to select the best thumbnail from
	// the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and
	// Range. The default value is macro {Best}.
	Start *string `json:"start,omitempty"`

	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601
	// format. The default is 2 seconds(PT2S). Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value
	// can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30
	// seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If
	// this value is 1, it means only producing one thumbnail at start time), or a
	// relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default
	// value is 100%, which means to stop at the end of the stream.
	Range *string `json:"range,omitempty"`

	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image
	// every 5 seconds), or a frame count (For example, 30 for one image every 30
	// frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step
	// value will affect the first generated thumbnail, which may not be exactly the
	// one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between
	// start time and Step position from start time as the first output. As the
	// default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one
	// specified at start time. Try to select reasonable value for Step if the first
	// thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `json:"step,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetCodec implements the CodecClassification interface for type Image.
func (i *Image) GetCodec() *Codec {
	return &Codec{
		ODataType: i.ODataType,
		Label:     i.Label,
	}
}

// GetImage implements the ImageClassification interface for type Image.
func (i *Image) GetImage() *Image { return i }

// GetVideo implements the VideoClassification interface for type Image.
func (i *Image) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: i.KeyFrameInterval,
		StretchMode:      i.StretchMode,
		SyncMode:         i.SyncMode,
		ODataType:        i.ODataType,
		Label:            i.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Image.
func (i Image) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", i.KeyFrameInterval)
	populate(objectMap, "label", i.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Image"
	populate(objectMap, "range", i.Range)
	populate(objectMap, "start", i.Start)
	populate(objectMap, "step", i.Step)
	populate(objectMap, "stretchMode", i.StretchMode)
	populate(objectMap, "syncMode", i.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Image.
func (i *Image) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &i.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &i.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &i.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &i.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &i.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &i.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &i.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ImageFormatClassification provides polymorphic access to related types.
// Call the interface's GetImageFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ImageFormat, *JpgFormat, *PNGFormat
type ImageFormatClassification interface {
	FormatClassification
	// GetImageFormat returns the ImageFormat content of the underlying type.
	GetImageFormat() *ImageFormat
}

// ImageFormat - Describes the properties for an output image file.
type ImageFormat struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetFormat implements the FormatClassification interface for type ImageFormat.
func (i *ImageFormat) GetFormat() *Format {
	return &Format{
		ODataType:       i.ODataType,
		FilenamePattern: i.FilenamePattern,
	}
}

// GetImageFormat implements the ImageFormatClassification interface for type ImageFormat.
func (i *ImageFormat) GetImageFormat() *ImageFormat { return i }

// MarshalJSON implements the json.Marshaller interface for type ImageFormat.
func (i ImageFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", i.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.ImageFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageFormat.
func (i *ImageFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &i.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InputDefinitionClassification provides polymorphic access to related types.
// Call the interface's GetInputDefinition() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FromAllInputFile, *FromEachInputFile, *InputDefinition, *InputFile
type InputDefinitionClassification interface {
	// GetInputDefinition returns the InputDefinition content of the underlying type.
	GetInputDefinition() *InputDefinition
}

// InputDefinition - Base class for defining an input. Use sub classes of this class to specify tracks selections and related
// metadata.
type InputDefinition struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []TrackDescriptorClassification `json:"includedTracks,omitempty"`
}

// GetInputDefinition implements the InputDefinitionClassification interface for type InputDefinition.
func (i *InputDefinition) GetInputDefinition() *InputDefinition { return i }

// MarshalJSON implements the json.Marshaller interface for type InputDefinition.
func (i InputDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", i.IncludedTracks)
	objectMap["@odata.type"] = i.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputDefinition.
func (i *InputDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InputFile - An InputDefinition for a single file. TrackSelections are scoped to the file specified.
type InputFile struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Name of the file that this input definition applies to.
	Filename *string `json:"filename,omitempty"`

	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []TrackDescriptorClassification `json:"includedTracks,omitempty"`
}

// GetInputDefinition implements the InputDefinitionClassification interface for type InputFile.
func (i *InputFile) GetInputDefinition() *InputDefinition {
	return &InputDefinition{
		ODataType:      i.ODataType,
		IncludedTracks: i.IncludedTracks,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InputFile.
func (i InputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filename", i.Filename)
	populate(objectMap, "includedTracks", i.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.InputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputFile.
func (i *InputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filename":
			err = unpopulate(val, &i.Filename)
			delete(rawMsg, key)
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Job - A Job resource type. The progress and state can be obtained by polling a Job or subscribing to events using EventGrid.
type Job struct {
	// The resource properties.
	Properties *JobProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// JobCollection - A collection of Job items.
type JobCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of Job items.
	Value []*Job `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobCollection.
func (j JobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", j.ODataNextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// JobError - Details of JobOutput errors.
type JobError struct {
	// READ-ONLY; Helps with categorization of errors.
	Category *JobErrorCategory `json:"category,omitempty" azure:"ro"`

	// READ-ONLY; Error code describing the error.
	Code *JobErrorCode `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; An array of details about specific errors that led to this reported error.
	Details []*JobErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; A human-readable language-dependent representation of the error.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via
	// Azure Portal.
	Retry *JobRetry `json:"retry,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobError.
func (j JobError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", j.Category)
	populate(objectMap, "code", j.Code)
	populate(objectMap, "details", j.Details)
	populate(objectMap, "message", j.Message)
	populate(objectMap, "retry", j.Retry)
	return json.Marshal(objectMap)
}

// JobErrorDetail - Details of JobOutput errors.
type JobErrorDetail struct {
	// READ-ONLY; Code describing the error detail.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; A human-readable representation of the error.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// JobInputClassification provides polymorphic access to related types.
// Call the interface's GetJobInput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *JobInput, *JobInputAsset, *JobInputClip, *JobInputHTTP, *JobInputSequence, *JobInputs
type JobInputClassification interface {
	// GetJobInput returns the JobInput content of the underlying type.
	GetJobInput() *JobInput
}

// JobInput - Base class for inputs to a Job.
type JobInput struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInput.
func (j *JobInput) GetJobInput() *JobInput { return j }

// JobInputAsset - Represents an Asset for input into a Job.
type JobInputAsset struct {
	// REQUIRED; The name of the input Asset.
	AssetName *string `json:"assetName,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End ClipTimeClassification `json:"end,omitempty"`

	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service
	// responses to prevent sensitive data exposure.
	Files []*string `json:"files,omitempty"`

	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []InputDefinitionClassification `json:"inputDefinitions,omitempty"`

	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform
	// can be authored so as to take an image file with the label 'xyz' and
	// apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should
	// be the image file, and it should have the label 'xyz'.
	Label *string `json:"label,omitempty"`

	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input
	// media.
	Start ClipTimeClassification `json:"start,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInputAsset.
func (j *JobInputAsset) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputAsset.
func (j *JobInputAsset) GetJobInputClip() *JobInputClip {
	return &JobInputClip{
		Files:            j.Files,
		Start:            j.Start,
		End:              j.End,
		Label:            j.Label,
		InputDefinitions: j.InputDefinitions,
		ODataType:        j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputAsset.
func (j JobInputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", j.AssetName)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputAsset"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputAsset.
func (j *JobInputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &j.AssetName)
			delete(rawMsg, key)
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobInputClipClassification provides polymorphic access to related types.
// Call the interface's GetJobInputClip() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *JobInputAsset, *JobInputClip, *JobInputHTTP
type JobInputClipClassification interface {
	JobInputClassification
	// GetJobInputClip returns the JobInputClip content of the underlying type.
	GetJobInputClip() *JobInputClip
}

// JobInputClip - Represents input files for a Job.
type JobInputClip struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End ClipTimeClassification `json:"end,omitempty"`

	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service
	// responses to prevent sensitive data exposure.
	Files []*string `json:"files,omitempty"`

	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []InputDefinitionClassification `json:"inputDefinitions,omitempty"`

	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform
	// can be authored so as to take an image file with the label 'xyz' and
	// apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should
	// be the image file, and it should have the label 'xyz'.
	Label *string `json:"label,omitempty"`

	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input
	// media.
	Start ClipTimeClassification `json:"start,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInputClip.
func (j *JobInputClip) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputClip.
func (j *JobInputClip) GetJobInputClip() *JobInputClip { return j }

// MarshalJSON implements the json.Marshaller interface for type JobInputClip.
func (j JobInputClip) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputClip"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputClip.
func (j *JobInputClip) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobInputHTTP - Represents HTTPS job input.
type JobInputHTTP struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided
	// file list is assumed to be fully qualified uris. Maximum length of 4000
	// characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
	BaseURI *string `json:"baseUri,omitempty"`

	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End ClipTimeClassification `json:"end,omitempty"`

	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service
	// responses to prevent sensitive data exposure.
	Files []*string `json:"files,omitempty"`

	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []InputDefinitionClassification `json:"inputDefinitions,omitempty"`

	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform
	// can be authored so as to take an image file with the label 'xyz' and
	// apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should
	// be the image file, and it should have the label 'xyz'.
	Label *string `json:"label,omitempty"`

	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input
	// media.
	Start ClipTimeClassification `json:"start,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInputHTTP.
func (j *JobInputHTTP) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputHTTP.
func (j *JobInputHTTP) GetJobInputClip() *JobInputClip {
	return &JobInputClip{
		Files:            j.Files,
		Start:            j.Start,
		End:              j.End,
		Label:            j.Label,
		InputDefinitions: j.InputDefinitions,
		ODataType:        j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputHTTP.
func (j JobInputHTTP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", j.BaseURI)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputHttp"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputHTTP.
func (j *JobInputHTTP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
			err = unpopulate(val, &j.BaseURI)
			delete(rawMsg, key)
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobInputSequence - A Sequence contains an ordered list of Clips where each clip is a JobInput. The Sequence will be treated
// as a single input.
type JobInputSequence struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// JobInputs that make up the timeline.
	Inputs []JobInputClipClassification `json:"inputs,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInputSequence.
func (j *JobInputSequence) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputSequence.
func (j JobInputSequence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputs", j.Inputs)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputSequence"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputSequence.
func (j *JobInputSequence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClipClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobInputs - Describes a list of inputs to a Job.
type JobInputs struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// List of inputs to a Job.
	Inputs []JobInputClassification `json:"inputs,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInputs.
func (j *JobInputs) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputs.
func (j JobInputs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputs", j.Inputs)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputs"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputs.
func (j *JobInputs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobOutputClassification provides polymorphic access to related types.
// Call the interface's GetJobOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *JobOutput, *JobOutputAsset
type JobOutputClassification interface {
	// GetJobOutput returns the JobOutput content of the underlying type.
	GetJobOutput() *JobOutput
}

// JobOutput - Describes all the properties of a JobOutput.
type JobOutput struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more
	// than one TransformOutput, whereby your Job has more than one JobOutput. In
	// such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the
	// Transform. Subsequently, when you retrieve the Job, either through events or on a
	// GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}'
	// will be used, where the preset name is the name of the
	// preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the
	// Job. Note that this index is the same as the relative index of the corresponding
	// TransformOutput within its Transform.
	Label *string `json:"label,omitempty"`

	// A preset used to override the preset in the corresponding transform output.
	PresetOverride PresetClassification `json:"presetOverride,omitempty"`

	// READ-ONLY; The UTC date and time at which this Job Output finished processing.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; If the JobOutput is in the Error state, it contains the details of the error.
	Error *JobError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate
	// and not intended to be used to predict Job completion times. To determine if the
	// JobOutput is complete, use the State property.
	Progress *int32 `json:"progress,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job Output began processing.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; Describes the state of the JobOutput.
	State *JobState `json:"state,omitempty" azure:"ro"`
}

// GetJobOutput implements the JobOutputClassification interface for type JobOutput.
func (j *JobOutput) GetJobOutput() *JobOutput { return j }

// MarshalJSON implements the json.Marshaller interface for type JobOutput.
func (j JobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = j.ODataType
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutput.
func (j *JobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobOutputAsset - Represents an Asset used as a JobOutput.
type JobOutputAsset struct {
	// REQUIRED; The name of the output Asset.
	AssetName *string `json:"assetName,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more
	// than one TransformOutput, whereby your Job has more than one JobOutput. In
	// such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the
	// Transform. Subsequently, when you retrieve the Job, either through events or on a
	// GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}'
	// will be used, where the preset name is the name of the
	// preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the
	// Job. Note that this index is the same as the relative index of the corresponding
	// TransformOutput within its Transform.
	Label *string `json:"label,omitempty"`

	// A preset used to override the preset in the corresponding transform output.
	PresetOverride PresetClassification `json:"presetOverride,omitempty"`

	// READ-ONLY; The UTC date and time at which this Job Output finished processing.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; If the JobOutput is in the Error state, it contains the details of the error.
	Error *JobError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate
	// and not intended to be used to predict Job completion times. To determine if the
	// JobOutput is complete, use the State property.
	Progress *int32 `json:"progress,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job Output began processing.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; Describes the state of the JobOutput.
	State *JobState `json:"state,omitempty" azure:"ro"`
}

// GetJobOutput implements the JobOutputClassification interface for type JobOutputAsset.
func (j *JobOutputAsset) GetJobOutput() *JobOutput {
	return &JobOutput{
		ODataType:      j.ODataType,
		Error:          j.Error,
		PresetOverride: j.PresetOverride,
		State:          j.State,
		Progress:       j.Progress,
		Label:          j.Label,
		StartTime:      j.StartTime,
		EndTime:        j.EndTime,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobOutputAsset.
func (j JobOutputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", j.AssetName)
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobOutputAsset"
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutputAsset.
func (j *JobOutputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &j.AssetName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobProperties - Properties of the Job.
type JobProperties struct {
	// REQUIRED; The inputs for the Job.
	Input JobInputClassification `json:"input,omitempty"`

	// REQUIRED; The outputs for the Job.
	Outputs []JobOutputClassification `json:"outputs,omitempty"`

	// Customer provided key, value pairs that will be returned in Job and JobOutput state events.
	CorrelationData map[string]*string `json:"correlationData,omitempty"`

	// Optional customer supplied description of the Job.
	Description *string `json:"description,omitempty"`

	// Priority with which the job should be processed. Higher priority jobs are processed before lower priority jobs. If not
	// set, the default is normal.
	Priority *Priority `json:"priority,omitempty"`

	// READ-ONLY; The UTC date and time when the customer has created the Job, in 'YYYY-MM-DDThh:mm:ssZ' format.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job finished processing.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time when the customer has last updated the Job, in 'YYYY-MM-DDThh:mm:ssZ' format.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job began processing.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the job.
	State *JobState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "correlationData", j.CorrelationData)
	populateTimeRFC3339(objectMap, "created", j.Created)
	populate(objectMap, "description", j.Description)
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "input", j.Input)
	populateTimeRFC3339(objectMap, "lastModified", j.LastModified)
	populate(objectMap, "outputs", j.Outputs)
	populate(objectMap, "priority", j.Priority)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationData":
			err = unpopulate(val, &j.CorrelationData)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &j.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "input":
			j.Input, err = unmarshalJobInputClassification(val)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &j.LastModified)
			delete(rawMsg, key)
		case "outputs":
			j.Outputs, err = unmarshalJobOutputClassificationArray(val)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, &j.Priority)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobsClientCancelJobOptions contains the optional parameters for the JobsClient.CancelJob method.
type JobsClientCancelJobOptions struct {
	// placeholder for future optional parameters
}

// JobsClientCreateOptions contains the optional parameters for the JobsClient.Create method.
type JobsClientCreateOptions struct {
	// placeholder for future optional parameters
}

// JobsClientDeleteOptions contains the optional parameters for the JobsClient.Delete method.
type JobsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobsClientGetOptions contains the optional parameters for the JobsClient.Get method.
type JobsClientGetOptions struct {
	// placeholder for future optional parameters
}

// JobsClientListOptions contains the optional parameters for the JobsClient.List method.
type JobsClientListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
}

// JobsClientUpdateOptions contains the optional parameters for the JobsClient.Update method.
type JobsClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// JpgFormat - Describes the settings for producing JPEG thumbnails.
type JpgFormat struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetFormat implements the FormatClassification interface for type JpgFormat.
func (j *JpgFormat) GetFormat() *Format {
	return &Format{
		ODataType:       j.ODataType,
		FilenamePattern: j.FilenamePattern,
	}
}

// GetImageFormat implements the ImageFormatClassification interface for type JpgFormat.
func (j *JpgFormat) GetImageFormat() *ImageFormat {
	return &ImageFormat{
		ODataType:       j.ODataType,
		FilenamePattern: j.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JpgFormat.
func (j JpgFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", j.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgFormat.
func (j *JpgFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &j.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JpgImage - Describes the properties for producing a series of JPEG images from the input video.
type JpgImage struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format
	// (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at
	// the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports
	// a macro {Best}, which tells the encoder to select the best thumbnail from
	// the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and
	// Range. The default value is macro {Best}.
	Start *string `json:"start,omitempty"`

	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601
	// format. The default is 2 seconds(PT2S). Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// A collection of output JPEG image layers to be produced by the encoder.
	Layers []*JpgLayer `json:"layers,omitempty"`

	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value
	// can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30
	// seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If
	// this value is 1, it means only producing one thumbnail at start time), or a
	// relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default
	// value is 100%, which means to stop at the end of the stream.
	Range *string `json:"range,omitempty"`

	// Sets the number of columns used in thumbnail sprite image. The number of rows are automatically calculated and a VTT file
	// is generated with the coordinate mappings for each thumbnail in the sprite.
	// Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will
	// not go beyond JPEG maximum pixel resolution limit 65535x65535.
	SpriteColumn *int32 `json:"spriteColumn,omitempty"`

	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image
	// every 5 seconds), or a frame count (For example, 30 for one image every 30
	// frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step
	// value will affect the first generated thumbnail, which may not be exactly the
	// one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between
	// start time and Step position from start time as the first output. As the
	// default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one
	// specified at start time. Try to select reasonable value for Step if the first
	// thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `json:"step,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetCodec implements the CodecClassification interface for type JpgImage.
func (j *JpgImage) GetCodec() *Codec {
	return &Codec{
		ODataType: j.ODataType,
		Label:     j.Label,
	}
}

// GetImage implements the ImageClassification interface for type JpgImage.
func (j *JpgImage) GetImage() *Image {
	return &Image{
		Start:            j.Start,
		Step:             j.Step,
		Range:            j.Range,
		KeyFrameInterval: j.KeyFrameInterval,
		StretchMode:      j.StretchMode,
		SyncMode:         j.SyncMode,
		ODataType:        j.ODataType,
		Label:            j.Label,
	}
}

// GetVideo implements the VideoClassification interface for type JpgImage.
func (j *JpgImage) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: j.KeyFrameInterval,
		StretchMode:      j.StretchMode,
		SyncMode:         j.SyncMode,
		ODataType:        j.ODataType,
		Label:            j.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JpgImage.
func (j JpgImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", j.KeyFrameInterval)
	populate(objectMap, "label", j.Label)
	populate(objectMap, "layers", j.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgImage"
	populate(objectMap, "range", j.Range)
	populate(objectMap, "spriteColumn", j.SpriteColumn)
	populate(objectMap, "start", j.Start)
	populate(objectMap, "step", j.Step)
	populate(objectMap, "stretchMode", j.StretchMode)
	populate(objectMap, "syncMode", j.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgImage.
func (j *JpgImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &j.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &j.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &j.Range)
			delete(rawMsg, key)
		case "spriteColumn":
			err = unpopulate(val, &j.SpriteColumn)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &j.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &j.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &j.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &j.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JpgLayer - Describes the settings to produce a JPEG image from the input video.
type JpgLayer struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int32 `json:"quality,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetLayer implements the LayerClassification interface for type JpgLayer.
func (j *JpgLayer) GetLayer() *Layer {
	return &Layer{
		ODataType: j.ODataType,
		Width:     j.Width,
		Height:    j.Height,
		Label:     j.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JpgLayer.
func (j JpgLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "height", j.Height)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgLayer"
	populate(objectMap, "quality", j.Quality)
	populate(objectMap, "width", j.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgLayer.
func (j *JpgLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "height":
			err = unpopulate(val, &j.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "quality":
			err = unpopulate(val, &j.Quality)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &j.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type KeyDelivery struct {
	// The access control properties for Key Delivery.
	AccessControl *AccessControl `json:"accessControl,omitempty"`
}

type KeyVaultProperties struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1)
	// or reference a key without a version (for example
	// https://vault/keys/mykey).
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// READ-ONLY; The current key used to encrypt the Media Services account, including the key version.
	CurrentKeyIdentifier *string `json:"currentKeyIdentifier,omitempty" azure:"ro"`
}

// LayerClassification provides polymorphic access to related types.
// Call the interface's GetLayer() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H264Layer, *H265Layer, *H265VideoLayer, *JpgLayer, *Layer, *PNGLayer, *VideoLayer
type LayerClassification interface {
	// GetLayer returns the Layer content of the underlying type.
	GetLayer() *Layer
}

// Layer - The encoder can be configured to produce video and/or images (thumbnails) at different resolutions, by specifying
// a layer for each desired resolution. A layer represents the properties for the video
// or image at a resolution.
type Layer struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetLayer implements the LayerClassification interface for type Layer.
func (l *Layer) GetLayer() *Layer { return l }

// ListContainerSasInput - The parameters to the list SAS request.
type ListContainerSasInput struct {
	// The SAS URL expiration time. This must be less than 24 hours from the current time.
	ExpiryTime *time.Time `json:"expiryTime,omitempty"`

	// The permissions to set on the SAS URL.
	Permissions *AssetContainerPermission `json:"permissions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListContainerSasInput.
func (l ListContainerSasInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expiryTime", l.ExpiryTime)
	populate(objectMap, "permissions", l.Permissions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListContainerSasInput.
func (l *ListContainerSasInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, &l.ExpiryTime)
			delete(rawMsg, key)
		case "permissions":
			err = unpopulate(val, &l.Permissions)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ListContentKeysResponse - Class of response for listContentKeys action
type ListContentKeysResponse struct {
	// ContentKeys used by current Streaming Locator
	ContentKeys []*StreamingLocatorContentKey `json:"contentKeys,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListContentKeysResponse.
func (l ListContentKeysResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentKeys", l.ContentKeys)
	return json.Marshal(objectMap)
}

type ListEdgePoliciesInput struct {
	// Unique identifier of the edge device.
	DeviceID *string `json:"deviceId,omitempty"`
}

// ListPathsResponse - Class of response for listPaths action
type ListPathsResponse struct {
	// Download Paths supported by current Streaming Locator
	DownloadPaths []*string `json:"downloadPaths,omitempty"`

	// Streaming Paths supported by current Streaming Locator
	StreamingPaths []*StreamingPath `json:"streamingPaths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListPathsResponse.
func (l ListPathsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "downloadPaths", l.DownloadPaths)
	populate(objectMap, "streamingPaths", l.StreamingPaths)
	return json.Marshal(objectMap)
}

// ListStreamingLocatorsResponse - The Streaming Locators associated with this Asset.
type ListStreamingLocatorsResponse struct {
	// READ-ONLY; The list of Streaming Locators.
	StreamingLocators []*AssetStreamingLocator `json:"streamingLocators,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ListStreamingLocatorsResponse.
func (l ListStreamingLocatorsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "streamingLocators", l.StreamingLocators)
	return json.Marshal(objectMap)
}

// LiveEvent - The live event.
type LiveEvent struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The live event properties.
	Properties *LiveEventProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEvent.
func (l LiveEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", l.ID)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// LiveEventActionInput - The LiveEvent action input parameter definition.
type LiveEventActionInput struct {
	// The flag indicates whether live outputs are automatically deleted when live event is being stopped. Deleting live outputs
	// do not delete the underlying assets.
	RemoveOutputsOnStop *bool `json:"removeOutputsOnStop,omitempty"`
}

// LiveEventEncoding - Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncoding struct {
	// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through
	// the incoming video and audio layer(s) to the output. When encodingType is set to
	// Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101
	// for more information. This property cannot
	// be modified after the live event is created.
	EncodingType *LiveEventEncodingType `json:"encodingType,omitempty"`

	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks
	// of an encoding live event. For example, use PT2S to indicate 2 seconds. For
	// the video track it also defines the key frame interval, or the length of a GoP (group of pictures). If this value is not
	// set for an encoding live event, the fragment duration defaults to 2 seconds.
	// The value cannot be set for pass-through live events.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot
	// be updated. If the encodingType is set to Standard, then the default preset
	// name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName *string `json:"presetName,omitempty"`

	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode *StretchMode `json:"stretchMode,omitempty"`
}

// LiveEventEndpoint - The live event endpoint.
type LiveEventEndpoint struct {
	// The endpoint protocol.
	Protocol *string `json:"protocol,omitempty"`

	// The endpoint URL.
	URL *string `json:"url,omitempty"`
}

// LiveEventInput - The live event input.
type LiveEventInput struct {
	// REQUIRED; The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol *LiveEventInputProtocol `json:"streamingProtocol,omitempty"`

	// Access control for live event input.
	AccessControl *LiveEventInputAccessControl `json:"accessControl,omitempty"`

	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If
	// omitted, the service will generate a unique value.
	AccessToken *string `json:"accessToken,omitempty"`

	// The input endpoints for the live event.
	Endpoints []*LiveEventEndpoint `json:"endpoints,omitempty"`

	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property
	// in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the
	// value empty for encoding live events.
	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventInput.
func (l LiveEventInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "accessToken", l.AccessToken)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "keyFrameIntervalDuration", l.KeyFrameIntervalDuration)
	populate(objectMap, "streamingProtocol", l.StreamingProtocol)
	return json.Marshal(objectMap)
}

// LiveEventInputAccessControl - The IP access control for live event input.
type LiveEventInputAccessControl struct {
	// The IP access control properties.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// LiveEventInputTrackSelection - A track selection condition. This property is reserved for future use, any value set on
// this property will be ignored.
type LiveEventInputTrackSelection struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation *string `json:"operation,omitempty"`

	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property *string `json:"property,omitempty"`

	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value *string `json:"value,omitempty"`
}

// LiveEventListResult - The LiveEvent list result.
type LiveEventListResult struct {
	// The number of result.
	ODataCount *int32 `json:"@odata.count,omitempty"`

	// The link to the next set of results. Not empty if value contains incomplete list of live outputs.
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// The result of the List Live Event operation.
	Value []*LiveEvent `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventListResult.
func (l LiveEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", l.ODataCount)
	populate(objectMap, "@odata.nextLink", l.ODataNextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LiveEventOutputTranscriptionTrack - Describes a transcription track in the output of a live event, generated using speech-to-text
// transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrack struct {
	// REQUIRED; The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName *string `json:"trackName,omitempty"`
}

// LiveEventPreview - Live event preview settings.
type LiveEventPreview struct {
	// The access control for live event preview.
	AccessControl *LiveEventPreviewAccessControl `json:"accessControl,omitempty"`

	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified
	// at creation time and cannot be updated. The identifier can be used in the
	// CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName
	// field.
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty"`

	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints []*LiveEventEndpoint `json:"endpoints,omitempty"`

	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview
	// locator url before the event is created. If omitted, the service will
	// generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator *string `json:"previewLocator,omitempty"`

	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventPreview.
func (l LiveEventPreview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "alternativeMediaId", l.AlternativeMediaID)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "previewLocator", l.PreviewLocator)
	populate(objectMap, "streamingPolicyName", l.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// LiveEventPreviewAccessControl - The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControl struct {
	// The IP access control properties.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// LiveEventProperties - The live event properties.
type LiveEventProperties struct {
	// REQUIRED; Live event input settings. It defines how the live event receives input from a contribution encoder.
	Input *LiveEventInput `json:"input,omitempty"`

	// Live event cross site access policies.
	CrossSiteAccessPolicies *CrossSiteAccessPolicies `json:"crossSiteAccessPolicies,omitempty"`

	// A description for the live event.
	Description *string `json:"description,omitempty"`

	// Encoding settings for the live event. It configures whether a live encoder is used for the live event and settings for
	// the live encoder if it is used.
	Encoding *LiveEventEncoding `json:"encoding,omitempty"`

	// When useStaticHostname is set to true, the hostnamePrefix specifies the first part of the hostname assigned to the live
	// event preview and ingest endpoints. The final hostname would be a combination of
	// this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix *string `json:"hostnamePrefix,omitempty"`

	// Live event preview settings. Preview allows live event producers to preview the live streaming content without creating
	// any live output.
	Preview *LiveEventPreview `json:"preview,omitempty"`

	// The options to use for the LiveEvent. This value is specified at creation time and cannot be updated. The valid values
	// for the array entry values are 'Default' and 'LowLatency'.
	StreamOptions []*StreamOptionsFlag `json:"streamOptions,omitempty"`

	// Live transcription settings for the live event. See https://go.microsoft.com/fwlink/?linkid=2133742 for more information
	// about the live transcription feature.
	Transcriptions []*LiveEventTranscription `json:"transcriptions,omitempty"`

	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. This value can only
	// be updated if the live event is in Standby state
	UseStaticHostname *bool `json:"useStaticHostname,omitempty"`

	// READ-ONLY; The creation time for the live event
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The last modified time of the live event.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the live event.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource state of the live event. See https://go.microsoft.com/fwlink/?linkid=2139012 for more information.
	ResourceState *LiveEventResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventProperties.
func (l LiveEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", l.Created)
	populate(objectMap, "crossSiteAccessPolicies", l.CrossSiteAccessPolicies)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "encoding", l.Encoding)
	populate(objectMap, "hostnamePrefix", l.HostnamePrefix)
	populate(objectMap, "input", l.Input)
	populateTimeRFC3339(objectMap, "lastModified", l.LastModified)
	populate(objectMap, "preview", l.Preview)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	populate(objectMap, "streamOptions", l.StreamOptions)
	populate(objectMap, "transcriptions", l.Transcriptions)
	populate(objectMap, "useStaticHostname", l.UseStaticHostname)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveEventProperties.
func (l *LiveEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &l.Created)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, &l.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "encoding":
			err = unpopulate(val, &l.Encoding)
			delete(rawMsg, key)
		case "hostnamePrefix":
			err = unpopulate(val, &l.HostnamePrefix)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &l.Input)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &l.LastModified)
			delete(rawMsg, key)
		case "preview":
			err = unpopulate(val, &l.Preview)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &l.ResourceState)
			delete(rawMsg, key)
		case "streamOptions":
			err = unpopulate(val, &l.StreamOptions)
			delete(rawMsg, key)
		case "transcriptions":
			err = unpopulate(val, &l.Transcriptions)
			delete(rawMsg, key)
		case "useStaticHostname":
			err = unpopulate(val, &l.UseStaticHostname)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LiveEventTranscription - Describes the transcription tracks in the output of a live event, generated using speech-to-text
// transcription. This property is reserved for future use, any value set on this property will be
// ignored.
type LiveEventTranscription struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied.
	// This property is reserved for future use, any value set on this property will
	// be ignored.
	InputTrackSelection []*LiveEventInputTrackSelection `json:"inputTrackSelection,omitempty"`

	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the
	// audio track. The value should be in BCP-47 format (e.g: 'en-US'). See
	// https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list
	// of supported languages.
	Language *string `json:"language,omitempty"`

	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property
	// is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack *LiveEventOutputTranscriptionTrack `json:"outputTranscriptionTrack,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventTranscription.
func (l LiveEventTranscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputTrackSelection", l.InputTrackSelection)
	populate(objectMap, "language", l.Language)
	populate(objectMap, "outputTranscriptionTrack", l.OutputTranscriptionTrack)
	return json.Marshal(objectMap)
}

// LiveEventsClientBeginAllocateOptions contains the optional parameters for the LiveEventsClient.BeginAllocate method.
type LiveEventsClientBeginAllocateOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientBeginCreateOptions contains the optional parameters for the LiveEventsClient.BeginCreate method.
type LiveEventsClientBeginCreateOptions struct {
	// The flag indicates if the resource should be automatically started on creation.
	AutoStart *bool
}

// LiveEventsClientBeginDeleteOptions contains the optional parameters for the LiveEventsClient.BeginDelete method.
type LiveEventsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientBeginResetOptions contains the optional parameters for the LiveEventsClient.BeginReset method.
type LiveEventsClientBeginResetOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientBeginStartOptions contains the optional parameters for the LiveEventsClient.BeginStart method.
type LiveEventsClientBeginStartOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientBeginStopOptions contains the optional parameters for the LiveEventsClient.BeginStop method.
type LiveEventsClientBeginStopOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientBeginUpdateOptions contains the optional parameters for the LiveEventsClient.BeginUpdate method.
type LiveEventsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientGetOptions contains the optional parameters for the LiveEventsClient.Get method.
type LiveEventsClientGetOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsClientListOptions contains the optional parameters for the LiveEventsClient.List method.
type LiveEventsClientListOptions struct {
	// placeholder for future optional parameters
}

// LiveOutput - The Live Output.
type LiveOutput struct {
	// Live output properties.
	Properties *LiveOutputProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// LiveOutputListResult - The LiveOutput list result.
type LiveOutputListResult struct {
	// The number of result.
	ODataCount *int32 `json:"@odata.count,omitempty"`

	// The link to the next set of results. Not empty if value contains incomplete list of live outputs.
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// The result of the List LiveOutput operation.
	Value []*LiveOutput `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputListResult.
func (l LiveOutputListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", l.ODataCount)
	populate(objectMap, "@odata.nextLink", l.ODataNextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LiveOutputProperties - The JSON object that contains the properties required to create a live output.
type LiveOutputProperties struct {
	// REQUIRED; ISO 8601 time between 1 minute to 25 hours to indicate the maximum content length that can be archived in the
	// asset for this live output. This also sets the maximum content length for the rewind
	// window. For example, use PT1H30M to indicate 1 hour and 30 minutes of archive window.
	ArchiveWindowLength *string `json:"archiveWindowLength,omitempty"`

	// REQUIRED; The asset that the live output will write to.
	AssetName *string `json:"assetName,omitempty"`

	// The description of the live output.
	Description *string `json:"description,omitempty"`

	// HTTP Live Streaming (HLS) packing setting for the live output.
	Hls *Hls `json:"hls,omitempty"`

	// The manifest file name. If not provided, the service will generate one automatically.
	ManifestName *string `json:"manifestName,omitempty"`

	// The initial timestamp that the live output will start at, any content before this value will not be archived.
	OutputSnapTime *int64 `json:"outputSnapTime,omitempty"`

	// READ-ONLY; The creation time the live output.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The time the live output was last modified.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the live output.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource state of the live output.
	ResourceState *LiveOutputResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputProperties.
func (l LiveOutputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "archiveWindowLength", l.ArchiveWindowLength)
	populate(objectMap, "assetName", l.AssetName)
	populateTimeRFC3339(objectMap, "created", l.Created)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "hls", l.Hls)
	populateTimeRFC3339(objectMap, "lastModified", l.LastModified)
	populate(objectMap, "manifestName", l.ManifestName)
	populate(objectMap, "outputSnapTime", l.OutputSnapTime)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveOutputProperties.
func (l *LiveOutputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "archiveWindowLength":
			err = unpopulate(val, &l.ArchiveWindowLength)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, &l.AssetName)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &l.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "hls":
			err = unpopulate(val, &l.Hls)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &l.LastModified)
			delete(rawMsg, key)
		case "manifestName":
			err = unpopulate(val, &l.ManifestName)
			delete(rawMsg, key)
		case "outputSnapTime":
			err = unpopulate(val, &l.OutputSnapTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &l.ResourceState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LiveOutputsClientBeginCreateOptions contains the optional parameters for the LiveOutputsClient.BeginCreate method.
type LiveOutputsClientBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// LiveOutputsClientBeginDeleteOptions contains the optional parameters for the LiveOutputsClient.BeginDelete method.
type LiveOutputsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// LiveOutputsClientGetOptions contains the optional parameters for the LiveOutputsClient.Get method.
type LiveOutputsClientGetOptions struct {
	// placeholder for future optional parameters
}

// LiveOutputsClientListOptions contains the optional parameters for the LiveOutputsClient.List method.
type LiveOutputsClientListOptions struct {
	// placeholder for future optional parameters
}

// LocationsClientCheckNameAvailabilityOptions contains the optional parameters for the LocationsClient.CheckNameAvailability
// method.
type LocationsClientCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// LogSpecification - A diagnostic log emitted by service.
type LogSpecification struct {
	// READ-ONLY; The time range for requests in each blob.
	BlobDuration *string `json:"blobDuration,omitempty" azure:"ro"`

	// READ-ONLY; The diagnostic log category display name.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The diagnostic log category name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// MediaFilterProperties - The Media Filter properties.
type MediaFilterProperties struct {
	// The first quality.
	FirstQuality *FirstQuality `json:"firstQuality,omitempty"`

	// The presentation time range.
	PresentationTimeRange *PresentationTimeRange `json:"presentationTimeRange,omitempty"`

	// The tracks selection conditions.
	Tracks []*FilterTrackSelection `json:"tracks,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaFilterProperties.
func (m MediaFilterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "firstQuality", m.FirstQuality)
	populate(objectMap, "presentationTimeRange", m.PresentationTimeRange)
	populate(objectMap, "tracks", m.Tracks)
	return json.Marshal(objectMap)
}

// MediaService - A Media Services account.
type MediaService struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The Managed Identity for the Media Services account.
	Identity *MediaServiceIdentity `json:"identity,omitempty"`

	// The resource properties.
	Properties *MediaServiceProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaService.
func (m MediaService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MediaServiceCollection - A collection of MediaService items.
type MediaServiceCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of MediaService items.
	Value []*MediaService `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceCollection.
func (m MediaServiceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", m.ODataNextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

type MediaServiceIdentity struct {
	// REQUIRED; The identity type.
	Type *string `json:"type,omitempty"`

	// The user assigned managed identities.
	UserAssignedIdentities map[string]*UserAssignedManagedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The Principal ID of the identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The Tenant ID of the identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceIdentity.
func (m MediaServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MediaServiceProperties - Properties of the Media Services account.
type MediaServiceProperties struct {
	// The account encryption properties.
	Encryption *AccountEncryption `json:"encryption,omitempty"`

	// The Key Delivery properties for Media Services account.
	KeyDelivery *KeyDelivery `json:"keyDelivery,omitempty"`

	// Whether or not public network access is allowed for resources under the Media Services account.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The storage accounts for this resource.
	StorageAccounts       []*StorageAccount      `json:"storageAccounts,omitempty"`
	StorageAuthentication *StorageAuthentication `json:"storageAuthentication,omitempty"`

	// READ-ONLY; The Media Services account ID.
	MediaServiceID *string `json:"mediaServiceId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceProperties.
func (m MediaServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryption", m.Encryption)
	populate(objectMap, "keyDelivery", m.KeyDelivery)
	populate(objectMap, "mediaServiceId", m.MediaServiceID)
	populate(objectMap, "publicNetworkAccess", m.PublicNetworkAccess)
	populate(objectMap, "storageAccounts", m.StorageAccounts)
	populate(objectMap, "storageAuthentication", m.StorageAuthentication)
	return json.Marshal(objectMap)
}

// MediaServiceUpdate - A Media Services account update.
type MediaServiceUpdate struct {
	// The Managed Identity for the Media Services account.
	Identity *MediaServiceIdentity `json:"identity,omitempty"`

	// The resource properties.
	Properties *MediaServiceProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceUpdate.
func (m MediaServiceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MetricDimension - A metric dimension.
type MetricDimension struct {
	// READ-ONLY; The display name for the dimension.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The metric dimension name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Whether to export metric to shoebox.
	ToBeExportedForShoebox *bool `json:"toBeExportedForShoebox,omitempty" azure:"ro"`
}

// MetricSpecification - A metric emitted by service.
type MetricSpecification struct {
	// Supported aggregation types.
	SupportedAggregationTypes []*string `json:"supportedAggregationTypes,omitempty"`

	// READ-ONLY; The metric aggregation type
	AggregationType *MetricAggregationType `json:"aggregationType,omitempty" azure:"ro"`

	// READ-ONLY; The metric dimensions.
	Dimensions []*MetricDimension `json:"dimensions,omitempty" azure:"ro"`

	// READ-ONLY; The metric display description.
	DisplayDescription *string `json:"displayDescription,omitempty" azure:"ro"`

	// READ-ONLY; The metric display name.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether regional MDM account is enabled.
	EnableRegionalMdmAccount *bool `json:"enableRegionalMdmAccount,omitempty" azure:"ro"`

	// READ-ONLY; The metric lock aggregation type
	LockAggregationType *MetricAggregationType `json:"lockAggregationType,omitempty" azure:"ro"`

	// READ-ONLY; The metric name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The source MDM account.
	SourceMdmAccount *string `json:"sourceMdmAccount,omitempty" azure:"ro"`

	// READ-ONLY; The source MDM namespace.
	SourceMdmNamespace *string `json:"sourceMdmNamespace,omitempty" azure:"ro"`

	// READ-ONLY; The supported time grain types.
	SupportedTimeGrainTypes []*string `json:"supportedTimeGrainTypes,omitempty" azure:"ro"`

	// READ-ONLY; The metric unit
	Unit *MetricUnit `json:"unit,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricSpecification.
func (m MetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", m.AggregationType)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", m.EnableRegionalMdmAccount)
	populate(objectMap, "lockAggregationType", m.LockAggregationType)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "sourceMdmAccount", m.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", m.SourceMdmNamespace)
	populate(objectMap, "supportedAggregationTypes", m.SupportedAggregationTypes)
	populate(objectMap, "supportedTimeGrainTypes", m.SupportedTimeGrainTypes)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// Mp4Format - Describes the properties for an output ISO MP4 file.
type Mp4Format struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of output files to produce. Each entry in the list is a set of audio and video layer labels to be muxed together
	// .
	OutputFiles []*OutputFile `json:"outputFiles,omitempty"`
}

// GetFormat implements the FormatClassification interface for type Mp4Format.
func (m *Mp4Format) GetFormat() *Format {
	return &Format{
		ODataType:       m.ODataType,
		FilenamePattern: m.FilenamePattern,
	}
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type Mp4Format.
func (m *Mp4Format) GetMultiBitrateFormat() *MultiBitrateFormat {
	return &MultiBitrateFormat{
		OutputFiles:     m.OutputFiles,
		ODataType:       m.ODataType,
		FilenamePattern: m.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Mp4Format.
func (m Mp4Format) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", m.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.Mp4Format"
	populate(objectMap, "outputFiles", m.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Mp4Format.
func (m *Mp4Format) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &m.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MultiBitrateFormatClassification provides polymorphic access to related types.
// Call the interface's GetMultiBitrateFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Mp4Format, *MultiBitrateFormat, *TransportStreamFormat
type MultiBitrateFormatClassification interface {
	FormatClassification
	// GetMultiBitrateFormat returns the MultiBitrateFormat content of the underlying type.
	GetMultiBitrateFormat() *MultiBitrateFormat
}

// MultiBitrateFormat - Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default
// behavior is to produce one output file for each video layer which is muxed together with all the
// audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormat struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of output files to produce. Each entry in the list is a set of audio and video layer labels to be muxed together
	// .
	OutputFiles []*OutputFile `json:"outputFiles,omitempty"`
}

// GetFormat implements the FormatClassification interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) GetFormat() *Format {
	return &Format{
		ODataType:       m.ODataType,
		FilenamePattern: m.FilenamePattern,
	}
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) GetMultiBitrateFormat() *MultiBitrateFormat { return m }

// MarshalJSON implements the json.Marshaller interface for type MultiBitrateFormat.
func (m MultiBitrateFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", m.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.MultiBitrateFormat"
	populate(objectMap, "outputFiles", m.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &m.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NoEncryption - Class for NoEncryption scheme
type NoEncryption struct {
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// Operation - An operation.
type Operation struct {
	// REQUIRED; The operation name.
	Name *string `json:"name,omitempty"`

	// Indicates the action type.
	ActionType *ActionType `json:"actionType,omitempty"`

	// The operation display name.
	Display *OperationDisplay `json:"display,omitempty"`

	// Whether the operation applies to data-plane.
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Origin of the operation.
	Origin *string `json:"origin,omitempty"`

	// Operation properties format.
	Properties *Properties `json:"properties,omitempty"`
}

// OperationCollection - A collection of Operation items.
type OperationCollection struct {
	// A collection of Operation items.
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationCollection.
func (o OperationCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationDisplay - Operation details.
type OperationDisplay struct {
	// The operation description.
	Description *string `json:"description,omitempty"`

	// The operation type.
	Operation *string `json:"operation,omitempty"`

	// The service provider.
	Provider *string `json:"provider,omitempty"`

	// Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// OutputFile - Represents an output file produced.
type OutputFile struct {
	// REQUIRED; The list of labels that describe how the encoder should multiplex video and audio into an output file. For example,
	// if the encoder is producing two video layers with labels v1 and v2, and one audio
	// layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented
	// by v1 and the audio track represented by a1.
	Labels []*string `json:"labels,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OutputFile.
func (o OutputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "labels", o.Labels)
	return json.Marshal(objectMap)
}

// OverlayClassification provides polymorphic access to related types.
// Call the interface's GetOverlay() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioOverlay, *Overlay, *VideoOverlay
type OverlayClassification interface {
	// GetOverlay returns the Overlay content of the underlying type.
	GetOverlay() *Overlay
}

// Overlay - Base type for all overlays - image, audio or video.
type Overlay struct {
	// REQUIRED; The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can
	// specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV,
	// MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video
	// file formats.
	InputLabel *string `json:"inputLabel,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`

	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format.
	// For example, PT30S to end the overlay at 30 seconds into the input video. If not
	// specified or the value is greater than the input video duration, the overlay will be applied until the end of the input
	// video if the overlay media duration is greater than the input video duration,
	// else the overlay will last as long as the overlay media duration.
	End *string `json:"end,omitempty"`

	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If
	// not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`

	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not
	// specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`

	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format.
	// For example, PT05S to start the overlay at 5 seconds into the input video.
	// If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
}

// GetOverlay implements the OverlayClassification interface for type Overlay.
func (o *Overlay) GetOverlay() *Overlay { return o }

// PNGFormat - Describes the settings for producing PNG thumbnails.
type PNGFormat struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetFormat implements the FormatClassification interface for type PNGFormat.
func (p *PNGFormat) GetFormat() *Format {
	return &Format{
		ODataType:       p.ODataType,
		FilenamePattern: p.FilenamePattern,
	}
}

// GetImageFormat implements the ImageFormatClassification interface for type PNGFormat.
func (p *PNGFormat) GetImageFormat() *ImageFormat {
	return &ImageFormat{
		ODataType:       p.ODataType,
		FilenamePattern: p.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PNGFormat.
func (p PNGFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", p.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.PngFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGFormat.
func (p *PNGFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &p.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &p.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PNGImage - Describes the properties for producing a series of PNG images from the input video.
type PNGImage struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format
	// (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at
	// the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports
	// a macro {Best}, which tells the encoder to select the best thumbnail from
	// the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and
	// Range. The default value is macro {Best}.
	Start *string `json:"start,omitempty"`

	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601
	// format. The default is 2 seconds(PT2S). Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// A collection of output PNG image layers to be produced by the encoder.
	Layers []*PNGLayer `json:"layers,omitempty"`

	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value
	// can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30
	// seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If
	// this value is 1, it means only producing one thumbnail at start time), or a
	// relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default
	// value is 100%, which means to stop at the end of the stream.
	Range *string `json:"range,omitempty"`

	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image
	// every 5 seconds), or a frame count (For example, 30 for one image every 30
	// frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step
	// value will affect the first generated thumbnail, which may not be exactly the
	// one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between
	// start time and Step position from start time as the first output. As the
	// default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one
	// specified at start time. Try to select reasonable value for Step if the first
	// thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `json:"step,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetCodec implements the CodecClassification interface for type PNGImage.
func (p *PNGImage) GetCodec() *Codec {
	return &Codec{
		ODataType: p.ODataType,
		Label:     p.Label,
	}
}

// GetImage implements the ImageClassification interface for type PNGImage.
func (p *PNGImage) GetImage() *Image {
	return &Image{
		Start:            p.Start,
		Step:             p.Step,
		Range:            p.Range,
		KeyFrameInterval: p.KeyFrameInterval,
		StretchMode:      p.StretchMode,
		SyncMode:         p.SyncMode,
		ODataType:        p.ODataType,
		Label:            p.Label,
	}
}

// GetVideo implements the VideoClassification interface for type PNGImage.
func (p *PNGImage) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: p.KeyFrameInterval,
		StretchMode:      p.StretchMode,
		SyncMode:         p.SyncMode,
		ODataType:        p.ODataType,
		Label:            p.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PNGImage.
func (p PNGImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", p.KeyFrameInterval)
	populate(objectMap, "label", p.Label)
	populate(objectMap, "layers", p.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.PngImage"
	populate(objectMap, "range", p.Range)
	populate(objectMap, "start", p.Start)
	populate(objectMap, "step", p.Step)
	populate(objectMap, "stretchMode", p.StretchMode)
	populate(objectMap, "syncMode", p.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGImage.
func (p *PNGImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &p.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &p.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &p.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &p.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &p.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &p.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &p.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &p.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &p.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PNGLayer - Describes the settings to produce a PNG image from the input video.
type PNGLayer struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetLayer implements the LayerClassification interface for type PNGLayer.
func (p *PNGLayer) GetLayer() *Layer {
	return &Layer{
		ODataType: p.ODataType,
		Width:     p.Width,
		Height:    p.Height,
		Label:     p.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PNGLayer.
func (p PNGLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "height", p.Height)
	populate(objectMap, "label", p.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.PngLayer"
	populate(objectMap, "width", p.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGLayer.
func (p *PNGLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "height":
			err = unpopulate(val, &p.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &p.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &p.ODataType)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &p.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PresentationTimeRange - The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRange struct {
	// The absolute end time boundary.
	EndTimestamp *int64 `json:"endTimestamp,omitempty"`

	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `json:"forceEndTimestamp,omitempty"`

	// The relative to end right edge.
	LiveBackoffDuration *int64 `json:"liveBackoffDuration,omitempty"`

	// The relative to end sliding window.
	PresentationWindowDuration *int64 `json:"presentationWindowDuration,omitempty"`

	// The absolute start time boundary.
	StartTimestamp *int64 `json:"startTimestamp,omitempty"`

	// The time scale of time stamps.
	Timescale *int64 `json:"timescale,omitempty"`
}

// PresetClassification provides polymorphic access to related types.
// Call the interface's GetPreset() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioAnalyzerPreset, *BuiltInStandardEncoderPreset, *FaceDetectorPreset, *Preset, *StandardEncoderPreset, *VideoAnalyzerPreset
type PresetClassification interface {
	// GetPreset returns the Preset content of the underlying type.
	GetPreset() *Preset
}

// Preset - Base type for all Presets, which define the recipe or instructions on how the input media files should be processed.
type Preset struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetPreset implements the PresetClassification interface for type Preset.
func (p *Preset) GetPreset() *Preset { return p }

// PresetConfigurations - An object of optional configuration settings for encoder.
type PresetConfigurations struct {
	// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity
	// as Speed for faster encoding but less compression efficiency.
	Complexity *Complexity `json:"complexity,omitempty"`

	// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set
	// InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only
	// outputs in separate MP4 files.
	InterleaveOutput *InterleaveOutput `json:"interleaveOutput,omitempty"`

	// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some
	// players.
	KeyFrameIntervalInSeconds *float32 `json:"keyFrameIntervalInSeconds,omitempty"`

	// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid
	// producing very high bitrate outputs for contents with high complexity.
	MaxBitrateBps *int32 `json:"maxBitrateBps,omitempty"`

	// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the
	// input is 4K.
	MaxHeight *int32 `json:"maxHeight,omitempty"`

	// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced
	// to control the overall cost of the encoding job.
	MaxLayers *int32 `json:"maxLayers,omitempty"`

	// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to
	// have a bottom layer that covers users with low network bandwidth.
	MinBitrateBps *int32 `json:"minBitrateBps,omitempty"`

	// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions
	// like 180P.
	MinHeight *int32 `json:"minHeight,omitempty"`
}

// PrivateEndpoint - The Private Endpoint resource.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - The Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionListResult - List of private endpoint connection associated with the specified storage account
type PrivateEndpointConnectionListResult struct {
	// Array of private endpoint connections
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// REQUIRED; A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// READ-ONLY; The provisioning state of the private endpoint connection resource.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionsClientCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnectionsClient.CreateOrUpdate
// method.
type PrivateEndpointConnectionsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientDeleteOptions contains the optional parameters for the PrivateEndpointConnectionsClient.Delete
// method.
type PrivateEndpointConnectionsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientGetOptions contains the optional parameters for the PrivateEndpointConnectionsClient.Get
// method.
type PrivateEndpointConnectionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientListOptions contains the optional parameters for the PrivateEndpointConnectionsClient.List
// method.
type PrivateEndpointConnectionsClientListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	// Resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkResourceListResult - A list of private link resources
type PrivateLinkResourceListResult struct {
	// Array of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// The private link resource Private link DNS zone name.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`

	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesClientGetOptions contains the optional parameters for the PrivateLinkResourcesClient.Get method.
type PrivateLinkResourcesClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesClientListOptions contains the optional parameters for the PrivateLinkResourcesClient.List method.
type PrivateLinkResourcesClientListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer
// and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// Properties - The service specification property.
type Properties struct {
	// READ-ONLY; The service specifications.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty" azure:"ro"`
}

// ProxyResource - The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a
// location
type ProxyResource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// Rectangle - Describes the properties of a rectangular window applied to the input media before processing it.
type Rectangle struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of
	// the video (For example, 50%).
	Height *string `json:"height,omitempty"`

	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video
	// (For example, 50%).
	Left *string `json:"left,omitempty"`

	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video
	// (For example, 50%).
	Top *string `json:"top,omitempty"`

	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the
	// video (For example, 50%).
	Width *string `json:"width,omitempty"`
}

// Resource - Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

type ResourceIdentity struct {
	// REQUIRED; Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
	UseSystemAssignedIdentity *bool `json:"useSystemAssignedIdentity,omitempty"`

	// The user assigned managed identity's ARM ID to use when accessing a resource.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// SelectAudioTrackByAttribute - Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttribute struct {
	// REQUIRED; The TrackAttribute to filter the tracks by.
	Attribute *TrackAttribute `json:"attribute,omitempty"`

	// REQUIRED; The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter *AttributeFilter `json:"filter,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Optional designation for single channel audio tracks. Can be used to combine the tracks into stereo or multi-channel audio
	// tracks.
	ChannelMapping *ChannelMapping `json:"channelMapping,omitempty"`

	// The value to filter the tracks by. Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue *string `json:"filterValue,omitempty"`
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) GetAudioTrackDescriptor() *AudioTrackDescriptor {
	return &AudioTrackDescriptor{
		ChannelMapping: s.ChannelMapping,
		ODataType:      s.ODataType,
	}
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByAttribute.
func (s SelectAudioTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "channelMapping", s.ChannelMapping)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectAudioTrackByAttribute"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, &s.Attribute)
			delete(rawMsg, key)
		case "channelMapping":
			err = unpopulate(val, &s.ChannelMapping)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, &s.FilterValue)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelectAudioTrackByID - Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByID struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; Track identifier to select
	TrackID *int64 `json:"trackId,omitempty"`

	// Optional designation for single channel audio tracks. Can be used to combine the tracks into stereo or multi-channel audio
	// tracks.
	ChannelMapping *ChannelMapping `json:"channelMapping,omitempty"`
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) GetAudioTrackDescriptor() *AudioTrackDescriptor {
	return &AudioTrackDescriptor{
		ChannelMapping: s.ChannelMapping,
		ODataType:      s.ODataType,
	}
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByID.
func (s SelectAudioTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelMapping", s.ChannelMapping)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectAudioTrackById"
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, &s.ChannelMapping)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		case "trackId":
			err = unpopulate(val, &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelectVideoTrackByAttribute - Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttribute struct {
	// REQUIRED; The TrackAttribute to filter the tracks by.
	Attribute *TrackAttribute `json:"attribute,omitempty"`

	// REQUIRED; The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter *AttributeFilter `json:"filter,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The value to filter the tracks by. Only used when AttributeFilter.ValueEquals is specified for the Filter property. For
	// TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g:
	// '1500000'). The TrackAttribute.Language is not supported for video tracks.
	FilterValue *string `json:"filterValue,omitempty"`
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) GetVideoTrackDescriptor() *VideoTrackDescriptor {
	return &VideoTrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByAttribute.
func (s SelectVideoTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectVideoTrackByAttribute"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, &s.Attribute)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, &s.FilterValue)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelectVideoTrackByID - Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByID struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; Track identifier to select
	TrackID *int64 `json:"trackId,omitempty"`
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) GetVideoTrackDescriptor() *VideoTrackDescriptor {
	return &VideoTrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByID.
func (s SelectVideoTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.SelectVideoTrackById"
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		case "trackId":
			err = unpopulate(val, &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceSpecification - The service metric specifications.
type ServiceSpecification struct {
	// READ-ONLY; List of log specifications.
	LogSpecifications []*LogSpecification `json:"logSpecifications,omitempty" azure:"ro"`

	// READ-ONLY; List of metric specifications.
	MetricSpecifications []*MetricSpecification `json:"metricSpecifications,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSpecification.
func (s ServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", s.LogSpecifications)
	populate(objectMap, "metricSpecifications", s.MetricSpecifications)
	return json.Marshal(objectMap)
}

// StandardEncoderPreset - Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPreset struct {
	// REQUIRED; The list of codecs to be used when encoding the input video.
	Codecs []CodecClassification `json:"codecs,omitempty"`

	// REQUIRED; The list of outputs to be produced by the encoder.
	Formats []FormatClassification `json:"formats,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// One or more filtering operations that are applied to the input media before encoding.
	Filters *Filters `json:"filters,omitempty"`
}

// GetPreset implements the PresetClassification interface for type StandardEncoderPreset.
func (s *StandardEncoderPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StandardEncoderPreset.
func (s StandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codecs", s.Codecs)
	populate(objectMap, "filters", s.Filters)
	populate(objectMap, "formats", s.Formats)
	objectMap["@odata.type"] = "#Microsoft.Media.StandardEncoderPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StandardEncoderPreset.
func (s *StandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codecs":
			s.Codecs, err = unmarshalCodecClassificationArray(val)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &s.Filters)
			delete(rawMsg, key)
		case "formats":
			s.Formats, err = unmarshalFormatClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageAccount - The storage account details.
type StorageAccount struct {
	// REQUIRED; The type of the storage account.
	Type *StorageAccountType `json:"type,omitempty"`

	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage
	// account must be a Standard Storage account (either Microsoft.ClassicStorage
	// or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	ID *string `json:"id,omitempty"`

	// The storage account identity.
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// READ-ONLY; The current status of the storage account mapping.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// StorageEncryptedAssetDecryptionData - Data needed to decrypt asset files encrypted with legacy storage encryption.
type StorageEncryptedAssetDecryptionData struct {
	// Asset File encryption metadata.
	AssetFileEncryptionMetadata []*AssetFileEncryptionMetadata `json:"assetFileEncryptionMetadata,omitempty"`

	// The Asset File storage encryption key.
	Key []byte `json:"key,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageEncryptedAssetDecryptionData.
func (s StorageEncryptedAssetDecryptionData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetFileEncryptionMetadata", s.AssetFileEncryptionMetadata)
	populateByteArray(objectMap, "key", s.Key, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageEncryptedAssetDecryptionData.
func (s *StorageEncryptedAssetDecryptionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetFileEncryptionMetadata":
			err = unpopulate(val, &s.AssetFileEncryptionMetadata)
			delete(rawMsg, key)
		case "key":
			err = runtime.DecodeByteArray(string(val), &s.Key, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingEndpoint - The streaming endpoint.
type StreamingEndpoint struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The streaming endpoint properties.
	Properties *StreamingEndpointProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpoint.
func (s StreamingEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// StreamingEndpointAccessControl - Streaming endpoint access control definition.
type StreamingEndpointAccessControl struct {
	// The access control of Akamai
	Akamai *AkamaiAccessControl `json:"akamai,omitempty"`

	// The IP access control of the streaming endpoint.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// StreamingEndpointListResult - The streaming endpoint list result.
type StreamingEndpointListResult struct {
	// The number of result.
	ODataCount *int32 `json:"@odata.count,omitempty"`

	// The link to the next set of results. Not empty if value contains incomplete list of streaming endpoints.
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// The result of the List StreamingEndpoint operation.
	Value []*StreamingEndpoint `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointListResult.
func (s StreamingEndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", s.ODataCount)
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingEndpointProperties - The streaming endpoint properties.
type StreamingEndpointProperties struct {
	// REQUIRED; The number of scale units. Use the Scale operation to adjust this value.
	ScaleUnits *int32 `json:"scaleUnits,omitempty"`

	// The access control definition of the streaming endpoint.
	AccessControl *StreamingEndpointAccessControl `json:"accessControl,omitempty"`

	// This feature is deprecated, do not set a value for this property.
	AvailabilitySetName *string `json:"availabilitySetName,omitempty"`

	// The CDN enabled flag.
	CdnEnabled *bool `json:"cdnEnabled,omitempty"`

	// The CDN profile name.
	CdnProfile *string `json:"cdnProfile,omitempty"`

	// The CDN provider name.
	CdnProvider *string `json:"cdnProvider,omitempty"`

	// The streaming endpoint access policies.
	CrossSiteAccessPolicies *CrossSiteAccessPolicies `json:"crossSiteAccessPolicies,omitempty"`

	// The custom host names of the streaming endpoint
	CustomHostNames []*string `json:"customHostNames,omitempty"`

	// The streaming endpoint description.
	Description *string `json:"description,omitempty"`

	// Max cache age
	MaxCacheAge *int64 `json:"maxCacheAge,omitempty"`

	// READ-ONLY; The exact time the streaming endpoint was created.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The free trial expiration time.
	FreeTrialEndTime *time.Time `json:"freeTrialEndTime,omitempty" azure:"ro"`

	// READ-ONLY; The streaming endpoint host name.
	HostName *string `json:"hostName,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the streaming endpoint was last modified.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the streaming endpoint.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource state of the streaming endpoint.
	ResourceState *StreamingEndpointResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointProperties.
func (s StreamingEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", s.AccessControl)
	populate(objectMap, "availabilitySetName", s.AvailabilitySetName)
	populate(objectMap, "cdnEnabled", s.CdnEnabled)
	populate(objectMap, "cdnProfile", s.CdnProfile)
	populate(objectMap, "cdnProvider", s.CdnProvider)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "crossSiteAccessPolicies", s.CrossSiteAccessPolicies)
	populate(objectMap, "customHostNames", s.CustomHostNames)
	populate(objectMap, "description", s.Description)
	populateTimeRFC3339(objectMap, "freeTrialEndTime", s.FreeTrialEndTime)
	populate(objectMap, "hostName", s.HostName)
	populateTimeRFC3339(objectMap, "lastModified", s.LastModified)
	populate(objectMap, "maxCacheAge", s.MaxCacheAge)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resourceState", s.ResourceState)
	populate(objectMap, "scaleUnits", s.ScaleUnits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingEndpointProperties.
func (s *StreamingEndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessControl":
			err = unpopulate(val, &s.AccessControl)
			delete(rawMsg, key)
		case "availabilitySetName":
			err = unpopulate(val, &s.AvailabilitySetName)
			delete(rawMsg, key)
		case "cdnEnabled":
			err = unpopulate(val, &s.CdnEnabled)
			delete(rawMsg, key)
		case "cdnProfile":
			err = unpopulate(val, &s.CdnProfile)
			delete(rawMsg, key)
		case "cdnProvider":
			err = unpopulate(val, &s.CdnProvider)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, &s.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "customHostNames":
			err = unpopulate(val, &s.CustomHostNames)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "freeTrialEndTime":
			err = unpopulateTimeRFC3339(val, &s.FreeTrialEndTime)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &s.HostName)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &s.LastModified)
			delete(rawMsg, key)
		case "maxCacheAge":
			err = unpopulate(val, &s.MaxCacheAge)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &s.ResourceState)
			delete(rawMsg, key)
		case "scaleUnits":
			err = unpopulate(val, &s.ScaleUnits)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingEndpointsClientBeginCreateOptions contains the optional parameters for the StreamingEndpointsClient.BeginCreate
// method.
type StreamingEndpointsClientBeginCreateOptions struct {
	// The flag indicates if the resource should be automatically started on creation.
	AutoStart *bool
}

// StreamingEndpointsClientBeginDeleteOptions contains the optional parameters for the StreamingEndpointsClient.BeginDelete
// method.
type StreamingEndpointsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsClientBeginScaleOptions contains the optional parameters for the StreamingEndpointsClient.BeginScale
// method.
type StreamingEndpointsClientBeginScaleOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsClientBeginStartOptions contains the optional parameters for the StreamingEndpointsClient.BeginStart
// method.
type StreamingEndpointsClientBeginStartOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsClientBeginStopOptions contains the optional parameters for the StreamingEndpointsClient.BeginStop method.
type StreamingEndpointsClientBeginStopOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsClientBeginUpdateOptions contains the optional parameters for the StreamingEndpointsClient.BeginUpdate
// method.
type StreamingEndpointsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsClientGetOptions contains the optional parameters for the StreamingEndpointsClient.Get method.
type StreamingEndpointsClientGetOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsClientListOptions contains the optional parameters for the StreamingEndpointsClient.List method.
type StreamingEndpointsClientListOptions struct {
	// placeholder for future optional parameters
}

// StreamingEntityScaleUnit - scale units definition
type StreamingEntityScaleUnit struct {
	// The scale unit number of the streaming endpoint.
	ScaleUnit *int32 `json:"scaleUnit,omitempty"`
}

// StreamingLocator - A Streaming Locator resource
type StreamingLocator struct {
	// Properties of the Streaming Locator.
	Properties *StreamingLocatorProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// StreamingLocatorCollection - A collection of StreamingLocator items.
type StreamingLocatorCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of StreamingLocator items.
	Value []*StreamingLocator `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorCollection.
func (s StreamingLocatorCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingLocatorContentKey - Class for content key in Streaming Locator
type StreamingLocatorContentKey struct {
	// REQUIRED; ID of Content Key
	ID *string `json:"id,omitempty"`

	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `json:"labelReferenceInStreamingPolicy,omitempty"`

	// Value of Content Key
	Value *string `json:"value,omitempty"`

	// READ-ONLY; ContentKeyPolicy used by Content Key
	PolicyName *string `json:"policyName,omitempty" azure:"ro"`

	// READ-ONLY; Tracks which use this Content Key
	Tracks []*TrackSelection `json:"tracks,omitempty" azure:"ro"`

	// READ-ONLY; Encryption type of Content Key
	Type *StreamingLocatorContentKeyType `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorContentKey.
func (s StreamingLocatorContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "labelReferenceInStreamingPolicy", s.LabelReferenceInStreamingPolicy)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingLocatorProperties - Properties of the Streaming Locator.
type StreamingLocatorProperties struct {
	// REQUIRED; Asset Name
	AssetName *string `json:"assetName,omitempty"`

	// REQUIRED; Name of the Streaming Policy used by this Streaming Locator. Either specify the name of Streaming Policy you
	// created or use one of the predefined Streaming Policies. The predefined Streaming Policies
	// available are: 'PredefinedDownloadOnly', 'PredefinedClearStreamingOnly', 'PredefinedDownloadAndClearStreaming', 'PredefinedClearKey',
	// 'PredefinedMultiDrmCencStreaming' and 'Predefined
	// MultiDrmStreaming'
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`

	// Alternative Media ID of this Streaming Locator
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty"`

	// The ContentKeys used by this Streaming Locator.
	ContentKeys []*StreamingLocatorContentKey `json:"contentKeys,omitempty"`

	// Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`

	// The end time of the Streaming Locator.
	EndTime *time.Time `json:"endTime,omitempty"`

	// A list of asset or account filters which apply to this streaming locator
	Filters []*string `json:"filters,omitempty"`

	// The start time of the Streaming Locator.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The StreamingLocatorId of the Streaming Locator.
	StreamingLocatorID *string `json:"streamingLocatorId,omitempty"`

	// READ-ONLY; The creation time of the Streaming Locator.
	Created *time.Time `json:"created,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorProperties.
func (s StreamingLocatorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternativeMediaId", s.AlternativeMediaID)
	populate(objectMap, "assetName", s.AssetName)
	populate(objectMap, "contentKeys", s.ContentKeys)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "filters", s.Filters)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "streamingLocatorId", s.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", s.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingLocatorProperties.
func (s *StreamingLocatorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternativeMediaId":
			err = unpopulate(val, &s.AlternativeMediaID)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, &s.AssetName)
			delete(rawMsg, key)
		case "contentKeys":
			err = unpopulate(val, &s.ContentKeys)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &s.EndTime)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &s.Filters)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, &s.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, &s.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingLocatorsClientCreateOptions contains the optional parameters for the StreamingLocatorsClient.Create method.
type StreamingLocatorsClientCreateOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsClientDeleteOptions contains the optional parameters for the StreamingLocatorsClient.Delete method.
type StreamingLocatorsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsClientGetOptions contains the optional parameters for the StreamingLocatorsClient.Get method.
type StreamingLocatorsClientGetOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsClientListContentKeysOptions contains the optional parameters for the StreamingLocatorsClient.ListContentKeys
// method.
type StreamingLocatorsClientListContentKeysOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsClientListOptions contains the optional parameters for the StreamingLocatorsClient.List method.
type StreamingLocatorsClientListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the
	// number of available items up to but not greater than the specified value n.
	Top *int32
}

// StreamingLocatorsClientListPathsOptions contains the optional parameters for the StreamingLocatorsClient.ListPaths method.
type StreamingLocatorsClientListPathsOptions struct {
	// placeholder for future optional parameters
}

// StreamingPath - Class of paths for streaming
type StreamingPath struct {
	// REQUIRED; Encryption scheme
	EncryptionScheme *EncryptionScheme `json:"encryptionScheme,omitempty"`

	// REQUIRED; Streaming protocol
	StreamingProtocol *StreamingPolicyStreamingProtocol `json:"streamingProtocol,omitempty"`

	// Streaming paths for each protocol and encryptionScheme pair
	Paths []*string `json:"paths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPath.
func (s StreamingPath) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptionScheme", s.EncryptionScheme)
	populate(objectMap, "paths", s.Paths)
	populate(objectMap, "streamingProtocol", s.StreamingProtocol)
	return json.Marshal(objectMap)
}

// StreamingPoliciesClientCreateOptions contains the optional parameters for the StreamingPoliciesClient.Create method.
type StreamingPoliciesClientCreateOptions struct {
	// placeholder for future optional parameters
}

// StreamingPoliciesClientDeleteOptions contains the optional parameters for the StreamingPoliciesClient.Delete method.
type StreamingPoliciesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// StreamingPoliciesClientGetOptions contains the optional parameters for the StreamingPoliciesClient.Get method.
type StreamingPoliciesClientGetOptions struct {
	// placeholder for future optional parameters
}

// StreamingPoliciesClientListOptions contains the optional parameters for the StreamingPoliciesClient.List method.
type StreamingPoliciesClientListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the
	// number of available items up to but not greater than the specified value n.
	Top *int32
}

// StreamingPolicy - A Streaming Policy resource
type StreamingPolicy struct {
	// Class to specify properties of Streaming Policy
	Properties *StreamingPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// StreamingPolicyCollection - A collection of StreamingPolicy items.
type StreamingPolicyCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of StreamingPolicy items.
	Value []*StreamingPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyCollection.
func (s StreamingPolicyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingPolicyContentKey - Class to specify properties of content key
type StreamingPolicyContentKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `json:"label,omitempty"`

	// Policy used by Content Key
	PolicyName *string `json:"policyName,omitempty"`

	// Tracks which use this content key
	Tracks []*TrackSelection `json:"tracks,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKey.
func (s StreamingPolicyContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", s.Label)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	return json.Marshal(objectMap)
}

// StreamingPolicyContentKeys - Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeys struct {
	// Default content key for an encryption scheme
	DefaultKey *DefaultKey `json:"defaultKey,omitempty"`

	// Representing tracks needs separate content key
	KeyToTrackMappings []*StreamingPolicyContentKey `json:"keyToTrackMappings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKeys.
func (s StreamingPolicyContentKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultKey", s.DefaultKey)
	populate(objectMap, "keyToTrackMappings", s.KeyToTrackMappings)
	return json.Marshal(objectMap)
}

// StreamingPolicyFairPlayConfiguration - Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfiguration struct {
	// REQUIRED; All license to be persistent or not
	AllowPersistentLicense *bool `json:"allowPersistentLicense,omitempty"`

	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
	// Services for issuing licenses. The template supports replaceable tokens that the
	// service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId},
	// which is replaced with the value of
	// StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being
	// requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
}

// StreamingPolicyPlayReadyConfiguration - Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
	// Services for issuing licenses. The template supports replaceable tokens that the
	// service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId},
	// which is replaced with the value of
	// StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being
	// requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`

	// Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `json:"playReadyCustomAttributes,omitempty"`
}

// StreamingPolicyProperties - Class to specify properties of Streaming Policy
type StreamingPolicyProperties struct {
	// Configuration of CommonEncryptionCbcs
	CommonEncryptionCbcs *CommonEncryptionCbcs `json:"commonEncryptionCbcs,omitempty"`

	// Configuration of CommonEncryptionCenc
	CommonEncryptionCenc *CommonEncryptionCenc `json:"commonEncryptionCenc,omitempty"`

	// Default ContentKey used by current Streaming Policy
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`

	// Configuration of EnvelopeEncryption
	EnvelopeEncryption *EnvelopeEncryption `json:"envelopeEncryption,omitempty"`

	// Configurations of NoEncryption
	NoEncryption *NoEncryption `json:"noEncryption,omitempty"`

	// READ-ONLY; Creation time of Streaming Policy
	Created *time.Time `json:"created,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyProperties.
func (s StreamingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commonEncryptionCbcs", s.CommonEncryptionCbcs)
	populate(objectMap, "commonEncryptionCenc", s.CommonEncryptionCenc)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populate(objectMap, "envelopeEncryption", s.EnvelopeEncryption)
	populate(objectMap, "noEncryption", s.NoEncryption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingPolicyProperties.
func (s *StreamingPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonEncryptionCbcs":
			err = unpopulate(val, &s.CommonEncryptionCbcs)
			delete(rawMsg, key)
		case "commonEncryptionCenc":
			err = unpopulate(val, &s.CommonEncryptionCenc)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "envelopeEncryption":
			err = unpopulate(val, &s.EnvelopeEncryption)
			delete(rawMsg, key)
		case "noEncryption":
			err = unpopulate(val, &s.NoEncryption)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingPolicyWidevineConfiguration - Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
	// Services for issuing licenses. The template supports replaceable tokens that the
	// service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId},
	// which is replaced with the value of
	// StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being
	// requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
}

// SyncStorageKeysInput - The input to the sync storage keys request.
type SyncStorageKeysInput struct {
	// The ID of the storage account resource.
	ID *string `json:"id,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TrackDescriptorClassification provides polymorphic access to related types.
// Call the interface's GetTrackDescriptor() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioTrackDescriptor, *SelectAudioTrackByAttribute, *SelectAudioTrackByID, *SelectVideoTrackByAttribute, *SelectVideoTrackByID,
// - *TrackDescriptor, *VideoTrackDescriptor
type TrackDescriptorClassification interface {
	// GetTrackDescriptor returns the TrackDescriptor content of the underlying type.
	GetTrackDescriptor() *TrackDescriptor
}

// TrackDescriptor - Base type for all TrackDescriptor types, which define the metadata and selection for tracks that should
// be processed by a Job
type TrackDescriptor struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type TrackDescriptor.
func (t *TrackDescriptor) GetTrackDescriptor() *TrackDescriptor { return t }

// TrackPropertyCondition - Class to specify one track property condition
type TrackPropertyCondition struct {
	// REQUIRED; Track property condition operation
	Operation *TrackPropertyCompareOperation `json:"operation,omitempty"`

	// REQUIRED; Track property type
	Property *TrackPropertyType `json:"property,omitempty"`

	// Track property value
	Value *string `json:"value,omitempty"`
}

// TrackSelection - Class to select a track
type TrackSelection struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections []*TrackPropertyCondition `json:"trackSelections,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackSelection.
func (t TrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", t.TrackSelections)
	return json.Marshal(objectMap)
}

// TrackedResource - The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags'
// and a 'location'
type TrackedResource struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// Transform - A Transform encapsulates the rules or instructions for generating desired outputs from input media, such as
// by transcoding or by extracting insights. After the Transform is created, it can be applied
// to input media by creating Jobs.
type Transform struct {
	// The resource properties.
	Properties *TransformProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Transform.
func (t Transform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// TransformCollection - A collection of Transform items.
type TransformCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of Transform items.
	Value []*Transform `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TransformCollection.
func (t TransformCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", t.ODataNextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TransformOutput - Describes the properties of a TransformOutput, which are the rules to be applied while generating the
// desired output.
type TransformOutput struct {
	// REQUIRED; Preset that describes the operations that will be used to modify, transcode, or extract insights from the source
	// file to generate the output.
	Preset PresetClassification `json:"preset,omitempty"`

	// A Transform can define more than one outputs. This property defines what the service should do when one output fails -
	// either continue to produce other outputs, or, stop the other outputs. The overall
	// Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError *OnErrorType `json:"onError,omitempty"`

	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for
	// processing TransformOutputs. The default priority is Normal.
	RelativePriority *Priority `json:"relativePriority,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TransformOutput.
func (t TransformOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "onError", t.OnError)
	populate(objectMap, "preset", t.Preset)
	populate(objectMap, "relativePriority", t.RelativePriority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformOutput.
func (t *TransformOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "onError":
			err = unpopulate(val, &t.OnError)
			delete(rawMsg, key)
		case "preset":
			t.Preset, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "relativePriority":
			err = unpopulate(val, &t.RelativePriority)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TransformProperties - A Transform.
type TransformProperties struct {
	// REQUIRED; An array of one or more TransformOutputs that the Transform should generate.
	Outputs []*TransformOutput `json:"outputs,omitempty"`

	// An optional verbose description of the Transform.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; The UTC date and time when the Transform was created, in 'YYYY-MM-DDThh:mm:ssZ' format.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time when the Transform was last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TransformProperties.
func (t TransformProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", t.Created)
	populate(objectMap, "description", t.Description)
	populateTimeRFC3339(objectMap, "lastModified", t.LastModified)
	populate(objectMap, "outputs", t.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformProperties.
func (t *TransformProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &t.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &t.LastModified)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, &t.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TransformsClientCreateOrUpdateOptions contains the optional parameters for the TransformsClient.CreateOrUpdate method.
type TransformsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TransformsClientDeleteOptions contains the optional parameters for the TransformsClient.Delete method.
type TransformsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// TransformsClientGetOptions contains the optional parameters for the TransformsClient.Get method.
type TransformsClientGetOptions struct {
	// placeholder for future optional parameters
}

// TransformsClientListOptions contains the optional parameters for the TransformsClient.List method.
type TransformsClientListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
}

// TransformsClientUpdateOptions contains the optional parameters for the TransformsClient.Update method.
type TransformsClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// TransportStreamFormat - Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video
// file(s).
type TransportStreamFormat struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file
	// name: {Basename} - An expansion macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of
	// input video files will be used. If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate
	// extension for this format. {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate.
	// Not applicable to thumbnails. {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of output files to produce. Each entry in the list is a set of audio and video layer labels to be muxed together
	// .
	OutputFiles []*OutputFile `json:"outputFiles,omitempty"`
}

// GetFormat implements the FormatClassification interface for type TransportStreamFormat.
func (t *TransportStreamFormat) GetFormat() *Format {
	return &Format{
		ODataType:       t.ODataType,
		FilenamePattern: t.FilenamePattern,
	}
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type TransportStreamFormat.
func (t *TransportStreamFormat) GetMultiBitrateFormat() *MultiBitrateFormat {
	return &MultiBitrateFormat{
		OutputFiles:     t.OutputFiles,
		ODataType:       t.ODataType,
		FilenamePattern: t.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TransportStreamFormat.
func (t TransportStreamFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", t.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.TransportStreamFormat"
	populate(objectMap, "outputFiles", t.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransportStreamFormat.
func (t *TransportStreamFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &t.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &t.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, &t.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UTCClipTime - Specifies the clip time as a Utc time position in the media file. The Utc time can point to a different position
// depending on whether the media file starts from a timestamp of zero or not.
type UTCClipTime struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// REQUIRED; The time position on the timeline of the input media based on Utc time.
	Time *time.Time `json:"time,omitempty"`
}

// GetClipTime implements the ClipTimeClassification interface for type UTCClipTime.
func (u *UTCClipTime) GetClipTime() *ClipTime {
	return &ClipTime{
		ODataType: u.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type UTCClipTime.
func (u UTCClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.UtcClipTime"
	populateTimeRFC3339(objectMap, "time", u.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UTCClipTime.
func (u *UTCClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &u.ODataType)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &u.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type UserAssignedManagedIdentity struct {
	// READ-ONLY; The client ID.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal ID.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// VideoClassification provides polymorphic access to related types.
// Call the interface's GetVideo() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H264Video, *H265Video, *Image, *JpgImage, *PNGImage, *Video
type VideoClassification interface {
	CodecClassification
	// GetVideo returns the Video content of the underlying type.
	GetVideo() *Video
}

// Video - Describes the basic properties for encoding the input video.
type Video struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601
	// format. The default is 2 seconds(PT2S). Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetCodec implements the CodecClassification interface for type Video.
func (v *Video) GetCodec() *Codec {
	return &Codec{
		ODataType: v.ODataType,
		Label:     v.Label,
	}
}

// GetVideo implements the VideoClassification interface for type Video.
func (v *Video) GetVideo() *Video { return v }

// MarshalJSON implements the json.Marshaller interface for type Video.
func (v Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", v.KeyFrameInterval)
	populate(objectMap, "label", v.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Video"
	populate(objectMap, "stretchMode", v.StretchMode)
	populate(objectMap, "syncMode", v.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Video.
func (v *Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &v.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &v.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &v.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &v.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VideoAnalyzerPreset - A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs
// a JSON format file.
type VideoAnalyzerPreset struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you
	// know the language of your content, it is recommended that you specify it. The
	// language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included
	// in basic mode. If the language isn't specified or set to null, automatic language
	// detection will choose the first language detected and process with the selected language for the duration of the file.
	// It does not currently support dynamically switching between languages after the
	// first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If
	// automatic detection fails to find the language, transcription would fallback to
	// 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `json:"audioLanguage,omitempty"`

	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions,omitempty"`

	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly',
	// and 'AllInsights'. The default is AllInsights. If you set this to
	// AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only,
	// then only video insights are generated. It is recommended that you not use
	// AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your
	// inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsToExtract *InsightsType `json:"insightsToExtract,omitempty"`

	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be
	// chosen.
	Mode *AudioAnalysisMode `json:"mode,omitempty"`
}

// GetAudioAnalyzerPreset implements the AudioAnalyzerPresetClassification interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) GetAudioAnalyzerPreset() *AudioAnalyzerPreset {
	return &AudioAnalyzerPreset{
		AudioLanguage:       v.AudioLanguage,
		Mode:                v.Mode,
		ExperimentalOptions: v.ExperimentalOptions,
		ODataType:           v.ODataType,
	}
}

// GetPreset implements the PresetClassification interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: v.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VideoAnalyzerPreset.
func (v VideoAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioLanguage", v.AudioLanguage)
	populate(objectMap, "experimentalOptions", v.ExperimentalOptions)
	populate(objectMap, "insightsToExtract", v.InsightsToExtract)
	populate(objectMap, "mode", v.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoAnalyzerPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, &v.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &v.ExperimentalOptions)
			delete(rawMsg, key)
		case "insightsToExtract":
			err = unpopulate(val, &v.InsightsToExtract)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &v.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VideoLayerClassification provides polymorphic access to related types.
// Call the interface's GetVideoLayer() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H264Layer, *VideoLayer
type VideoLayerClassification interface {
	LayerClassification
	// GetVideoLayer returns the VideoLayer content of the underlying type.
	GetVideoLayer() *VideoLayer
}

// VideoLayer - Describes the settings to be used when encoding the input video into a desired output bitrate layer.
type VideoLayer struct {
	// REQUIRED; The average bitrate in bits per second at which to encode the input video when generating this layer. This is
	// a required field.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on
	// whenever the video profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`

	// The number of B-frames to be used when encoding this layer. If not specified, the encoder chooses an appropriate number
	// based on the video profile and level.
	BFrames *int32 `json:"bFrames,omitempty"`

	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N
	// are integers (For example, 30000/1001), or in the form of a number (For example,
	// 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified,
	// the encoder will use the same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming
	// the output file.
	Label *string `json:"label,omitempty"`

	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults
	// to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`

	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will
	// use a single slice for each frame.
	Slices *int32 `json:"slices,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example
	// 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetLayer implements the LayerClassification interface for type VideoLayer.
func (v *VideoLayer) GetLayer() *Layer {
	return &Layer{
		ODataType: v.ODataType,
		Width:     v.Width,
		Height:    v.Height,
		Label:     v.Label,
	}
}

// GetVideoLayer implements the VideoLayerClassification interface for type VideoLayer.
func (v *VideoLayer) GetVideoLayer() *VideoLayer { return v }

// MarshalJSON implements the json.Marshaller interface for type VideoLayer.
func (v VideoLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adaptiveBFrame", v.AdaptiveBFrame)
	populate(objectMap, "bFrames", v.BFrames)
	populate(objectMap, "bitrate", v.Bitrate)
	populate(objectMap, "frameRate", v.FrameRate)
	populate(objectMap, "height", v.Height)
	populate(objectMap, "label", v.Label)
	populate(objectMap, "maxBitrate", v.MaxBitrate)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoLayer"
	populate(objectMap, "slices", v.Slices)
	populate(objectMap, "width", v.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoLayer.
func (v *VideoLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptiveBFrame":
			err = unpopulate(val, &v.AdaptiveBFrame)
			delete(rawMsg, key)
		case "bFrames":
			err = unpopulate(val, &v.BFrames)
			delete(rawMsg, key)
		case "bitrate":
			err = unpopulate(val, &v.Bitrate)
			delete(rawMsg, key)
		case "frameRate":
			err = unpopulate(val, &v.FrameRate)
			delete(rawMsg, key)
		case "height":
			err = unpopulate(val, &v.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &v.Label)
			delete(rawMsg, key)
		case "maxBitrate":
			err = unpopulate(val, &v.MaxBitrate)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		case "slices":
			err = unpopulate(val, &v.Slices)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &v.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VideoOverlay - Describes the properties of a video overlay.
type VideoOverlay struct {
	// REQUIRED; The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can
	// specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV,
	// MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video
	// file formats.
	InputLabel *string `json:"inputLabel,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`

	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle *Rectangle `json:"cropRectangle,omitempty"`

	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format.
	// For example, PT30S to end the overlay at 30 seconds into the input video. If not
	// specified or the value is greater than the input video duration, the overlay will be applied until the end of the input
	// video if the overlay media duration is greater than the input video duration,
	// else the overlay will last as long as the overlay media duration.
	End *string `json:"end,omitempty"`

	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If
	// not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`

	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not
	// specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`

	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `json:"opacity,omitempty"`

	// The location in the input video where the overlay is applied.
	Position *Rectangle `json:"position,omitempty"`

	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format.
	// For example, PT05S to start the overlay at 5 seconds into the input video.
	// If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
}

// GetOverlay implements the OverlayClassification interface for type VideoOverlay.
func (v *VideoOverlay) GetOverlay() *Overlay {
	return &Overlay{
		ODataType:       v.ODataType,
		InputLabel:      v.InputLabel,
		Start:           v.Start,
		End:             v.End,
		FadeInDuration:  v.FadeInDuration,
		FadeOutDuration: v.FadeOutDuration,
		AudioGainLevel:  v.AudioGainLevel,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VideoOverlay.
func (v VideoOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioGainLevel", v.AudioGainLevel)
	populate(objectMap, "cropRectangle", v.CropRectangle)
	populate(objectMap, "end", v.End)
	populate(objectMap, "fadeInDuration", v.FadeInDuration)
	populate(objectMap, "fadeOutDuration", v.FadeOutDuration)
	populate(objectMap, "inputLabel", v.InputLabel)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoOverlay"
	populate(objectMap, "opacity", v.Opacity)
	populate(objectMap, "position", v.Position)
	populate(objectMap, "start", v.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoOverlay.
func (v *VideoOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, &v.AudioGainLevel)
			delete(rawMsg, key)
		case "cropRectangle":
			err = unpopulate(val, &v.CropRectangle)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, &v.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, &v.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, &v.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, &v.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		case "opacity":
			err = unpopulate(val, &v.Opacity)
			delete(rawMsg, key)
		case "position":
			err = unpopulate(val, &v.Position)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &v.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VideoTrackDescriptorClassification provides polymorphic access to related types.
// Call the interface's GetVideoTrackDescriptor() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SelectVideoTrackByAttribute, *SelectVideoTrackByID, *VideoTrackDescriptor
type VideoTrackDescriptorClassification interface {
	TrackDescriptorClassification
	// GetVideoTrackDescriptor returns the VideoTrackDescriptor content of the underlying type.
	GetVideoTrackDescriptor() *VideoTrackDescriptor
}

// VideoTrackDescriptor - A TrackSelection to select video tracks.
type VideoTrackDescriptor struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: v.ODataType,
	}
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) GetVideoTrackDescriptor() *VideoTrackDescriptor { return v }

// MarshalJSON implements the json.Marshaller interface for type VideoTrackDescriptor.
func (v VideoTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.VideoTrackDescriptor"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
